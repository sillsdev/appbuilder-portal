(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("semantic-ui-react"), require("react-dom"), require("moment"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "semantic-ui-react", "react-dom", "moment"], factory);
	else if(typeof exports === 'object')
		exports["optimajet-builder"] = factory(require("react"), require("semantic-ui-react"), require("react-dom"), require("moment"));
	else
		root["optimajet-builder"] = factory(root["react"], root["semantic-ui-react"], root["react-dom"], root["moment"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_15__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 26);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.capitalize = capitalize;
exports.callbackName = callbackName;
exports.isObject = isObject;
exports.extend = extend;
exports.isFunction = isFunction;
exports.nextTick = nextTick;
exports.object = object;
exports.isArguments = isArguments;
exports.throwIf = throwIf;
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function callbackName(string, prefix) {
    prefix = prefix || "on";
    return prefix + exports.capitalize(string);
}

/*
 * isObject, extend, isFunction, isArguments are taken from underscore/lodash in
 * order to remove the dependency
 */
function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return type === "function" || type === "object" && !!obj;
}

function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j < keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}

function isFunction(value) {
    return typeof value === "function";
}

exports.EventEmitter = __webpack_require__(29);

function nextTick(callback) {
    setTimeout(callback, 0);
}

function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i < keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}

function isArguments(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && "callee" in value && typeof value.length === "number";
}

function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _joins = __webpack_require__(18);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Extract child listenables from a parent from their
 * children property and return them in a keyed Object
 *
 * @param {Object} listenable The parent listenable
 */
var mapChildListenables = function mapChildListenables(listenable) {
    var i = 0,
        children = {},
        childName;
    for (; i < (listenable.children || []).length; ++i) {
        childName = listenable.children[i];
        if (listenable[childName]) {
            children[childName] = listenable[childName];
        }
    }
    return children;
};

/**
 * Make a flat dictionary of all listenables including their
 * possible children (recursively), concatenating names in camelCase.
 *
 * @param {Object} listenables The top-level listenables
 */
var flattenListenables = function flattenListenables(listenables) {
    var flattened = {};
    for (var key in listenables) {
        var listenable = listenables[key];
        var childMap = mapChildListenables(listenable);

        // recursively flatten children
        var children = flattenListenables(childMap);

        // add the primary listenable and chilren
        flattened[key] = listenable;
        for (var childKey in children) {
            var childListenable = children[childKey];
            flattened[key + _.capitalize(childKey)] = childListenable;
        }
    }

    return flattened;
};

/**
 * An internal utility function used by `validateListening`
 *
 * @param {Action|Store} listenable The listenable we want to search for
 * @returns {Boolean} The result of a recursive search among `this.subscriptions`
 */
var hasListener = exports.hasListener = function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i < (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j < listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * A convenience method that listens to all listenables in the given object.
 *
 * @param {Object} listenables An object of listenables. Keys will be used as callback method names.
 */
var listenToMany = exports.listenToMany = function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
};

/**
 * Checks if the current context can listen to the supplied listenable
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @returns {String|Undefined} An error message, or undefined if there was no problem.
 */
var validateListening = exports.validateListening = function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener && listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
};

/**
 * Sets up a subscription to the given listenable for the context object
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @param {Function|String} callback The callback to register as event handler
 * @param {Function|String} defaultCallback The callback to register as default handler
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
};

/**
 * Stops listening to a single listenable
 *
 * @param {Action|Store} listenable The action or store we no longer want to listen to
 * @returns {Boolean} True if a subscription was found and removed, otherwise false.
 */
var stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i < subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
};

/**
 * Stops all subscriptions and empties subscriptions array
 */
var stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
};

/**
 * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.
 * @param {Action|Store} listenable The publisher we want to get initial state from
 * @param {Function|String} defaultCallback The method to receive the data
 */
var fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data && _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
};

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with the last emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)("last");

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with the first emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)("first");

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with all emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)("all");

/**
 * The callback will be called once all listenables have triggered.
 * If a callback triggers twice before that happens, an error is thrown.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)("strict");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = ( true ? exports : {});

JSON5.parse = (function () {
    "use strict";

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,           // The index of the current character
        lineNumber,   // The current line number
        columnNumber, // The current column number
        ch,           // The current character
        escapee = {
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        renderChar = function (chr) {
            return chr === '' ? 'EOF' : "'" + chr + "'";
        },

        error = function (m) {

// Call error when something is wrong.

            var error = new SyntaxError();
            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
            error.at = at;
            // These two property names have been chosen to agree with the ones in Gecko, the only popular
            // environment which seems to supply this info on JSON.parse
            error.lineNumber = lineNumber;
            error.columnNumber = columnNumber;
            throw error;
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at++;
            columnNumber++;
            if (ch === '\n' || ch === '\r' && peek() !== '\n') {
                lineNumber++;
                columnNumber = 0;
            }
            return ch;
        },

        peek = function () {

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        },

        identifier = function () {

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                error("Bad identifier as unquoted key");
            }

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) {
                key += ch;
            }

            return key;
        },

        number = function () {

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') {
                sign = ch;
                next(ch);
            }

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') {
                number = word();
                if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number');
                }
                return (sign === '-') ? -number : number;
            }

            // support for NaN
            if (ch === 'N' ) {
              number = word();
              if (!isNaN(number)) {
                error('expected word to be NaN');
              }
              // ignore sign as -NaN also is NaN
              return number;
            }

            if (ch === '0') {
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') {
                    string += ch;
                    next();
                    base = 16;
                } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal');
                }
            }

            switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9' ) {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
            }

            if(sign === '-') {
                number = -string;
            } else {
                number = +string;
            }

            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff;

// When parsing for string values, we must look for ' or " and \ characters.

            if (ch === '"' || ch === "'") {
                delim = ch;
                while (next()) {
                    if (ch === delim) {
                        next();
                        return string;
                    } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (ch === '\r') {
                            if (peek() === '\n') {
                                next();
                            }
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else if (ch === '\n') {
                        // unescaped newlines are invalid; see:
                        // https://github.com/aseemk/json5/issues/24
                        // TODO this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        inlineComment = function () {

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') {
                error("Not an inline comment");
            }

            do {
                next();
                if (ch === '\n' || ch === '\r') {
                    next();
                    return;
                }
            } while (ch);
        },

        blockComment = function () {

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') {
                error("Not a block comment");
            }

            do {
                next();
                while (ch === '*') {
                    next('*');
                    if (ch === '/') {
                        next('/');
                        return;
                    }
                }
            } while (ch);

            error("Unterminated block comment");
        },

        comment = function () {

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') {
                error("Not a comment");
            }

            next('/');

            if (ch === '/') {
                inlineComment();
            } else if (ch === '*') {
                blockComment();
            } else {
                error("Unrecognized comment");
            }
        },

        white = function () {

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) {
                if (ch === '/') {
                    comment();
                } else if (ws.indexOf(ch) >= 0) {
                    next();
                } else {
                    return;
                }
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            }
            error("Unexpected " + renderChar(ch));
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                while (ch) {
                    if (ch === ']') {
                        next(']');
                        return array;   // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                        error("Missing array element");
                    } else {
                        array.push(value());
                    }
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                while (ch) {
                    if (ch === '}') {
                        next('}');
                        return object;   // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                        key = string();
                    } else {
                        key = identifier();
                    }

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
            return string();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({'': result}, '')) : result;
    };
}());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) {
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") {
            return replacer.call(holder, key, value);
        } else if(replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9') ||
            c === '_' || c === '$';
    }

    function isWordStart(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            c === '_' || c === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1, length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
    function escapeString(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch(typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length-1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    if (obj_part.length) {
                        buffer += makeIndent(indentStr, objStack.length, true)
                    }
                    buffer += "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = {"":obj};
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Reflux = __webpack_require__(16);

var BuilderActions = Reflux.createActions(['add', 'showEditForm', 'remove', 'saveData', 'save', 'move']);

module.exports = BuilderActions;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _editformControls = __webpack_require__(21);

var _radiogroup = __webpack_require__(24);

var _radiogroup2 = _interopRequireDefault(_radiogroup);

var _menugroup = __webpack_require__(52);

var _menugroup2 = _interopRequireDefault(_menugroup);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _gridview = __webpack_require__(53);

var _gridview2 = _interopRequireDefault(_gridview);

var _chartview = __webpack_require__(56);

var _chartview2 = _interopRequireDefault(_chartview);

var _workflowbar = __webpack_require__(57);

var _workflowbar2 = _interopRequireDefault(_workflowbar);

var _dictionary = __webpack_require__(58);

var _dictionary2 = _interopRequireDefault(_dictionary);

var _container = __webpack_require__(59);

var _container2 = _interopRequireDefault(_container);

var _staticcontent = __webpack_require__(60);

var _staticcontent2 = _interopRequireDefault(_staticcontent);

var _collectioneditor = __webpack_require__(14);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

var _controlbar = __webpack_require__(61);

var _controlbar2 = _interopRequireDefault(_controlbar);

var _dropdowntrigger = __webpack_require__(62);

var _dropdowntrigger2 = _interopRequireDefault(_dropdowntrigger);

var _semanticcontrol = __webpack_require__(63);

var _semanticcontrol2 = _interopRequireDefault(_semanticcontrol);

var _dropzone = __webpack_require__(64);

var _dropzone2 = _interopRequireDefault(_dropzone);

var _functionalfilter = __webpack_require__(25);

var _search = __webpack_require__(66);

var _search2 = _interopRequireDefault(_search);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//------DWKitFormControls-----------
var DWKitFormControls = {
    Items: [{ key: "sepContainers", title: 'Containers', isseparate: true, defaultopen: true }, { key: "container", title: 'DIV', control: _container2.default, editControl: _editformControls.ContainerEditControl }, { key: "form", title: 'Form', control: _semanticcontrol2.default, editControl: _editformControls.FormEditControl }, {
        key: "formgroup",
        title: 'Form Group',
        control: _semanticcontrol2.default,
        editControl: _editformControls.FormGroupEditControl,
        defaultValues: { widths: "equal" }
    }, {
        key: "menu", title: 'Menu', control: _menugroup2.default, editControl: _editformControls.MenuEditControl,
        defaultValues: {
            items: [{ target: 'menu1', title: 'Menu 1' }, { target: 'menu2', title: 'Menu 2' }, { target: 'menu3', title: 'Menu 3' }]
        }
    }, {
        key: "workflowbar",
        title: 'Workflow bar',
        control: _workflowbar2.default,
        editControl: _editformControls.WorkflowBarEditControl,
        defaultValues: {
            events: {
                onCommandClick: { active: true, actions: ["workflowExecuteCommand"] },
                onSetStateClick: { active: true, actions: ["workflowSetState"] }
            }
        }
    }, {
        key: "customblock",
        title: 'Custom block',
        control: undefined,
        editControl: _editformControls.CustomBlockEditControl,
        defaultValues: { sourceType: 'form' }
    }, { key: "sepCollection", title: 'Collections', isseparate: true }, {
        key: "gridview", title: 'GridView', control: _gridview2.default, editControl: _editformControls.GridEditControl, defaultValues: {
            columns: [{ key: 'id', name: 'ID' }, { key: 'title', name: 'Title' }, { key: 'count', name: 'Count' }]
        }
    }, {
        key: "collectioneditor",
        title: 'Collection Editor',
        control: _collectioneditor2.default,
        editControl: _editformControls.CollectionEditorEditControl,
        defaultValues: {
            idField: "Id",
            parentIdField: "ParentId",
            columns: [{ key: 'Id', name: 'ID' }, { key: 'Title', name: 'Title' }, { key: 'Count', name: 'Count' }]
        }
    }, { key: "sepControls", title: 'Controls', isseparate: true }, {
        key: "header",
        title: 'Header',
        control: _semanticcontrol2.default,
        editControl: _editformControls.HeaderEditControl,
        defaultValues: { content: "Header", size: "medium" }
    }, {
        key: "input",
        title: 'Input',
        control: _semanticcontrol2.default,
        editControl: _editformControls.InputEditControl,
        defaultValues: { label: "Input", fluid: true, onChangeTimeout: 200 }
    }, {
        key: "textarea",
        title: 'TextArea',
        control: _semanticcontrol2.default,
        editControl: _editformControls.TextAreaEditControl,
        defaultValues: { label: "TextArea", fluid: true }
    }, {
        key: "dictionary",
        title: 'Dictionary',
        control: _dictionary2.default,
        editControl: _editformControls.DictionaryEditControl,
        defaultValues: { label: "Dictionary", fluid: true, selection: true }
    }, {
        key: "dropdown",
        title: 'Dropdown',
        control: _semanticcontrol2.default,
        editControl: _editformControls.DropdownEditControl,
        defaultValues: {
            label: "Dropdown", fluid: true, selection: true,
            "data-elements": [{ key: 1, value: 1, text: 'Item 1' }, { key: 2, value: 2, text: 'Item 2' }, { key: 3, value: 3, text: 'Item 3' }]
        }
    }, {
        key: "checkbox",
        title: 'CheckBox',
        control: _semanticcontrol2.default,
        editControl: _editformControls.CheckboxEditControl,
        defaultValues: { label: "Checkbox" }
    }, {
        key: "radiogroup",
        title: 'Radio group',
        control: _radiogroup2.default,
        editControl: _editformControls.RadioGroupEditControl,
        defaultValues: {
            label: "Radio",
            "data-elements": [{ key: 1, value: 1, text: 'Item 1' }, { key: 2, value: 2, text: 'Item 2' }, { key: 3, value: 3, text: 'Item 3' }]
        }
    }, {
        key: "button",
        title: 'Button',
        control: _semanticcontrol2.default,
        editControl: _editformControls.ButtonEditControl,
        defaultValues: { content: "Button" }
    }, {
        key: "label",
        title: 'Label',
        control: _semanticcontrol2.default,
        editControl: _editformControls.LabelEditControl,
        defaultValues: { content: "Label" }
    }, {
        key: "message",
        title: 'Message',
        control: _semanticcontrol2.default,
        editControl: _editformControls.MessageEditControl,
        defaultValues: { header: "Message", content: "Description..." }
    }, {
        key: "image",
        title: 'Image',
        control: _semanticcontrol2.default,
        editControl: _editformControls.ImageEditControl,
        defaultValues: { src: '/images/unknown.png' }
    }, {
        key: "statistic", title: 'Statistic', control: _semanticcontrol2.default, editControl: _editformControls.StatisticEditControl,
        defaultValues: {
            "data-elements": [{ label: 'Score', value: '22,1%' }, { label: 'Views', value: '30,000' }, { label: 'Points', value: '500' }]
        }
    }, {
        key: "customcontrol",
        title: 'Custom control',
        control: undefined,
        editControl: _editformControls.CustomEditControl,
        defaultValues: { props: "{  }" }
    }, {
        key: "staticcontent",
        title: 'Static Content',
        control: _staticcontent2.default,
        editControl: _editformControls.StaticContentEditControl,
        defaultValues: { content: "Text..." }
    }, {
        key: "dropdowntrigger",
        title: 'Dropdown trigger',
        control: _dropdowntrigger2.default,
        editControl: _editformControls.DropdownTriggerEditControl,
        defaultValues: {
            defaultValue: "User",
            items: [{ target: '#1', title: 'Item 1' }, { target: '#2', title: 'Item 2' }, { target: '#3', title: 'Item 3' }]
        }
    }, {
        key: "dropzonecontrol",
        title: 'Dropzone',
        control: _dropzone2.default,
        editControl: _editformControls.DropzoneEditControl,
        defaultValues: {
            showFiletypeIcon: false,
            autoProcessQueue: true,
            addRemoveLinks: true,
            multile: true
        }
    }, {
        key: "breadcrumb",
        title: 'Breadcrumbs',
        control: _semanticcontrol2.default,
        editControl: _editformControls.BreadcrumbEditControl,
        defaultValues: {
            items: [{ "text": "Home", "url": "/" }, { "divider": "right angle", "text": "Page1", "url": "/page1" }, { "text": "Page2", "active": true }],
            events: {
                onItemClick: { active: true, actions: ["redirect"] }
            }
        }
    }, {
        key: "search",
        title: 'Search',
        control: _search2.default,
        editControl: _editformControls.SearchEditControl,
        defaultValues: {}
    }, { key: "sepCharts", title: 'Charts', isseparate: true }, {
        key: "barchart",
        title: 'Bar',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "bar", datasetLabel: "" }
    }, {
        key: "linechart",
        title: 'Line',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "line", datasetLabel: "" }
    }, {
        key: "scatterchart",
        title: 'Scatter',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "scatter", datasetLabel: "" }
    }, {
        key: "doughnutchart",
        title: 'Doughnut',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "doughnut", datasetLabel: "" }
    }, {
        key: "piechart",
        title: 'Pie',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "pie", datasetLabel: "" }
    }, {
        key: "radarchart",
        title: 'Radar',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "radar", datasetLabel: "" }
    }],

    createControls: function createControls(parentComponent, _ref) {
        var model = _ref.model,
            data = _ref.data,
            errors = _ref.errors,
            eventOnEdit = _ref.eventOnEdit,
            eventOnDelete = _ref.eventOnDelete,
            eventOnCopy = _ref.eventOnCopy,
            handleEvent = _ref.handleEvent,
            parentItem = _ref.parentItem,
            getFormFunc = _ref.getFormFunc,
            getAdditionalDataForControl = _ref.getAdditionalDataForControl,
            buildermode = _ref.buildermode,
            hideControls = _ref.hideControls,
            readOnlyControls = _ref.readOnlyControls,
            readOnly = _ref.readOnly,
            disableRefs = _ref.disableRefs,
            uploadUrl = _ref.uploadUrl,
            downloadUrl = _ref.downloadUrl,
            extendedData = _ref.extendedData,
            controlsToReplace = _ref.controlsToReplace,
            needCheckReplace = _ref.needCheckReplace,
            parentPlaceholder = _ref.parentPlaceholder,
            formItem = _ref.formItem,
            controlBarRight = _ref.controlBarRight;


        var res = [];
        if (model === null || model === undefined) return res;

        for (var i = 0; i < model.length; i++) {
            if (Array.isArray(hideControls) && hideControls.includes(model[i].key)) {
                continue;
            }

            var item = void 0;
            var dbtype = model[i]["data-buildertype"];
            if (dbtype === "customcontrol") {
                if (model[i].type === undefined || model[i].type === "") {
                    item = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-formbuilder-empty', key: model[i].key },
                        'Fill Type property for rendering the control.'
                    );
                } else {
                    var controlPropsInit = model[i].props === undefined ? {} : _json2.default.parse(model[i].props);
                    var controlProps = _extends({}, controlPropsInit, {
                        key: model[i].key,
                        name: model[i].key,
                        className: model[i]["style-customcss"],
                        style: this.getStyle(model[i], buildermode),
                        "data-buildertype": model[i]["data-buildertype"],
                        getAdditionalDataForControl: getAdditionalDataForControl,
                        uploadUrl: uploadUrl, downloadUrl: downloadUrl
                    });

                    if (readOnly || Array.isArray(readOnlyControls) && readOnlyControls.includes(controlProps.key)) controlProps.readOnly = true;

                    var children = model[i].children;
                    if (model[i].children !== undefined) {
                        try {
                            children = _json2.default.parse(model[i].children);
                        } catch (e) {}
                    }

                    if (children === undefined || Array.isArray(children) && children.length === 0) {
                        item = _react2.default.createElement(model[i].type, controlProps);
                    } else {
                        item = _react2.default.createElement(model[i].type, controlProps, children);
                    }
                }
            } else if (dbtype === "customblock") {
                var children_source = [];
                var renderempty = false;
                var cbbuildermode = false;
                var addDropZones = false;
                var newParentItem = model[i];
                var newParentPlaceholder = parentPlaceholder;
                var newFormItem = formItem;

                if (model[i].sourceType === 'form' || model[i].sourceType === undefined) {
                    if (model[i].children !== undefined && model[i].children !== "") {
                        children_source = model[i].children;
                    } else {
                        if (getFormFunc === undefined) {
                            console.error('Error: "getFormFunc" parameter is undefined!. Please, set "getFormFunc" parameter for DWKitBuilder or DWKitForm!');
                            continue;
                        }

                        if (model[i].formname !== undefined && model[i].formname !== "") {
                            children_source = getFormFunc(model[i].formname);
                        } else {
                            renderempty = true;
                        }
                    }
                } else if (model[i].sourceType === 'placeholder') {
                    cbbuildermode = eventOnEdit !== undefined;
                    addDropZones = eventOnEdit !== undefined;
                    newParentItem = parentItem;

                    if (newParentPlaceholder === undefined) newParentPlaceholder = model[i];

                    if (newFormItem === undefined) {
                        newFormItem = parentItem;
                    }

                    if (newFormItem !== undefined && newFormItem.placeholders !== undefined && newFormItem.placeholders[model[i].key] !== undefined) {

                        children_source = newFormItem.placeholders[model[i].key];
                    }
                } else {
                    if (model[i].source !== undefined && model[i].source !== "") children_source = _json2.default.parse(model[i].source);else renderempty = true;
                }

                if (renderempty) {
                    item = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-formbuilder-empty', key: model[i].key },
                        'Set a form name or source in propepries.'
                    );
                } else {
                    var _children = this.createControls(parentComponent, {
                        model: children_source,
                        data: data,
                        errors: errors,
                        buildermode: cbbuildermode,
                        eventOnEdit: eventOnEdit,
                        eventOnDelete: eventOnDelete,
                        eventOnCopy: eventOnCopy,
                        parentItem: newParentItem,
                        handleEvent: handleEvent,
                        getFormFunc: getFormFunc,
                        getAdditionalDataForControl: getAdditionalDataForControl,
                        hideControls: hideControls,
                        readOnlyControls: readOnlyControls,
                        readOnly: readOnly,
                        disableRefs: disableRefs,
                        uploadUrl: uploadUrl, downloadUrl: downloadUrl, controlsToReplace: controlsToReplace, needCheckReplace: needCheckReplace,
                        parentPlaceholder: newParentPlaceholder,
                        formItem: newFormItem
                    });

                    var className = model[i]["style-customcss"];
                    if (buildermode) {
                        className = (className == undefined ? "" : className + " ") + "dwkit-formbuilder-item-container";
                    }

                    var formProps = {
                        key: model[i].key,
                        name: model[i].key,
                        className: className,
                        style: this.getStyle(model[i], buildermode),
                        "data-buildertype": model[i]["data-buildertype"]
                    };

                    if (addDropZones) {
                        if (_children === undefined) _children = [];

                        if (_children.length > 0) {
                            var dz_footer = DWKitFormControls.createBuilderDropzone(model[i].key + "_dropzone_footer", newFormItem === undefined ? undefined : newFormItem.key, //parentItem === undefined ? undefined : parentItem.key,
                            _children[_children.length - 1].key, model[i].key, model[i].key);
                            _children.push(dz_footer);
                        }

                        var dz = DWKitFormControls.createBuilderDropzone(model[i].key + "_dropzone_header", newFormItem === undefined ? undefined : newFormItem.key, //parentItem === undefined ? undefined : parentItem.key,
                        undefined, model[i].key, model[i].key);
                        _children.unshift(dz);
                    }

                    item = _react2.default.createElement('div', formProps, _children);
                }
            } else {
                var control = this.getControlByType(dbtype);
                if (control === null) {
                    item = _react2.default.createElement(
                        'div',
                        { key: model[i].key },
                        dbtype,
                        ' is unsupported'
                    );
                } else {
                    if (this.isContainer(dbtype)) {

                        var _newFormItem = formItem;
                        if (_newFormItem == undefined && parentItem != undefined && parentItem.sourceType == "form") {
                            _newFormItem = parentItem;
                        }

                        var isGorizontalGroup = buildermode && model[i]["data-buildertype"] === "formgroup" && model[i].orientation !== "grouped";
                        var _children2 = this.createControls(parentComponent, {
                            model: model[i].children,
                            data: data,
                            errors: errors,
                            buildermode: buildermode,
                            eventOnEdit: eventOnEdit,
                            eventOnDelete: eventOnDelete,
                            eventOnCopy: eventOnCopy,
                            parentItem: model[i],
                            handleEvent: handleEvent,
                            getFormFunc: getFormFunc,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            hideControls: hideControls,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            uploadUrl: uploadUrl, downloadUrl: downloadUrl, controlsToReplace: controlsToReplace, needCheckReplace: needCheckReplace,
                            parentPlaceholder: undefined,
                            formItem: _newFormItem,
                            controlBarRight: isGorizontalGroup
                        });
                        if (buildermode) {
                            if (_children2.length > 0) {
                                var _textDZ = isGorizontalGroup ? "..." : "... " + model[i].key + " down ...";
                                var dropzone_footer = this.createBuilderDropzone(model[i].key + "-dropzone_footer", model[i].key, undefined, _textDZ);
                                _children2.push(dropzone_footer);
                            }

                            var textDZ = isGorizontalGroup ? "..." : "... " + model[i].key + " up ...";
                            var dropzone_header = this.createBuilderDropzone(model[i].key + "-dropzone_header", model[i].key, undefined, textDZ);
                            _children2.unshift(dropzone_header);
                        }
                        item = this.createControl(parentComponent, control, {
                            model: model[i],
                            data: data,
                            errors: errors,
                            parentItem: parentItem,
                            buildermode: buildermode,
                            children: _children2,
                            handleEvent: handleEvent,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            parentPlaceholder: parentPlaceholder,
                            controlsToReplace: controlsToReplace,
                            needCheckReplace: needCheckReplace,
                            eventOnEdit: eventOnEdit, eventOnDelete: eventOnDelete, eventOnCopy: eventOnCopy
                        });
                    } else {
                        item = this.createControl(parentComponent, control, {
                            model: model[i],
                            data: data,
                            errors: errors,
                            parentItem: parentItem,
                            buildermode: buildermode,
                            handleEvent: handleEvent,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            uploadUrl: uploadUrl,
                            downloadUrl: downloadUrl,
                            extendedData: extendedData,
                            parentPlaceholder: parentPlaceholder,
                            controlsToReplace: controlsToReplace,
                            needCheckReplace: needCheckReplace,
                            eventOnEdit: eventOnEdit, eventOnDelete: eventOnDelete, eventOnCopy: eventOnCopy
                        });
                    }
                }
            }

            if (buildermode) {
                if (i > 0 && i < model.length) {
                    var dropzone_bw = this.createBuilderDropzone(model[i].key + "-dropzone_bw", parentItem === undefined ? undefined : parentItem.key, model[i].key, "...", parentPlaceholder === undefined ? undefined : parentPlaceholder.key);
                    res.push(dropzone_bw);
                }

                var buildercontrol = _react2.default.createElement(_controlbar2.default, { key: model[i].key + "_controlbar",
                    text: model[i]["data-buildertype"],
                    model: model[i], parent: parentComponent,
                    onDelete: eventOnDelete, onEdit: eventOnEdit, onCopy: eventOnCopy,
                    isGroup: model[i]["data-buildertype"] === "formgroup",
                    controlOnRight: controlBarRight });

                if (controlBarRight) {
                    res.push(item);
                    res.push(buildercontrol);
                } else {
                    res.push(buildercontrol);
                    res.push(item);
                }
            } else {
                res.push(item);
            }
        }

        return res;
    },

    getControlByType: function getControlByType(buildertype) {
        var control = undefined;
        for (var i = 0; i < this.Items.length; i++) {
            if (this.Items[i].key === buildertype) {
                control = this.Items[i].control;
                break;
            }
        }
        return control;
    },
    getEditControlByType: function getEditControlByType(buildertype) {
        var control = undefined;
        for (var i = 0; i < this.Items.length; i++) {
            if (this.Items[i].key === buildertype) {
                control = this.Items[i].editControl;
                break;
            }
        }
        return control;
    },

    getStyle: function getStyle(model, buildermode) {
        var style = {
            marginTop: model["style-marginTop"],
            marginBottom: model["style-marginBottom"],
            marginLeft: model["style-marginLeft"],
            marginRight: model["style-marginRight"],
            width: model["style-width"],
            height: model["style-height"]
        };

        if (model["style-float"] !== undefined) {
            style.float = model["style-float"];
        }

        if (model["style-hidden"]) {
            if (buildermode) style.opacity = 0.2;else style.display = "none";
        }

        if (model["style-source"] !== undefined) {
            var properties = model["style-source"].split(';');
            properties.forEach(function (property) {
                var tup = property.split(':');
                if (tup.length === 2) {
                    var p = tup[0].replace(/^\s+|\s+$/g, '');
                    style[p] = tup[1].replace(/^\s+|\s+$/g, '');
                }
            });
        }

        if (model["style-font-size"] !== undefined) {
            style["font-size"] = model["style-font-size"];
        }

        return style;
    },


    regexForReplace: /{\S+}/gm,

    createControl: function createControl(parentComponent, control, _ref2) {
        var model = _ref2.model,
            data = _ref2.data,
            errors = _ref2.errors,
            parentItem = _ref2.parentItem,
            buildermode = _ref2.buildermode,
            children = _ref2.children,
            handleEvent = _ref2.handleEvent,
            getAdditionalDataForControl = _ref2.getAdditionalDataForControl,
            readOnlyControls = _ref2.readOnlyControls,
            readOnly = _ref2.readOnly,
            disableRefs = _ref2.disableRefs,
            uploadUrl = _ref2.uploadUrl,
            downloadUrl = _ref2.downloadUrl,
            extendedData = _ref2.extendedData,
            controlsToReplace = _ref2.controlsToReplace,
            needCheckReplace = _ref2.needCheckReplace,
            eventOnEdit = _ref2.eventOnEdit,
            eventOnDelete = _ref2.eventOnDelete,
            eventOnCopy = _ref2.eventOnCopy;


        var obj = void 0;
        var i = void 0;
        var res = undefined;
        var props = {
            key: model.key,
            name: model.key,
            className: model["style-customcss"],
            style: this.getStyle(model, buildermode),
            "data-buildertype": model["data-buildertype"]
        };
        var dataBuilderType = props["data-buildertype"];
        var needReplace = needCheckReplace || controlsToReplace.includes(model.key);

        if (buildermode && this.isContainer(props["data-buildertype"])) {
            props.className = (props.className == undefined ? "" : props.className + " ") + "dwkit-formbuilder-item-container";
        }

        if (!disableRefs) {
            props.ref = model.key;
        }

        if (model.readOnly !== undefined) {
            props.readOnly = model.readOnly;
        }

        if (readOnly || Array.isArray(readOnlyControls) && readOnlyControls.includes(model.key)) {
            props.readOnly = true;
        }
        var regexForReplace = this.regexForReplace;
        var replaceControlValue = function replaceControlValue(originalValue) {
            if (!needReplace || originalValue === undefined || originalValue === null) return originalValue;
            var replaceFromData = function replaceFromData(m) {
                if (data === undefined || data === null) return "";
                var value = data[m.slice(1, m.length - 1)];
                if (value === null || value === undefined) return "";
                return value;
            };
            if (Array.isArray(originalValue)) {
                var newValue = [];
                var needPushKey = false;
                originalValue.forEach(function (v) {
                    var newV = {};
                    for (var p in v) {
                        if (v.hasOwnProperty(p)) {
                            if (v[p] !== undefined && v[p] !== null && typeof v[p] === "string") {
                                newV[p] = v[p].replace(regexForReplace, function (m) {
                                    return replaceFromData(m);
                                });
                                if (!needPushKey && needCheckReplace && newV[p] !== v[p]) needPushKey = true;
                            } else if (Array.isArray(v[p])) {
                                newV[p] = replaceControlValue(v[p]);
                            } else {
                                newV[p] = v[p];
                            }
                        }
                    }
                    newValue.push(newV);
                });
                if (needPushKey) controlsToReplace.push(model.key);
                return newValue;
            } else {
                if (typeof originalValue !== "string") return originalValue;
                var _newValue = originalValue.replace(regexForReplace, function (m) {
                    return replaceFromData(m);
                });
                if (needCheckReplace && originalValue !== _newValue) {
                    controlsToReplace.push(model.key);
                }
                return _newValue;
            }
        };

        if (control === _semanticcontrol2.default) {
            if (dataBuilderType === "header") {
                props.content = replaceControlValue(model.content);
                props.subheader = replaceControlValue(model.subheader);
            } else if (dataBuilderType === "label") {
                props.content = replaceControlValue(model.content);
            } else if (dataBuilderType === "message") {
                props.content = replaceControlValue(model.content);
                props.header = replaceControlValue(model.header);
            } else if (dataBuilderType === "image") {
                props.src = replaceControlValue(model.src);
                props.href = replaceControlValue(model.href);
            } else if (dataBuilderType === "breadcrumb") {
                props.items = replaceControlValue(model.items);
            }

            res = _react2.default.createElement(_semanticcontrol2.default, _extends({}, props, { additionalParams: {
                    model: model, data: data, errors: errors, children: children, handleEvent: handleEvent, parentItem: parentItem, uploadUrl: uploadUrl, downloadUrl: downloadUrl
                } }));
        } else if (control === _dictionary2.default) {
            props.label = model.label;
            props.defaultValue = model.defaultvalue;
            props.placeholder = model.placeholder;
            props.loading = model.loading;
            props.error = model.error;
            props.disabled = model.disabled;
            props.fluid = model.fluid;
            props.selection = model.selection;
            props.multiple = model.multiple;
            props.search = model.search;
            props.dataModel = model.dataModel;
            props.clearable = model.clearable;
            props.columns = model.columns;
            props.paging = model.paging;
            props.pageSize = model.pageSize;
            props.getAdditionalDataForControl = getAdditionalDataForControl;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (handleEvent !== null) {
                props.onChange = function (e, _ref3) {
                    var name = _ref3.name,
                        value = _ref3.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            }
            props.parentIsForm = this.isForm(parentItem);

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_dictionary2.default, props);
        } else if (control === _dropdowntrigger2.default) {
            props.defaultValue = model.defaultValue;
            props.items = model.items;
            props.imageUrl = model.imageUrl;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_dropdowntrigger2.default, props);
        } else if (control === _search2.default) {
            props.url = model.url;
            props.category = model.category;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_search2.default, props);
        } else if (control === _radiogroup2.default) {
            var items = [];
            if (model["data-elements"] !== undefined) {
                if (Array.isArray(model["data-elements"])) {
                    items = model["data-elements"];
                } else {
                    items = _json2.default.parse(model["data-elements"]);
                }
            }

            if (handleEvent !== null) {
                props.onChange = function (e, _ref4) {
                    var name = _ref4.name,
                        value = _ref4.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            }

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_radiogroup2.default, _extends({}, props, {
                label: model.label,
                direction: model.direction,
                placeholder: model.placeholder,
                items: items }));
        } else if (control === _collectioneditor2.default) {
            props.columns = model.columns;
            props.draggable = model.draggable;
            props.hierarchical = model.hierarchical;
            props.parentIdField = model.parentIdField;
            props.idField = model.idField;
            props.childrenField = model.childrenField;
            props.collapseAll = model.collapseAll;
            props.disableAdd = model.disableAdd;
            props.placeholders = model.placeholders;
            if (props.placeholders != undefined) {
                props.getAdditionalDataForControl = getAdditionalDataForControl;
                props.createControl = function (parentControl, databuildertype, parameters) {
                    var control = DWKitFormControls.getControlByType(databuildertype);
                    if (control == undefined) {
                        console.error("Control is unsupported!", databuildertype, parentControl, parameters);
                        return;
                    }

                    var item = DWKitFormControls.createControl(parentControl, control, parameters);
                    var res = [];
                    if (parameters.buildermode) {
                        var buildercontrol = _react2.default.createElement(_controlbar2.default, { key: parameters.model.key + "_controlbar",
                            model: parameters.model, parent: parentComponent,
                            onDelete: eventOnDelete, onEdit: eventOnEdit, onCopy: eventOnCopy });
                        res.push(buildercontrol);
                        res.push(item);
                        return res;
                    }
                    return item;
                };
            }
            props.handleEvent = handleEvent;
            props.downloadUrl = downloadUrl;
            props.uploadUrl = uploadUrl;
            if (handleEvent !== null) {
                props.onChange = function (e, _ref5) {
                    var name = _ref5.name,
                        value = _ref5.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            } else if (buildermode) {
                props.onChange = function (e, _ref6) {
                    var name = _ref6.name,
                        value = _ref6.value;

                    props.value = value;
                };
            }

            if (data !== undefined) props.value = data[props.key];

            if (errors !== undefined) props.error = errors[props.key];

            if (buildermode && props.value === undefined && props.columns !== undefined) {
                props.buildermode = buildermode;
                props.createBuilderDropzone = function (columnName, value) {
                    return DWKitFormControls.createBuilderDropzone(props.key, props.key, undefined, columnName, columnName);
                };
                props.value = [];
                for (i = 0; i < 5; i++) {
                    props.value.push({});
                }

                if (Boolean(model.hierarchical) && model.parentIdField !== undefined && model.parentIdField !== "" && model.idField !== undefined && model.idField !== "") {
                    for (i = 1; i < 5; i++) {
                        var parent = props.value[i];
                        if (parent[model.idField] === undefined) {
                            parent[model.idField] = i;
                        }

                        for (var j = 0; j < 2; j++) {
                            var child = {};
                            child[model.parentIdField] = parent[model.idField];
                            props.value.push(child);
                        }
                    }
                }
            }

            res = _react2.default.createElement(_collectioneditor2.default, props);
        } else if (control === _gridview2.default) {
            props.columns = model.columns;
            props.multiselect = model.multiselect;
            props.rowKey = model.rowKey;
            props.editForm = model.editForm;
            props.editFlow = model.editFlow;
            props.editType = model.editType;
            props.pagerType = model.pagerType;
            props.pageSize = model.pageSize;
            props.rowHeight = model.rowHeight;
            props.minHeight = model.minHeight;
            props.autoHeight = model.autoHeight;
            props.offSet = model.offSet;
            props.disableSort = model.disableSort;
            props.resizeColumns = model.resizeColumns;
            props.editFormShowType = model.editFormShowType;
            props.getAdditionalDataForControl = getAdditionalDataForControl;
            props.handleEvent = handleEvent;
            props.defaultSort = model.defaultSort;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (data !== undefined) props.value = data[props.key];

            if (buildermode && props.value === undefined) {
                props.value = [];

                var _loop = function _loop() {
                    var obj = {};
                    props.columns.forEach(function (c) {
                        obj[c.key] = c.key + "_" + i;
                    });
                    props.value.push(obj);
                };

                for (i = 0; i < 30; i++) {
                    _loop();
                }
            }
            if (extendedData !== undefined && extendedData.filters !== undefined && extendedData.filters[props.key] !== undefined) {
                props.filter = new _functionalfilter.FunctionalFilter(extendedData.filters[props.key], props.columns.map(function (c) {
                    return c.key;
                }));
            }
            res = _react2.default.createElement(_gridview2.default, props);
        } else if (control === _menugroup2.default) {
            props["data-items"] = replaceControlValue(model.items);
            props.pointing = model.pointing;
            props.secondary = model.secondary;
            props.tabular = model.tabular;
            props.fluid = model.fluid;
            props.vertical = model.vertical;
            props.activeitem = model.activeitem;
            props.link = model.link;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_menugroup2.default, props);
        } else if (control === _chartview2.default) {
            props.chartType = model.chartType;
            props.responsive = model.responsive;
            props.legendPosition = model.legendPosition;
            props.title = model.title;
            props.titleSize = model.titleSize;
            props.datasetCustom = model.datasetCustom;
            props.dataLabels = model.dataLabels;
            props.datasetLabel = model.datasetLabel;
            props.datasetSteppedLine = model.datasetSteppedLine;
            props.datasetBorderColor = model.datasetBorderColor;
            props.datasetFill = model.datasetFill;
            props.datasetBorderWidth = model.datasetBorderWidth;
            props.datasetBackgroundColor = model.datasetBackgroundColor;

            if (buildermode) {
                if (props.datasetCustom) {
                    props.value = [1, 2, 3, 4, 3, 2, 1];
                } else {

                    var testData = props.chartType !== "scatter" ? [6, 23, 15, 3] : [{ x: 6, y: -12 }, { x: 11, y: 1 }, { x: 24, y: 5 }, { x: 40, y: 32 }];

                    props.value = {
                        labels: ["Q1", "Q2", "Q3", "Q4"],
                        datasets: [{
                            data: testData
                        }]
                    };
                }
            } else {
                if (data !== undefined) props.value = data[props.key];
            }

            res = _react2.default.createElement(_chartview2.default, props);
        } else if (control === _workflowbar2.default) {
            props.blockSetState = model.blockSetState;
            props.setStateButton = model.setStateButton;
            props.handleEvent = handleEvent;
            props.getAdditionalDataForControl = getAdditionalDataForControl;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (buildermode) {
                props.commands = [{ value: "approve", text: "Approve", type: 1 }, { value: "back", text: "Back", type: 2 }];

                props.states = [{ value: "draft", text: "Draft" }, { value: "state1", text: "State 1" }, { value: "state2", text: "State 2" }, { value: "state3", text: "State 3" }, { value: "finish", text: "Finish" }];
            }

            res = _react2.default.createElement(_workflowbar2.default, props);
        } else if (control === _container2.default) {
            res = _react2.default.createElement(_container2.default, _extends({}, props, { children: children }));
        } else if (control === _staticcontent2.default) {
            props.content = replaceControlValue(model.content);
            props.isHtml = model.isHtml;
            res = _react2.default.createElement(_staticcontent2.default, props);
        } else if (control === _dropzone2.default) {
            props.iconFiletypes = model.iconFiletypes;
            props.postUrl = uploadUrl;
            props.showFiletypeIcon = model.showFiletypeIcon;
            props.autoProcessQueue = model.autoProcessQueue;
            props.addRemoveLinks = model.addRemoveLinks;
            res = _react2.default.createElement(_dropzone2.default, _extends({}, props, {
                additionalParams: { model: model, data: data, errors: errors, children: children, handleEvent: handleEvent, parentItem: parentItem } }));
        } else {
            console.error("Control is unsupported!", control, model);
        }

        return res;
    },

    isContainer: function isContainer(key) {
        return key === 'form' || key === 'formgroup' || key === 'grid' || key === 'gridrow' || key === 'gridcolumn' || key === 'card' || key === 'cardcontent' || key === 'container' || key === 'div';
    },
    isForm: function isForm(model) {
        return model !== null && model !== undefined && (model["data-buildertype"] === "form" || model["data-buildertype"] === "formgroup");
    },
    createBuilderDropzone: function createBuilderDropzone(key, elementToInsert, elementafter, text, placeholderKey) {
        // if(text === undefined)
        text = "DROP ZONE";
        return _react2.default.createElement(
            'div',
            { name: key, key: key, elementafter: elementafter, elementtoinsert: elementToInsert, placeholderkey: placeholderKey, className: 'dwkit-formbuilder-zone' },
            text
        );
    },

    fillDefaultValues: function fillDefaultValues(model, defaultValues) {
        var control = undefined;
        for (var k in defaultValues) {
            if (model[k] === undefined) model[k] = defaultValues[k];
        }
        return model;
    }
};

module.exports = DWKitFormControls;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(40)();
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Reflux = __webpack_require__(16);
var BuilderActions = __webpack_require__(6);
var DWKitFormControls = __webpack_require__(7);

var _data;

var DWKitStore = Reflux.createStore({
  init: function init() {
    this.listenTo(BuilderActions.add, this.add);
    this.listenTo(BuilderActions.move, this.move);
    this.listenTo(BuilderActions.remove, this.remove);
    this.listenTo(BuilderActions.save, this.save);
    this.listenTo(BuilderActions.saveData, this._updateOrder);

    _data = [];
  },

  move: function move(key, el) {
    if (el == undefined) return;

    var item = this.findItemByKey(key, _data);
    var sortedArray = this._excludeItemByKey(key, _data);

    if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_footer') {
      sortedArray.push(item);
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_header') {
      sortedArray.unshift(item);
    } else if (el.attributes['elementtoinsert'] != undefined) {
      var parentControl;
      var insertIndex = 0;
      var parentKey = el.attributes['elementtoinsert'];

      if (parentKey != undefined) {
        parentControl = this.findItemByKey(parentKey.value, sortedArray);
      }

      if (parentControl != undefined) {
        var placeholderKey = el.attributes['placeholderkey'];
        var container = undefined;

        if (placeholderKey === undefined) {
          if (parentControl.children == undefined) parentControl.children = [];
          container = parentControl.children;
        } else {
          if (parentControl.placeholders === undefined) parentControl.placeholders = {};
          if (parentControl.placeholders[placeholderKey.value] == undefined) {
            parentControl.placeholders[placeholderKey.value] = [];
          }
          container = parentControl.placeholders[placeholderKey.value];
        }

        if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_footer')) {
          container.push(item);
        } else if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_header')) {
          container.unshift(item);
        } else {
          var afterKey = el.attributes['elementafter'];
          var afterControl;
          if (afterKey != undefined) {
            afterControl = this.findItemByKey(afterKey.value, container);
          }
          container.splice(container.indexOf(afterControl), 0, item);
        }
      } else {
        console.error("ERROR: element is not found", parentKey, item, el);
      }
    } else if (el.attributes['elementafter'] != undefined) {
      var control;
      var afterKey = el.attributes['elementafter'];
      if (afterKey != undefined) {
        control = this.findItemByKey(afterKey.value, sortedArray);
      }

      if (control != undefined) {
        sortedArray.splice(sortedArray.indexOf(control), 0, item);
      } else {
        console.error("ERROR: element is not found", afterKey, item, el);
      }
    }

    this.setData(sortedArray);
  },
  _excludeItemByKey: function _excludeItemByKey(key, data) {
    var sortedArray = [];
    for (var i = 0; i < data.length; i++) {
      if (data[i].key == key) continue;

      sortedArray.push(data[i]);

      if (data[i].children) {
        sortedArray[sortedArray.length - 1].children = this._excludeItemByKey(key, data[i].children);
      }

      if (data[i].placeholders != undefined) {
        for (var ph in data[i].placeholders) {
          if (Array.isArray(data[i].placeholders[ph])) {
            sortedArray[sortedArray.length - 1].placeholders[ph] = this._excludeItemByKey(key, data[i].placeholders[ph]);
          }
        }
      }
    }
    return sortedArray;
  },
  add: function add(item, el) {
    var res = DWKitFormControls.fillDefaultValues({
      key: this.getDefaultKey(item.key),
      "data-buildertype": item.builderType !== undefined ? item.builderType : item.key
    }, item.defaultValues);

    if (el == undefined) {
      if (_data.length > 0 && _data[_data.length - 1]["data-buildertype"] == 'form') {
        var p = _data[_data.length - 1];
        if (p.children == undefined) p.children = [];
        p.children.push(res);
      } else {
        _data.push(res);
      }
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_footer') {
      _data.push(res);
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_header') {
      _data.unshift(res);
    } else if (el.attributes['elementtoinsert'] != undefined) {
      var parentControl;
      var insertIndex = 0;
      var parentKey = el.attributes['elementtoinsert'];

      if (parentKey != undefined) {
        parentControl = this.findItemByKey(parentKey.value, _data);
      }

      if (parentControl != undefined) {
        var placeholderKey = el.attributes['placeholderkey'];
        var container = undefined;

        if (placeholderKey === undefined) {
          if (parentControl.children == undefined) parentControl.children = [];
          container = parentControl.children;
        } else {
          if (parentControl.placeholders === undefined) {
            parentControl.placeholders = {};
          }
          if (parentControl.placeholders[placeholderKey.value] == undefined) {
            parentControl.placeholders[placeholderKey.value] = [];
          }
          container = parentControl.placeholders[placeholderKey.value];
        }

        if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_footer')) {
          container.push(res);
        } else if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_header')) {
          container.unshift(res);
        } else {
          var afterKey = el.attributes['elementafter'];
          var afterControl;
          if (afterKey != undefined) {
            afterControl = this.findItemByKey(afterKey.value, container);
          }
          container.splice(container.indexOf(afterControl), 0, res);
        }
      } else {
        console.error("ERROR: element is not found", parentKey, item, el);
      }
    } else if (el.attributes['elementafter'] != undefined) {
      var control;
      var afterKey = el.attributes['elementafter'];
      if (afterKey != undefined) {
        control = this.findItemByKey(afterKey.value, _data);
      }

      if (control != undefined) {
        _data.splice(_data.indexOf(control), 0, res);
      } else {
        console.error("ERROR: element is not found", afterKey, buildertype, title, el);
      }
    }

    this.trigger(_data);
  },

  remove: function remove(item) {
    this.removeItemByKey(item.key, _data);
    this.trigger(_data);
  },

  copy: function copy(item) {
    var newItem = this.copyObj(item);
    this.insertAfterKey(newItem, item.key, _data);
    this.makeUniqueKeys(newItem);
    this.trigger(_data);
  },

  getData: function getData() {
    return _data;
  },

  setData: function setData(data) {
    _data = data;
    this.trigger(_data);
  },

  _updateOrder: function _updateOrder(elements) {
    _data = elements;
    this.trigger(_data);
  },

  getDefaultKey: function getDefaultKey(name) {
    var index = 1;
    var tmp = name + '_' + index;

    var allKeys = this.getAllKeys(_data);
    for (var i = 0; i < allKeys.length; i++) {
      var item = allKeys[i];
      var tmp = name + '_' + index;
      if (item == tmp) {
        index++;
        i = -1;
      }
    }

    return tmp;
  },
  getAllKeys: function getAllKeys(items) {
    var res = [];
    if (items != undefined) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        res.push(item.key);
        if (item.children != undefined) {
          var childkeys = this.getAllKeys(item.children);
          res = res.concat(childkeys);
        } else if (item.placeholders != undefined) {
          for (var ph in item.placeholders) {
            if (Array.isArray(item.placeholders[ph])) {
              var phkeys = this.getAllKeys(item.placeholders[ph]);
              res = res.concat(phkeys);
            }
          }
        }
      }
    }

    return res;
  },
  getByKey: function getByKey(key) {
    return this.findItemByKey(key, _data);
  },
  findItemByKey: function findItemByKey(key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) return item;else if (item.children != undefined) {
        var res = this.findItemByKey(key, item.children);
        if (res != undefined) return res;
      } else if (item.placeholders != undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            var res = this.findItemByKey(key, item.placeholders[ph]);
            if (res != undefined) return res;
          }
        }
      }
    }
    return undefined;
  },
  insertAfterKey: function insertAfterKey(insertItem, key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) {
        items.splice(i + 1, 0, insertItem);
        return true;
      }

      if (item.children !== undefined) {
        if (this.insertAfterKey(insertItem, key, item.children)) {
          return true;
        }
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            if (this.insertAfterKey(insertItem, key, item.placeholders[ph])) {
              return true;
            }
          }
        }
      }
    }
    return undefined;
  },
  updateItemByKey: function updateItemByKey(key, item) {
    var data = this.getByKey(key);
    for (var i in item) {
      data[i] = item[i];
    }

    if (key != item.key) {
      this.replaceDepensKeys(key, item.key);
    }

    this.trigger(_data);
  },

  replaceDepensKeys: function replaceDepensKeys(oldKey, newKey, items) {
    if (items == undefined) items = _data;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (Array.isArray(item["events-onclick-targets"])) {
        var targets = item["events-onclick-targets"];
        for (var j = 0; j < targets.length; j++) {
          if (targets[j] == oldKey) targets[j] = newKey;
        }
      }

      if (item.children != undefined) {
        this.replaceDepensKeys(oldKey, newKey, item.children);
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            this.replaceDepensKeys(oldKey, newKey, item.placeholders[ph]);
          }
        }
      }
    }
  },
  removeItemByKey: function removeItemByKey(key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) {
        items.splice(i, 1);
        break;
      }

      if (item.children != undefined) {
        this.removeItemByKey(key, item.children);
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            this.removeItemByKey(key, item.placeholders[ph]);
          }
        }
      }
    }
  },
  copyObj: function copyObj(obj) {
    if (null == obj || "object" != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;
    var copy = obj.constructor();

    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) copy[attr] = this.copyObj(obj[attr]);
    }
    return copy;
  },
  makeUniqueKeys: function makeUniqueKeys(obj) {
    var me = this;
    var buildertype = obj["data-buildertype"];
    if (buildertype != undefined) {
      obj.key = this.getDefaultKey(buildertype);
    }

    if (Array.isArray(obj.children)) {
      obj.children.forEach(function (c) {
        me.makeUniqueKeys(c);
      });
    }

    if (obj.placeholders !== undefined) {
      for (var ph in obj.placeholders) {
        if (Array.isArray(obj.placeholders[ph])) {
          obj.placeholders[ph].forEach(function (c) {
            me.makeUniqueKeys(c);
          });
        }
      }
    }
  }
});

module.exports = DWKitStore;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.__keep = exports.joinConcat = exports.joinStrict = exports.joinLeading = exports.all = exports.joinTrailing = exports.use = exports.nextTick = exports.setEventEmitter = exports.createActions = exports.createStore = exports.createAction = exports.utils = exports.StoreMethods = exports.PublisherMethods = exports.ListenerMethods = exports.ActionMethods = exports.version = undefined;

var _ActionMethods = __webpack_require__(17);

var ActionMethods = _interopRequireWildcard(_ActionMethods);

var _ListenerMethods = __webpack_require__(3);

var ListenerMethods = _interopRequireWildcard(_ListenerMethods);

var _PublisherMethods = __webpack_require__(12);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _StoreMethods = __webpack_require__(20);

var StoreMethods = _interopRequireWildcard(_StoreMethods);

var _joins = __webpack_require__(18);

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _createAction = __webpack_require__(32);

var _createStore = __webpack_require__(19);

var _Keep = __webpack_require__(11);

var __keep = _interopRequireWildcard(_Keep);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var version = {
    "reflux-core": "1.0.0"
};

var joinTrailing = (0, _joins.staticJoinCreator)("last");
var all = joinTrailing; // Reflux.all alias for backward compatibility
var joinLeading = (0, _joins.staticJoinCreator)("first");
var joinStrict = (0, _joins.staticJoinCreator)("strict");
var joinConcat = (0, _joins.staticJoinCreator)("all");

var utils = _;


/**
 * Convenience function for creating a set of actions
 *
 * @param definitions the definitions for the actions to be created
 * @returns an object with actions of corresponding action names
 */
var createActions = function () {
    var reducer = function reducer(definitions, actions) {
        Object.keys(definitions).forEach(function (actionName) {
            var val = definitions[actionName];
            actions[actionName] = (0, _createAction.createAction)(val);
        });
    };

    return function (definitions) {
        var actions = {};
        if (definitions instanceof Array) {
            definitions.forEach(function (val) {
                if (_.isObject(val)) {
                    reducer(val, actions);
                } else {
                    actions[val] = (0, _createAction.createAction)(val);
                }
            });
        } else {
            reducer(definitions, actions);
        }
        return actions;
    };
}();

/**
 * Sets the eventmitter that Reflux uses
 */
function setEventEmitter(ctx) {
    _.EventEmitter = ctx;
}

/**
 * Sets the method used for deferring actions and stores
 */
function nextTick(nextTick) {
    _.nextTick = nextTick;
}

function use(pluginCb) {
    pluginCb(this);
}

/**
 * Provides the set of created actions and stores for introspection
 */
/*eslint-disable no-underscore-dangle*/


// export in format that supports syntax: var Reflux = require('reflux-core');
exports.version = version;
exports.ActionMethods = ActionMethods;
exports.ListenerMethods = ListenerMethods;
exports.PublisherMethods = PublisherMethods;
exports.StoreMethods = StoreMethods;
exports.utils = utils;
exports.createAction = _createAction.createAction;
exports.createStore = _createStore.createStore;
exports.createActions = createActions;
exports.setEventEmitter = setEventEmitter;
exports.nextTick = nextTick;
exports.use = use;
exports.joinTrailing = joinTrailing;
exports.all = all;
exports.joinLeading = joinLeading;
exports.joinStrict = joinStrict;
exports.joinConcat = joinConcat;
exports.__keep = __keep;
/*eslint-enable no-underscore-dangle*/

// export in format that supports syntax: import Reflux from 'reflux-core';

Object.defineProperty(exports, "default", {
    get: function get() {
        return exports;
    }
});

/**
 * Warn if Function.prototype.bind not available
 */
if (!Function.prototype.bind) {
    console.error("Function.prototype.bind not available. " + "ES5 shim required. " + "https://github.com/spoike/refluxjs#es5");
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

// this needs to be set to true before Keep.js starts storing, done via useKeep
var use = false;

var createdStores = [];

var createdActions = [];

function useKeep() {
	var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}

function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}

function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}

function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}

exports.useKeep = useKeep;
exports.addStore = addStore;
exports.addAction = addAction;
exports.createdStores = createdStores;
exports.createdActions = createdActions;
exports.reset = reset;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * A module of methods for object that you want to be able to listen to.
 * This module is consumed by `createStore` and `createAction`
 */

/**
 * Hook used by the publisher that is invoked before emitting
 * and before `shouldEmit`. The arguments are the ones that the action
 * is invoked with. If this function returns something other than
 * undefined, that will be passed on as arguments for shouldEmit and
 * emission.
 */
var preEmit = exports.preEmit = function preEmit() {};

/**
 * Hook used by the publisher after `preEmit` to determine if the
 * event should be emitted with given arguments. This may be overridden
 * in your application, default implementation always returns true.
 *
 * @returns {Boolean} true if event should be emitted
 */
var shouldEmit = exports.shouldEmit = function shouldEmit() {
    return true;
};

/**
 * Subscribes the given callback for action triggered
 *
 * @param {Function} callback The callback to register as event handler
 * @param {Mixed} [optional] bindContext The context to bind the callback with
 * @returns {Function} Callback that unsubscribes the registered event handler
 */
var listen = exports.listen = function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
};

/**
 * Publishes an event using `this.emitter` (if `shouldEmit` agrees)
 */
var trigger = exports.trigger = function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
};

/**
 * Tries to publish the event on the next tick
 */
var triggerAsync = exports.triggerAsync = function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
};

/**
 * Wraps the trigger mechanism with a deferral function.
 *
 * @param {Function} callback the deferral function,
 *        first argument is the resolving function and the
 *        rest are the arguments provided from the previous
 *        trigger invocation
 */
var deferWith = exports.deferWith = function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(2),
    ListenerMethods = __webpack_require__(3);

/**
 * A module meant to be consumed as a mixin by a React component. Supplies the methods from
 * `ListenerMethods` mixin and takes care of teardown of subscriptions.
 * Note that if you're using the `connect` mixin you don't need this mixin, as connect will
 * import everything this mixin contains!
 */
module.exports = _.extend({

    /**
     * Cleans up all listener previously registered.
     */
    componentWillUnmount: ListenerMethods.stopListeningToAll

}, ListenerMethods);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _semanticUiReact = __webpack_require__(1);

var _upload = __webpack_require__(22);

var _upload2 = _interopRequireDefault(_upload);

var _datepicker = __webpack_require__(23);

var _datepicker2 = _interopRequireDefault(_datepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionEditor = function (_React$Component) {
    _inherits(CollectionEditor, _React$Component);

    function CollectionEditor(props) {
        _classCallCheck(this, CollectionEditor);

        var _this = _possibleConstructorReturn(this, (CollectionEditor.__proto__ || Object.getPrototypeOf(CollectionEditor)).call(this, props));

        _this.state = {
            expanded: {}
        };
        return _this;
    }

    _createClass(CollectionEditor, [{
        key: 'applyCollapseAll',
        value: function applyCollapseAll(data) {
            for (var p in data) {
                if (this.state.expanded[p] == undefined) this.state.expanded[p] = false;
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var columns = this.props.columns;
            var data = this.props.value;
            var error = this.props.error;

            if (Boolean(this.props.collapseAll) && Array.isArray(data)) {
                this.applyCollapseAll(data);
            }

            if (columns == undefined || columns.length == 0) {
                return _react2.default.createElement(
                    'div',
                    null,
                    'Fill columns property!'
                );
            }

            this.state.data = this.getCopyRowsFromProps();
            return _react2.default.createElement(
                'div',
                { style: this.props.style, className: 'field' },
                _react2.default.createElement(
                    'label',
                    null,
                    this.props.label
                ),
                _react2.default.createElement(
                    'table',
                    { className: 'dwkit-collectioneditor' },
                    _react2.default.createElement(
                        'tbody',
                        null,
                        this.renderHeaderRow(columns),
                        this.renderRows(columns, this.state.data, error)
                    )
                )
            );
        }
    }, {
        key: 'renderHeaderRow',
        value: function renderHeaderRow(columns) {
            var res = [];
            var index = 0;
            columns.forEach(function (c) {
                var key;
                var title;
                var width;
                var dataListOptions = undefined;
                if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                    key = c.key;
                    title = c.name;
                    width = c.width;
                    if (Array.isArray(c.dataList)) dataListOptions = c.dataList;
                } else {
                    key = c;
                    title = c;
                }

                if (title != undefined && title.length >= 2) {
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                }

                var dataListControl;
                var dataListId = undefined;
                if (dataListOptions != undefined) {
                    dataListId = key + "_datalist";
                    var optValue = [];
                    dataListOptions.forEach(function (o) {
                        optValue.push(_react2.default.createElement('option', { key: o, value: o }));
                    });
                    dataListControl = _react2.default.createElement(
                        'datalist',
                        { key: dataListId, id: dataListId },
                        optValue
                    );
                }

                res.push(_react2.default.createElement(
                    'td',
                    { key: index, style: { width: width } },
                    title,
                    dataListControl
                ));
                index++;
            });

            if (!Boolean(this.props.readOnly) && this.props.disableAdd !== true) {
                var addcontent = "Add";
                if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.collectioneditor != undefined) {
                    addcontent = window.DWKitAdminLang.collectioneditor.add;
                }
                res.push(_react2.default.createElement(
                    'td',
                    { key: 'btntd', className: 'dwkit-collectioneditor-buttoncol' },
                    _react2.default.createElement(
                        'a',
                        { key: 'btnadd', className: 'dwkit-btn', onClick: this.btnAdd.bind(this) },
                        addcontent
                    )
                ));
            }

            return _react2.default.createElement(
                'tr',
                { key: 'headertr', className: 'dwkit-collectioneditor-header' },
                res
            );
        }
    }, {
        key: 'getDragColumn',
        value: function getDragColumn(rows, i) {
            var draggable = !Boolean(this.props.readOnly) && Boolean(this.props.draggable);
            if (draggable) {
                return _react2.default.createElement(
                    'div',
                    {
                        draggable: draggable,
                        onDragStart: this.onDragStart.bind(this, i, rows),
                        onDragEnd: this.onDragEnd.bind(this, i, rows),
                        onDragOver: this.onDragOver.bind(this),
                        onDrop: this.onDrop.bind(this, i, rows),
                        key: 'celldrag', className: 'dwkit-collectioneditor-action' },
                    _react2.default.createElement(_semanticUiReact.Icon, { onClick: this.onExpand.bind(this, i, false), name: 'ellipsis vertical' })
                );
            }
            return undefined;
        }
    }, {
        key: 'renderRows',
        value: function renderRows(columns, data, errors, parentIdValue, level, prefix) {
            var _this2 = this;

            var me = this;
            var res = [];
            var rows = data;
            if (level == undefined) level = 0;

            if (prefix === undefined) prefix = "";

            for (var i = 0; i < rows.length; i++) {
                if (this.props.childrenField === undefined && this.props.hierarchical) {
                    if (rows[i][this.props.parentIdField] != parentIdValue) {
                        continue;
                    }
                }

                var dragcol = this.getDragColumn(rows, i);
                var expand = undefined;
                var children = undefined;
                if (this.props.hierarchical) {
                    var icon = void 0;
                    var parentPrefix = prefix + String(i + "_");
                    if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                        var parentId = rows[i][this.props.idField];
                        if (parentId != undefined && parentId != "") {
                            children = this.renderRows(columns, data, errors, parentId, level + 1, parentPrefix);
                            if (children.length > 0) {
                                var isexpanded = this.state.expanded[prefix + i];
                                if (isexpanded == undefined || isexpanded == true) {
                                    icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, false), className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                                } else {
                                    icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, true), className: 'dwkit-collectioneditor-imgbutton', src: '/images/expand.svg' });
                                    children = undefined;
                                }
                            }
                        }
                    } else if (Array.isArray(rows[i][this.props.childrenField]) && rows[i][this.props.childrenField].length > 0) {
                        children = this.renderRows(columns, rows[i][this.props.childrenField], errors, undefined, level + 1, parentPrefix);
                        if (children.length > 0) {
                            var isexpanded = this.state.expanded[prefix + i];
                            if (isexpanded == undefined || isexpanded == true) {
                                icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, false), className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                            } else {
                                icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, true), className: 'dwkit-collectioneditor-imgbutton', src: '/images/expand.svg' });
                                children = undefined;
                            }
                        }
                    } else {
                        icon = _react2.default.createElement('img', { style: { opacity: 0 }, className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                    }

                    expand = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-collectioneditor-action' },
                        icon
                    );
                }

                var row = [];
                var errorOnRow = Array.isArray(errors) ? errors[i] : undefined;
                for (var j = 0; j < columns.length; j++) {
                    var colName = void 0;
                    var control = this.props.readOnly ? "" : "input";
                    var dataListId = undefined;
                    var options = undefined;
                    if (_typeof(columns[j]) === 'object') {
                        colName = columns[j].key;
                        control = columns[j].control;
                        if (Array.isArray(columns[j].dataList)) {
                            dataListId = colName + "_datalist";
                        }

                        if (Array.isArray(columns[j].options)) {
                            options = columns[j].options;
                        }
                    } else {
                        colName = columns[j];
                    }

                    var errorFlag = undefined;
                    if (errorOnRow != undefined) {
                        errorFlag = Boolean(errorOnRow[colName]);
                    }

                    var element = undefined;
                    if (control == "checkbox") {
                        element = _react2.default.createElement(_semanticUiReact.Form.Checkbox, {
                            key: i + "_" + j,
                            name: colName,
                            checked: Boolean(rows[i][colName]),
                            readOnly: Boolean(this.props.readOnly),
                            error: errorFlag,
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "span") {
                        element = _react2.default.createElement(
                            'span',
                            {
                                key: i + "_" + j,
                                name: colName },
                            rows[i][colName]
                        );
                    } else if (control == "number") {
                        var value = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Input, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'number',
                            error: errorFlag,
                            value: value,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "date") {
                        var _value = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_datepicker2.default, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'date',
                            error: errorFlag,
                            value: _value,
                            isForm: true,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "datetime") {
                        var _value2 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_datepicker2.default, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'datetime',
                            error: errorFlag,
                            value: _value2,
                            isForm: true,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "dropdown") {
                        var _value3 = rows[i][colName] == null ? Boolean(columns[j].multiple) ? [] : "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Dropdown, {
                            key: i + "_" + j,
                            name: colName,
                            multiple: Boolean(columns[j].multiple),
                            error: errorFlag,
                            value: _value3,
                            options: options,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]),
                            selection: true, fluid: true, search: true });
                    } else if (control == "file" || control == "file2") {
                        var _value4 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_upload2.default, {
                            key: i + "_" + j,
                            name: colName,
                            error: errorFlag,
                            value: _value4,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]),
                            downloadUrl: this.props.downloadUrl,
                            uploadUrl: this.props.uploadUrl,
                            isForm: true,
                            hideClearButton: control == "file2" });
                    } else if (control == "custom") {
                        var _value5 = rows[i][colName] == null ? "" : rows[i][colName];
                        if (this.props.placeholders != undefined && Array.isArray(this.props.placeholders[colName]) && this.props.placeholders[colName].length > 0) {
                            var model = this.props.placeholders[colName][0];
                            if (model != undefined) {
                                (function () {
                                    model.key = colName;
                                    var row = rows[i];
                                    element = _this2.props.createControl(_this2, model["data-buildertype"], {
                                        model: model, data: row, errors: errorOnRow,
                                        parentItem: _this2.props.name,
                                        buildermode: _this2.props.buildermode,
                                        handleEvent: function handleEvent(args) {
                                            if (args.eventName == "onChange") {
                                                me.handleChange(row, args.syntheticEvent, { name: args.name, value: args.value, checked: args.checked });
                                            } else {
                                                this.props.handleChange(args);
                                            }
                                        },
                                        getAdditionalDataForControl: _this2.props.getAdditionalDataForControl,
                                        readOnly: _this2.props.readOnly,
                                        uploadUrl: _this2.props.uploadUrl,
                                        downloadUrl: _this2.props.downloadUrl,
                                        controlsToReplace: []
                                    });
                                })();
                            }
                        } else if (this.props.buildermode && this.props.createBuilderDropzone != undefined) {
                            element = this.props.createBuilderDropzone(colName, _value5);
                        }
                    } else {
                        var _value6 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Input, {
                            key: i + "_" + j,
                            name: colName,
                            list: dataListId,
                            error: errorFlag,
                            value: _value6,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    }

                    if (j == 0) {
                        var paddingLeft = void 0;
                        if (level != 0) {
                            paddingLeft = String(level * 15 + 5) + "px";
                        }

                        row.push(_react2.default.createElement(
                            'td',
                            { key: i + "_" + j + "td", style: { paddingLeft: paddingLeft } },
                            expand,
                            dragcol,
                            element
                        ));
                    } else row.push(_react2.default.createElement(
                        'td',
                        { key: i + "_" + j + "td" },
                        element
                    ));
                }

                if (!Boolean(this.props.readOnly)) {
                    if (this.props.hierarchical) {
                        row.push(_react2.default.createElement(
                            'td',
                            { key: 'celldelete', className: 'dwkit-collectioneditor-cellbtn' },
                            _react2.default.createElement(
                                'div',
                                { className: 'field' },
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'addchild', onClick: this.btnAddChild.bind(this, i, rows), link: true, name: 'add' }),
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'delete', onClick: this.btnDelete.bind(this, i, rows), link: true, name: 'delete' })
                            )
                        ));
                    } else {
                        row.push(_react2.default.createElement(
                            'td',
                            { key: 'celldelete', className: 'dwkit-collectioneditor-cellbtn' },
                            _react2.default.createElement(
                                'div',
                                { className: 'field' },
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'delete', onClick: this.btnDelete.bind(this, i, undefined), link: true, name: 'delete' })
                            )
                        ));
                    }
                }

                res.push(_react2.default.createElement(
                    'tr',
                    { key: prefix + i, className: 'dwkit-collectioneditor-row', 'data-rowindex': i },
                    row
                ));
                res = res.concat(children);
            }

            return res;
        }
    }, {
        key: 'btnDelete',
        value: function btnDelete(index, rows) {
            if (this.props.onChange == undefined) return;

            if (rows === undefined) rows = this.state.data;

            var obj = rows[index];
            rows.splice(index, 1);

            this.sendChangesToParent();
        }
    }, {
        key: 'btnAddChild',
        value: function btnAddChild(index, rows) {
            if (rows === undefined) rows = this.state.data == undefined ? [] : this.state.datae;

            var objParent = rows[index];
            var obj = this.props.defaultrow == undefined ? {} : _extends({}, this.props.defaultrow);

            if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                obj[this.props.parentIdField] = objParent[this.props.idField];
                rows.push(obj);
            } else {
                if (!Array.isArray(rows[index][this.props.childrenField])) rows[index][this.props.childrenField] = [];

                rows[index][this.props.childrenField].push(obj);
            }

            if (this.props.handleEvent != undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onAddChild", parameters: { rowIdx: rows.length - 1, row: obj } });
            }
            this.sendChangesToParent();
        }
    }, {
        key: 'btnAdd',
        value: function btnAdd() {
            var obj = this.props.defaultrow == undefined ? {} : this.props.defaultrow;
            this.state.data.push(obj);

            if (this.props.handleEvent != undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onAdd", parameters: { rowIdx: this.state.data.length - 1, row: obj } });
            }

            this.sendChangesToParent();
        }
    }, {
        key: 'onExpand',
        value: function onExpand(i, value) {
            this.state.expanded[i] = value;
            this.forceUpdate();
        }
    }, {
        key: 'onDragOver',
        value: function onDragOver(e) {
            e.preventDefault();
        }
    }, {
        key: 'onDragStart',
        value: function onDragStart(index, rows, e) {
            e.dataTransfer.setData('index', index);
            this.state.dragElementIndex = index;
            this.state.dragRows = rows;
        }
    }, {
        key: 'onDragEnd',
        value: function onDragEnd(index, e) {
            this.state.dragElementIndex = undefined;
            this.state.dragRows = undefined;
        }
    }, {
        key: 'onDrop',
        value: function onDrop(index, rows, e) {
            var rowIndexA = this.state.dragElementIndex;
            var rowsA = this.state.dragRows;
            var rowIndexB = index;
            var rowsB = rows;
            if (rowIndexA != undefined) {
                if (rowIndexB != rowIndexA) {
                    if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                        rowsA[rowIndexA][this.props.parentIdField] = rowsB[rowIndexB][this.props.parentIdField];
                    }
                    rowsB.splice(rowIndexB, 0, rowsA.splice(rowIndexA, 1)[0]);
                    this.sendChangesToParent();
                }
                e.preventDefault();
            }
            return false;
        }
    }, {
        key: 'handleChange',
        value: function handleChange(item, e, _ref) {
            var name = _ref.name,
                value = _ref.value,
                checked = _ref.checked;

            if (this.props.onChange == undefined) return;

            if (value == undefined && checked != undefined) {
                item[name] = checked;
            } else {
                item[name] = value;
            }

            this.sendChangesToParent();

            if (e != undefined) e.preventDefault();else this.forceUpdate();
        }
    }, {
        key: 'getCopyRowsFromProps',
        value: function getCopyRowsFromProps() {
            var rows = this.props.value == undefined ? [] : this.props.value;
            this.state.stringmode = false;
            if (!Array.isArray(rows)) {
                rows = _json2.default.parse(rows);
                this.state.stringmode = true;
            } else {
                rows = rows.slice();
            }

            return rows;
        }
    }, {
        key: 'sendChangesToParent',
        value: function sendChangesToParent() {
            var rows = this.state.data;
            var res = this.state.stringmode ? _json2.default.stringify(rows) : rows;
            this.props.onChange(null, { name: this.props.name, value: res });
        }
    }]);

    return CollectionEditor;
}(_react2.default.Component);

exports.default = CollectionEditor;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var Reflux = __webpack_require__(10);

Reflux.serverMode = typeof window !== 'object';

Reflux.connect = __webpack_require__(33);

Reflux.connectFilter = __webpack_require__(34);

Reflux.ListenerMixin = __webpack_require__(13);

Reflux.listenTo = __webpack_require__(35);

Reflux.listenToMany = __webpack_require__(36);

__webpack_require__(37);

module.exports = Reflux;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.staticJoinCreator = staticJoinCreator;
exports.instanceJoinCreator = instanceJoinCreator;

var _createStore = __webpack_require__(19);

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Internal module used to create static and instance join methods
 */

var slice = Array.prototype.slice,
    strategyMethodNames = {
    strict: "joinStrict",
    first: "joinLeading",
    last: "joinTrailing",
    all: "joinConcat"
};

/**
 * Used in `index.js` to create the static join methods
 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
 * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy
 */
function staticJoinCreator(strategy) {
    return function () /* listenables... */{
        var listenables = slice.call(arguments);
        return (0, _createStore.createStore)({
            init: function init() {
                this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
            }
        });
    };
}

/**
 * Used in `ListenerMethods.js` to create the instance join methods
 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
 * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy
 */
function instanceJoinCreator(strategy) {
    return function () /* listenables..., callback*/{
        _.throwIf(arguments.length < 2, "Cannot create a join with less than 2 listenables!");
        var listenables = slice.call(arguments),
            callback = listenables.pop(),
            numberOfListenables = listenables.length,
            join = {
            numberOfListenables: numberOfListenables,
            callback: this[callback] || callback,
            listener: this,
            strategy: strategy
        },
            i,
            cancels = [],
            subobj;
        for (i = 0; i < numberOfListenables; i++) {
            _.throwIf(this.validateListening(listenables[i]));
        }
        for (i = 0; i < numberOfListenables; i++) {
            cancels.push(listenables[i].listen(newListener(i, join), this));
        }
        reset(join);
        subobj = { listenable: listenables };
        subobj.stop = makeStopper(subobj, cancels, this);
        this.subscriptions = (this.subscriptions || []).concat(subobj);
        return subobj;
    };
}

// ---- internal join functions ----

function makeStopper(subobj, cancels, context) {
    return function () {
        var i,
            subs = context.subscriptions,
            index = subs ? subs.indexOf(subobj) : -1;
        _.throwIf(index === -1, "Tried to remove join already gone from subscriptions list!");
        for (i = 0; i < cancels.length; i++) {
            cancels[i]();
        }
        subs.splice(index, 1);
    };
}

function reset(join) {
    join.listenablesEmitted = new Array(join.numberOfListenables);
    join.args = new Array(join.numberOfListenables);
}

function newListener(i, join) {
    return function () {
        var callargs = slice.call(arguments);
        if (join.listenablesEmitted[i]) {
            switch (join.strategy) {
                case "strict":
                    throw new Error("Strict join failed because listener triggered twice.");
                case "last":
                    join.args[i] = callargs;break;
                case "all":
                    join.args[i].push(callargs);
            }
        } else {
            join.listenablesEmitted[i] = true;
            join.args[i] = join.strategy === "all" ? [callargs] : callargs;
        }
        emitIfAllListenablesEmitted(join);
    };
}

function emitIfAllListenablesEmitted(join) {
    for (var i = 0; i < join.numberOfListenables; i++) {
        if (!join.listenablesEmitted[i]) {
            return;
        }
    }
    join.callback.apply(join.listener, join.args);
    reset(join);
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStore = createStore;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _Keep = __webpack_require__(11);

var Keep = _interopRequireWildcard(_Keep);

var _mixer = __webpack_require__(30);

var _bindMethods = __webpack_require__(31);

var _StoreMethods = __webpack_require__(20);

var StoreMethods = _interopRequireWildcard(_StoreMethods);

var _PublisherMethods = __webpack_require__(12);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _ListenerMethods = __webpack_require__(3);

var ListenerMethods = _interopRequireWildcard(_ListenerMethods);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var allowed = { preEmit: 1, shouldEmit: 1 };

/**
 * Creates an event emitting Data Store. It is mixed in with functions
 * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`
 * and `shouldEmit` may be overridden in the definition object.
 *
 * @param {Object} definition The data store object definition
 * @returns {Store} A data store instance
 */
function createStore(definition) {

    definition = definition || {};

    for (var a in StoreMethods) {
        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {
            throw new Error("Cannot override API method " + a + " in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {
            throw new Error("Cannot override API method " + d + " in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    definition = (0, _mixer.mix)(definition);

    function Store() {
        var i = 0,
            arr;
        this.subscriptions = [];
        this.emitter = new _.EventEmitter();
        this.eventLabel = "change";
        (0, _bindMethods.bindMethods)(this, definition);
        if (this.init && _.isFunction(this.init)) {
            this.init();
        }
        if (this.listenables) {
            arr = [].concat(this.listenables);
            for (; i < arr.length; i++) {
                this.listenToMany(arr[i]);
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.addStore(store);

    return store;
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _collectioneditor = __webpack_require__(14);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _eventseditor = __webpack_require__(51);

var _eventseditor2 = _interopRequireDefault(_eventseditor);

var _radiogroup = __webpack_require__(24);

var _radiogroup2 = _interopRequireDefault(_radiogroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//------Edit Form-------------------
var BaseEditControl = function (_React$Component) {
  _inherits(BaseEditControl, _React$Component);

  function BaseEditControl(props) {
    _classCallCheck(this, BaseEditControl);

    var _this = _possibleConstructorReturn(this, (BaseEditControl.__proto__ || Object.getPrototypeOf(BaseEditControl)).call(this, props));

    _this.state = {
      activeItem: 'general'
    };

    _this.menuItems = [{ key: 'general', name: 'general', content: _this.getLocalValue('generaltab', 'General'), active: true, onClick: _this.handleItemClick.bind(_this) }, { key: 'style', name: 'style', content: _this.getLocalValue('styletab', 'Style'), active: false, onClick: _this.handleItemClick.bind(_this) }, { key: 'events', name: 'events', content: _this.getLocalValue('eventstab', 'Events'), active: false, onClick: _this.handleItemClick.bind(_this) }, { key: 'other', name: 'other', content: _this.getLocalValue('othertab', 'Other'), active: false, onClick: _this.handleItemClick.bind(_this) }];
    return _this;
  }

  _createClass(BaseEditControl, [{
    key: 'getLocalValue',
    value: function getLocalValue(key, defaultvalue, formname) {
      var local = this.props.localization;
      var block = formname != undefined ? formname : "base";

      if (local == undefined || local[block] == undefined || local[block][key] == undefined) return defaultvalue;
      return local[block][key];
    }
  }, {
    key: 'handleItemClick',
    value: function handleItemClick(e, _ref) {
      var name = _ref.name;

      this.setState({ activeItem: name });
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      var activeItem = this.state.activeItem;

      this.menuItems.forEach(function (item) {
        item.active = item.name === activeItem;
      });

      return _react2.default.createElement(
        _semanticUiReact.Modal.Description,
        null,
        _react2.default.createElement(_semanticUiReact.Menu, { key: 'descriptionMenu', pointing: true, secondary: true, items: this.menuItems }),
        this.getDetailDescription(activeItem)
      );
    }
  }, {
    key: 'getDetailDescription',
    value: function getDetailDescription(activeItem) {
      var segment;

      if (activeItem === 'general') segment = this.getGeneralDescription();else if (activeItem === 'style') segment = this.getStyleDescription();else if (activeItem === 'events') segment = this.getEventsDescription();else if (activeItem === 'other') segment = this.getOtherDescription();

      return segment;
    }
  }, {
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'generalDescriptionForm' },
        _react2.default.createElement(_semanticUiReact.Form.Input, { key: 'name', label: 'Name', name: 'key', value: data.key, onChange: handleChange })
      );
    }
  }, {
    key: 'getStyleDescription',
    value: function getStyleDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var stylesource_ps = "/*** Example Code ***/\ncolor:red;\npaddingTop:5px;";
      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'styleDescriptionForm' },
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-width', label: this.getLocalValue('widthfield', 'Width'), placeholder: '100px', value: data["style-width"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-height', label: this.getLocalValue('heightfield', 'Height'), placeholder: '100px', value: data["style-height"], onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginTop', label: this.getLocalValue('margintopfield', 'Margin Top'), placeholder: '0px', value: data["style-marginTop"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginBottom', label: this.getLocalValue('marginbottomfield', 'Margin Bottom'), placeholder: '0px', value: data["style-marginBottom"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginLeft', label: this.getLocalValue('marginleftfield', 'Margin Left'), placeholder: '0px', value: data["style-marginLeft"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginRight', label: this.getLocalValue('marginrightfield', 'Margin Right'), placeholder: '0px', value: data["style-marginRight"], onChange: handleChange })
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-customcss', label: this.getLocalValue('customcssclassfield', 'Custom CSS class'), placeholder: 'dwkit-application-css (without \'.\')', value: data["style-customcss"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'style-source', label: this.getLocalValue('stylefield', 'Style'), placeholder: stylesource_ps, value: data["style-source"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'style-hidden', label: this.getLocalValue('hiddenfield', 'Hidden'), checked: data["style-hidden"], onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return [];
    }
  }, {
    key: 'getEventsDescription',
    value: function getEventsDescription() {
      var me = this;
      var data = this.props.data;
      if (data.events == undefined) data.events = {};

      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      var actions = this.props.actions;
      var events = this.getEventsList();
      var content;
      if (!Array.isArray(events) || events.length == 0) {
        content = _react2.default.createElement(
          _semanticUiReact.Message,
          { icon: true },
          _react2.default.createElement(_semanticUiReact.Image, { src: '/images/dwkitbuilder-info.png', height: '32px' }),
          _react2.default.createElement(
            _semanticUiReact.Message.Content,
            null,
            this.getLocalValue('controlhasnoeventsmsg', 'This control has no events.')
          )
        );
      } else {
        var controlsOnForm = this.props.parent.getControlsList();
        var listControls = [];
        for (var i = 0; i < controlsOnForm.length; i++) {
          if (data.key == controlsOnForm[i]) continue;
          listControls.push({ text: controlsOnForm[i], value: controlsOnForm[i] });
        }
        content = _react2.default.createElement(_eventseditor2.default, {
          key: 'events', name: 'events',
          data: data.events,
          events: events,
          actions: actions,
          targets: listControls,
          onAdditionActions: this.handleAdditionActions.bind(this),
          onChange: handleChange });
      }
      var timeot = null;
      if (events.includes("onChange")) {
        timeot = _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'onChangeTimeout',
          style: { width: 100 },
          placeholder: "0",
          type: "number",
          label: this.getLocalValue("onchangetimeout", "onChange timeout"),
          value: data.onChangeTimeout, onChange: handleChange });
      }

      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'eventsDescriptionForm' },
        _react2.default.createElement(
          _semanticUiReact.Message,
          { icon: true },
          _react2.default.createElement(_semanticUiReact.Image, { src: '/images/dwkitbuilder-info.png', height: '32px' }),
          _react2.default.createElement(
            _semanticUiReact.Message.Content,
            null,
            this.getLocalValue('eventsinfomsg', 'These flags enable processing from this element.')
          )
        ),
        timeot,
        content
      );
    }
  }, {
    key: 'getOtherDescription',
    value: function getOtherDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var customvalidation_ps = "/*** Example Code ***/\nvalue > 10 ? true : 'Must be more 10'";
      var visibleconition_ps = "/*** Example Code ***/\ndata.type == 1 ? true : false";
      var readOnlyconition_ps = "/*** Example Code ***/\ndata.type == 1 ? true : false";

      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'otherDescriptionForm' },
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'other-required', label: this.getLocalValue('requiredfield', 'Required'), checked: data["other-required"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultValue', label: this.getLocalValue('defaultvaluefield', 'Default value'), value: data["defaultValue"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-customValidation', label: this.getLocalValue('customvalidationfield', 'Custom Validation'), placeholder: customvalidation_ps, value: data["other-customValidation"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-visibleConition', label: this.getLocalValue('visibleconditionfield', 'Visible condition'), placeholder: visibleconition_ps, value: data["other-visibleConition"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-readOnlyConition', label: this.getLocalValue('readonlyconditionfield', 'ReadOnly condition'), placeholder: readOnlyconition_ps, value: data["other-readOnlyConition"], onChange: handleChange })
      );
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        _semanticUiReact.Modal,
        { dimmer: 'inverted', open: this.props.open, onClose: this.props.onClose.bind(this.props.parent) },
        _react2.default.createElement(
          _semanticUiReact.Modal.Content,
          null,
          _react2.default.createElement(
            _semanticUiReact.Modal.Description,
            null,
            this.getDescription()
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Modal.Actions,
          null,
          _react2.default.createElement(
            _semanticUiReact.Button,
            { className: 'buttontype1', onClick: this.props.onSave.bind(this.props.parent) },
            this.getLocalValue('savebutton', 'Save')
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { className: 'buttontype2', onClick: this.props.onClose.bind(this.props.parent) },
            this.getLocalValue('cancelbutton', 'Cancel')
          )
        )
      );
    }
  }, {
    key: 'checkActionsList',
    value: function checkActionsList(value) {
      var isExists = false;

      for (var i = 0; i < this.props.actions.length; i++) {
        if (this.props.actions[i] == value) {
          isExists = true;
          break;
        }
      }

      if (!isExists) {
        this.props.actions.push({ text: value, value: value });
      }
    }
  }, {
    key: 'handleAdditionActions',
    value: function handleAdditionActions(e, _ref2) {
      var value = _ref2.value;

      this.checkActionsList(value);
      this.forceUpdate();
    }
  }]);

  return BaseEditControl;
}(_react2.default.Component);

var HeaderEditControl = function (_BaseEditControl) {
  _inherits(HeaderEditControl, _BaseEditControl);

  function HeaderEditControl(props) {
    _classCallCheck(this, HeaderEditControl);

    return _possibleConstructorReturn(this, (HeaderEditControl.__proto__ || Object.getPrototypeOf(HeaderEditControl)).call(this, props));
  }

  _createClass(HeaderEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "headerform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "header"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "headerform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('textalignfield', 'Text Align', "headerform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textalignleft', 'Left', "headerform"), value: 'left', checked: data.textAlign === 'left', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textaligncenter', 'Center', "headerform"), value: 'center', checked: data.textAlign === 'center', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textalignright', 'Right', "headerform"), value: 'right', checked: data.textAlign === 'right', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'subheader', label: this.getLocalValue('subheaderfield', 'Subheader', "headerform"), value: data.subheader, onChange: handleChange })
      );
    }
  }]);

  return HeaderEditControl;
}(BaseEditControl);

var ButtonEditControl = function (_BaseEditControl2) {
  _inherits(ButtonEditControl, _BaseEditControl2);

  function ButtonEditControl(props) {
    _classCallCheck(this, ButtonEditControl);

    return _possibleConstructorReturn(this, (ButtonEditControl.__proto__ || Object.getPrototypeOf(ButtonEditControl)).call(this, props));
  }

  _createClass(ButtonEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizebig', 'Big'), value: 'big' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }, { text: this.getLocalValue('sizemassive', 'Massive'), value: 'massive' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "buttonform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'buttonType', label: this.getLocalValue('typenonefield', 'None', "buttonform"), value: '', checked: data.buttonType === '' || data.buttonType === undefined, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'buttonType', label: this.getLocalValue('typesubmitfield', 'Submit', "buttonform"), value: 'submit', checked: data.buttonType === 'submit', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "buttonform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "buttonform"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'basic', label: this.getLocalValue('basicfield', 'Basic', "buttonform"), checked: data.basic, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'circular', label: this.getLocalValue('circularfield', 'Circular', "buttonform"), checked: data.circular, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'compact', label: this.getLocalValue('compactfield', 'Compact', "buttonform"), checked: data.compact, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "buttonform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "buttonform"), checked: data.fluid, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "buttonform"), checked: data.inverted, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "buttonform"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'primary', label: this.getLocalValue('primaryfield', 'Primary', "buttonform"), checked: data.primary, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'secondary', label: this.getLocalValue('secondaryfield', 'Secondary', "buttonform"), checked: data.secondary, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'toggle', label: this.getLocalValue('togglefield', 'Toggle', "buttonform"), checked: data.toggle, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('floatedfield', 'Floated', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floateddefaultfield', 'Default', "buttonform"), value: '', checked: data.floated === undefined || data.floated === '', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedleftfield', 'Left', "buttonform"), value: 'left', checked: data.floated === 'left', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedrightfield', 'Right', "buttonform"), value: 'right', checked: data.floated === 'right', onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick"];
    }
  }]);

  return ButtonEditControl;
}(BaseEditControl);

var LabelEditControl = function (_BaseEditControl3) {
  _inherits(LabelEditControl, _BaseEditControl3);

  function LabelEditControl(props) {
    _classCallCheck(this, LabelEditControl);

    return _possibleConstructorReturn(this, (LabelEditControl.__proto__ || Object.getPrototypeOf(LabelEditControl)).call(this, props));
  }

  _createClass(LabelEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      var attacheddata = [{ text: this.getLocalValue('attachednone', 'None'), value: '' }, { text: this.getLocalValue('attachedtop', 'Top'), value: 'top' }, { text: this.getLocalValue('attachedbottom', 'Bottom'), value: 'bottom' }, { text: this.getLocalValue('attachedtopright', 'Top right'), value: 'top right' }, { text: this.getLocalValue('attachedtopleft', 'Top left'), value: 'top left' }, { text: this.getLocalValue('attachedbottomleft', 'Bottom left'), value: 'bottom left' }, { text: this.getLocalValue('attachedbottomright', 'Bottom right'), value: 'bottom right' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "labelform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'attached', selection: true, fluid: true, options: attacheddata, placeholder: attacheddata[0].text, label: this.getLocalValue('attachedfield', 'Attached', "labelform"), value: data.attached, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "labelform"), value: data.content, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "labelform"), value: data.size, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "labelform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'basic', label: this.getLocalValue('basicfield', 'Basic', "labelform"), checked: data.basic, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'circular', label: this.getLocalValue('circularfield', 'Circular', "labelform"), checked: data.circular, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'corner', label: this.getLocalValue('cornerfield', 'Corner', "labelform"), checked: data.corner, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floating', label: this.getLocalValue('floatingfield', 'Floating', "labelform"), checked: data.floating, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'horizontal', label: this.getLocalValue('horizontalfield', 'Horizontal', "labelform"), checked: data.horizontal, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'pointing', label: this.getLocalValue('pointingfield', 'Pointing', "labelform"), checked: data.pointing, onChange: handleChange })
            )
          )
        )
      );
    }
  }]);

  return LabelEditControl;
}(BaseEditControl);

var StaticContentEditControl = function (_BaseEditControl4) {
  _inherits(StaticContentEditControl, _BaseEditControl4);

  function StaticContentEditControl(props) {
    _classCallCheck(this, StaticContentEditControl);

    return _possibleConstructorReturn(this, (StaticContentEditControl.__proto__ || Object.getPrototypeOf(StaticContentEditControl)).call(this, props));
  }

  _createClass(StaticContentEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "staticcontentform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-font-size', placeholder: '20px', label: this.getLocalValue('fontsizefield', 'Font size', "staticcontentform"), value: data["style-font-size"], onChange: handleChange })
        ),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'isHtml', label: this.getLocalValue('allowhtmlfield', 'Allow HTML', "staticcontentform"), checked: data.isHtml, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.TextArea, { rows: 6, autoHeight: true, name: 'content', label: this.getLocalValue('contentfield', 'Content', "staticcontentform"), value: data.content, onChange: handleChange })
      );
    }
  }]);

  return StaticContentEditControl;
}(BaseEditControl);

var MessageEditControl = function (_BaseEditControl5) {
  _inherits(MessageEditControl, _BaseEditControl5);

  function MessageEditControl(props) {
    _classCallCheck(this, MessageEditControl);

    return _possibleConstructorReturn(this, (MessageEditControl.__proto__ || Object.getPrototypeOf(MessageEditControl)).call(this, props));
  }

  _createClass(MessageEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "messageform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'header', label: this.getLocalValue('headerfield', 'Header', "messageform"), value: data.header, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "messageform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'compact', label: this.getLocalValue('compactfield', 'Compact', "messageform"), checked: data.compact, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "messageform"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floating', label: this.getLocalValue('floatingfield', 'Floating', "messageform"), checked: data.floating, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'info', label: this.getLocalValue('infofield', 'Info', "messageform"), checked: data.info, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'negative', label: this.getLocalValue('negativefield', 'Negative', "messageform"), checked: data.negative, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'positive', label: this.getLocalValue('positivefield', 'Positive', "messageform"), checked: data.positive, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'success', label: this.getLocalValue('successfield', 'Success', "messageform"), checked: data.success, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'warning', label: this.getLocalValue('warningfield', 'Warning', "messageform"), checked: data.warning, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "messageform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "messageform"), value: data.size, onChange: handleChange })
        )
      );
    }
  }]);

  return MessageEditControl;
}(BaseEditControl);

var InputEditControl = function (_BaseEditControl6) {
  _inherits(InputEditControl, _BaseEditControl6);

  function InputEditControl(props) {
    _classCallCheck(this, InputEditControl);

    return _possibleConstructorReturn(this, (InputEditControl.__proto__ || Object.getPrototypeOf(InputEditControl)).call(this, props));
  }

  _createClass(InputEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }, { text: this.getLocalValue('sizemassive', 'Massive'), value: 'massive' }];

      var labelPositions = [{ text: this.getLocalValue('labeldefault', 'Default'), value: '' }, { text: this.getLocalValue('labelleft', 'Left'), value: 'left' }, { text: this.getLocalValue('labelright', 'Right'), value: 'right' }, { text: this.getLocalValue('labelleftcorner', 'Left corner'), value: 'left corner' }, { text: this.getLocalValue('labelrightcorner', 'Right corner'), value: 'right corner' }];

      var disableDateFormat = data.type !== "date" && data.type !== "datetime" && data.type !== "time";

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "inputform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "inputform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "inputform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typetext', 'Text', "inputform"), value: 'text', checked: data.type == undefined || data.type == 'text', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typenumber', 'Number', "inputform"), value: 'number', checked: data.type === 'number', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typepasswod', 'Password', "inputform"), value: 'password', checked: data.type === 'password', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typefile', 'File', "inputform"), value: 'file', checked: data.type === 'file', onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typedate', 'Date', "inputform"), value: 'date', checked: data.type === 'date', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typetime', 'Time', "inputform"), value: 'time', checked: data.type === 'time', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typedatetime', 'Date & Time', "inputform"), value: 'datetime', checked: data.type === 'datetime', onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'labelPosition', selection: true, fluid: true, placeholder: labelPositions[0].text, options: labelPositions, label: this.getLocalValue('labelpositionfield', 'Label position', "inputform"), value: data.labelPosition, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "inputform"), value: data.placeholder, onChange: handleChange })
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "inputform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "inputform"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "inputform"), checked: data.inverted, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "inputform"), checked: data.error, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "inputform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'transparent', label: this.getLocalValue('transparentfield', 'Transparent', "inputform"), checked: data.transparent, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "inputform"), checked: data.fluid, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "inputform"), checked: data.readOnly, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "inputform"), value: data.size, onChange: handleChange })
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return InputEditControl;
}(BaseEditControl);

var TextAreaEditControl = function (_BaseEditControl7) {
  _inherits(TextAreaEditControl, _BaseEditControl7);

  function TextAreaEditControl(props) {
    _classCallCheck(this, TextAreaEditControl);

    return _possibleConstructorReturn(this, (TextAreaEditControl.__proto__ || Object.getPrototypeOf(TextAreaEditControl)).call(this, props));
  }

  _createClass(TextAreaEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "textareaform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "textareaform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rows', placeholder: '3', type: 'number', label: this.getLocalValue('rowsfield', 'Rows', "textareaform"), value: data.rows, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "textareaform"), value: data.placeholder, onChange: handleChange }),
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('placeholderfield', 'Options', "textareaform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoHeight', label: this.getLocalValue('autoheightfield', 'Auto height', "textareaform"), checked: data.autoHeight, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "textareaform"), checked: data.readOnly, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return TextAreaEditControl;
}(BaseEditControl);

var SearchEditControl = function (_BaseEditControl8) {
  _inherits(SearchEditControl, _BaseEditControl8);

  function SearchEditControl(props) {
    _classCallCheck(this, SearchEditControl);

    return _possibleConstructorReturn(this, (SearchEditControl.__proto__ || Object.getPrototypeOf(SearchEditControl)).call(this, props));
  }

  _createClass(SearchEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "searchform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'url', label: this.getLocalValue('urlfield', 'Url', "searchform"), value: data.url, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'category', label: this.getLocalValue('categoryfield', 'Enable Categories', "searchform"), checked: Boolean(data.category), onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onSelect"];
    }
  }]);

  return SearchEditControl;
}(BaseEditControl);

var CheckboxEditControl = function (_BaseEditControl9) {
  _inherits(CheckboxEditControl, _BaseEditControl9);

  function CheckboxEditControl(props) {
    _classCallCheck(this, CheckboxEditControl);

    return _possibleConstructorReturn(this, (CheckboxEditControl.__proto__ || Object.getPrototypeOf(CheckboxEditControl)).call(this, props));
  }

  _createClass(CheckboxEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "checkboxform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "checkboxform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "checkboxform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fitted', label: this.getLocalValue('fittedfield', 'Fitted', "checkboxform"), checked: data.fitted, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'indeterminate', label: this.getLocalValue('indeterminatefield', 'Indeterminate', "checkboxform"), checked: data.indeterminate, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'ReadOnly', "checkboxform"), checked: data.readOnly, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "checkboxform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'slider', label: this.getLocalValue('sliderfield', 'Slider', "checkboxform"), checked: data.slider, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'toggle', label: this.getLocalValue('togglefield', 'Toggle', "checkboxform"), checked: data.toggle, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return CheckboxEditControl;
}(BaseEditControl);

var DropdownEditControl = function (_BaseEditControl10) {
  _inherits(DropdownEditControl, _BaseEditControl10);

  function DropdownEditControl(props) {
    _classCallCheck(this, DropdownEditControl);

    return _possibleConstructorReturn(this, (DropdownEditControl.__proto__ || Object.getPrototypeOf(DropdownEditControl)).call(this, props));
  }

  _createClass(DropdownEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var labelPositions = [{ text: this.getLocalValue('labeldefault', 'Default'), value: '' }, { text: this.getLocalValue('labelleft', 'Left'), value: 'left' }, { text: this.getLocalValue('labelright', 'Right'), value: 'right' }, { text: this.getLocalValue('labelleftcorner', 'Left corner'), value: 'left corner' }, { text: this.getLocalValue('labelrightcorner', 'Right corner'), value: 'right corner' }];

      var dataColumns = [{ key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "dropdownform") }, { key: 'text', name: this.getLocalValue('datatextcolumn', 'Text', "dropdownform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dropdownform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "dropdownform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            draggable: true,
            columns: dataColumns,
            label: this.getLocalValue('datafield', 'Data', "dropdownform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: 'Placeholder', value: data.placeholder, onChange: handleChange }),
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('optionsfield', 'Options', "dropdownform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "dropdownform"), checked: data.loading, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "dropdownform"), checked: data.error, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "dropdownform"), checked: data.disabled, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "dropdownform"), checked: data.fluid, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiple', label: this.getLocalValue('multiplefield', 'Multiple', "dropdownform"), checked: data.multiple, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'search', label: this.getLocalValue('searchfield', 'Search', "dropdownform"), checked: data.search, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'selection', label: this.getLocalValue('selectionfield', 'Selection', "dropdownform"), checked: data.selection, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "dropdownform"), checked: data.readOnly, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'allowAddItems', label: this.getLocalValue('allowAddItemsfield', 'Allow add items', "dropdownform"), disabled: !(data.search && data.multiple), checked: data.allowAddItems, onChange: handleChange })
              )
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return DropdownEditControl;
}(BaseEditControl);

var DictionaryEditControl = function (_BaseEditControl11) {
  _inherits(DictionaryEditControl, _BaseEditControl11);

  function DictionaryEditControl(props) {
    _classCallCheck(this, DictionaryEditControl);

    return _possibleConstructorReturn(this, (DictionaryEditControl.__proto__ || Object.getPrototypeOf(DictionaryEditControl)).call(this, props));
  }

  _createClass(DictionaryEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dictionaryform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "dictionaryform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'dataModel', label: this.getLocalValue('datamodelfield', 'Data model', "dictionaryform"), value: data.dataModel, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "dictionaryform"), value: data.placeholder, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'columns', label: this.getLocalValue('columnsfield', 'Columns (Name ASC, Email)', "dictionaryform"), value: data.columns, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'pageSize', label: this.getLocalValue('pagesizefield', 'Page Size', "dictionaryform"), disabled: !Boolean(data.paging), value: data.pageSize, placeholder: '100', onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "dictionaryform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'paging', label: this.getLocalValue('pagingfield', 'Server pagination', "dictionaryform"), checked: data.paging, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'search', label: this.getLocalValue('searchfield', 'Search', "dictionaryform"), checked: data.search, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiple', label: this.getLocalValue('multiplefield', 'Multiple', "dictionaryform"), checked: data.multiple, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "dictionaryform"), checked: data.readOnly, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "dictionaryform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'clearable', label: this.getLocalValue('clearablefield', 'Clearable', "dictionaryform"), checked: data.clearable, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'selection', label: this.getLocalValue('selectionfield', 'Selection', "dictionaryform"), checked: data.selection, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "dictionaryform"), checked: data.fluid, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "dictionaryform"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "dictionaryform"), checked: data.loading, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onChange"];
    }
  }]);

  return DictionaryEditControl;
}(BaseEditControl);

var RadioGroupEditControl = function (_BaseEditControl12) {
  _inherits(RadioGroupEditControl, _BaseEditControl12);

  function RadioGroupEditControl(props) {
    _classCallCheck(this, RadioGroupEditControl);

    return _possibleConstructorReturn(this, (RadioGroupEditControl.__proto__ || Object.getPrototypeOf(RadioGroupEditControl)).call(this, props));
  }

  _createClass(RadioGroupEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var dataColumns = [{ key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "radiogroupform") }, { key: 'text', name: this.getLocalValue('datatextcolumn', 'Text', "radiogroupform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "radiogroupform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "radiogroupform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            draggable: true,
            columns: dataColumns,
            label: this.getLocalValue('datafield', 'Data', "radiogroupform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('groupdirectfield', 'Group direct', "radiogroupform")
            ),
            _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'direction', label: this.getLocalValue('directiongorizontalfield', 'Gorizontal', "radiogroupform"), value: 'g', checked: data.direction === undefined || data.direction === 'g', onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'direction', label: this.getLocalValue('directionverticalfield', 'Vertical', "radiogroupform"), value: 'v', checked: data.direction === 'v', onChange: handleChange }),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "radiogroupform"), checked: data.readOnly, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return RadioGroupEditControl;
}(BaseEditControl);

var FormEditControl = function (_BaseEditControl13) {
  _inherits(FormEditControl, _BaseEditControl13);

  function FormEditControl(props) {
    _classCallCheck(this, FormEditControl);

    return _possibleConstructorReturn(this, (FormEditControl.__proto__ || Object.getPrototypeOf(FormEditControl)).call(this, props));
  }

  _createClass(FormEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "form"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "form"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "form")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "form"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "form"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "form"), checked: data.inverted, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'reply', label: this.getLocalValue('replyfield', 'Reply', "form"), checked: data.reply, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'success', label: this.getLocalValue('successfield', 'Success', "form"), checked: data.success, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'warning', label: this.getLocalValue('warningfield', 'Warning', "form"), checked: data.warning, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onSubmit"];
    }
  }]);

  return FormEditControl;
}(BaseEditControl);

var FormGroupEditControl = function (_BaseEditControl14) {
  _inherits(FormGroupEditControl, _BaseEditControl14);

  function FormGroupEditControl(props) {
    _classCallCheck(this, FormGroupEditControl);

    return _possibleConstructorReturn(this, (FormGroupEditControl.__proto__ || Object.getPrototypeOf(FormGroupEditControl)).call(this, props));
  }

  _createClass(FormGroupEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "formgroupform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('widthsfield', 'Widths', "formgroupform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthsdefaultfield', 'Default', "formgroupform"), checked: data.widths === undefined, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthsequalfield', 'Equal', "formgroupform"), value: 'equal', checked: data.widths === 'equal', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthscustomfield', 'Custom (1 - 16)', "formgroupform"), value: 'custom', checked: data.widths === 'custom', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "formgroupform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { inline: true },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'orientation', label: this.getLocalValue('orientationcolumnsfield', 'Columns', "formgroupform"), value: 'inline', checked: data.orientation === undefined || data.orientation === 'inline', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'orientation', label: this.getLocalValue('orientationrowsfield', 'Rows', "formgroupform"), value: 'grouped', checked: data.orientation === "grouped", onChange: handleChange })
            )
          ),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'widthsCustom', disabled: data.widths !== 'custom', placeholder: '2', value: data.widthsCustom, onChange: handleChange })
        )
      );
    }
  }]);

  return FormGroupEditControl;
}(BaseEditControl);

var ContainerEditControl = function (_BaseEditControl15) {
  _inherits(ContainerEditControl, _BaseEditControl15);

  function ContainerEditControl(props) {
    _classCallCheck(this, ContainerEditControl);

    return _possibleConstructorReturn(this, (ContainerEditControl.__proto__ || Object.getPrototypeOf(ContainerEditControl)).call(this, props));
  }

  _createClass(ContainerEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var floatdata = [{ text: this.getLocalValue('floatnonefield', 'None', "containerform"), value: '' }, { text: this.getLocalValue('floatleftfield', 'Left', "containerform"), value: 'left' }, { text: this.getLocalValue('floatrightfield', 'Right', "containerform"), value: 'right' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "containerform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'style-float', selection: true, fluid: true, options: floatdata, placeholder: floatdata[0].text, label: this.getLocalValue('floatfield', 'Float', "containerform"), value: data["style-float"], onChange: handleChange })
        )
      );
    }
  }]);

  return ContainerEditControl;
}(BaseEditControl);

var ImageEditControl = function (_BaseEditControl16) {
  _inherits(ImageEditControl, _BaseEditControl16);

  function ImageEditControl(props) {
    _classCallCheck(this, ImageEditControl);

    return _possibleConstructorReturn(this, (ImageEditControl.__proto__ || Object.getPrototypeOf(ImageEditControl)).call(this, props));
  }

  _createClass(ImageEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "imageform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'src', label: this.getLocalValue('srcfield', 'Src', "imageform"), value: data.src, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'href', label: this.getLocalValue('hreffield', 'Href', "imageform"), value: data.href, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('optionsfield', 'Options', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'avatar', label: this.getLocalValue('avatarfield', 'Avatar', "imageform"), checked: data.avatar, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'bordered', label: this.getLocalValue('borderedfield', 'Bordered', "imageform"), checked: data.bordered, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'centered', label: this.getLocalValue('centeredfield', 'Centered', "imageform"), checked: data.centered, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "imageform"), checked: data.disabled, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inline', label: this.getLocalValue('inlinefield', 'Inline', "imageform"), checked: data.inline, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'spaced', label: this.getLocalValue('spacedfield', 'Spaced', "imageform"), checked: data.spaced, onChange: handleChange })
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('floatedfield', 'Floated', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedleftfield', 'Left', "imageform"), value: 'left', checked: data.floated === 'left' || data.floated === '', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedrightfield', 'Right', "imageform"), value: 'right', checked: data.floated === 'right', onChange: handleChange })
              ),
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('verticalalignfield', 'Vertical align', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalaligntopfield', 'Top', "imageform"), value: 'top', checked: data.verticalAlign === 'top', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalalignmiddlefield', 'Middle', "imageform"), value: 'middle', checked: data.verticalAlign === 'middle', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalalignbottomfield', 'Bottom', "imageform"), value: 'bottom', checked: data.verticalAlign === 'bottom', onChange: handleChange })
              )
            )
          )
        )
      );
    }
  }]);

  return ImageEditControl;
}(BaseEditControl);

var StatisticEditControl = function (_BaseEditControl17) {
  _inherits(StatisticEditControl, _BaseEditControl17);

  function StatisticEditControl(props) {
    _classCallCheck(this, StatisticEditControl);

    return _possibleConstructorReturn(this, (StatisticEditControl.__proto__ || Object.getPrototypeOf(StatisticEditControl)).call(this, props));
  }

  _createClass(StatisticEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      var datacolumns = [{ key: 'label', name: this.getLocalValue('datakeycolumn', 'Label', "statisticform") }, { key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "statisticform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "statisticform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "statisticform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floated', label: this.getLocalValue('floatedfield', 'Floated', "statisticform"), checked: data.floated, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'horizontal', label: this.getLocalValue('horizontalfield', 'Horizontal', "statisticform"), checked: data.horizontal, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            columns: datacolumns,
            label: this.getLocalValue('datafield', 'Data', "statisticform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "statisticform"), value: data.size, onChange: handleChange })
        )
      );
    }
  }]);

  return StatisticEditControl;
}(BaseEditControl);

var GridEditControl = function (_BaseEditControl18) {
  _inherits(GridEditControl, _BaseEditControl18);

  function GridEditControl(props) {
    _classCallCheck(this, GridEditControl);

    return _possibleConstructorReturn(this, (GridEditControl.__proto__ || Object.getPrototypeOf(GridEditControl)).call(this, props));
  }

  _createClass(GridEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var pagertype = [{ value: "", text: this.getLocalValue('pagertypenonefield', 'None', "gridform") }, { value: "server", text: this.getLocalValue('pagertypeserverfield', 'Server', "gridform") }];

      var editformtype = [{ value: "", text: this.getLocalValue('editformtypedefaultfield', 'Default', "gridform") }];

      var columns = [{ key: 'key', name: this.getLocalValue('keycolumn', 'Key', "gridform") }, { key: 'name', name: this.getLocalValue('namecolumn', 'Name', "gridform") }, { key: 'type', name: this.getLocalValue('typecolumn', 'Type', "gridform"), dataList: ["", "number", "checkbox", "date", "datetime", "time", "custom"] }, { key: 'width', name: this.getLocalValue('widthcolumn', 'Width', "gridform"), control: 'number' }, { key: 'resizable', name: this.getLocalValue('resizablecolumn', 'Resizable', "gridform"), control: "checkbox" }];

      var editTypeItems = [{ key: "form", text: "Form", value: undefined }, { key: "flow", text: "Flow", value: "flow" }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "gridform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "gridform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiselect', label: this.getLocalValue('multiselectfield', 'Multiselect', "gridform"), checked: data.multiselect, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disableSort', label: this.getLocalValue('disablesortfield', 'Disable sorting', "gridform"), checked: data.disableSort, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_radiogroup2.default, {
                name: 'editType',
                label: this.getLocalValue('edittypefield', 'Edit type', "gridform"),
                items: editTypeItems,
                value: data.editType,
                onChange: handleChange }),
              data.editType != "flow" && _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'editForm', label: this.getLocalValue('editformfield', 'Edit form', "gridform"), disabled: data.inline == true, value: data.editForm, onChange: handleChange }),
              data.editType == "flow" && _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'editFlow', label: this.getLocalValue('editflowfield', 'Edit flow', "gridform"), disabled: data.inline == true, value: data.editFlow, onChange: handleChange })
            ),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rowKey', label: this.getLocalValue('rowkeyfield', 'Row key', "gridform"), value: data.rowKey, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'pageSize', label: this.getLocalValue('pagesizefield', 'Page size', "gridform"), value: data.pageSize, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultSort', label: this.getLocalValue('defaultsortfield', 'Default sort', "gridform"), placeholder: 'Name ASC', value: data.defaultSort, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'editFormShowType', selection: true, fluid: true, label: this.getLocalValue('editformshowtypefield', 'Edit form show type', "gridform"), placeholder: editformtype[0].text, options: editformtype, value: data.editFormShowType, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'pagerType', selection: true, fluid: true, label: this.getLocalValue('pagertypefield', 'Pagination type', "gridform"), placeholder: 'None', options: pagertype, value: data.pagerType, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rowHeight', label: this.getLocalValue('rowheightfield', 'Row height', "gridform"), value: data.rowHeight, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'minHeight', label: this.getLocalValue('minheightfield', 'Min height', "gridform"), value: data.minHeight, onChange: handleChange }),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoHeight', label: this.getLocalValue('autoheightfield', 'Auto Height', "gridform"), checked: Boolean(data.autoHeight), onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'offSet', label: this.getLocalValue('offsetfield', 'OffSet', "gridform"), disabled: !Boolean(data.autoHeight), value: data.offSet, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'field' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'columns',
            draggable: true,
            columns: columns,
            label: this.getLocalValue('columnsfield', 'Columns', "gridform"),
            name: 'columns',
            value: data["columns"],
            onChange: handleChange })
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onRowClick", "onRowDblClick", "onSelectionChanged"];
    }
  }]);

  return GridEditControl;
}(BaseEditControl);

var CollectionEditorEditControl = function (_BaseEditControl19) {
  _inherits(CollectionEditorEditControl, _BaseEditControl19);

  function CollectionEditorEditControl(props) {
    _classCallCheck(this, CollectionEditorEditControl);

    return _possibleConstructorReturn(this, (CollectionEditorEditControl.__proto__ || Object.getPrototypeOf(CollectionEditorEditControl)).call(this, props));
  }

  _createClass(CollectionEditorEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var me = this;
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'key', name: this.getLocalValue('keycolumn', 'Key', "collectioneditorform") }, { key: 'name', name: this.getLocalValue('namecolumn', 'Name', "collectioneditorform") }, { key: 'control', name: this.getLocalValue('controlcolumn', 'Control', "collectioneditorform"), dataList: ["input", "checkbox", "span", "number", "file", "date", "datetime", "custom"] }, { key: 'width', name: this.getLocalValue('widthcolumn', 'Width', "collectioneditorform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "collectioneditorform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'idField', label: this.getLocalValue('idfield', 'Id field', "collectioneditorform"), disabled: data.hierarchical != true, value: data.idField, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "collectioneditorform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'ReadOnly', "collectioneditorform"), checked: data.readOnly, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'draggable', label: this.getLocalValue('draggablefield', 'Draggable', "collectioneditorform"), checked: data.draggable, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'hierarchical', label: this.getLocalValue('hierarchicalfield', 'Hierarchical', "collectioneditorform"), checked: data.hierarchical, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disableAdd', label: this.getLocalValue('disableAdd', 'Disable Add', "collectioneditorform"), checked: data.disableAdd, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'collapseAll', label: this.getLocalValue('collapseallfield', 'Collapse all', "collectioneditorform"), disabled: data.hierarchical != true, checked: data.collapseAll, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'parentIdField', label: this.getLocalValue('parentidfield', 'ParentId field', "collectioneditorform"), disabled: data.hierarchical != true, value: data.parentIdField, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'childrenField', label: this.getLocalValue('childrenField', 'Children field', "collectioneditorform"), disabled: data.hierarchical != true || data.parentIdField !== undefined && data.parentIdField !== "", value: data.childrenField, onChange: handleChange })
          )
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'columns',
          columns: columns,
          label: this.getLocalValue('columnsfield', 'Columns', "collectioneditorform"),
          name: 'columns',
          value: data["columns"],
          height: '200px',
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onChange", "onAdd", "onDelete"];
    }
  }]);

  return CollectionEditorEditControl;
}(BaseEditControl);

var CustomEditControl = function (_BaseEditControl20) {
  _inherits(CustomEditControl, _BaseEditControl20);

  function CustomEditControl(props) {
    _classCallCheck(this, CustomEditControl);

    return _possibleConstructorReturn(this, (CustomEditControl.__proto__ || Object.getPrototypeOf(CustomEditControl)).call(this, props));
  }

  _createClass(CustomEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "customform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'type', label: this.getLocalValue('typefield', 'Type control', "customform"), value: data.type, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'props', label: this.getLocalValue('propsfield', 'Props', "customform"), name: 'props',
            value: data["props"],
            onChange: handleChange,
            rows: 5 }),
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'children', label: this.getLocalValue('childrenfield', 'Children', "customform"), name: 'children',
            value: data["children"],
            onChange: handleChange,
            rows: 5 })
        )
      );
    }
  }]);

  return CustomEditControl;
}(BaseEditControl);

var CustomBlockEditControl = function (_BaseEditControl21) {
  _inherits(CustomBlockEditControl, _BaseEditControl21);

  function CustomBlockEditControl(props) {
    _classCallCheck(this, CustomBlockEditControl);

    return _possibleConstructorReturn(this, (CustomBlockEditControl.__proto__ || Object.getPrototypeOf(CustomBlockEditControl)).call(this, props));
  }

  _createClass(CustomBlockEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "customblockform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('sourcetypefield', 'Source type', "customblockform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('sourcetypeformfield', 'Form name', "customblockform"), value: 'form', checked: data.sourceType === undefined || data.sourceType == 'form', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('sourcetypejsonfield', 'JSON source', "customblockform"), value: 'source', checked: data.sourceType === 'source', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('placeholderfield', 'Placeholder', "customblockform"), value: 'placeholder', checked: data.sourceType === 'placeholder', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'formname', label: this.getLocalValue('formnamefield', 'Form name', "customblockform"), value: data.formname, onChange: handleChange,
          disabled: data.sourceType != undefined && data.sourceType != 'form' }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'source', label: this.getLocalValue('sourcefield', 'JSON source', "customblockform"), name: 'source',
          value: data["source"], onChange: handleChange, rows: 10,
          disabled: data.sourceType != 'source' })
      );
    }
  }]);

  return CustomBlockEditControl;
}(BaseEditControl);

var MenuEditControl = function (_BaseEditControl22) {
  _inherits(MenuEditControl, _BaseEditControl22);

  function MenuEditControl(props) {
    _classCallCheck(this, MenuEditControl);

    return _possibleConstructorReturn(this, (MenuEditControl.__proto__ || Object.getPrototypeOf(MenuEditControl)).call(this, props));
  }

  _createClass(MenuEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'target', name: this.getLocalValue('itemstargetcolumn', 'Target', "menuform"), width: 150 }, { key: 'title', name: this.getLocalValue('itemstitlecolumn', 'Title', "menuform") }, { key: 'visibleCondition', name: this.getLocalValue('visibleConditioncolumn', 'Visible Condition', "menuform") }];
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "menuform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'activeItem', label: this.getLocalValue('activeitemfield', 'Active Item', "menuform"), value: data.activeItem, onChange: handleChange })
        ),
        _react2.default.createElement(
          'div',
          { className: 'field' },
          _react2.default.createElement(
            'label',
            null,
            this.getLocalValue('optionsfield', 'Options', "menuform")
          ),
          _react2.default.createElement(
            _semanticUiReact.Form.Group,
            null,
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'pointing', label: this.getLocalValue('pointingfield', 'Pointing', "menuform"), checked: data.pointing, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'secondary', label: this.getLocalValue('secondaryfield', 'Secondary', "menuform"), checked: data.secondary, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'tabular', label: this.getLocalValue('tabularfield', 'Tabular', "menuform"), checked: data.tabular, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "menuform"), checked: data.fluid, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'vertical', label: this.getLocalValue('verticalfield', 'Vertical', "menuform"), checked: data.vertical, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'link', label: this.getLocalValue('linkfield', 'Link', "menuform"), checked: data.link, onChange: handleChange })
          )
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          hierarchical: true,
          childrenField: 'children',
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "menuform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return MenuEditControl;
}(BaseEditControl);

var BreadcrumbEditControl = function (_BaseEditControl23) {
  _inherits(BreadcrumbEditControl, _BaseEditControl23);

  function BreadcrumbEditControl(props) {
    _classCallCheck(this, BreadcrumbEditControl);

    return _possibleConstructorReturn(this, (BreadcrumbEditControl.__proto__ || Object.getPrototypeOf(BreadcrumbEditControl)).call(this, props));
  }

  _createClass(BreadcrumbEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'text', name: this.getLocalValue('itemstextcolumn', 'Text', "breadcrumbform") }, { key: 'url', name: this.getLocalValue('itemsurlcolumn', 'Url', "breadcrumbform") }, { key: 'active', control: 'checkbox', name: this.getLocalValue('itemsactivecolumn', 'Active', "breadcrumbform") }, { key: 'divider', name: this.getLocalValue('itemsiconcolumn', 'Divider Icon', "breadcrumbform"), dataList: ["right angle", "right chevron"] }];
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "breadcrumbform"), value: data.key, onChange: handleChange })
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "breadcrumbform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return BreadcrumbEditControl;
}(BaseEditControl);

var DropdownTriggerEditControl = function (_BaseEditControl24) {
  _inherits(DropdownTriggerEditControl, _BaseEditControl24);

  function DropdownTriggerEditControl(props) {
    _classCallCheck(this, DropdownTriggerEditControl);

    return _possibleConstructorReturn(this, (DropdownTriggerEditControl.__proto__ || Object.getPrototypeOf(DropdownTriggerEditControl)).call(this, props));
  }

  _createClass(DropdownTriggerEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'target', name: this.getLocalValue('itemstargetcolumn', 'Target', "dropdowntriggerform") }, { key: 'title', name: this.getLocalValue('itemstitlecolumn', 'Title', "dropdowntriggerform") }, { key: 'visibleCondition', name: this.getLocalValue('itemsvisibleconditioncolumn', 'Visible Condition', "dropdowntriggerform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dropdowntriggerform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultValue', label: this.getLocalValue('defaultvaluefield', 'Default Value', "dropdowntriggerform"), value: data.defaultValue == undefined ? "" : data.defaultValue, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'imageUrl', label: this.getLocalValue('imageurlfield', 'ImageUrl', "dropdowntriggerform"), value: data.imageUrl == undefined ? "" : data.imageUrl, onChange: handleChange }),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "dropdowntriggerform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return DropdownTriggerEditControl;
}(BaseEditControl);

var DropzoneEditControl = function (_BaseEditControl25) {
  _inherits(DropzoneEditControl, _BaseEditControl25);

  function DropzoneEditControl(props) {
    _classCallCheck(this, DropzoneEditControl);

    return _possibleConstructorReturn(this, (DropzoneEditControl.__proto__ || Object.getPrototypeOf(DropzoneEditControl)).call(this, props));
  }

  _createClass(DropzoneEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "uploadform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'iconFiletypes', label: this.getLocalValue('iconFiletypes', 'Icon file types', "uploadform"), placeholder: '*.png, *.jpg, *.gif', value: data.iconFiletypes == undefined ? "" : data.iconFiletypes, onChange: handleChange }),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          null,
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'showFiletypeIcon', label: this.getLocalValue('showFiletypeIcon', 'Show file type icon', "uploadform"), checked: data.showFiletypeIcon, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoProcessQueue', label: this.getLocalValue('autoProcessQueue', 'Auto process queue', "uploadform"), checked: data.autoProcessQueue, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'addRemoveLinks', label: this.getLocalValue('addRemoveLinks', 'Add remove links', "uploadform"), checked: data.addRemoveLinks, onChange: handleChange })
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["success"];
    }
  }]);

  return DropzoneEditControl;
}(BaseEditControl);

//----------
//Chart
//----------


var ChartEditControl = function (_BaseEditControl26) {
  _inherits(ChartEditControl, _BaseEditControl26);

  function ChartEditControl(props) {
    _classCallCheck(this, ChartEditControl);

    return _possibleConstructorReturn(this, (ChartEditControl.__proto__ || Object.getPrototypeOf(ChartEditControl)).call(this, props));
  }

  _createClass(ChartEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      var legendPositionOptions = [{ value: "", text: this.getLocalValue('legendpositiondefaultfield', 'Default', "chartform") }, { value: "top", text: this.getLocalValue('legendpositiontopfield', 'Top', "chartform") }, { value: "left", text: this.getLocalValue('legendpositionleftfield', 'Left', "chartform") }, { value: "bottom", text: this.getLocalValue('legendpositionbottomfield', 'Bottom', "chartform") }, { value: "right", text: this.getLocalValue('legendpositionrightfield', 'Right', "chartform") }];

      var disableCustom = data.datasetCustom == "" || data.datasetCustom == undefined;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "chartform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'title', label: this.getLocalValue('titlefield', 'Title', "chartform"), value: data.title, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'titleSize', label: this.getLocalValue('titlesizefield', 'Title size', "chartform"), value: data.titleSize, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'legendPosition', selection: true, fluid: true, label: this.getLocalValue('legendpositionfield', 'Legend position', "chartform"), placeholder: legendPositionOptions[0].text, options: legendPositionOptions, value: data.legendPosition, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'responsive', label: this.getLocalValue('responsivefield', 'Responsive', "chartform"), checked: data.responsive, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'datasetCustom', label: this.getLocalValue('datasetcustomfield', 'Dataset custom', "chartform"), checked: data.datasetCustom, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'dataLabels', style: { paddingTop: "5px" }, disabled: disableCustom, placeholder: this.getLocalValue('datalabelsplaceholder', 'Q1, Q2, Q3, Q4', "chartform"),
              label: this.getLocalValue('datalabelsfield', 'Data labels', "chartform"), value: data.dataLabels, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'datasetLabel', disabled: disableCustom, label: this.getLocalValue('datasetlabelfield', 'Dataset Label', "chartform"), value: data.datasetLabel, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'datasetBackgroundColor', disabled: disableCustom, label: this.getLocalValue('datasetbackgroundcolorfield', 'Dataset BackgroundColor', "chartform"), value: data.datasetBackgroundColor, onChange: handleChange })
          )
        )
      );
    }
  }]);

  return ChartEditControl;
}(BaseEditControl);

//----------
//Workflow
//----------


var WorkflowBarEditControl = function (_BaseEditControl27) {
  _inherits(WorkflowBarEditControl, _BaseEditControl27);

  function WorkflowBarEditControl(props) {
    _classCallCheck(this, WorkflowBarEditControl);

    return _possibleConstructorReturn(this, (WorkflowBarEditControl.__proto__ || Object.getPrototypeOf(WorkflowBarEditControl)).call(this, props));
  }

  _createClass(WorkflowBarEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "workflowform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'setStateButton', label: this.getLocalValue('setstatebuttonfield', 'Set state button', "workflowform"), value: data.setStateButton, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'blockSetState', label: this.getLocalValue('blocksetstatefield', 'Block SetState', "workflowform"), checked: Boolean(data.blockSetState), onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onCommandClick", "onSetStateClick", "onReceivedCommands"];
    }
  }]);

  return WorkflowBarEditControl;
}(BaseEditControl);

module.exports = {
  BaseEditControl: BaseEditControl,
  HeaderEditControl: HeaderEditControl,
  ButtonEditControl: ButtonEditControl,
  LabelEditControl: LabelEditControl,
  MessageEditControl: MessageEditControl,
  InputEditControl: InputEditControl,
  TextAreaEditControl: TextAreaEditControl,
  DropdownEditControl: DropdownEditControl,
  DictionaryEditControl: DictionaryEditControl,
  RadioGroupEditControl: RadioGroupEditControl,
  CheckboxEditControl: CheckboxEditControl,
  FormEditControl: FormEditControl,
  FormGroupEditControl: FormGroupEditControl,
  ImageEditControl: ImageEditControl,
  StatisticEditControl: StatisticEditControl,
  GridEditControl: GridEditControl,
  CustomEditControl: CustomEditControl,
  MenuEditControl: MenuEditControl,
  ChartEditControl: ChartEditControl,
  WorkflowBarEditControl: WorkflowBarEditControl,
  ContainerEditControl: ContainerEditControl,
  StaticContentEditControl: StaticContentEditControl,
  CollectionEditorEditControl: CollectionEditorEditControl,
  CustomBlockEditControl: CustomBlockEditControl,
  DropdownTriggerEditControl: DropdownTriggerEditControl,
  DropzoneEditControl: DropzoneEditControl,
  BreadcrumbEditControl: BreadcrumbEditControl,
  SearchEditControl: SearchEditControl
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Upload = function (_React$Component) {
  _inherits(Upload, _React$Component);

  function Upload(props) {
    _classCallCheck(this, Upload);

    var _this = _possibleConstructorReturn(this, (Upload.__proto__ || Object.getPrototypeOf(Upload)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(Upload, [{
    key: "render",
    value: function render() {
      var type = this.props.type;
      var controls = [];
      var isForm = this.props.isForm;
      var token = this.props.value;

      if (token != undefined && token != null && token != "") {
        var downloadtext = "Download";
        var cleartext = "Clear";
        if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.button != undefined) {
          downloadtext = window.DWKitAdminLang.button.download;
          cleartext = window.DWKitAdminLang.button.clear;
        }

        var isHideClear = this.props.disabled || this.props.readOnly || this.props.hideClearButton;
        controls.push(_react2.default.createElement(
          "a",
          { key: "download", className: "ui button", target: "blank", href: this.props.downloadUrl + token },
          downloadtext
        ));

        if (!isHideClear) {
          controls.push(_react2.default.createElement(
            "span",
            { key: "sparator" },
            "\xA0\xA0"
          ));
          controls.push(_react2.default.createElement(
            "button",
            { key: "clear", className: "ui button", onClick: this.onClear.bind(this) },
            cleartext
          ));
        }
      } else {
        if (this.props.disabled || this.props.readOnly) controls.push(_react2.default.createElement("span", null));else controls.push(_react2.default.createElement("input", { key: "uploadcontrol", type: "file", name: this.props.name, onChange: this.onChange.bind(this) }));
      }

      var res = undefined;
      if (isForm) {
        res = _react2.default.createElement(
          "div",
          { className: "field" },
          this.props.label != undefined && _react2.default.createElement(
            "label",
            null,
            this.props.label
          ),
          _react2.default.createElement(
            "div",
            { "data-buildertype": type },
            controls
          )
        );
      } else {
        res = _react2.default.createElement(
          "div",
          { "data-buildertype": type },
          this.props.label != undefined && _react2.default.createElement(
            "div",
            { className: "ui label label" },
            this.props.label
          ),
          controls
        );
      }

      return res;
    }
  }, {
    key: "onChange",
    value: function onChange(e) {
      var me = this;
      var formdata = new FormData();
      formdata.append(me.props.name, e.target.files[0]);

      $.ajax({
        url: me.props.uploadUrl,
        type: 'POST',
        processData: false,
        contentType: false,
        dataType: 'json',
        data: formdata,
        success: function success(jsonData) {
          if (jsonData.success == true) {
            if (me.props.onChange != undefined) {
              me.props.onChange(e, { name: me.props.name, value: jsonData.message });
            }
          }
        }
      });
    }
  }, {
    key: "onClear",
    value: function onClear() {
      if (this.props.onChange != undefined) this.props.onChange(undefined, { name: this.props.name, value: null });
    }
  }]);

  return Upload;
}(_react2.default.Component);

exports.default = Upload;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDatepicker = __webpack_require__(39);

var _reactDatepicker2 = _interopRequireDefault(_reactDatepicker);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatePicker = function (_React$Component) {
  _inherits(DatePicker, _React$Component);

  function DatePicker(props) {
    _classCallCheck(this, DatePicker);

    var _this = _possibleConstructorReturn(this, (DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(DatePicker, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var type = this.props.type;
      var isForm = this.props.isForm;
      var date = this.props.value ? (0, _moment2.default)(this.props.value) : undefined;

      var controlProps = {};
      controlProps.readOnly = this.props.readOnly;

      if (type === "date") {
        if (window.DWKitLang !== undefined && window.DWKitLang.common != undefined && window.DWKitLang.common.dateFormat != undefined) {
          controlProps.dateFormat = window.DWKitLang.common.dateFormat;
        } else {
          controlProps.dateFormat = "DD.MM.YYYY";
        }
      } else if (type === "time") {
        controlProps.showTimeSelect = true;
        controlProps.showTimeSelectOnly = true;
        controlProps.timeIntervals = 10;
        if (window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.timeFormat != undefined) {
          controlProps.dateFormat = window.DWKitLang.common.timeFormat;
        } else {
          controlProps.dateFormat = "HH:mm";
          controlProps.timeFormat = "HH:mm";
        }
      } else if (type === "datetime") {
        controlProps.showTimeSelect = true;
        if (window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined) {
          controlProps.timeFormat = window.DWKitLang.common.timeFormat;
          controlProps.dateFormat = window.DWKitLang.common.dateFormat + " " + (window.DWKitLang.common.timeFormat == undefined ? "HH:ss" : window.DWKitLang.common.timeFormat);
        } else {
          controlProps.dateFormat = "DD.MM.YYYY HH:mm";
          controlProps.timeFormat = "HH:mm";
        }
      }

      if (this.props.dateFormat != undefined && this.props.dateFormat != "") controlProps.dateFormat;

      this.state.dateFormat = controlProps.dateFormat;

      var control = void 0;

      control = _react2.default.createElement(_reactDatepicker2.default, _extends({}, controlProps, {
        peekNextMonth: true,
        showMonthDropdown: true,
        showYearDropdown: true,
        dropdownMode: 'select',
        isClearable: !this.props.readOnly,
        placeholderText: this.placeholder,
        selected: date,
        onChange: this.onChange.bind(this),
        onChangeRaw: function onChangeRaw(event) {
          return _this2.handleChangeRaw(event.target.value);
        }
      }));

      var res = undefined;
      if (isForm) {
        var divClass = "field";
        if (this.props.error) divClass += " error";
        res = _react2.default.createElement(
          'div',
          { className: divClass },
          this.props.label != undefined && _react2.default.createElement(
            'label',
            null,
            this.props.label
          ),
          _react2.default.createElement(
            'div',
            { 'data-buildertype': type, className: 'ui fluid input' },
            control
          )
        );
      } else {
        var _divClass = "ui fluid labeled input";
        if (this.props.error) _divClass += " error";
        res = _react2.default.createElement(
          'div',
          { 'data-buildertype': type, className: _divClass },
          this.props.label != undefined && _react2.default.createElement(
            'div',
            { className: 'ui label label' },
            this.props.label
          ),
          control
        );
      }

      return res;
    }
  }, {
    key: 'handleChangeRaw',
    value: function handleChangeRaw(value) {
      var date = undefined;
      var type = this.props.type;
      date = (0, _moment2.default)(value, this.state.dateFormat);
      this.onChange(date);
    }
  }, {
    key: 'onChange',
    value: function onChange(date) {
      if (this.props.readOnly) return;

      if (this.props.onChange != undefined) {
        var value = null;
        if (date != null && date != undefined) {
          var type = this.props.type;
          var format = "";
          if (type === "date") {
            value = date.format("YYYY-MM-DD");
          } else {
            value = date.toJSON();
          }
        }

        this.props.onChange(null, { name: this.props.name, value: value });
      }
    }
  }]);

  return DatePicker;
}(_react2.default.Component);

exports.default = DatePicker;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioGroup = function (_React$Component) {
    _inherits(RadioGroup, _React$Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, (RadioGroup.__proto__ || Object.getPrototypeOf(RadioGroup)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(RadioGroup, [{
        key: 'onChange',
        value: function onChange(e, _ref) {
            var name = _ref.name,
                value = _ref.value;

            if (this.props.onChange != undefined) {
                this.props.onChange(e, { name: this.props.name, value: value });
            } else {
                console.error("Set onChange property for RadioGroup!");
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var me = this;
            var fields = this.props.items.map(function (item) {
                return _react2.default.createElement(
                    _semanticUiReact.Form.Field,
                    { key: item.key + "_formfield" },
                    _react2.default.createElement(_semanticUiReact.Form.Radio, {
                        key: item.key,
                        label: item.text,
                        name: me.props.name + '_radioGroup',
                        value: item.value,
                        readOnly: me.props.readOnly,
                        checked: me.props.value === item.value,
                        onChange: me.onChange.bind(this)
                    })
                );
            }, this);

            if (this.props.direction == 'v') {
                return _react2.default.createElement(
                    'div',
                    { className: 'ui form' },
                    _react2.default.createElement(
                        'label',
                        null,
                        this.props.label
                    ),
                    _react2.default.createElement(
                        _semanticUiReact.Form,
                        { className: this.props.className, style: this.props.style },
                        fields
                    )
                );
            }

            return _react2.default.createElement(
                'div',
                { className: 'ui form' },
                _react2.default.createElement(
                    'div',
                    { className: 'field' },
                    _react2.default.createElement(
                        'label',
                        null,
                        this.props.label
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: this.props.className, style: this.props.style },
                        _react2.default.createElement(
                            _semanticUiReact.Form.Group,
                            { key: 'group' },
                            fields
                        )
                    )
                )
            );
        }
    }]);

    return RadioGroup;
}(_react2.default.Component);

exports.default = RadioGroup;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FilterTerms = function () {
    function FilterTerms() {
        _classCallCheck(this, FilterTerms);
    }

    _createClass(FilterTerms, null, [{
        key: "IsGreater",
        value: function IsGreater(value) {
            return value === FilterTerms.Greater;
        }
    }, {
        key: "IsLess",
        value: function IsLess(value) {
            return value === FilterTerms.Less;
        }
    }, {
        key: "IsEqual",
        value: function IsEqual(value) {
            return value === FilterTerms.Equal;
        }
    }, {
        key: "IsGreaterOrEqual",
        value: function IsGreaterOrEqual(value) {
            return value === FilterTerms.GreaterOrEqual;
        }
    }, {
        key: "IsLessOrEqual",
        value: function IsLessOrEqual(value) {
            return value === FilterTerms.LessOrEqual;
        }
    }, {
        key: "IsNotEqual",
        value: function IsNotEqual(value) {
            return value === FilterTerms.NotEqual;
        }
    }, {
        key: "IsLike",
        value: function IsLike(value) {
            return value.toLowerCase() === FilterTerms.Like || value.toLowerCase() === "*like*";
        }
    }, {
        key: "IsStartsWith",
        value: function IsStartsWith(value) {
            return value.toLowerCase() === FilterTerms.StartsWith;
        }
    }, {
        key: "IsEndsWith",
        value: function IsEndsWith(value) {
            return value.toLowerCase() === FilterTerms.EndsWith;
        }
    }, {
        key: "Evaluate",
        value: function Evaluate(value, expected, term) {
            if (FilterTerms.IsGreater(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v > e;
                });
            }
            if (FilterTerms.IsLess(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v < e;
                });
            }
            if (FilterTerms.IsEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v === e;
                });
            }
            if (FilterTerms.IsGreaterOrEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v >= e;
                });
            }
            if (FilterTerms.IsLessOrEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v <= e;
                });
            }
            if (FilterTerms.IsNotEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v !== e;
                });
            }
            if (FilterTerms.IsLike(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.indexOf(e) >= 0;
                });
            }
            if (FilterTerms.IsStartsWith(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.startsWith(e);
                });
            }
            if (FilterTerms.IsEndsWith(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.endsWith(e);
                });
            }

            throw "Unknown term " + term;
        }
    }, {
        key: "likeCompare",
        value: function likeCompare(value, expected, comparator) {
            if (value === null && expected === null) return true;

            if (value === undefined && expected === undefined) return true;

            if (value === null || value === undefined) return false;

            if (expected === null || expected === undefined) return false;
            return comparator(value.toString().toLowerCase(), expected.toString().toLowerCase());
        }
    }, {
        key: "compareWithTypeCheck",
        value: function compareWithTypeCheck(value, expected, comparator) {
            if (value === null && expected === null) return true;

            if (value === undefined && expected === undefined) return true;

            if (value === null || value === undefined) return false;

            if (expected === null || expected === undefined) return false;

            if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === (typeof expected === "undefined" ? "undefined" : _typeof(expected))) {
                return comparator(value, expected);
            } else if (typeof value === "number" && typeof expected === "string") {
                return comparator(value, parseFloat(expected));
            } else if (typeof value === "string" && typeof expected === "number") {
                return comparator(value, expected.toString());
            } else {
                return comparator(value, expected);
            }
        }
    }, {
        key: "Greater",
        get: function get() {
            return ">";
        }
    }, {
        key: "Less",
        get: function get() {
            return ">";
        }
    }, {
        key: "Equal",
        get: function get() {
            return "=";
        }
    }, {
        key: "GreaterOrEqual",
        get: function get() {
            return ">=";
        }
    }, {
        key: "LessOrEqual",
        get: function get() {
            return "<=";
        }
    }, {
        key: "NotEqual",
        get: function get() {
            return "!=";
        }
    }, {
        key: "Like",
        get: function get() {
            return "like";
        }
    }, {
        key: "StartsWith",
        get: function get() {
            return "like*";
        }
    }, {
        key: "EndsWith",
        get: function get() {
            return "*like";
        }
    }]);

    return FilterTerms;
}();

var FunctionalFilter = function () {
    function FunctionalFilter(objectFilter, columns) {
        var _this = this;

        _classCallCheck(this, FunctionalFilter);

        this._innerFilter = {};
        if (objectFilter === undefined || !Array.isArray(objectFilter)) return;
        if (columns === undefined || !Array.isArray(columns)) throw "columns must be array";

        objectFilter.forEach(function (el) {
            if (el === undefined) return;
            var applyToColumns = void 0;
            if (el.column === "*") {
                applyToColumns = columns;
            } else {
                applyToColumns = el.column.split(",").map(function (n) {
                    return n.trim();
                });
            }

            _this.AddFilter({ names: applyToColumns, expected: el.value, term: el.term });
        });
    }

    _createClass(FunctionalFilter, [{
        key: "AddFilter",
        value: function AddFilter(_ref) {
            var _this2 = this;

            var names = _ref.names,
                expected = _ref.expected,
                term = _ref.term,
                id = _ref.id;

            if (names.length < 1) return;

            var filterId = names.length === 1 ? names[0] : names.sort().join("_");
            var filter = void 0;
            if (!this._innerFilter.hasOwnProperty(filterId)) {
                filter = this._innerFilter[filterId] = {};
                filter.funcs = [];
                filter.items = [];
                filter.test = function (r) {
                    return _this2._innerFilter[filterId].funcs.every(function (f) {
                        return f(r);
                    });
                };
            } else {
                filter = this._innerFilter[filterId];
            }

            var compFunc = void 0;
            var singleCompFunc = function singleCompFunc(r, name) {
                var propName = Object.keys(r).find(function (k) {
                    return k.toString().toLowerCase() === name.toLowerCase();
                });
                if (propName !== undefined) {
                    var result = FilterTerms.Evaluate(r[propName], expected, term);
                    return result;
                } else return false;
            };

            if (names.length === 1) {
                compFunc = function compFunc(r) {
                    return singleCompFunc(r, names[0]);
                };
            } else {
                compFunc = function compFunc(r) {
                    return names.some(function (name) {
                        return singleCompFunc(r, name);
                    });
                };
            }
            filter.funcs.push(compFunc);
            filter.items.push({ expected: expected, term: term, id: id });
        }
    }, {
        key: "RemoveFilter",
        value: function RemoveFilter(_ref2) {
            var _this3 = this;

            var name = _ref2.name,
                id = _ref2.id;

            var filterId = void 0;
            var names = void 0;
            if (name !== undefined) {
                if (Array.isArray(name)) {
                    filterId = name.length === 1 ? name[0] : name.sort().join("_");
                    names = name;
                } else {
                    filterId = name;
                    names = [name];
                }
            }

            if (name !== undefined && id === undefined) {
                delete this._innerFilter[filterId];
            } else if (name === undefined && id === undefined) {
                this._innerFilter = {};
            } else {
                var recreateProperty = function recreateProperty(filterId, names, id) {
                    if (!_this3._innerFilter.hasOwnProperty(filterId)) return;
                    var newItems = _this3._innerFilter[filterId].items.filter(function (el) {
                        return el.id !== id;
                    });
                    if (newItems.length < _this3._innerFilter[filterId].items.length) {
                        delete _this3._innerFilter[filterId];
                        newItems.forEach(function (ni) {
                            _this3.AddFilter({ names: names, expected: ni.expected, term: ni.term, id: ni.id });
                        });
                    }
                };

                if (name !== undefined && id !== undefined) {
                    recreateProperty(filterId, names, id);
                } else {
                    var allFilterIds = Object.keys(this._innerFilter);
                    allFilterIds.forEach(function (filterId) {
                        recreateProperty(filterId, filterId.split("_"), id);
                    });
                }
            }
        }
    }, {
        key: "IsRowMatched",
        value: function IsRowMatched(row) {
            var allNames = Object.keys(this._innerFilter);
            if (allNames.length <= 0) return true;

            for (var i = 0; i < allNames.length; i++) {
                if (!this._innerFilter[allNames[i]].test(row)) return false;
            }

            return true;
        }
    }, {
        key: "GetFilterAsObjects",
        value: function GetFilterAsObjects() {
            var _this4 = this;

            if (this._innerFilter === undefined) return [];
            var result = [];
            var allNames = Object.keys(this._innerFilter);
            allNames.forEach(function (pn) {
                _this4._innerFilter[pn].items.forEach(function (i) {
                    result.push({ column: pn.replace(/_/g, ","), value: i.expected, term: i.term });
                });
            });
            return result;
        }
    }]);

    return FunctionalFilter;
}();

exports.FilterTerms = FilterTerms;
exports.FunctionalFilter = FunctionalFilter;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DWKitForm = exports.DWKitFormBuider = undefined;

var _builder = __webpack_require__(27);

var _builder2 = _interopRequireDefault(_builder);

var _form = __webpack_require__(70);

var _form2 = _interopRequireDefault(_form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.DWKitFormBuider = _builder2.default;
exports.DWKitForm = _form2.default;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(5);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbar = __webpack_require__(28);

var _toolbar2 = _interopRequireDefault(_toolbar);

var _preview = __webpack_require__(67);

var _preview2 = _interopRequireDefault(_preview);

var _store = __webpack_require__(9);

var _store2 = _interopRequireDefault(_store);

var _editform = __webpack_require__(68);

var _editform2 = _interopRequireDefault(_editform);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _lang = __webpack_require__(69);

var _lang2 = _interopRequireDefault(_lang);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DWKitFormBuider = function (_React$Component) {
  _inherits(DWKitFormBuider, _React$Component);

  function DWKitFormBuider(props) {
    _classCallCheck(this, DWKitFormBuider);

    var _this = _possibleConstructorReturn(this, (DWKitFormBuider.__proto__ || Object.getPrototypeOf(DWKitFormBuider)).call(this, props));

    _this.state = {
      defaultForm: props.defaultForm,
      apiurl: props.apiurl,
      imagefolder: props.imagefolder,
      actions: props.actions,
      dropzoneactive: true
    };
    return _this;
  }

  _createClass(DWKitFormBuider, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.state.defaultForm != undefined) this.load(this.state.defaultForm);
    }
  }, {
    key: "exists",
    value: function exists(code) {
      return _store2.default.exists(code);
    }
  }, {
    key: "setBuilderMode",
    value: function setBuilderMode(enabled) {
      if (enabled) {
        $('.dwkit-formbuilder-zone').show();
        $('.dwkit-formbuilder-item-toolbar-header').show();
      } else {
        $('.dwkit-formbuilder-zone').hide();
        $('.dwkit-formbuilder-item-toolbar-header').hide();
      }

      this.setState({
        dropzoneactive: enabled
      });
    }
  }, {
    key: "create",
    value: function create() {
      _store2.default.setData([]);
      this.setBuilderMode(true);
    }
  }, {
    key: "loadData",
    value: function loadData(data) {
      _store2.default.setData(data);
      this.setBuilderMode(true);
    }
  }, {
    key: "getData",
    value: function getData() {
      return _store2.default.getData();
    }
  }, {
    key: "load",
    value: function load(code) {
      var data = this.props.getFormFunc(code);
      _store2.default.setData(data);
      this.setState({
        code: code
      });

      this.setBuilderMode(true);
    }
  }, {
    key: "download",
    value: function download() {
      var data = _store2.default.getData();
      var jsonContent = 'data:text/json;charset=utf-8,';
      jsonContent += JSON.stringify(data, null, 2);
      var encodedUri = jsonContent;
      var link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "form.json");
      document.body.appendChild(link);
      link.click();
    }
  }, {
    key: "upload",
    value: function upload(form, successFunc) {
      var file = form.files[0];
      var reader = new FileReader();
      reader.onload = function (theFile) {
        return function (e) {
          var data = JSON.parse(e.target.result);
          _store2.default.setData(data);
        };
      }(file);

      reader.readAsText(file);
    }
  }, {
    key: "handleShowDropzonesClick",
    value: function handleShowDropzonesClick(e, _ref) {
      var name = _ref.name,
          checked = _ref.checked;

      this.setBuilderMode(checked);
    }
  }, {
    key: "onChooseFileUpload",
    value: function onChooseFileUpload(e) {
      $('#builderUploadFile').click();
    }
  }, {
    key: "onChangeFileUpload",
    value: function onChangeFileUpload(e) {
      $('#builderUploadSubmit').click();
    }
  }, {
    key: "onUpload",
    value: function onUpload(e) {
      e.preventDefault();
      this.upload(document.getElementById("builderUploadFile"));
    }
  }, {
    key: "onDownload",
    value: function onDownload(e) {
      this.download();
    }
  }, {
    key: "showsample1",
    value: function showsample1() {
      this.load("invoiceform");
    }
  }, {
    key: "showsample2",
    value: function showsample2() {
      this.load("projectform");
    }
  }, {
    key: "getHeader",
    value: function getHeader() {
      var local = this.getCurrentLocalization();

      var spanSelectorStyle = this.state.dropzoneactive ? "" : "dwkit-formbuilder-selector-preview";
      return _react2.default.createElement(
        "div",
        { className: "dwkit-formbuilder-header" },
        _react2.default.createElement(
          "div",
          { className: "dwkit-formbuilder-header-left" },
          _react2.default.createElement("img", { className: "dwkit-formbuilder-header-logo", src: "/images/logo.svg" })
        ),
        _react2.default.createElement(
          "div",
          { className: "dwkit-formbuilder-header-center" },
          _react2.default.createElement(
            _semanticUiReact.Button,
            { name: "btnEmpty", className: "buttontype2", onClick: this.create.bind(this) },
            local.clearbutton
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { name: "btnSample1", className: "buttontype1", onClick: this.showsample1.bind(this) },
            "Sample 1"
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { name: "btnSample1", className: "buttontype1", onClick: this.showsample2.bind(this) },
            "Sample 2"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "dwkit-formbuilder-header-right" },
          _react2.default.createElement(
            "div",
            { className: "dwkit-formbuilder-selector" },
            _react2.default.createElement(
              "span",
              { className: spanSelectorStyle },
              "Preview"
            ),
            _react2.default.createElement(_semanticUiReact.Checkbox, { toggle: true, name: "cbShowDropzones", label: "Builder", checked: this.state.dropzoneactive, onChange: this.handleShowDropzonesClick.bind(this) })
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { name: "btnUpload", className: "buttontype2", onClick: this.onChooseFileUpload.bind(this) },
            local.uploadbutton
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { name: "btnDownload", className: "buttontype2", onClick: this.onDownload.bind(this) },
            local.downloadbutton
          ),
          _react2.default.createElement(
            "form",
            { action: "/", method: "post", id: "builderUploadForm", style: { display: "none" }, onSubmit: this.onUpload.bind(this) },
            _react2.default.createElement("input", { type: "file", id: "builderUploadFile", onChange: this.onChangeFileUpload.bind(this) }),
            _react2.default.createElement("input", { type: "submit", id: "builderUploadSubmit" })
          )
        )
      );
    }
  }, {
    key: "render",
    value: function render() {
      var localization = this.getCurrentLocalization();

      var className = "dwkit-formbuilder";
      if (this.state.dropzoneactive) {
        className += " dwkit-formbuilder-dropzoneactive";
      }

      var builder = _react2.default.createElement(
        "div",
        { className: className },
        _react2.default.createElement(
          "div",
          { className: "dwkit-formbuilder-content" },
          _react2.default.createElement(_preview2.default, {
            getFormFunc: this.props.getFormFunc,
            getFormFist: this.props.getFormFist,
            getAdditionalDataForControl: this.props.getAdditionalDataForControl,
            localization: localization.preview,
            downloadUrl: this.props.downloadUrl,
            uploadUrl: this.props.uploadUrl }),
          _react2.default.createElement(_editform2.default, { actions: this.state.actions, localization: localization.editforms })
        ),
        _react2.default.createElement(_toolbar2.default, { localization: localization.toolbar, templates: this.props.templates })
      );

      if (this.props.showHeader) {
        return _react2.default.createElement(
          "div",
          null,
          this.getHeader(),
          builder
        );
      }

      return builder;
    }
  }, {
    key: "getCurrentLocalization",
    value: function getCurrentLocalization() {
      if (this.props.localization != undefined) {
        return this.props.localization;
      }

      return _lang2.default;
    }
  }]);

  return DWKitFormBuider;
}(_react2.default.Component);

exports.default = DWKitFormBuider;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _actions = __webpack_require__(6);

var _actions2 = _interopRequireDefault(_actions);

var _controls = __webpack_require__(7);

var _controls2 = _interopRequireDefault(_controls);

var _editformControls = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Toolbar = function (_React$Component) {
  _inherits(Toolbar, _React$Component);

  function Toolbar(props) {
    _classCallCheck(this, Toolbar);

    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, props));

    var items = [].concat(_toConsumableArray(_controls2.default.Items));
    if (Array.isArray(_this.props.templates) && _this.props.templates.length > 0) {
      items.push({ key: "sepTemplates", title: 'Templates', isseparate: true, defaultopen: false });

      _this.props.templates.forEach(function (template) {
        items.push({
          key: template,
          builderType: "customblock",
          title: template,
          control: undefined,
          editControl: _editformControls.CustomBlockEditControl,
          defaultValues: { formname: template, sourceType: "form" } });
      });
    }

    _this.makeLocalization(items);

    _this.state = {
      items: items
    };
    return _this;
  }

  _createClass(Toolbar, [{
    key: 'makeLocalization',
    value: function makeLocalization(items) {
      if (this.props.localization == undefined) return;

      var local = this.props.localization;
      for (var i = 0; i < items.length; i++) {
        if (local[items[i].key] != undefined) {
          items[i].title = local[items[i].key];
        }
      }
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(item, e) {
      var selector = '.dwkit-formbuilder-zone';
      e.dataTransfer.setData('text', '');

      if (item.forContainerType != undefined) {
        var cTypes = item.forContainerType.split(',');
        var subSelector = "";
        cTypes.forEach(function (c) {
          if (subSelector.length > 0) subSelector += ",";
          subSelector += "[data-buildertype='" + c + "'] > " + selector;
        });
        selector = subSelector;
      }

      $(selector).addClass('dwkit-formbuilder-zone-active').on('dragenter', this.onTargetDragEnter.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragleave', this.onTargetDragLeave.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragover', function (e) {
        e.preventDefault();
      }).on('drop', this.onDrop.bind(this, item));
    }
  }, {
    key: 'onTargetDragEnter',
    value: function onTargetDragEnter(item, css, e) {
      $(e.target).addClass(css);
    }
  }, {
    key: 'onTargetDragLeave',
    value: function onTargetDragLeave(item, css, e) {
      $(e.target).removeClass(css);
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(item) {
      this.stop = false;
      var zones = $('.dwkit-formbuilder-zone');

      zones.removeClass('dwkit-formbuilder-zone-active');
      zones.removeClass('dwkit-formbuilder-zone-select');
      zones.off();
    }
  }, {
    key: 'onDrop',
    value: function onDrop(item, e) {
      var el = $(e.target);
      if (el.length > 0) {
        _actions2.default.add(item, el[0]);
      }

      this.onDragEnd(item);
      return false;
    }
  }, {
    key: 'onDoubleClick',
    value: function onDoubleClick(item) {
      _actions2.default.add(item);
    }
  }, {
    key: 'onExpand',
    value: function onExpand(item, value) {
      item.isexpanded = value;
      this.setCookie("toolbar_" + item.key, value);
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var me = this;
      var expandedbock = false;
      return _react2.default.createElement(
        'div',
        { className: 'dwkit-formbuilder-toolbox' },
        _react2.default.createElement(
          'ul',
          null,
          this.state.items.map(function (item) {
            var title = item.title;
            if (me.props.localization != undefined && me.props.localization[item.key] != undefined) {
              title = me.props.localization[item.key];
            }

            if (item.isseparate) {
              var icon;
              var onclick;

              if (item.isexpanded == undefined) {
                var cookievalue = me.getCookie("toolbar_" + item.key);
                item.isexpanded = cookievalue != undefined ? cookievalue == "true" : item.defaultopen;
              }

              if (item.isexpanded) {
                expandedbock = true;
                onclick = me.onExpand.bind(me, item, false);
                icon = _react2.default.createElement(
                  'span',
                  null,
                  '\u2013'
                ); //<img  key="btnexpand" className="collapse" src="/images/collapse.svg"/>;
              } else {
                expandedbock = false;
                onclick = me.onExpand.bind(me, item, true);
                icon = _react2.default.createElement(
                  'span',
                  null,
                  '+'
                ); //<img key="btnexpand" className="expand" src="/images/expand.svg"/>;
              }

              return _react2.default.createElement(
                'li',
                { draggable: 'false', onClick: onclick, className: 'dwkit-formbuilder-toolbox-subheader', key: item.key },
                title,
                icon
              );
            }

            if (expandedbock) {
              var w = item.imagewidth != undefined ? item.imagewidth : 32;
              var h = item.imageheight != undefined ? item.imageheight : 32;

              return _react2.default.createElement(
                'li',
                { draggable: 'true', className: 'dwkit-formbuilder-toolbox-control',
                  key: item.key,
                  onDragStart: _this2.onDragStart.bind(_this2, item),
                  onDragEnd: _this2.onDragEnd.bind(_this2, item),
                  onDoubleClick: _this2.onDoubleClick.bind(_this2, item),
                  onDrag: _this2.onDrag.bind(_this2) },
                _react2.default.createElement('img', { className: 'dwkit-formbuilder-toolbox-control-icon', src: '/images/dwkitbuilder-toolbar-move.png' }),
                _react2.default.createElement(
                  'div',
                  { className: 'dwkit-formbuilder-toolbox-control-text' },
                  title
                )
              );
            }
          })
        )
      );
    }
  }, {
    key: 'onDrag',
    value: function onDrag(e) {
      var step = 10;
      if (e.clientY < 150) {
        this.scroll(-step);
      }

      if (e.clientY > $(window).height() - 150) {
        this.scroll(step);
      }
    }
  }, {
    key: 'scroll',
    value: function (_scroll) {
      function scroll(_x) {
        return _scroll.apply(this, arguments);
      }

      scroll.toString = function () {
        return _scroll.toString();
      };

      return scroll;
    }(function (step) {
      var scrollY = $(window).scrollTop();
      $(window).scrollTop(scrollY + step);
      if (!stop) {
        setTimeout(function () {
          scroll(step);
        }, 20);
      }
    })
  }, {
    key: 'getCookie',
    value: function getCookie(name) {
      var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
      return matches ? decodeURIComponent(matches[1]) : undefined;
    }
  }, {
    key: 'setCookie',
    value: function setCookie(name, value, options) {
      options = options || {};

      var expires = options.expires;

      if (typeof expires == "number" && expires) {
        var d = new Date();
        d.setTime(d.getTime() + expires * 1000);
        expires = options.expires = d;
      }
      if (expires && expires.toUTCString) {
        options.expires = expires.toUTCString();
      }

      value = encodeURIComponent(value);

      var updatedCookie = name + "=" + value;

      for (var propName in options) {
        updatedCookie += "; " + propName;
        var propValue = options[propName];
        if (propValue !== true) {
          updatedCookie += "=" + propValue;
        }
      }

      document.cookie = updatedCookie;
    }
  }]);

  return Toolbar;
}(_react2.default.Component);

exports.default = Toolbar;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} [once=false] Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Hold the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mix = mix;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mix(def) {
    var composed = {
        init: [],
        preEmit: [],
        shouldEmit: []
    };

    var updated = function mixDef(mixin) {
        var mixed = {};
        if (mixin.mixins) {
            mixin.mixins.forEach(function (subMixin) {
                _.extend(mixed, mixDef(subMixin));
            });
        }
        _.extend(mixed, mixin);
        Object.keys(composed).forEach(function (composable) {
            if (mixin.hasOwnProperty(composable)) {
                composed[composable].push(mixin[composable]);
            }
        });
        return mixed;
    }(def);

    if (composed.init.length > 1) {
        updated.init = function () {
            var args = arguments;
            composed.init.forEach(function (init) {
                init.apply(this, args);
            }, this);
        };
    }
    if (composed.preEmit.length > 1) {
        updated.preEmit = function () {
            return composed.preEmit.reduce(function (args, preEmit) {
                var newValue = preEmit.apply(this, args);
                return newValue === undefined ? args : [newValue];
            }.bind(this), arguments);
        };
    }
    if (composed.shouldEmit.length > 1) {
        updated.shouldEmit = function () {
            var args = arguments;
            return !composed.shouldEmit.some(function (shouldEmit) {
                return !shouldEmit.apply(this, args);
            }, this);
        };
    }
    Object.keys(composed).forEach(function (composable) {
        if (composed[composable].length === 1) {
            updated[composable] = composed[composable][0];
        }
    });

    return updated;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bindMethods = bindMethods;
function bindMethods(store, definition) {
    for (var name in definition) {
        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);

            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== "function" || !definition.hasOwnProperty(name)) {
                continue;
            }

            store[name] = definition[name].bind(store);
        } else {
            var property = definition[name];

            if (typeof property !== "function" || !definition.hasOwnProperty(name)) {
                continue;
            }

            store[name] = property.bind(store);
        }
    }

    return store;
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAction = createAction;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _ActionMethods = __webpack_require__(17);

var ActionMethods = _interopRequireWildcard(_ActionMethods);

var _PublisherMethods = __webpack_require__(12);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _Keep = __webpack_require__(11);

var Keep = _interopRequireWildcard(_Keep);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var allowed = { preEmit: 1, shouldEmit: 1 };

/**
 * Creates an action functor object. It is mixed in with functions
 * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may
 * be overridden in the definition object.
 *
 * @param {Object} definition The action object definition
 */
function createAction(definition) {

    definition = definition || {};
    if (!_.isObject(definition)) {
        definition = { actionName: definition };
    }

    for (var a in ActionMethods) {
        if (!allowed[a] && PublisherMethods[a]) {
            throw new Error("Cannot override API method " + a + " in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] && PublisherMethods[d]) {
            throw new Error("Cannot override API method " + d + " in action creation. Use another method name or override it on Reflux.PublisherMethods instead.");
        }
    }

    definition.children = definition.children || [];
    if (definition.asyncResult) {
        definition.children = definition.children.concat(["completed", "failed"]);
    }

    var i = 0,
        childActions = {};
    for (; i < definition.children.length; i++) {
        var chDef = definition.children[i];
        var chName = typeof chDef === "string" ? chDef : chDef.actionName;
        childActions[chName] = createAction(chDef);
    }

    var context = _.extend({
        eventLabel: "action",
        emitter: new _.EventEmitter(),
        _isAction: true
    }, PublisherMethods, ActionMethods, definition);

    var functor = function functor() {
        var hasChildActions = false;
        /* eslint no-unused-vars:0 */
        for (var ignore in functor.childActions) {
            hasChildActions = true;break;
        }
        var async = !functor.sync && typeof functor.sync !== "undefined" || hasChildActions;
        var triggerType = async ? "triggerAsync" : "trigger";
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.addAction(functor);

    return functor;
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3),
    ListenerMixin = __webpack_require__(13),
    _ = __webpack_require__(2);

module.exports = function(listenable, key) {

    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            return _.object([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
            var me = this;

            _.extend(me, ListenerMethods);

            this.listenTo(listenable, function(v) {
                me.setState(_.object([key],[v]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3),
    ListenerMixin = __webpack_require__(13),
    _ = __webpack_require__(2);

module.exports = function(listenable, key, filterFunc) {

    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            // Filter initial payload from store.
            var result = filterFunc.call(this, listenable.getInitialState());
            if (typeof(result) !== 'undefined') {
                return _.object([key], [result]);
            } else {
                return {};
            }
        },
        componentDidMount: function() {
            var me = this;

            _.extend(this, ListenerMethods);

            this.listenTo(listenable, function(value) {
                var result = filterFunc.call(me, value);
                me.setState(_.object([key], [result]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3);

/**
 * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,
 * without having to manually set listeners in the `componentDidMount` method.
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @param {Function|String} callback The callback to register as event handler
 * @param {Function|String} defaultCallback The callback to register as default handler
 * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.
 */
module.exports = function(listenable,callback,initial){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenTo!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenTo(listenable,callback,initial);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3);

/**
 * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,
 * without having to manually set listeners in the `componentDidMount` method. This version is used
 * to automatically set up a `listenToMany` call.
 *
 * @param {Object} listenables An object of listenables
 * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.
 */
module.exports = function(listenables){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenToMany!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenToMany(listenables);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {


/* globals React: false */

var Reflux = __webpack_require__(10);
Reflux.defineReact = __webpack_require__(38);

// useful utility for ES6 work, mimics the ability to extend
Reflux.utils.inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}
	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
};

// first try to see if there's a global React var and use it
if (typeof React !== 'undefined' && React) {
	Reflux.defineReact(React);
// otherwise we're gonna resort to 'try' stuff in case of other environments
} else {
	try {
		var R = __webpack_require__(0); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck for in node
		Reflux.defineReact(R);
	} catch (e) {}
}


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* globals React: false */

var Reflux = __webpack_require__(10);

/**
 * Reflux.defineReact function where you can manually supply
 * the React object in order to create in case Reflux needs to load before
 * React or there is a modular environment where there won't be a global
 * React variable.
 * @note The third param is for internal usage only.
 */
var _react, _defined = false;
function defineReact(react, noLongerUsed, extend)
{
	var proto, _extend;
	
	// if no Reflux object is yet available then return and just wait until defineReact is called manually with it
	try {
		_react  = react  || _react  || React;
		_extend = extend || _react.Component;
	} catch (e) {
		return;
	}
	
	// if Reflux and React aren't present then ignore, wait until they are properly present
	// also ignore if it's been called before UNLESS there's manual extending happening
	if (!_react || !_extend || (_defined && !extend)) {
		return;
	}
	
	// ----------- BEGIN Reflux.Component ------------
	/**
	 * Reflux.Component:
	 * An implementation for idiomatic React.js classes that mix with
	 * Reflux stores. To utilize extend Reflux.Component instead of
	 * React.Component. Then you may hook any Reflux store that has a
	 * `this.state` property containing its state values to the component
	 * via `this.store` or an Array of Reflux stores via `this.stores` in
	 * the component's constructor (similar to how you assign initial state
	 * in the constructor in ES6 style React). The default values of the
	 * stores will automatically reflect in the component's state, and any
	 * further `trigger` calls from that store will update properties passed
	 * in the trigger into the component automatically.
	 */
	var RefluxComponent = function(props, context, updater) {
		_extend.call(this, props, context, updater);
	};
	
	// equivalent of `extends React.Component` or other class if provided via `extend` param
	Reflux.utils.inherits(RefluxComponent, _extend);
	
	proto = RefluxComponent.prototype;
	
	/**
	 * this.storeKeys
	 * When this is a falsey value (null by default) the component mixes in
	 * all properties from the stores attached to it and updates on changes
	 * from all of them. When set to an array of string keys it will only
	 * utilized state property names of those keys in any store attached. This
	 * lets you choose which parts of stores update the component on a component-
	 * by-component basis. If using this it is best set in the constructor.
	 */
	proto.storeKeys = null;
	
	// on the mounting of the component that is where the store/stores are attached and initialized if needed
	proto.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i < ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId && Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j<jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	};
	
	// on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean
	proto.componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	};
	
	/**
	 * this.mapStoreToState
	 * This function allow you to supply map the state of a store to the
	 * state of this component manually via your own logic. This method
	 * is completely separate from this.store/this.stores and/or this.storeKeys.
	 * Call this function with an ES6 store (class or singleton instance) as the
	 * first argument and your filter function as the second. Your filter function
	 * will receive an object of the parts of the ES6 store being updated every
	 * time its setState is called. Your filter function then returns an object
	 * which will be merged with the component state (IF it has any properties at all,
	 * should you return a blank object the component will not rerender).
	 */
	proto.mapStoreToState = function(store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object 
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	};
	
	/**
	 * Reflux.Component.extend(OtherClass)
	 * This allows you to get classes that extend off of another React.Component
	 * inheriting class. For example if you're using a third party that uses
	 * components that allow `class MyComponent extends LibComponent` (where LibComponent
	 * itself extends React.Component) and you want to use that component with ES6 then
	 * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`
	 * then you can use `class MyComponent extends MyDualComponent` to get the benefits
	 * of both libraries.
	 */
	RefluxComponent.extend = function(clss) {
		return defineReact(null, null, clss);
	};
	
	// if is being manually called with an `extend` argument present then just return the created class
	if (extend) {
		return RefluxComponent;
	}
	
	// otherwise set as Reflux.Component and continue with other normal definitions
	Reflux.Component = RefluxComponent;
	
	// also set Reflux.PureComponent (if it exists) using the .extend feature
	if (_react.PureComponent) {
		Reflux.PureComponent = RefluxComponent.extend(_react.PureComponent);
	}
	
	// ------------ END Reflux.Component ------------
	
	// --------- BEGIN Reflux.Store ------------
	/**
	 * Reflux.Store:
	 * Also implements optional Reflux.Store class that is idiomatic with
	 * the React ES6 style. You extend Reflux.Store and then the rest works
	 * the same as createStore, except the constructor instead of init, and
	 * it holds state in a state property, and a .setState method is available
	 * which automatically updates state and does a trigger. Then when using
	 * with this.store or this.stores in an ES6 component just plass the class,
	 * it will deal with a singleton instantiation of the class automatically.
	 */
	var RefluxStore = function() {
		// extending doesn't really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	};
	
	proto = RefluxStore.prototype;
	
	// this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store
	// it is essentially a shortcut to the `listenToMany` method
	Object.defineProperty(proto, "listenables", {
		get: function () {
			return this.__listenables__;
		},
		set: function (v) {
			var Combined = {};
			if (Array.isArray(v)){
				v.forEach(function(obj) {
					for (var key in obj) {
						Combined[key] = obj[key];
					}
				});
			} else {
				Combined = v;
			}
			this.__listenables__ = Combined;
			this.listenToMany(Combined);
		},
		enumerable: true,
		configurable: true
	});
	
	// allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update
	// components that it is attached to in a simple way that is idiomatic with React
	proto.setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	};
	
	// this is a static property so that other code can identify that this is a Reflux.Store class
	// has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet
	Object.defineProperty(RefluxStore, "isES6Store", {
		get: function () {
			return true;
		},
		enumerable: true,
		configurable: true
	});
	
	// allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)
	Object.defineProperty(RefluxStore, "state", {
		get: function () {
			if (!this.singleton) {
				throw new Error('Reflux.Store.state is inaccessible before the store has been initialized.');
			}
			return this.singleton.state;
		},
		enumerable: true,
		configurable: true
	});
	
	/* NOTE:
	If a Reflux.Store definition is given a static id property and used
	properly within a Reflux.Component or with Reflux.initStore then
	it will be added to the Reflux.GlobalState object which automatically tracks the
	current state of all such defined stores in the program. */
	
	Reflux.Store = RefluxStore;
	// ----------- END Reflux.Store -------------
	
	// --------- BEGIN Reflux Static Props/Methods ------------
	/**
	 * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's
	 * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id "MyStore" and
	 * a state {"color":"red"} will end up with a Reflux.GlobalState of {"MyStore":{"color":"red"}}
	 * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you
	 * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component
	 * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global
	 * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will
	 * not continue to mutate as Reflux.GlobalState continues to mutate.
	 */
	Reflux.GlobalState = Reflux.GlobalState || {};
	
	/**
	 * Reflux.stores
	 * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.
	 */
	Reflux.stores = {};
	
	/**
	 * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState 
	 * which will not continue to mutate as Reflux.GlobalState does. It can essentially store
	 * snapshots of the global state as the program goes for saving or for in-app time travel.
	 */
	Reflux.getGlobalState = function() {
		return clone(Reflux.GlobalState);
	};
	
	/**
	 * Reflux.setGlobalState takes one argument that is a representation of the a possible
	 * global state. It updates all stores in the program to represent data in that given state.
	 * This includes triggering those stores so that that state is represented in any Reflux.Component
	 * instances they are attached to. Partial states may be given to it, and only the represented
	 * stores/state values will be updated.
	 */
	Reflux.setGlobalState = function(obj) {
		for (var storeID in obj) {
			if (Reflux.stores[storeID]) {
				Reflux.stores[storeID].setState(obj[storeID]);
			} else {
				Reflux.GlobalState[storeID] = obj[storeID];
			}
		}
	};
	
	/**
	 * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton
	 * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to
	 * this.store or this.stores during the mounting phase of a component without having to actually attach the
	 * store to a component in order to work properly with the global state.
	 */
	// Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is
	// now for more broad instantiation of globally stored AND non-globally stored classes
	Reflux.initializeGlobalStore = Reflux.initStore = function(str) {
		var storeId = str.id;
		// if they're initializing something twice then we're done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it's easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class's singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	};
	// --------- END Reflux Static Props/Methods ------------
	
	// so it knows not to redefine Reflux static stuff and stores if called again
	_defined = true;
}

// filters a state object by storeKeys array (if it exists)
// if filtering and obj contains no properties to use, returns false to let the component know not to update
function filterByStoreKeys(storeKeys, obj)
{
	// if there are not storeKeys defined then simply return the whole original object
	if (!storeKeys) {
		return obj;
	}
	// otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none
	var doUpdate = false;
	var updateObj = {};
	for (var i = 0, ii = storeKeys.length; i < ii; i++) {
		var prop = storeKeys[i];
		if (obj.hasOwnProperty(prop)) {
			doUpdate = true;
			updateObj[prop] = obj[prop];
		}
	}
	return doUpdate ? updateObj : false;
}

// this is utilized by some of the global state functionality in order to get a clone that will
// not continue to be modified as the GlobalState mutates
function clone(frm, to) {
	if (frm === null || typeof frm !== "object") {
		return frm;
	}
	if (frm.constructor !== Object && frm.constructor !== Array) {
		return frm;
	}
	if (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function ||
		frm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {
		return new frm.constructor(frm);
	}
	to = to || new frm.constructor();
	for (var name in frm) {
		to[name] = typeof to[name] === "undefined" ? clone(frm[name], null) : to[name];
	}
	return to;
}

module.exports = defineReact;



/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CalendarContainer", function() { return CalendarContainer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_classnames__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_react_popper__ = __webpack_require__(44);







var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};









var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function generateYears(year, noOfYear, minDate, maxDate) {
  var list = [];
  for (var i = 0; i < 2 * noOfYear + 1; i++) {
    var newYear = year + noOfYear - i;
    var isInRange = true;

    if (minDate) {
      isInRange = minDate.year() <= newYear;
    }

    if (maxDate && isInRange) {
      isInRange = maxDate.year() >= newYear;
    }

    if (isInRange) {
      list.push(newYear);
    }
  }

  return list;
}

var YearDropdownOptions = function (_React$Component) {
  inherits(YearDropdownOptions, _React$Component);

  function YearDropdownOptions(props) {
    classCallCheck(this, YearDropdownOptions);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.renderOptions = function () {
      var selectedYear = _this.props.year;
      var options = _this.state.yearsList.map(function (year) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: selectedYear === year ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
            key: year,
            ref: year,
            onClick: _this.onChange.bind(_this, year)
          },
          selectedYear === year ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__year-option--selected" },
            "\u2713"
          ) : "",
          year
        );
      });

      var minYear = _this.props.minDate ? _this.props.minDate.year() : null;
      var maxYear = _this.props.maxDate ? _this.props.maxDate.year() : null;

      if (!maxYear || !_this.state.yearsList.find(function (year) {
        return year === maxYear;
      })) {
        options.unshift(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: "react-datepicker__year-option",
            ref: "upcoming",
            key: "upcoming",
            onClick: _this.incrementYears
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" })
        ));
      }

      if (!minYear || !_this.state.yearsList.find(function (year) {
        return year === minYear;
      })) {
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: "react-datepicker__year-option",
            ref: "previous",
            key: "previous",
            onClick: _this.decrementYears
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" })
        ));
      }

      return options;
    };

    _this.onChange = function (year) {
      _this.props.onChange(year);
    };

    _this.handleClickOutside = function () {
      _this.props.onCancel();
    };

    _this.shiftYears = function (amount) {
      var years = _this.state.yearsList.map(function (year) {
        return year + amount;
      });

      _this.setState({
        yearsList: years
      });
    };

    _this.incrementYears = function () {
      return _this.shiftYears(1);
    };

    _this.decrementYears = function () {
      return _this.shiftYears(-1);
    };

    var yearDropdownItemNumber = props.yearDropdownItemNumber,
        scrollableYearDropdown = props.scrollableYearDropdown;

    var noOfYear = yearDropdownItemNumber || (scrollableYearDropdown ? 10 : 5);

    _this.state = {
      yearsList: generateYears(_this.props.year, noOfYear, _this.props.minDate, _this.props.maxDate)
    };
    return _this;
  }

  YearDropdownOptions.prototype.render = function render() {
    var dropdownClass = __WEBPACK_IMPORTED_MODULE_2_classnames___default()({
      "react-datepicker__year-dropdown": true,
      "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
    });

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: dropdownClass },
      this.renderOptions()
    );
  };

  return YearDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

YearDropdownOptions.propTypes = {
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  year: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var dayOfWeekCodes = {
  1: "mon",
  2: "tue",
  3: "wed",
  4: "thu",
  5: "fri",
  6: "sat",
  7: "sun"
};

// These functions are not exported so
// that we avoid magic strings like 'days'
function set$1(date, unit, to) {
  return date.set(unit, to);
}

function add(date, amount, unit) {
  return date.add(amount, unit);
}

function subtract(date, amount, unit) {
  return date.subtract(amount, unit);
}

function get$1(date, unit) {
  return date.get(unit);
}

function getStartOf(date, unit) {
  return date.startOf(unit);
}

// ** Date Constructors **

function newDate(point) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default()(point);
}

function newDateWithOffset(utcOffset) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default()().utc().utcOffset(utcOffset);
}

function now(maybeFixedUtcOffset) {
  if (maybeFixedUtcOffset == null) {
    return newDate();
  }
  return newDateWithOffset(maybeFixedUtcOffset);
}

function cloneDate(date) {
  return date.clone();
}

function parseDate(value, _ref) {
  var dateFormat = _ref.dateFormat,
      locale = _ref.locale;

  var m = __WEBPACK_IMPORTED_MODULE_4_moment___default()(value, dateFormat, locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale(), true);
  return m.isValid() ? m : null;
}

// ** Date "Reflection" **

function isMoment(date) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.isMoment(date);
}

function isDate(date) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.isDate(date);
}

// ** Date Formatting **

function formatDate(date, format) {
  return date.format(format);
}

function safeDateFormat(date, _ref2) {
  var dateFormat = _ref2.dateFormat,
      locale = _ref2.locale;

  return date && date.clone().locale(locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale()).format(Array.isArray(dateFormat) ? dateFormat[0] : dateFormat) || "";
}

// ** Date Setters **

function setTime(date, _ref3) {
  var hour = _ref3.hour,
      minute = _ref3.minute,
      second = _ref3.second;

  date.set({ hour: hour, minute: minute, second: second });
  return date;
}

function setMonth(date, month) {
  return set$1(date, "month", month);
}

function setYear(date, year) {
  return set$1(date, "year", year);
}



// ** Date Getters **

function getSecond(date) {
  return get$1(date, "second");
}

function getMinute(date) {
  return get$1(date, "minute");
}

function getHour(date) {
  return get$1(date, "hour");
}

// Returns day of week
function getDay(date) {
  return get$1(date, "day");
}

function getWeek(date) {
  return get$1(date, "week");
}

function getMonth(date) {
  return get$1(date, "month");
}

function getYear(date) {
  return get$1(date, "year");
}

// Returns day of month
function getDate(date) {
  return get$1(date, "date");
}



function getDayOfWeekCode(day) {
  return dayOfWeekCodes[day.isoWeekday()];
}

// *** Start of ***

function getStartOfDay(date) {
  return getStartOf(date, "day");
}

function getStartOfWeek(date) {
  return getStartOf(date, "week");
}
function getStartOfMonth(date) {
  return getStartOf(date, "month");
}

function getStartOfDate(date) {
  return getStartOf(date, "date");
}

// *** End of ***





// ** Date Math **

// *** Addition ***

function addMinutes(date, amount) {
  return add(date, amount, "minutes");
}

function addHours(date, amount) {
  return add(date, amount, "hours");
}

function addDays(date, amount) {
  return add(date, amount, "days");
}

function addWeeks(date, amount) {
  return add(date, amount, "weeks");
}

function addMonths(date, amount) {
  return add(date, amount, "months");
}

function addYears(date, amount) {
  return add(date, amount, "years");
}

// *** Subtraction ***
function subtractDays(date, amount) {
  return subtract(date, amount, "days");
}

function subtractWeeks(date, amount) {
  return subtract(date, amount, "weeks");
}

function subtractMonths(date, amount) {
  return subtract(date, amount, "months");
}

function subtractYears(date, amount) {
  return subtract(date, amount, "years");
}

// ** Date Comparison **

function isBefore(date1, date2) {
  return date1.isBefore(date2);
}

function isAfter(date1, date2) {
  return date1.isAfter(date2);
}

function equals(date1, date2) {
  return date1.isSame(date2);
}

function isSameYear(date1, date2) {
  if (date1 && date2) {
    return date1.isSame(date2, "year");
  } else {
    return !date1 && !date2;
  }
}

function isSameMonth(date1, date2) {
  if (date1 && date2) {
    return date1.isSame(date2, "month");
  } else {
    return !date1 && !date2;
  }
}

function isSameDay(moment1, moment2) {
  if (moment1 && moment2) {
    return moment1.isSame(moment2, "day");
  } else {
    return !moment1 && !moment2;
  }
}



function isDayInRange(day, startDate, endDate) {
  var before = startDate.clone().startOf("day").subtract(1, "seconds");
  var after = endDate.clone().startOf("day").add(1, "seconds");
  return day.clone().startOf("day").isBetween(before, after);
}

// *** Diffing ***



// ** Date Localization **

function localizeDate(date, locale) {
  return date.clone().locale(locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale());
}







function getLocaleData(date) {
  return date.localeData();
}

function getLocaleDataForLocale(locale) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.localeData(locale);
}

function getFormattedWeekdayInLocale(locale, date, formatFunc) {
  return formatFunc(locale.weekdays(date));
}

function getWeekdayMinInLocale(locale, date) {
  return locale.weekdaysMin(date);
}

function getWeekdayShortInLocale(locale, date) {
  return locale.weekdaysShort(date);
}

// TODO what is this format exactly?
function getMonthInLocale(locale, date, format) {
  return locale.months(date, format);
}

function getMonthShortInLocale(locale, date) {
  return locale.monthsShort(date);
}

// ** Utils for some components **

function isDayDisabled(day) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      minDate = _ref4.minDate,
      maxDate = _ref4.maxDate,
      excludeDates = _ref4.excludeDates,
      includeDates = _ref4.includeDates,
      filterDate = _ref4.filterDate;

  return minDate && day.isBefore(minDate, "day") || maxDate && day.isAfter(maxDate, "day") || excludeDates && excludeDates.some(function (excludeDate) {
    return isSameDay(day, excludeDate);
  }) || includeDates && !includeDates.some(function (includeDate) {
    return isSameDay(day, includeDate);
  }) || filterDate && !filterDate(day.clone()) || false;
}

function isTimeDisabled(time, disabledTimes) {
  var l = disabledTimes.length;
  for (var i = 0; i < l; i++) {
    if (disabledTimes[i].get("hours") === time.get("hours") && disabledTimes[i].get("minutes") === time.get("minutes")) {
      return true;
    }
  }

  return false;
}

function isTimeInDisabledRange(time, _ref5) {
  var minTime = _ref5.minTime,
      maxTime = _ref5.maxTime;

  if (!minTime || !maxTime) {
    throw new Error("Both minTime and maxTime props required");
  }

  var base = __WEBPACK_IMPORTED_MODULE_4_moment___default()().hours(0).minutes(0).seconds(0);
  var baseTime = base.clone().hours(time.get("hours")).minutes(time.get("minutes"));
  var min = base.clone().hours(minTime.get("hours")).minutes(minTime.get("minutes"));
  var max = base.clone().hours(maxTime.get("hours")).minutes(maxTime.get("minutes"));

  return !(baseTime.isSameOrAfter(min) && baseTime.isSameOrBefore(max));
}

function allDaysDisabledBefore(day, unit) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      minDate = _ref6.minDate,
      includeDates = _ref6.includeDates;

  var dateBefore = day.clone().subtract(1, unit);
  return minDate && dateBefore.isBefore(minDate, unit) || includeDates && includeDates.every(function (includeDate) {
    return dateBefore.isBefore(includeDate, unit);
  }) || false;
}

function allDaysDisabledAfter(day, unit) {
  var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      maxDate = _ref7.maxDate,
      includeDates = _ref7.includeDates;

  var dateAfter = day.clone().add(1, unit);
  return maxDate && dateAfter.isAfter(maxDate, unit) || includeDates && includeDates.every(function (includeDate) {
    return dateAfter.isAfter(includeDate, unit);
  }) || false;
}

function getEffectiveMinDate(_ref8) {
  var minDate = _ref8.minDate,
      includeDates = _ref8.includeDates;

  if (includeDates && minDate) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.min(includeDates.filter(function (includeDate) {
      return minDate.isSameOrBefore(includeDate, "day");
    }));
  } else if (includeDates) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.min(includeDates);
  } else {
    return minDate;
  }
}

function getEffectiveMaxDate(_ref9) {
  var maxDate = _ref9.maxDate,
      includeDates = _ref9.includeDates;

  if (includeDates && maxDate) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.max(includeDates.filter(function (includeDate) {
      return maxDate.isSameOrAfter(includeDate, "day");
    }));
  } else if (includeDates) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.max(includeDates);
  } else {
    return maxDate;
  }
}

function getHightLightDaysMap() {
  var highlightDates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var defaultClassName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "react-datepicker__day--highlighted";

  var dateClasses = new Map();
  for (var i = 0, len = highlightDates.length; i < len; i++) {
    var obj = highlightDates[i];
    if (isMoment(obj)) {
      var key = obj.format("MM.DD.YYYY");
      var classNamesArr = dateClasses.get(key) || [];
      if (!classNamesArr.includes(defaultClassName)) {
        classNamesArr.push(defaultClassName);
        dateClasses.set(key, classNamesArr);
      }
    } else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object") {
      var keys = Object.keys(obj);
      var className = keys[0];
      var arrOfMoments = obj[keys[0]];
      if (typeof className === "string" && arrOfMoments.constructor === Array) {
        for (var k = 0, _len = arrOfMoments.length; k < _len; k++) {
          var _key = arrOfMoments[k].format("MM.DD.YYYY");
          var _classNamesArr = dateClasses.get(_key) || [];
          if (!_classNamesArr.includes(className)) {
            _classNamesArr.push(className);
            dateClasses.set(_key, _classNamesArr);
          }
        }
      }
    }
  }

  return dateClasses;
}

function timesToInjectAfter(startOfDay, currentTime, currentMultiplier, intervals, injectedTimes) {
  var l = injectedTimes.length;
  var times = [];
  for (var i = 0; i < l; i++) {
    var injectedTime = addMinutes(addHours(cloneDate(startOfDay), getHour(injectedTimes[i])), getMinute(injectedTimes[i]));
    var nextTime = addMinutes(cloneDate(startOfDay), (currentMultiplier + 1) * intervals);

    if (injectedTime.isBetween(currentTime, nextTime)) {
      times.push(injectedTimes[i]);
    }
  }

  return times;
}

var WrappedYearDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(YearDropdownOptions);

var YearDropdown = function (_React$Component) {
  inherits(YearDropdown, _React$Component);

  function YearDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, YearDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function () {
      var minYear = _this.props.minDate ? getYear(_this.props.minDate) : 1900;
      var maxYear = _this.props.maxDate ? getYear(_this.props.maxDate) : 2100;

      var options = [];
      for (var i = minYear; i <= maxYear; i++) {
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: i, value: i },
          i
        ));
      }
      return options;
    }, _this.onSelectChange = function (e) {
      _this.onChange(e.target.value);
    }, _this.renderSelectMode = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: _this.props.year,
          className: "react-datepicker__year-select",
          onChange: _this.onSelectChange
        },
        _this.renderSelectOptions()
      );
    }, _this.renderReadView = function (visible) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__year-read-view",
          onClick: function onClick(event) {
            return _this.toggleDropdown(event);
          }
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__year-read-view--selected-year" },
          _this.props.year
        )
      );
    }, _this.renderDropdown = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedYearDropdownOptions, {
        key: "dropdown",
        ref: "options",
        year: _this.props.year,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        scrollableYearDropdown: _this.props.scrollableYearDropdown,
        yearDropdownItemNumber: _this.props.yearDropdownItemNumber
      });
    }, _this.renderScrollMode = function () {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    }, _this.onChange = function (year) {
      _this.toggleDropdown();
      if (year === _this.props.year) return;
      _this.props.onChange(year);
    }, _this.toggleDropdown = function (event) {
      _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      }, function () {
        if (_this.props.adjustDateOnChange) {
          _this.handleYearChange(_this.props.date, event);
        }
      });
    }, _this.handleYearChange = function (date, event) {
      _this.onSelect(date, event);
      _this.setOpen();
    }, _this.onSelect = function (date, event) {
      if (_this.props.onSelect) {
        _this.props.onSelect(date, event);
      }
    }, _this.setOpen = function () {
      if (_this.props.setOpen) {
        _this.props.setOpen(true);
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  YearDropdown.prototype.render = function render() {
    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return YearDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

YearDropdown.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  year: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  setOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var MonthDropdownOptions = function (_React$Component) {
  inherits(MonthDropdownOptions, _React$Component);

  function MonthDropdownOptions() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthDropdownOptions);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.renderOptions = function () {
      return _this.props.monthNames.map(function (month, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: _this.props.month === i ? "react-datepicker__month-option --selected_month" : "react-datepicker__month-option",
            key: month,
            ref: month,
            onClick: _this.onChange.bind(_this, i)
          },
          _this.props.month === i ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__month-option--selected" },
            "\u2713"
          ) : "",
          month
        );
      });
    }, _this.onChange = function (month) {
      return _this.props.onChange(month);
    }, _this.handleClickOutside = function () {
      return _this.props.onCancel();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthDropdownOptions.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "react-datepicker__month-dropdown" },
      this.renderOptions()
    );
  };

  return MonthDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthDropdownOptions.propTypes = {
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  monthNames: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired).isRequired
};

var WrappedMonthDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(MonthDropdownOptions);

var MonthDropdown = function (_React$Component) {
  inherits(MonthDropdown, _React$Component);

  function MonthDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function (monthNames) {
      return monthNames.map(function (M, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: i, value: i },
          M
        );
      });
    }, _this.renderSelectMode = function (monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: _this.props.month,
          className: "react-datepicker__month-select",
          onChange: function onChange(e) {
            return _this.onChange(e.target.value);
          }
        },
        _this.renderSelectOptions(monthNames)
      );
    }, _this.renderReadView = function (visible, monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__month-read-view",
          onClick: _this.toggleDropdown
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__month-read-view--selected-month" },
          monthNames[_this.props.month]
        )
      );
    }, _this.renderDropdown = function (monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedMonthDropdownOptions, {
        key: "dropdown",
        ref: "options",
        month: _this.props.month,
        monthNames: monthNames,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown
      });
    }, _this.renderScrollMode = function (monthNames) {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible, monthNames)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown(monthNames));
      }
      return result;
    }, _this.onChange = function (month) {
      _this.toggleDropdown();
      if (month !== _this.props.month) {
        _this.props.onChange(month);
      }
    }, _this.toggleDropdown = function () {
      return _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthDropdown.prototype.render = function render() {
    var _this2 = this;

    var localeData = getLocaleDataForLocale(this.props.locale);
    var monthNames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function (M) {
      return getMonthShortInLocale(localeData, newDate({ M: M }));
    } : function (M) {
      return getMonthInLocale(localeData, newDate({ M: M }), _this2.props.dateFormat);
    });

    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode(monthNames);
        break;
      case "select":
        renderedDropdown = this.renderSelectMode(monthNames);
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return MonthDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthDropdown.propTypes = {
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool
};

function generateMonthYears(minDate, maxDate) {
  var list = [];

  var currDate = getStartOfMonth(cloneDate(minDate));
  var lastDate = getStartOfMonth(cloneDate(maxDate));

  while (!isAfter(currDate, lastDate)) {
    list.push(cloneDate(currDate));

    addMonths(currDate, 1);
  }

  return list;
}

var MonthYearDropdownOptions = function (_React$Component) {
  inherits(MonthYearDropdownOptions, _React$Component);

  function MonthYearDropdownOptions(props) {
    classCallCheck(this, MonthYearDropdownOptions);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.renderOptions = function () {
      return _this.state.monthYearsList.map(function (monthYear) {
        var monthYearPoint = monthYear.valueOf();

        var isSameMonthYear = isSameYear(_this.props.date, monthYear) && isSameMonth(_this.props.date, monthYear);

        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: isSameMonthYear ? "react-datepicker__month-year-option --selected_month-year" : "react-datepicker__month-year-option",
            key: monthYearPoint,
            ref: monthYearPoint,
            onClick: _this.onChange.bind(_this, monthYearPoint)
          },
          isSameMonthYear ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__month-year-option--selected" },
            "\u2713"
          ) : "",
          formatDate(monthYear, _this.props.dateFormat)
        );
      });
    };

    _this.onChange = function (monthYear) {
      return _this.props.onChange(monthYear);
    };

    _this.handleClickOutside = function () {
      _this.props.onCancel();
    };

    _this.state = {
      monthYearsList: generateMonthYears(_this.props.minDate, _this.props.maxDate)
    };
    return _this;
  }

  MonthYearDropdownOptions.prototype.render = function render() {
    var dropdownClass = __WEBPACK_IMPORTED_MODULE_2_classnames___default()({
      "react-datepicker__month-year-dropdown": true,
      "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
    });

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: dropdownClass },
      this.renderOptions()
    );
  };

  return MonthYearDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthYearDropdownOptions.propTypes = {
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired
};

var WrappedMonthYearDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(MonthYearDropdownOptions);

var MonthYearDropdown = function (_React$Component) {
  inherits(MonthYearDropdown, _React$Component);

  function MonthYearDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthYearDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function () {
      var currDate = getStartOfMonth(localizeDate(_this.props.minDate, _this.props.locale));
      var lastDate = getStartOfMonth(localizeDate(_this.props.maxDate, _this.props.locale));

      var options = [];

      while (!isAfter(currDate, lastDate)) {
        var timepoint = currDate.valueOf();
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: timepoint, value: timepoint },
          formatDate(currDate, _this.props.dateFormat)
        ));

        addMonths(currDate, 1);
      }

      return options;
    }, _this.onSelectChange = function (e) {
      _this.onChange(e.target.value);
    }, _this.renderSelectMode = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: getStartOfMonth(_this.props.date).valueOf(),
          className: "react-datepicker__month-year-select",
          onChange: _this.onSelectChange
        },
        _this.renderSelectOptions()
      );
    }, _this.renderReadView = function (visible) {
      var yearMonth = formatDate(localizeDate(newDate(_this.props.date), _this.props.locale), _this.props.dateFormat);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__month-year-read-view",
          onClick: function onClick(event) {
            return _this.toggleDropdown(event);
          }
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__month-year-read-view--selected-month-year" },
          yearMonth
        )
      );
    }, _this.renderDropdown = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedMonthYearDropdownOptions, {
        key: "dropdown",
        ref: "options",
        date: _this.props.date,
        dateFormat: _this.props.dateFormat,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown,
        minDate: localizeDate(_this.props.minDate, _this.props.locale),
        maxDate: localizeDate(_this.props.maxDate, _this.props.locale),
        scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown
      });
    }, _this.renderScrollMode = function () {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    }, _this.onChange = function (monthYearPoint) {
      _this.toggleDropdown();

      var changedDate = newDate(parseInt(monthYearPoint));

      if (isSameYear(_this.props.date, changedDate) && isSameMonth(_this.props.date, changedDate)) {
        return;
      }

      _this.props.onChange(changedDate);
    }, _this.toggleDropdown = function () {
      return _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthYearDropdown.prototype.render = function render() {
    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return MonthYearDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthYearDropdown.propTypes = {
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool
};

var Day = function (_React$Component) {
  inherits(Day, _React$Component);

  function Day() {
    var _temp, _this, _ret;

    classCallCheck(this, Day);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (!_this.isDisabled() && _this.props.onClick) {
        _this.props.onClick(event);
      }
    }, _this.handleMouseEnter = function (event) {
      if (!_this.isDisabled() && _this.props.onMouseEnter) {
        _this.props.onMouseEnter(event);
      }
    }, _this.isSameDay = function (other) {
      return isSameDay(_this.props.day, other);
    }, _this.isKeyboardSelected = function () {
      return !_this.props.inline && !_this.isSameDay(_this.props.selected) && _this.isSameDay(_this.props.preSelection);
    }, _this.isDisabled = function () {
      return isDayDisabled(_this.props.day, _this.props);
    }, _this.getHighLightedClass = function (defaultClassName) {
      var _this$props = _this.props,
          day = _this$props.day,
          highlightDates = _this$props.highlightDates;


      if (!highlightDates) {
        return false;
      }

      // Looking for className in the Map of {'day string, 'className'}
      var dayStr = day.format("MM.DD.YYYY");
      return highlightDates.get(dayStr);
    }, _this.isInRange = function () {
      var _this$props2 = _this.props,
          day = _this$props2.day,
          startDate = _this$props2.startDate,
          endDate = _this$props2.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isDayInRange(day, startDate, endDate);
    }, _this.isInSelectingRange = function () {
      var _this$props3 = _this.props,
          day = _this$props3.day,
          selectsStart = _this$props3.selectsStart,
          selectsEnd = _this$props3.selectsEnd,
          selectingDate = _this$props3.selectingDate,
          startDate = _this$props3.startDate,
          endDate = _this$props3.endDate;


      if (!(selectsStart || selectsEnd) || !selectingDate || _this.isDisabled()) {
        return false;
      }

      if (selectsStart && endDate && selectingDate.isSameOrBefore(endDate)) {
        return isDayInRange(day, selectingDate, endDate);
      }

      if (selectsEnd && startDate && selectingDate.isSameOrAfter(startDate)) {
        return isDayInRange(day, startDate, selectingDate);
      }

      return false;
    }, _this.isSelectingRangeStart = function () {
      if (!_this.isInSelectingRange()) {
        return false;
      }

      var _this$props4 = _this.props,
          day = _this$props4.day,
          selectingDate = _this$props4.selectingDate,
          startDate = _this$props4.startDate,
          selectsStart = _this$props4.selectsStart;


      if (selectsStart) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, startDate);
      }
    }, _this.isSelectingRangeEnd = function () {
      if (!_this.isInSelectingRange()) {
        return false;
      }

      var _this$props5 = _this.props,
          day = _this$props5.day,
          selectingDate = _this$props5.selectingDate,
          endDate = _this$props5.endDate,
          selectsEnd = _this$props5.selectsEnd;


      if (selectsEnd) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, endDate);
      }
    }, _this.isRangeStart = function () {
      var _this$props6 = _this.props,
          day = _this$props6.day,
          startDate = _this$props6.startDate,
          endDate = _this$props6.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(startDate, day);
    }, _this.isRangeEnd = function () {
      var _this$props7 = _this.props,
          day = _this$props7.day,
          startDate = _this$props7.startDate,
          endDate = _this$props7.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(endDate, day);
    }, _this.isWeekend = function () {
      var weekday = getDay(_this.props.day);
      return weekday === 0 || weekday === 6;
    }, _this.isOutsideMonth = function () {
      return _this.props.month !== undefined && _this.props.month !== getMonth(_this.props.day);
    }, _this.getClassNames = function (date) {
      var dayClassName = _this.props.dayClassName ? _this.props.dayClassName(date) : undefined;
      return __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker__day", dayClassName, "react-datepicker__day--" + getDayOfWeekCode(_this.props.day), {
        "react-datepicker__day--disabled": _this.isDisabled(),
        "react-datepicker__day--selected": _this.isSameDay(_this.props.selected),
        "react-datepicker__day--keyboard-selected": _this.isKeyboardSelected(),
        "react-datepicker__day--range-start": _this.isRangeStart(),
        "react-datepicker__day--range-end": _this.isRangeEnd(),
        "react-datepicker__day--in-range": _this.isInRange(),
        "react-datepicker__day--in-selecting-range": _this.isInSelectingRange(),
        "react-datepicker__day--selecting-range-start": _this.isSelectingRangeStart(),
        "react-datepicker__day--selecting-range-end": _this.isSelectingRangeEnd(),
        "react-datepicker__day--today": _this.isSameDay(now(_this.props.utcOffset)),
        "react-datepicker__day--weekend": _this.isWeekend(),
        "react-datepicker__day--outside-month": _this.isOutsideMonth()
      }, _this.getHighLightedClass("react-datepicker__day--highlighted"));
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Day.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: this.getClassNames(this.props.day),
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        "aria-label": "day-" + getDate(this.props.day),
        role: "option"
      },
      getDate(this.props.day)
    );
  };

  return Day;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Day.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var WeekNumber = function (_React$Component) {
  inherits(WeekNumber, _React$Component);

  function WeekNumber() {
    var _temp, _this, _ret;

    classCallCheck(this, WeekNumber);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  WeekNumber.prototype.render = function render() {
    var weekNumberClasses = {
      "react-datepicker__week-number": true,
      "react-datepicker__week-number--clickable": !!this.props.onClick
    };
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: __WEBPACK_IMPORTED_MODULE_2_classnames___default()(weekNumberClasses),
        "aria-label": "week-" + this.props.weekNumber,
        onClick: this.handleClick
      },
      this.props.weekNumber
    );
  };

  return WeekNumber;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

WeekNumber.propTypes = {
  weekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var Week = function (_React$Component) {
  inherits(Week, _React$Component);

  function Week() {
    var _temp, _this, _ret;

    classCallCheck(this, Week);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleDayClick = function (day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    }, _this.handleDayMouseEnter = function (day) {
      if (_this.props.onDayMouseEnter) {
        _this.props.onDayMouseEnter(day);
      }
    }, _this.handleWeekClick = function (day, weekNumber, event) {
      if (typeof _this.props.onWeekSelect === "function") {
        _this.props.onWeekSelect(day, weekNumber, event);
      }
    }, _this.formatWeekNumber = function (startOfWeek) {
      if (_this.props.formatWeekNumber) {
        return _this.props.formatWeekNumber(startOfWeek);
      }
      return getWeek(startOfWeek);
    }, _this.renderDays = function () {
      var startOfWeek = getStartOfWeek(cloneDate(_this.props.day));
      var days = [];
      var weekNumber = _this.formatWeekNumber(startOfWeek);
      if (_this.props.showWeekNumber) {
        var onClickAction = _this.props.onWeekSelect ? _this.handleWeekClick.bind(_this, startOfWeek, weekNumber) : undefined;
        days.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WeekNumber, { key: "W", weekNumber: weekNumber, onClick: onClickAction }));
      }
      return days.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {
        var day = addDays(cloneDate(startOfWeek), offset);
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Day, {
          key: offset,
          day: day,
          month: _this.props.month,
          onClick: _this.handleDayClick.bind(_this, day),
          onMouseEnter: _this.handleDayMouseEnter.bind(_this, day),
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          excludeDates: _this.props.excludeDates,
          includeDates: _this.props.includeDates,
          inline: _this.props.inline,
          highlightDates: _this.props.highlightDates,
          selectingDate: _this.props.selectingDate,
          filterDate: _this.props.filterDate,
          preSelection: _this.props.preSelection,
          selected: _this.props.selected,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          dayClassName: _this.props.dayClassName,
          utcOffset: _this.props.utcOffset
        });
      }));
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Week.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "react-datepicker__week" },
      this.renderDays()
    );
  };

  return Week;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Week.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onDayClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onDayMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6;

var Month = function (_React$Component) {
  inherits(Month, _React$Component);

  function Month() {
    var _temp, _this, _ret;

    classCallCheck(this, Month);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleDayClick = function (day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    }, _this.handleDayMouseEnter = function (day) {
      if (_this.props.onDayMouseEnter) {
        _this.props.onDayMouseEnter(day);
      }
    }, _this.handleMouseLeave = function () {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave();
      }
    }, _this.isWeekInMonth = function (startOfWeek) {
      var day = _this.props.day;
      var endOfWeek = addDays(cloneDate(startOfWeek), 6);
      return isSameMonth(startOfWeek, day) || isSameMonth(endOfWeek, day);
    }, _this.renderWeeks = function () {
      var weeks = [];
      var isFixedHeight = _this.props.fixedHeight;
      var currentWeekStart = getStartOfWeek(getStartOfMonth(cloneDate(_this.props.day)));
      var i = 0;
      var breakAfterNextPush = false;

      while (true) {
        weeks.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Week, {
          key: i,
          day: currentWeekStart,
          month: getMonth(_this.props.day),
          onDayClick: _this.handleDayClick,
          onDayMouseEnter: _this.handleDayMouseEnter,
          onWeekSelect: _this.props.onWeekSelect,
          formatWeekNumber: _this.props.formatWeekNumber,
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          excludeDates: _this.props.excludeDates,
          includeDates: _this.props.includeDates,
          inline: _this.props.inline,
          highlightDates: _this.props.highlightDates,
          selectingDate: _this.props.selectingDate,
          filterDate: _this.props.filterDate,
          preSelection: _this.props.preSelection,
          selected: _this.props.selected,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          showWeekNumber: _this.props.showWeekNumbers,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          dayClassName: _this.props.dayClassName,
          utcOffset: _this.props.utcOffset
        }));

        if (breakAfterNextPush) break;

        i++;
        currentWeekStart = addWeeks(cloneDate(currentWeekStart), 1);

        // If one of these conditions is true, we will either break on this week
        // or break on the next week
        var isFixedAndFinalWeek = isFixedHeight && i >= FIXED_HEIGHT_STANDARD_WEEK_COUNT;
        var isNonFixedAndOutOfMonth = !isFixedHeight && !_this.isWeekInMonth(currentWeekStart);

        if (isFixedAndFinalWeek || isNonFixedAndOutOfMonth) {
          if (_this.props.peekNextMonth) {
            breakAfterNextPush = true;
          } else {
            break;
          }
        }
      }

      return weeks;
    }, _this.getClassNames = function () {
      var _this$props = _this.props,
          selectingDate = _this$props.selectingDate,
          selectsStart = _this$props.selectsStart,
          selectsEnd = _this$props.selectsEnd;

      return __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker__month", {
        "react-datepicker__month--selecting-range": selectingDate && (selectsStart || selectsEnd)
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Month.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: this.getClassNames(),
        onMouseLeave: this.handleMouseLeave,
        role: "listbox"
      },
      this.renderWeeks()
    );
  };

  return Month;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Month.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onDayClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onDayMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMouseLeave: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var Time = function (_React$Component) {
  inherits(Time, _React$Component);

  function Time() {
    var _temp, _this, _ret;

    classCallCheck(this, Time);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (time) {
      if ((_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || _this.props.excludeTimes && isTimeDisabled(time, _this.props.excludeTimes) || _this.props.includeTimes && !isTimeDisabled(time, _this.props.includeTimes)) {
        return;
      }

      _this.props.onChange(time);
    }, _this.liClasses = function (time, currH, currM) {
      var classes = ["react-datepicker__time-list-item"];

      if (currH === getHour(time) && currM === getMinute(time)) {
        classes.push("react-datepicker__time-list-item--selected");
      }
      if ((_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || _this.props.excludeTimes && isTimeDisabled(time, _this.props.excludeTimes) || _this.props.includeTimes && !isTimeDisabled(time, _this.props.includeTimes)) {
        classes.push("react-datepicker__time-list-item--disabled");
      }
      if (_this.props.injectTimes && (getHour(time) * 60 + getMinute(time)) % _this.props.intervals !== 0) {
        classes.push("react-datepicker__time-list-item--injected");
      }

      return classes.join(" ");
    }, _this.renderTimes = function () {
      var times = [];
      var format = _this.props.format ? _this.props.format : "hh:mm A";
      var intervals = _this.props.intervals;
      var activeTime = _this.props.selected ? _this.props.selected : newDate();
      var currH = getHour(activeTime);
      var currM = getMinute(activeTime);
      var base = getStartOfDay(newDate());
      var multiplier = 1440 / intervals;
      var sortedInjectTimes = _this.props.injectTimes && _this.props.injectTimes.sort(function (a, b) {
        return a - b;
      });
      for (var i = 0; i < multiplier; i++) {
        var currentTime = addMinutes(cloneDate(base), i * intervals);
        times.push(currentTime);

        if (sortedInjectTimes) {
          var timesToInject = timesToInjectAfter(base, currentTime, i, intervals, sortedInjectTimes);
          times = times.concat(timesToInject);
        }
      }

      return times.map(function (time, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "li",
          {
            key: i,
            onClick: _this.handleClick.bind(_this, time),
            className: _this.liClasses(time, currH, currM)
          },
          formatDate(time, format)
        );
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Time.prototype.componentDidMount = function componentDidMount() {
    // code to ensure selected time will always be in focus within time window when it first appears
    var multiplier = 60 / this.props.intervals;
    var currH = this.props.selected ? getHour(this.props.selected) : getHour(newDate());
    this.list.scrollTop = 30 * (multiplier * currH);
  };

  Time.prototype.render = function render() {
    var _this2 = this;

    var height = null;
    if (this.props.monthRef) {
      height = this.props.monthRef.clientHeight - 39;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__time-container " + (this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "")
      },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__header react-datepicker__header--time" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker-time__header" },
          this.props.timeCaption
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__time" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__time-box" },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "ul",
            {
              className: "react-datepicker__time-list",
              ref: function ref(list) {
                _this2.list = list;
              },
              style: height ? { height: height } : {}
            },
            this.renderTimes.bind(this)()
          )
        )
      )
    );
  };

  createClass(Time, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        intervals: 30,
        onTimeChange: function onTimeChange() {},
        todayButton: null,
        timeCaption: "Time"
      };
    }
  }]);
  return Time;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Time.propTypes = {
  format: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  intervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  monthRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array
};

function CalendarContainer(_ref) {
  var className = _ref.className,
      children = _ref.children;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: className },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", { className: "react-datepicker__triangle" }),
    children
  );
}

CalendarContainer.propTypes = {
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node
};

var DROPDOWN_FOCUS_CLASSNAMES = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"];

var isDropdownSelect = function isDropdownSelect() {
  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var classNames = (element.className || "").split(/\s+/);
  return DROPDOWN_FOCUS_CLASSNAMES.some(function (testClassname) {
    return classNames.indexOf(testClassname) >= 0;
  });
};

var Calendar = function (_React$Component) {
  inherits(Calendar, _React$Component);
  createClass(Calendar, null, [{
    key: "defaultProps",
    get: function get$$1() {
      var _ref;

      return _ref = {
        onDropdownFocus: function onDropdownFocus() {},
        monthsShown: 1,
        forceShowMonthNavigation: false,
        timeCaption: "Time",
        previousMonthButtonLabel: "Previous Month"
      }, _ref["previousMonthButtonLabel"] = "Next Month", _ref;
    }
  }]);

  function Calendar(props) {
    classCallCheck(this, Calendar);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.handleClickOutside = function (event) {
      _this.props.onClickOutside(event);
    };

    _this.handleDropdownFocus = function (event) {
      if (isDropdownSelect(event.target)) {
        _this.props.onDropdownFocus();
      }
    };

    _this.getDateInView = function () {
      var _this$props = _this.props,
          preSelection = _this$props.preSelection,
          selected = _this$props.selected,
          openToDate = _this$props.openToDate,
          utcOffset = _this$props.utcOffset;

      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var current = now(utcOffset);
      var initialDate = openToDate || selected || preSelection;
      if (initialDate) {
        return initialDate;
      } else {
        if (minDate && isBefore(current, minDate)) {
          return minDate;
        } else if (maxDate && isAfter(current, maxDate)) {
          return maxDate;
        }
      }
      return current;
    };

    _this.localizeDate = function (date) {
      return localizeDate(date, _this.props.locale);
    };

    _this.increaseMonth = function () {
      _this.setState({
        date: addMonths(cloneDate(_this.state.date), 1)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.decreaseMonth = function () {
      _this.setState({
        date: subtractMonths(cloneDate(_this.state.date), 1)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.handleDayClick = function (day, event) {
      return _this.props.onSelect(day, event);
    };

    _this.handleDayMouseEnter = function (day) {
      return _this.setState({ selectingDate: day });
    };

    _this.handleMonthMouseLeave = function () {
      return _this.setState({ selectingDate: null });
    };

    _this.handleYearChange = function (date) {
      if (_this.props.onYearChange) {
        _this.props.onYearChange(date);
      }
    };

    _this.handleMonthChange = function (date) {
      if (_this.props.onMonthChange) {
        _this.props.onMonthChange(date);
      }
      if (_this.props.adjustDateOnChange) {
        if (_this.props.onSelect) {
          _this.props.onSelect(date);
        }
        if (_this.props.setOpen) {
          _this.props.setOpen(true);
        }
      }
    };

    _this.handleMonthYearChange = function (date) {
      _this.handleYearChange(date);
      _this.handleMonthChange(date);
    };

    _this.changeYear = function (year) {
      _this.setState({
        date: setYear(cloneDate(_this.state.date), year)
      }, function () {
        return _this.handleYearChange(_this.state.date);
      });
    };

    _this.changeMonth = function (month) {
      _this.setState({
        date: setMonth(cloneDate(_this.state.date), month)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.changeMonthYear = function (monthYear) {
      _this.setState({
        date: setYear(setMonth(cloneDate(_this.state.date), getMonth(monthYear)), getYear(monthYear))
      }, function () {
        return _this.handleMonthYearChange(_this.state.date);
      });
    };

    _this.header = function () {
      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.date;

      var startOfWeek = getStartOfWeek(cloneDate(date));
      var dayNames = [];
      if (_this.props.showWeekNumbers) {
        dayNames.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { key: "W", className: "react-datepicker__day-name" },
          _this.props.weekLabel || "#"
        ));
      }
      return dayNames.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {
        var day = addDays(cloneDate(startOfWeek), offset);
        var localeData = getLocaleData(day);
        var weekDayName = _this.formatWeekday(localeData, day);

        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { key: offset, className: "react-datepicker__day-name" },
          weekDayName
        );
      }));
    };

    _this.formatWeekday = function (localeData, day) {
      if (_this.props.formatWeekDay) {
        return getFormattedWeekdayInLocale(localeData, day, _this.props.formatWeekDay);
      }
      return _this.props.useWeekdaysShort ? getWeekdayShortInLocale(localeData, day) : getWeekdayMinInLocale(localeData, day);
    };

    _this.renderPreviousMonthButton = function () {
      var allPrevDaysDisabled = allDaysDisabledBefore(_this.state.date, "month", _this.props);

      if (!_this.props.forceShowMonthNavigation && !_this.props.showDisabledMonthNavigation && allPrevDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }

      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--previous"];

      var clickHandler = _this.decreaseMonth;

      if (allPrevDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--previous--disabled");
        clickHandler = null;
      }

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "button",
        {
          type: "button",
          className: classes.join(" "),
          onClick: clickHandler
        },
        _this.props.previousMonthButtonLabel
      );
    };

    _this.renderNextMonthButton = function () {
      var allNextDaysDisabled = allDaysDisabledAfter(_this.state.date, "month", _this.props);

      if (!_this.props.forceShowMonthNavigation && !_this.props.showDisabledMonthNavigation && allNextDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }

      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
      if (_this.props.showTimeSelect) {
        classes.push("react-datepicker__navigation--next--with-time");
      }
      if (_this.props.todayButton) {
        classes.push("react-datepicker__navigation--next--with-today-button");
      }

      var clickHandler = _this.increaseMonth;

      if (allNextDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--next--disabled");
        clickHandler = null;
      }

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "button",
        {
          type: "button",
          className: classes.join(" "),
          onClick: clickHandler
        },
        _this.props.nextMonthButtonLabel
      );
    };

    _this.renderCurrentMonth = function () {
      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.date;

      var classes = ["react-datepicker__current-month"];

      if (_this.props.showYearDropdown) {
        classes.push("react-datepicker__current-month--hasYearDropdown");
      }
      if (_this.props.showMonthDropdown) {
        classes.push("react-datepicker__current-month--hasMonthDropdown");
      }
      if (_this.props.showMonthYearDropdown) {
        classes.push("react-datepicker__current-month--hasMonthYearDropdown");
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: classes.join(" ") },
        formatDate(date, _this.props.dateFormat)
      );
    };

    _this.renderYearDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showYearDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(YearDropdown, {
        adjustDateOnChange: _this.props.adjustDateOnChange,
        date: _this.state.date,
        onSelect: _this.props.onSelect,
        setOpen: _this.props.setOpen,
        dropdownMode: _this.props.dropdownMode,
        onChange: _this.changeYear,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        year: getYear(_this.state.date),
        scrollableYearDropdown: _this.props.scrollableYearDropdown,
        yearDropdownItemNumber: _this.props.yearDropdownItemNumber
      });
    };

    _this.renderMonthDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showMonthDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(MonthDropdown, {
        dropdownMode: _this.props.dropdownMode,
        locale: _this.props.locale,
        dateFormat: _this.props.dateFormat,
        onChange: _this.changeMonth,
        month: getMonth(_this.state.date),
        useShortMonthInDropdown: _this.props.useShortMonthInDropdown
      });
    };

    _this.renderMonthYearDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showMonthYearDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(MonthYearDropdown, {
        dropdownMode: _this.props.dropdownMode,
        locale: _this.props.locale,
        dateFormat: _this.props.dateFormat,
        onChange: _this.changeMonthYear,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        date: _this.state.date,
        scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown
      });
    };

    _this.renderTodayButton = function () {
      if (!_this.props.todayButton || _this.props.showTimeSelectOnly) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          className: "react-datepicker__today-button",
          onClick: function onClick(e) {
            return _this.props.onSelect(getStartOfDate(now(_this.props.utcOffset)), e);
          }
        },
        _this.props.todayButton
      );
    };

    _this.renderMonths = function () {
      if (_this.props.showTimeSelectOnly) {
        return;
      }

      var monthList = [];
      for (var i = 0; i < _this.props.monthsShown; ++i) {
        var monthDate = addMonths(cloneDate(_this.state.date), i);
        var monthKey = "month-" + i;
        monthList.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            key: monthKey,
            ref: function ref(div) {
              _this.monthContainer = div;
            },
            className: "react-datepicker__month-container"
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "div",
            { className: "react-datepicker__header" },
            _this.renderCurrentMonth(monthDate),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
              "div",
              {
                className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--" + _this.props.dropdownMode,
                onFocus: _this.handleDropdownFocus
              },
              _this.renderMonthDropdown(i !== 0),
              _this.renderMonthYearDropdown(i !== 0),
              _this.renderYearDropdown(i !== 0)
            ),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
              "div",
              { className: "react-datepicker__day-names" },
              _this.header(monthDate)
            )
          ),
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Month, {
            day: monthDate,
            dayClassName: _this.props.dayClassName,
            onDayClick: _this.handleDayClick,
            onDayMouseEnter: _this.handleDayMouseEnter,
            onMouseLeave: _this.handleMonthMouseLeave,
            onWeekSelect: _this.props.onWeekSelect,
            formatWeekNumber: _this.props.formatWeekNumber,
            minDate: _this.props.minDate,
            maxDate: _this.props.maxDate,
            excludeDates: _this.props.excludeDates,
            highlightDates: _this.props.highlightDates,
            selectingDate: _this.state.selectingDate,
            includeDates: _this.props.includeDates,
            inline: _this.props.inline,
            fixedHeight: _this.props.fixedHeight,
            filterDate: _this.props.filterDate,
            preSelection: _this.props.preSelection,
            selected: _this.props.selected,
            selectsStart: _this.props.selectsStart,
            selectsEnd: _this.props.selectsEnd,
            showWeekNumbers: _this.props.showWeekNumbers,
            startDate: _this.props.startDate,
            endDate: _this.props.endDate,
            peekNextMonth: _this.props.peekNextMonth,
            utcOffset: _this.props.utcOffset
          })
        ));
      }
      return monthList;
    };

    _this.renderTimeSection = function () {
      if (_this.props.showTimeSelect) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Time, {
          selected: _this.props.selected,
          onChange: _this.props.onTimeChange,
          format: _this.props.timeFormat,
          includeTimes: _this.props.includeTimes,
          intervals: _this.props.timeIntervals,
          minTime: _this.props.minTime,
          maxTime: _this.props.maxTime,
          excludeTimes: _this.props.excludeTimes,
          timeCaption: _this.props.timeCaption,
          todayButton: _this.props.todayButton,
          showMonthDropdown: _this.props.showMonthDropdown,
          showMonthYearDropdown: _this.props.showMonthYearDropdown,
          showYearDropdown: _this.props.showYearDropdown,
          withPortal: _this.props.withPortal,
          monthRef: _this.state.monthContainer,
          injectTimes: _this.props.injectTimes
        });
      }
    };

    _this.state = {
      date: _this.localizeDate(_this.getDateInView()),
      selectingDate: null,
      monthContainer: _this.monthContainer
    };
    return _this;
  }

  Calendar.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    // monthContainer height is needed in time component
    // to determine the height for the ul in the time component
    // setState here so height is given after final component
    // layout is rendered
    if (this.props.showTimeSelect) {
      this.assignMonthContainer = function () {
        _this2.setState({ monthContainer: _this2.monthContainer });
      }();
    }
  };

  Calendar.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.preSelection && !isSameDay(this.props.preSelection, prevProps.preSelection)) {
      this.setState({
        date: this.localizeDate(this.props.preSelection)
      });
    } else if (this.props.openToDate && !isSameDay(this.props.openToDate, prevProps.openToDate)) {
      this.setState({
        date: this.localizeDate(this.props.openToDate)
      });
    }
  };

  Calendar.prototype.render = function render() {
    var Container = this.props.container || CalendarContainer;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      Container,
      {
        className: __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker", this.props.className, {
          "react-datepicker--time-only": this.props.showTimeSelectOnly
        })
      },
      this.renderPreviousMonthButton(),
      this.renderNextMonthButton(),
      this.renderMonths(),
      this.renderTodayButton(),
      this.renderTimeSection(),
      this.props.children
    );
  };

  return Calendar;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Calendar.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  container: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array]).isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]),
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  monthsShown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onClickOutside: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onMonthChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onYearChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  forceShowMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  onDropdownFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  showTimeSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelectOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  timeFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  timeIntervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onTimeChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  openToDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  useWeekdaysShort: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  withPortal: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  weekLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  setOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showDisabledMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  previousMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  nextMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string
};

var popperPlacementPositions = ["auto", "auto-left", "auto-right", "bottom", "bottom-end", "bottom-start", "left", "left-end", "left-start", "right", "right-end", "right-start", "top", "top-end", "top-start"];

var PopperComponent = function (_React$Component) {
  inherits(PopperComponent, _React$Component);

  function PopperComponent() {
    classCallCheck(this, PopperComponent);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  PopperComponent.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        hidePopper = _props.hidePopper,
        popperComponent = _props.popperComponent,
        popperModifiers = _props.popperModifiers,
        popperPlacement = _props.popperPlacement,
        targetComponent = _props.targetComponent;


    var popper = void 0;

    if (!hidePopper) {
      var classes = __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker-popper", className);
      popper = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_5_react_popper__["b" /* Popper */],
        {
          className: classes,
          modifiers: popperModifiers,
          placement: popperPlacement
        },
        popperComponent
      );
    }

    if (this.props.popperContainer) {
      popper = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(this.props.popperContainer, {}, popper);
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      __WEBPACK_IMPORTED_MODULE_5_react_popper__["a" /* Manager */],
      null,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_5_react_popper__["c" /* Target */],
        { className: "react-datepicker-wrapper" },
        targetComponent
      ),
      popper
    );
  };

  createClass(PopperComponent, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        hidePopper: true,
        popperModifiers: {
          preventOverflow: {
            enabled: true,
            escapeWithReference: true,
            boundariesElement: "viewport"
          }
        },
        popperPlacement: "bottom-start"
      };
    }
  }]);
  return PopperComponent;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

PopperComponent.propTypes = {
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  hidePopper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  popperComponent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,
  popperModifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // <datepicker/> props
  popperPlacement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(popperPlacementPositions), // <datepicker/> props
  popperContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  targetComponent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element
};

var outsideClickIgnoreClass = "react-datepicker-ignore-onclickoutside";
var WrappedCalendar = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(Calendar);

// Compares dates year+month combinations
function hasPreSelectionChanged(date1, date2) {
  if (date1 && date2) {
    return getMonth(date1) !== getMonth(date2) || getYear(date1) !== getYear(date2);
  }

  return date1 !== date2;
}

function hasSelectionChanged(date1, date2) {
  if (date1 && date2) {
    return !equals(date1, date2);
  }

  return false;
}

/**
 * General datepicker component.
 */

var DatePicker = function (_React$Component) {
  inherits(DatePicker, _React$Component);
  createClass(DatePicker, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        allowSameDay: false,
        dateFormat: "L",
        dateFormatCalendar: "MMMM YYYY",
        onChange: function onChange() {},

        disabled: false,
        disabledKeyboardNavigation: false,
        dropdownMode: "scroll",
        onFocus: function onFocus() {},
        onBlur: function onBlur() {},
        onKeyDown: function onKeyDown() {},
        onSelect: function onSelect() {},
        onClickOutside: function onClickOutside$$1() {},
        onMonthChange: function onMonthChange() {},

        preventOpenOnFocus: false,
        onYearChange: function onYearChange() {},

        monthsShown: 1,
        readOnly: false,
        withPortal: false,
        shouldCloseOnSelect: true,
        showTimeSelect: false,
        timeIntervals: 30,
        timeCaption: "Time",
        previousMonthButtonLabel: "Previous Month",
        nextMonthButtonLabel: "Next month"
      };
    }
  }]);

  function DatePicker(props) {
    classCallCheck(this, DatePicker);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.getPreSelection = function () {
      return _this.props.openToDate ? newDate(_this.props.openToDate) : _this.props.selectsEnd && _this.props.startDate ? newDate(_this.props.startDate) : _this.props.selectsStart && _this.props.endDate ? newDate(_this.props.endDate) : now(_this.props.utcOffset);
    };

    _this.calcInitialState = function () {
      var defaultPreSelection = _this.getPreSelection();
      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var boundedPreSelection = minDate && isBefore(defaultPreSelection, minDate) ? minDate : maxDate && isAfter(defaultPreSelection, maxDate) ? maxDate : defaultPreSelection;
      return {
        open: _this.props.startOpen || false,
        preventFocus: false,
        preSelection: _this.props.selected ? newDate(_this.props.selected) : boundedPreSelection,
        // transforming highlighted days (perhaps nested array)
        // to flat Map for faster access in day.jsx
        highlightDates: getHightLightDaysMap(_this.props.highlightDates),
        focused: false
      };
    };

    _this.clearPreventFocusTimeout = function () {
      if (_this.preventFocusTimeout) {
        clearTimeout(_this.preventFocusTimeout);
      }
    };

    _this.setFocus = function () {
      if (_this.input && _this.input.focus) {
        _this.input.focus();
      }
    };

    _this.setOpen = function (open) {
      _this.setState({
        open: open,
        preSelection: open && _this.state.open ? _this.state.preSelection : _this.calcInitialState().preSelection,
        lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE
      });
    };

    _this.handleFocus = function (event) {
      if (!_this.state.preventFocus) {
        _this.props.onFocus(event);
        if (!_this.props.preventOpenOnFocus && !_this.props.readOnly) {
          _this.setOpen(true);
        }
      }
      _this.setState({ focused: true });
    };

    _this.cancelFocusInput = function () {
      clearTimeout(_this.inputFocusTimeout);
      _this.inputFocusTimeout = null;
    };

    _this.deferFocusInput = function () {
      _this.cancelFocusInput();
      _this.inputFocusTimeout = setTimeout(function () {
        return _this.setFocus();
      }, 1);
    };

    _this.handleDropdownFocus = function () {
      _this.cancelFocusInput();
    };

    _this.handleBlur = function (event) {
      if (_this.state.open && !_this.props.withPortal) {
        _this.deferFocusInput();
      } else {
        _this.props.onBlur(event);
      }
      _this.setState({ focused: false });
    };

    _this.handleCalendarClickOutside = function (event) {
      if (!_this.props.inline) {
        _this.setOpen(false);
      }
      _this.props.onClickOutside(event);
      if (_this.props.withPortal) {
        event.preventDefault();
      }
    };

    _this.handleChange = function () {
      for (var _len = arguments.length, allArgs = Array(_len), _key = 0; _key < _len; _key++) {
        allArgs[_key] = arguments[_key];
      }

      var event = allArgs[0];
      if (_this.props.onChangeRaw) {
        _this.props.onChangeRaw.apply(_this, allArgs);
        if (typeof event.isDefaultPrevented !== "function" || event.isDefaultPrevented()) {
          return;
        }
      }
      _this.setState({
        inputValue: event.target.value,
        lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT
      });
      var date = parseDate(event.target.value, _this.props);
      if (date || !event.target.value) {
        _this.setSelected(date, event, true);
      }
    };

    _this.handleSelect = function (date, event) {
      // Preventing onFocus event to fix issue
      // https://github.com/Hacker0x01/react-datepicker/issues/628
      _this.setState({ preventFocus: true }, function () {
        _this.preventFocusTimeout = setTimeout(function () {
          return _this.setState({ preventFocus: false });
        }, 50);
        return _this.preventFocusTimeout;
      });
      _this.setSelected(date, event);
      if (!_this.props.shouldCloseOnSelect || _this.props.showTimeSelect) {
        _this.setPreSelection(date);
      } else if (!_this.props.inline) {
        _this.setOpen(false);
      }
    };

    _this.setSelected = function (date, event, keepInput) {
      var changedDate = date;

      if (changedDate !== null && isDayDisabled(changedDate, _this.props)) {
        return;
      }

      if (!isSameDay(_this.props.selected, changedDate) || _this.props.allowSameDay) {
        if (changedDate !== null) {
          if (_this.props.selected) {
            var selected = _this.props.selected;
            if (keepInput) selected = newDate(changedDate);
            changedDate = setTime(newDate(changedDate), {
              hour: getHour(selected),
              minute: getMinute(selected),
              second: getSecond(selected)
            });
          }
          if (!_this.props.inline) {
            _this.setState({
              preSelection: changedDate
            });
          }
        }
        _this.props.onChange(changedDate, event);
      }

      _this.props.onSelect(changedDate, event);

      if (!keepInput) {
        _this.setState({ inputValue: null });
      }
    };

    _this.setPreSelection = function (date) {
      var isDateRangePresent = typeof _this.props.minDate !== "undefined" && typeof _this.props.maxDate !== "undefined";
      var isValidDateSelection = isDateRangePresent && date ? isDayInRange(date, _this.props.minDate, _this.props.maxDate) : true;
      if (isValidDateSelection) {
        _this.setState({
          preSelection: date
        });
      }
    };

    _this.handleTimeChange = function (time) {
      var selected = _this.props.selected ? _this.props.selected : _this.getPreSelection();
      var changedDate = setTime(cloneDate(selected), {
        hour: getHour(time),
        minute: getMinute(time)
      });

      _this.setState({
        preSelection: changedDate
      });

      _this.props.onChange(changedDate);
      _this.setOpen(false);
      _this.setState({ inputValue: null });
    };

    _this.onInputClick = function () {
      if (!_this.props.disabled && !_this.props.readOnly) {
        _this.setOpen(true);
      }
    };

    _this.onInputKeyDown = function (event) {
      _this.props.onKeyDown(event);
      var eventKey = event.key;
      if (!_this.state.open && !_this.props.inline && !_this.props.preventOpenOnFocus) {
        if (eventKey === "ArrowDown" || eventKey === "ArrowUp") {
          _this.onInputClick();
        }
        return;
      }
      var copy = newDate(_this.state.preSelection);
      if (eventKey === "Enter") {
        event.preventDefault();
        if ((isMoment(_this.state.preSelection) || isDate(_this.state.preSelection)) && _this.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE) {
          _this.handleSelect(copy, event);
          !_this.props.shouldCloseOnSelect && _this.setPreSelection(copy);
        } else {
          _this.setOpen(false);
        }
      } else if (eventKey === "Escape") {
        event.preventDefault();
        _this.setOpen(false);
      } else if (eventKey === "Tab") {
        _this.setOpen(false);
      } else if (!_this.props.disabledKeyboardNavigation) {
        var newSelection = void 0;
        switch (eventKey) {
          case "ArrowLeft":
            newSelection = subtractDays(copy, 1);
            break;
          case "ArrowRight":
            newSelection = addDays(copy, 1);
            break;
          case "ArrowUp":
            newSelection = subtractWeeks(copy, 1);
            break;
          case "ArrowDown":
            newSelection = addWeeks(copy, 1);
            break;
          case "PageUp":
            newSelection = subtractMonths(copy, 1);
            break;
          case "PageDown":
            newSelection = addMonths(copy, 1);
            break;
          case "Home":
            newSelection = subtractYears(copy, 1);
            break;
          case "End":
            newSelection = addYears(copy, 1);
            break;
        }
        if (!newSelection) return; // Let the input component handle this keydown
        event.preventDefault();
        _this.setState({ lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE });
        if (_this.props.adjustDateOnChange) {
          _this.setSelected(newSelection);
        }
        _this.setPreSelection(newSelection);
      }
    };

    _this.onClearClick = function (event) {
      if (event) {
        if (event.preventDefault) {
          event.preventDefault();
        }
      }
      _this.props.onChange(null, event);
      _this.setState({ inputValue: null });
    };

    _this.clear = function () {
      _this.onClearClick();
    };

    _this.renderCalendar = function () {
      if (!_this.props.inline && (!_this.state.open || _this.props.disabled || _this.props.readOnly)) {
        return null;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        WrappedCalendar,
        {
          ref: function ref(elem) {
            _this.calendar = elem;
          },
          locale: _this.props.locale,
          adjustDateOnChange: _this.props.adjustDateOnChange,
          setOpen: _this.setOpen,
          dateFormat: _this.props.dateFormatCalendar,
          useWeekdaysShort: _this.props.useWeekdaysShort,
          formatWeekDay: _this.props.formatWeekDay,
          dropdownMode: _this.props.dropdownMode,
          selected: _this.props.selected,
          preSelection: _this.state.preSelection,
          onSelect: _this.handleSelect,
          onWeekSelect: _this.props.onWeekSelect,
          openToDate: _this.props.openToDate,
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          excludeDates: _this.props.excludeDates,
          filterDate: _this.props.filterDate,
          onClickOutside: _this.handleCalendarClickOutside,
          formatWeekNumber: _this.props.formatWeekNumber,
          highlightDates: _this.state.highlightDates,
          includeDates: _this.props.includeDates,
          includeTimes: _this.props.includeTimes,
          injectTimes: _this.props.injectTimes,
          inline: _this.props.inline,
          peekNextMonth: _this.props.peekNextMonth,
          showMonthDropdown: _this.props.showMonthDropdown,
          useShortMonthInDropdown: _this.props.useShortMonthInDropdown,
          showMonthYearDropdown: _this.props.showMonthYearDropdown,
          showWeekNumbers: _this.props.showWeekNumbers,
          showYearDropdown: _this.props.showYearDropdown,
          withPortal: _this.props.withPortal,
          forceShowMonthNavigation: _this.props.forceShowMonthNavigation,
          showDisabledMonthNavigation: _this.props.showDisabledMonthNavigation,
          scrollableYearDropdown: _this.props.scrollableYearDropdown,
          scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown,
          todayButton: _this.props.todayButton,
          weekLabel: _this.props.weekLabel,
          utcOffset: _this.props.utcOffset,
          outsideClickIgnoreClass: outsideClickIgnoreClass,
          fixedHeight: _this.props.fixedHeight,
          monthsShown: _this.props.monthsShown,
          onDropdownFocus: _this.handleDropdownFocus,
          onMonthChange: _this.props.onMonthChange,
          onYearChange: _this.props.onYearChange,
          dayClassName: _this.props.dayClassName,
          showTimeSelect: _this.props.showTimeSelect,
          showTimeSelectOnly: _this.props.showTimeSelectOnly,
          onTimeChange: _this.handleTimeChange,
          timeFormat: _this.props.timeFormat,
          timeIntervals: _this.props.timeIntervals,
          minTime: _this.props.minTime,
          maxTime: _this.props.maxTime,
          excludeTimes: _this.props.excludeTimes,
          timeCaption: _this.props.timeCaption,
          className: _this.props.calendarClassName,
          container: _this.props.calendarContainer,
          yearDropdownItemNumber: _this.props.yearDropdownItemNumber,
          previousMonthButtonLabel: _this.props.previousMonthButtonLabel,
          nextMonthButtonLabel: _this.props.nextMonthButtonLabel
        },
        _this.props.children
      );
    };

    _this.renderDateInput = function () {
      var _classnames, _React$cloneElement;

      var className = __WEBPACK_IMPORTED_MODULE_2_classnames___default()(_this.props.className, (_classnames = {}, _classnames[outsideClickIgnoreClass] = _this.state.open, _classnames));

      var customInput = _this.props.customInput || __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("input", { type: "text" });
      var customInputRef = _this.props.customInputRef || "ref";
      var inputValue = typeof _this.props.value === "string" ? _this.props.value : typeof _this.state.inputValue === "string" ? _this.state.inputValue : safeDateFormat(_this.props.selected, _this.props);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(customInput, (_React$cloneElement = {}, _React$cloneElement[customInputRef] = function (input) {
        _this.input = input;
      }, _React$cloneElement.value = inputValue, _React$cloneElement.onBlur = _this.handleBlur, _React$cloneElement.onChange = _this.handleChange, _React$cloneElement.onClick = _this.onInputClick, _React$cloneElement.onFocus = _this.handleFocus, _React$cloneElement.onKeyDown = _this.onInputKeyDown, _React$cloneElement.id = _this.props.id, _React$cloneElement.name = _this.props.name, _React$cloneElement.autoFocus = _this.props.autoFocus, _React$cloneElement.placeholder = _this.props.placeholderText, _React$cloneElement.disabled = _this.props.disabled, _React$cloneElement.autoComplete = _this.props.autoComplete, _React$cloneElement.className = className, _React$cloneElement.title = _this.props.title, _React$cloneElement.readOnly = _this.props.readOnly, _React$cloneElement.required = _this.props.required, _React$cloneElement.tabIndex = _this.props.tabIndex, _React$cloneElement));
    };

    _this.renderClearButton = function () {
      if (_this.props.isClearable && _this.props.selected != null) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("button", {
          type: "button",
          className: "react-datepicker__close-icon",
          onClick: _this.onClearClick,
          title: _this.props.clearButtonTitle,
          tabIndex: -1
        });
      } else {
        return null;
      }
    };

    _this.state = _this.calcInitialState();
    return _this;
  }

  DatePicker.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.inline && hasPreSelectionChanged(prevProps.selected, this.props.selected)) {
      this.setPreSelection(this.props.selected);
    }
    if (prevProps.highlightDates !== this.props.highlightDates) {
      this.setState({
        highlightDates: getHightLightDaysMap(this.props.highlightDates)
      });
    }
    if (!prevState.focused && hasSelectionChanged(prevProps.selected, this.props.selected)) {
      this.setState({ inputValue: null });
    }
  };

  DatePicker.prototype.componentWillUnmount = function componentWillUnmount() {
    this.clearPreventFocusTimeout();
  };

  DatePicker.prototype.render = function render() {
    var calendar = this.renderCalendar();

    if (this.props.inline && !this.props.withPortal) {
      return calendar;
    }

    if (this.props.withPortal) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        null,
        !this.props.inline ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__input-container" },
          this.renderDateInput(),
          this.renderClearButton()
        ) : null,
        this.state.open || this.props.inline ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__portal" },
          calendar
        ) : null
      );
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(PopperComponent, {
      className: this.props.popperClassName,
      hidePopper: !this.state.open || this.props.disabled || this.props.readOnly,
      popperModifiers: this.props.popperModifiers,
      targetComponent: __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__input-container" },
        this.renderDateInput(),
        this.renderClearButton()
      ),
      popperContainer: this.props.popperContainer,
      popperComponent: calendar,
      popperPlacement: this.props.popperPlacement
    });
  };

  return DatePicker;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

DatePicker.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  allowSameDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  autoComplete: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  autoFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  calendarClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  calendarContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  customInput: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,
  customInputRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  // eslint-disable-next-line react/no-unused-prop-types
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array]),
  dateFormatCalendar: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  disabled: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  disabledKeyboardNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  isClearable: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  monthsShown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  name: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  onBlur: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onClickOutside: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onChangeRaw: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onKeyDown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMonthChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onYearChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  openToDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  placeholderText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  popperContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  popperClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, // <PopperComponent/> props
  popperModifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // <PopperComponent/> props
  popperPlacement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(popperPlacementPositions), // <PopperComponent/> props
  preventOpenOnFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  readOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  required: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  forceShowMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showDisabledMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  startOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  tabIndex: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  title: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  useWeekdaysShort: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  value: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  weekLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  withPortal: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  shouldCloseOnSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelectOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  timeFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  timeIntervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  clearButtonTitle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  previousMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  nextMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string
};
var PRESELECT_CHANGE_VIA_INPUT = "input";
var PRESELECT_CHANGE_VIA_NAVIGATE = "navigate";


/* harmony default export */ __webpack_exports__["default"] = (DatePicker);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(41);

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IGNORE_CLASS_NAME */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);



function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Check whether some DOM node is our Component's node.
 */
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  } // SVG <use/> elements do not technically reside in the rendered DOM, so
  // they do not have classList directly, but they offer a link to their
  // corresponding element, which can have classList. This extra check is for
  // that case.
  // See: http://www.w3.org/TR/SVG11/struct.html#InterfaceSVGUseElement
  // Discussion: https://github.com/Pomax/react-onclickoutside/pull/17


  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }

  return current.classList.contains(ignoreClass);
}
/**
 * Try to find our node in a hierarchy of nodes, returning the document
 * node as highest node if our node is not found in the path up.
 */

function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  } // If source=local then this event came from 'somewhere'
  // inside and should be ignored. We could handle this with
  // a layered approach, too, but that requires going back to
  // thinking in terms of Dom node nesting, running counter
  // to React's 'you shouldn't care about the DOM' philosophy.


  while (current.parentNode) {
    if (isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }

    current = current.parentNode;
  }

  return current;
}
/**
 * Check if the browser scrollbar was clicked
 */

function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}

// ideally will get replaced with external dep
// when rafrex/detect-passive-events#4 and rafrex/detect-passive-events#5 get merged in
var testPassiveEventSupport = function testPassiveEventSupport() {
  if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
    return;
  }

  var passive = false;
  var options = Object.defineProperty({}, 'passive', {
    get: function get() {
      passive = true;
    }
  });

  var noop = function noop() {};

  window.addEventListener('testPassiveEventSupport', noop, options);
  window.removeEventListener('testPassiveEventSupport', noop, options);
  return passive;
};

function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }

  return function () {
    return ++seed;
  };
}

var uid = autoInc();

var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ['touchstart', 'touchmove'];
var IGNORE_CLASS_NAME = 'ignore-react-onclickoutside';
/**
 * Options for addEventHandler and removeEventHandler
 */

function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = null;
  var isTouchEvent = touchEvents.indexOf(eventName) !== -1;

  if (isTouchEvent && passiveEventSupport) {
    handlerOptions = {
      passive: !instance.props.preventDefault
    };
  }

  return handlerOptions;
}
/**
 * This function generates the HOC function that you'll use
 * in order to impart onOutsideClick listening to an
 * arbitrary component. It gets called at the end of the
 * bootstrapping code to yield an instance of the
 * onClickOutsideHOC function defined inside setupHOC().
 */


function onClickOutsideHOC(WrappedComponent, config) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(onClickOutside, _Component);

    function onClickOutside(props) {
      var _this;

      _this = _Component.call(this, props) || this;

      _this.__outsideClickHandler = function (event) {
        if (typeof _this.__clickOutsideHandlerProp === 'function') {
          _this.__clickOutsideHandlerProp(event);

          return;
        }

        var instance = _this.getInstance();

        if (typeof instance.props.handleClickOutside === 'function') {
          instance.props.handleClickOutside(event);
          return;
        }

        if (typeof instance.handleClickOutside === 'function') {
          instance.handleClickOutside(event);
          return;
        }

        throw new Error('WrappedComponent lacks a handleClickOutside(event) function for processing outside click events.');
      };

      _this.enableOnClickOutside = function () {
        if (typeof document === 'undefined' || enabledInstances[_this._uid]) {
          return;
        }

        if (typeof passiveEventSupport === 'undefined') {
          passiveEventSupport = testPassiveEventSupport();
        }

        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;

        if (!events.forEach) {
          events = [events];
        }

        handlersMap[_this._uid] = function (event) {
          if (_this.props.disableOnClickOutside) return;
          if (_this.componentNode === null) return;

          if (_this.props.preventDefault) {
            event.preventDefault();
          }

          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }

          if (_this.props.excludeScrollbar && clickedScrollbar(event)) return;
          var current = event.target;

          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }

          _this.__outsideClickHandler(event);
        };

        events.forEach(function (eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_this, eventName));
        });
      };

      _this.disableOnClickOutside = function () {
        delete enabledInstances[_this._uid];
        var fn = handlersMap[_this._uid];

        if (fn && typeof document !== 'undefined') {
          var events = _this.props.eventTypes;

          if (!events.forEach) {
            events = [events];
          }

          events.forEach(function (eventName) {
            return document.removeEventListener(eventName, fn, getEventHandlerOptions(_this, eventName));
          });
          delete handlersMap[_this._uid];
        }
      };

      _this.getRef = function (ref) {
        return _this.instanceRef = ref;
      };

      _this._uid = uid();
      return _this;
    }
    /**
     * Access the WrappedComponent's instance.
     */


    var _proto = onClickOutside.prototype;

    _proto.getInstance = function getInstance() {
      if (!WrappedComponent.prototype.isReactComponent) {
        return this;
      }

      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };

    /**
     * Add click listeners to the current document,
     * linked to this component's state.
     */
    _proto.componentDidMount = function componentDidMount() {
      // If we are in an environment without a DOM such
      // as shallow rendering or snapshots then we exit
      // early to prevent any unhandled errors being thrown.
      if (typeof document === 'undefined' || !document.createElement) {
        return;
      }

      var instance = this.getInstance();

      if (config && typeof config.handleClickOutside === 'function') {
        this.__clickOutsideHandlerProp = config.handleClickOutside(instance);

        if (typeof this.__clickOutsideHandlerProp !== 'function') {
          throw new Error('WrappedComponent lacks a function for processing outside click events specified by the handleClickOutside config option.');
        }
      }

      this.componentNode = Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__["findDOMNode"])(this.getInstance());
      this.enableOnClickOutside();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__["findDOMNode"])(this.getInstance());
    };
    /**
     * Remove all document's event listeners for this component
     */


    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    /**
     * Can be called to explicitly enable event listening
     * for clicks and touches outside of this element.
     */


    /**
     * Pass-through render
     */
    _proto.render = function render() {
      // eslint-disable-next-line no-unused-vars
      var _props = this.props,
          excludeScrollbar = _props.excludeScrollbar,
          props = _objectWithoutProperties(_props, ["excludeScrollbar"]);

      if (WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }

      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(WrappedComponent, props);
    };

    return onClickOutside;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]), _class.displayName = "OnClickOutside(" + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ")", _class.defaultProps = {
    eventTypes: ['mousedown', 'touchstart'],
    excludeScrollbar: config && config.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function () {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}


/* harmony default export */ __webpack_exports__["a"] = (onClickOutsideHOC);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Manager__ = __webpack_require__(45);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__Manager__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Target__ = __webpack_require__(46);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__Target__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Popper__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_2__Popper__["a"]; });
/* unused harmony reexport placements */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Arrow__ = __webpack_require__(50);
/* unused harmony reexport Arrow */





/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Manager = function (_Component) {
  _inherits(Manager, _Component);

  function Manager() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Manager);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Manager.__proto__ || Object.getPrototypeOf(Manager)).call.apply(_ref, [this].concat(args))), _this), _this._setTargetNode = function (node) {
      _this._targetNode = node;
    }, _this._getTargetNode = function () {
      return _this._targetNode;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Manager, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        popperManager: {
          setTargetNode: this._setTargetNode,
          getTargetNode: this._getTargetNode
        }
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          tag = _props.tag,
          children = _props.children,
          restProps = _objectWithoutProperties(_props, ['tag', 'children']);

      if (tag !== false) {
        return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(tag, restProps, children);
      } else {
        return children;
      }
    }
  }]);

  return Manager;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

Manager.childContextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};
Manager.propTypes = {
  tag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Manager.defaultProps = {
  tag: 'div'
};


/* harmony default export */ __webpack_exports__["a"] = (Manager);

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }




var Target = function Target(props, context) {
  var _props$component = props.component,
      component = _props$component === undefined ? 'div' : _props$component,
      innerRef = props.innerRef,
      children = props.children,
      restProps = _objectWithoutProperties(props, ['component', 'innerRef', 'children']);

  var popperManager = context.popperManager;

  var targetRef = function targetRef(node) {
    popperManager.setTargetNode(node);
    if (typeof innerRef === 'function') {
      innerRef(node);
    }
  };

  if (typeof children === 'function') {
    var targetProps = { ref: targetRef };
    return children({ targetProps: targetProps, restProps: restProps });
  }

  var componentProps = _extends({}, restProps);

  if (typeof component === 'string') {
    componentProps.ref = targetRef;
  } else {
    componentProps.innerRef = targetRef;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
};

Target.contextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};

Target.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};

/* harmony default export */ __webpack_exports__["a"] = (Target);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export placements */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_popper_js__ = __webpack_require__(48);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var placements = __WEBPACK_IMPORTED_MODULE_2_popper_js__["a" /* default */].placements;

var Popper = function (_Component) {
  _inherits(Popper, _Component);

  function Popper() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Popper);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popper.__proto__ || Object.getPrototypeOf(Popper)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this._setArrowNode = function (node) {
      _this._arrowNode = node;
    }, _this._getTargetNode = function () {
      if (_this.props.target) {
        return _this.props.target;
      } else if (!_this.context.popperManager || !_this.context.popperManager.getTargetNode()) {
        throw new Error('Target missing. Popper must be given a target from the Popper Manager, or as a prop.');
      }
      return _this.context.popperManager.getTargetNode();
    }, _this._getOffsets = function (data) {
      return Object.keys(data.offsets).map(function (key) {
        return data.offsets[key];
      });
    }, _this._isDataDirty = function (data) {
      if (_this.state.data) {
        return JSON.stringify(_this._getOffsets(_this.state.data)) !== JSON.stringify(_this._getOffsets(data));
      } else {
        return true;
      }
    }, _this._updateStateModifier = {
      enabled: true,
      order: 900,
      fn: function fn(data) {
        if (_this._isDataDirty(data)) {
          _this.setState({ data: data });
        }
        return data;
      }
    }, _this._getPopperStyle = function () {
      var data = _this.state.data;


      if (!_this._popper || !data) {
        return {
          position: 'absolute',
          pointerEvents: 'none',
          opacity: 0
        };
      }

      return _extends({
        position: data.offsets.popper.position
      }, data.styles);
    }, _this._getPopperPlacement = function () {
      return _this.state.data ? _this.state.data.placement : undefined;
    }, _this._getPopperHide = function () {
      return !!_this.state.data && _this.state.data.hide ? '' : undefined;
    }, _this._getArrowStyle = function () {
      if (!_this.state.data || !_this.state.data.offsets.arrow) {
        return {};
      } else {
        var _this$state$data$offs = _this.state.data.offsets.arrow,
            top = _this$state$data$offs.top,
            left = _this$state$data$offs.left;

        return { top: top, left: left };
      }
    }, _this._handlePopperRef = function (node) {
      _this._popperNode = node;
      if (node) {
        _this._createPopper();
      } else {
        _this._destroyPopper();
      }
      if (_this.props.innerRef) {
        _this.props.innerRef(node);
      }
    }, _this._scheduleUpdate = function () {
      _this._popper && _this._popper.scheduleUpdate();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Popper, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        popper: {
          setArrowNode: this._setArrowNode,
          getArrowStyle: this._getArrowStyle
        }
      };
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(lastProps) {
      if (lastProps.placement !== this.props.placement || lastProps.eventsEnabled !== this.props.eventsEnabled || lastProps.target !== this.props.target) {
        this._destroyPopper();
        this._createPopper();
      }
      if (lastProps.children !== this.props.children) {
        this._scheduleUpdate();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._destroyPopper();
    }
  }, {
    key: '_createPopper',
    value: function _createPopper() {
      var _this2 = this;

      var _props = this.props,
          placement = _props.placement,
          eventsEnabled = _props.eventsEnabled;

      var modifiers = _extends({}, this.props.modifiers, {
        applyStyle: { enabled: false },
        updateState: this._updateStateModifier
      });
      if (this._arrowNode) {
        modifiers.arrow = _extends({}, this.props.modifiers.arrow || {}, {
          element: this._arrowNode
        });
      }
      this._popper = new __WEBPACK_IMPORTED_MODULE_2_popper_js__["a" /* default */](this._getTargetNode(), this._popperNode, {
        placement: placement,
        eventsEnabled: eventsEnabled,
        modifiers: modifiers
      });

      // TODO: look into setTimeout scheduleUpdate call, without it, the popper will not position properly on creation
      setTimeout(function () {
        return _this2._scheduleUpdate();
      });
    }
  }, {
    key: '_destroyPopper',
    value: function _destroyPopper() {
      if (this._popper) {
        this._popper.destroy();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          component = _props2.component,
          innerRef = _props2.innerRef,
          placement = _props2.placement,
          eventsEnabled = _props2.eventsEnabled,
          modifiers = _props2.modifiers,
          children = _props2.children,
          restProps = _objectWithoutProperties(_props2, ['component', 'innerRef', 'placement', 'eventsEnabled', 'modifiers', 'children']);

      var popperStyle = this._getPopperStyle();
      var popperPlacement = this._getPopperPlacement();
      var popperHide = this._getPopperHide();

      if (typeof children === 'function') {
        var popperProps = {
          ref: this._handlePopperRef,
          style: popperStyle,
          'data-placement': popperPlacement,
          'data-x-out-of-boundaries': popperHide
        };
        return children({
          popperProps: popperProps,
          restProps: restProps,
          scheduleUpdate: this._scheduleUpdate
        });
      }

      var componentProps = _extends({}, restProps, {
        style: _extends({}, restProps.style, popperStyle),
        'data-placement': popperPlacement,
        'data-x-out-of-boundaries': popperHide
      });

      if (typeof component === 'string') {
        componentProps.ref = this._handlePopperRef;
      } else {
        componentProps.innerRef = this._handlePopperRef;
      }

      return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
    }
  }]);

  return Popper;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

Popper.contextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};
Popper.childContextTypes = {
  popper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};
Popper.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  placement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(placements),
  eventsEnabled: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  modifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([
  // the following check is needed for SSR
  __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(typeof Element !== 'undefined' ? Element : Object), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    getBoundingClientRect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
    clientWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
    clientHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired
  })])
};
Popper.defaultProps = {
  component: 'div',
  placement: 'bottom',
  eventsEnabled: true,
  modifiers: {}
};


/* harmony default export */ __webpack_exports__["a"] = (Popper);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.6
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;


  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthOddness = reference.width % 2 === popper.width % 2;
  var bothOddWidth = reference.width % 2 === 1 && popper.width % 2 === 1;
  var noRound = function noRound(v) {
    return v;
  };

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthOddness ? Math.round : Math.floor;
  var verticalToInteger = !shouldRound ? noRound : Math.round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["a"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(49)))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }




var Arrow = function Arrow(props, context) {
  var _props$component = props.component,
      component = _props$component === undefined ? 'span' : _props$component,
      innerRef = props.innerRef,
      children = props.children,
      restProps = _objectWithoutProperties(props, ['component', 'innerRef', 'children']);

  var popper = context.popper;

  var arrowRef = function arrowRef(node) {
    popper.setArrowNode(node);
    if (typeof innerRef === 'function') {
      innerRef(node);
    }
  };
  var arrowStyle = popper.getArrowStyle();

  if (typeof children === 'function') {
    var arrowProps = {
      ref: arrowRef,
      style: arrowStyle
    };
    return children({ arrowProps: arrowProps, restProps: restProps });
  }

  var componentProps = _extends({}, restProps, {
    style: _extends({}, arrowStyle, restProps.style)
  });

  if (typeof component === 'string') {
    componentProps.ref = arrowRef;
  } else {
    componentProps.innerRef = arrowRef;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
};

Arrow.contextTypes = {
  popper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};

Arrow.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};

/* unused harmony default export */ var _unused_webpack_default_export = (Arrow);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _collectioneditor = __webpack_require__(14);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventsEditor = function (_React$Component) {
    _inherits(EventsEditor, _React$Component);

    function EventsEditor(props) {
        _classCallCheck(this, EventsEditor);

        var _this = _possibleConstructorReturn(this, (EventsEditor.__proto__ || Object.getPrototypeOf(EventsEditor)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(EventsEditor, [{
        key: 'render',
        value: function render() {
            var me = this;
            var data = this.props.data;
            var events = this.props.events;
            var actionOptions = [];
            if (Array.isArray(this.props.actions)) {
                this.props.actions.forEach(function (a) {
                    actionOptions.push({ text: a, value: a });
                });
            }
            var targetOptions = [].concat(_toConsumableArray(this.props.targets));

            var res = [];
            events.forEach(function (e) {
                var key = e + "_events";
                var event = data != undefined ? data[e] : undefined;
                if (event == undefined) {
                    event = {};
                }

                if (event.actions == undefined) event.actions = [];
                if (event.targets == undefined) event.targets = [];
                if (event.parameters == undefined) event.parameters = [];

                if (Array.isArray(event.actions)) {
                    event.actions.forEach(function (a) {
                        var isFind = false;
                        for (var i = 0; i < actionOptions.length; i++) {
                            if (a == actionOptions[i].value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            actionOptions.push({ text: a, value: a });
                        }
                    });
                }

                if (Array.isArray(event.targets)) {
                    event.targets.forEach(function (a) {
                        var isFind = false;
                        for (var i = 0; i < targetOptions.length; i++) {
                            if (a == targetOptions[i].value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            targetOptions.push({ text: a, value: a });
                        }
                    });
                }

                res.push(_react2.default.createElement(
                    'div',
                    { key: key },
                    _react2.default.createElement(_semanticUiReact.Form.Checkbox, { width: 3, key: 'active', label: e, name: 'active', checked: event.active, onChange: me.handleChange.bind(me, e) }),
                    _react2.default.createElement(
                        'div',
                        { key: 'divGroup', style: event.active ? {} : { display: 'none' } },
                        _react2.default.createElement(
                            _semanticUiReact.Form.Group,
                            { key: 'Group' },
                            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { key: 'actions', label: 'Actions', multiple: true, search: true, selection: true, allowAdditions: true,
                                name: 'actions', options: actionOptions, value: event.actions,
                                onAddItem: me.actionsOnAddItem.bind(me), onChange: me.handleChange.bind(me, e) }),
                            _react2.default.createElement(_collectioneditor2.default, { key: 'parameters',
                                columns: ['name', 'value'],
                                label: 'Parameters',
                                name: 'parameters',
                                value: event.parameters,
                                onChange: me.handleChange.bind(me, e) }),
                            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { key: 'targets', label: 'Targets', multiple: true, search: true, selection: true,
                                name: 'targets', options: targetOptions, value: event.targets,
                                onChange: me.handleChange.bind(me, e) })
                        )
                    )
                ));
            });

            return _react2.default.createElement(
                'div',
                null,
                res
            );
        }
    }, {
        key: 'handleChange',
        value: function handleChange(eventName, e, _ref) {
            var name = _ref.name,
                value = _ref.value,
                checked = _ref.checked;

            var event = this.props.data[eventName];
            if (event == undefined) {
                event = {};
                this.props.data[eventName] = event;
            }

            if (value == undefined && checked != undefined) {
                event[name] = checked;
            } else {
                event[name] = value;

                if (value != undefined && value != "") {
                    event.active = true;
                }
            }
            if (this.props.onChange != undefined) this.props.onChange(e, { name: this.props.name, value: this.props.data });
        }
    }, {
        key: 'actionsOnAddItem',
        value: function actionsOnAddItem(e, _ref2) {
            var value = _ref2.value;

            if (this.props.onAdditionActions != undefined) this.props.onAdditionActions(e, { value: value });
        }
    }]);

    return EventsEditor;
}(_react2.default.Component);

exports.default = EventsEditor;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MenuGroup = function (_React$Component) {
    _inherits(MenuGroup, _React$Component);

    function MenuGroup(props) {
        _classCallCheck(this, MenuGroup);

        var _this = _possibleConstructorReturn(this, (MenuGroup.__proto__ || Object.getPrototypeOf(MenuGroup)).call(this, props));

        _this.state = {};

        if (props.value != undefined) {
            _this.state.activeitem = props.value;
        } else if (props.activeitem != null) {
            _this.state.activeitem = props.activeitem;
        }
        return _this;
    }

    _createClass(MenuGroup, [{
        key: 'handleItemClick',
        value: function handleItemClick(e, _ref) {
            var name = _ref.name;

            if (this.props.handleEvent != undefined) {
                var res = this.props.handleEvent({
                    e: e,
                    key: this.props.name,
                    eventName: "onItemClick",
                    parameters: { target: name }
                });
                if (res != false) {
                    this.setState({ activeitem: name });
                }
            }
        }
    }, {
        key: 'handleItemClick2',
        value: function handleItemClick2(p, e) {
            this.handleItemClick(e, p);
            e.preventDefault();
        }
    }, {
        key: 'render',
        value: function render() {
            var items = this.props["data-items"];
            if (items == undefined || items == "") {
                items = [];
            } else if (!Array.isArray(items)) {
                items = _json2.default.parse(items);
            }

            var children = this.renderItems(items);

            var controlProps = {};
            for (var p in this.props) {
                if (p == "data-items" || p == 'activeitem' || p == 'handleEvent' || p == 'link') continue;
                controlProps[p] = this.props[p];
            }

            return _react2.default.createElement(
                _semanticUiReact.Menu,
                controlProps,
                children
            );
        }
    }, {
        key: 'renderItems',
        value: function renderItems(items, keyPrefix) {
            var children = [];
            if (keyPrefix === undefined) keyPrefix = "";

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                if (item.visibleCondition !== undefined && item.visibleCondition !== null && item.visibleCondition !== "") {
                    var args = '';
                    var body = 'return ' + item.visibleCondition;
                    try {
                        if (!new Function(args, body)()) {
                            continue;
                        }
                    } catch (e) {};
                }

                var key = String(keyPrefix) + String(i);
                var titleSpan = _react2.default.createElement('span', { dangerouslySetInnerHTML: { __html: item.title } });
                if (Array.isArray(item.children) && item.children.length > 0) {
                    children.push(_react2.default.createElement(
                        _semanticUiReact.Menu.Item,
                        null,
                        _react2.default.createElement(
                            _semanticUiReact.Menu.Header,
                            null,
                            titleSpan
                        ),
                        _react2.default.createElement(
                            _semanticUiReact.Menu.Menu,
                            null,
                            this.renderItems(item.children, key + "_")
                        )
                    ));
                } else {
                    var content = this.props.link ? _react2.default.createElement(
                        'a',
                        { style: { color: "inherit" }, href: item.target, onClick: this.handleItemClick2.bind(this, { name: item.target }) },
                        titleSpan
                    ) : titleSpan;

                    children.push(_react2.default.createElement(
                        _semanticUiReact.Menu.Item,
                        {
                            key: key,
                            name: item.target,
                            active: this.state.activeitem === item.target,
                            onClick: this.handleItemClick.bind(this) },
                        content
                    ));
                }
            }
            return children;
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (prevState.activeitem !== nextProps.value) {
                return { activeitem: nextProps.value };
            }

            return null;
        }
    }]);

    return MenuGroup;
}(_react2.default.Component);

exports.default = MenuGroup;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _reactDataGrid = __webpack_require__(54);

var _reactDataGrid2 = _interopRequireDefault(_reactDataGrid);

var _functionalfilter = __webpack_require__(25);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Filter object structure:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               let filter = [
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {column: "Name" | "Name1,Name2,Name3" | "*",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               value: value,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               term: ">" | "<" | "=" | ">=" | "<=" | "!=" | "like" | "like*" | "*like" | "*like*"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "*like*" === "like"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var CheckBoxFormatter = function (_React$Component) {
    _inherits(CheckBoxFormatter, _React$Component);

    function CheckBoxFormatter() {
        _classCallCheck(this, CheckBoxFormatter);

        return _possibleConstructorReturn(this, (CheckBoxFormatter.__proto__ || Object.getPrototypeOf(CheckBoxFormatter)).apply(this, arguments));
    }

    _createClass(CheckBoxFormatter, [{
        key: 'render',
        value: function render() {
            var value = Boolean(this.props.value);
            return _react2.default.createElement(_semanticUiReact.Checkbox, { checked: value, disabled: true });
        }
    }]);

    return CheckBoxFormatter;
}(_react2.default.Component);

var NumberFormatter = function (_React$Component2) {
    _inherits(NumberFormatter, _React$Component2);

    function NumberFormatter() {
        _classCallCheck(this, NumberFormatter);

        return _possibleConstructorReturn(this, (NumberFormatter.__proto__ || Object.getPrototypeOf(NumberFormatter)).apply(this, arguments));
    }

    _createClass(NumberFormatter, [{
        key: 'render',
        value: function render() {
            var value = this.props.value;
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: value },
                    value
                )
            );
        }
    }]);

    return NumberFormatter;
}(_react2.default.Component);

var DateFormatter = function (_React$Component3) {
    _inherits(DateFormatter, _React$Component3);

    function DateFormatter() {
        _classCallCheck(this, DateFormatter);

        return _possibleConstructorReturn(this, (DateFormatter.__proto__ || Object.getPrototypeOf(DateFormatter)).apply(this, arguments));
    }

    _createClass(DateFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined ? window.DWKitLang.common.dateFormat : "L";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return DateFormatter;
}(_react2.default.Component);

var DateTimeFormatter = function (_React$Component4) {
    _inherits(DateTimeFormatter, _React$Component4);

    function DateTimeFormatter() {
        _classCallCheck(this, DateTimeFormatter);

        return _possibleConstructorReturn(this, (DateTimeFormatter.__proto__ || Object.getPrototypeOf(DateTimeFormatter)).apply(this, arguments));
    }

    _createClass(DateTimeFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined ? window.DWKitLang.common.dateFormat + " " + (window.DWKitLang.common.timeFormat !== undefined ? window.DWKitLang.common.timeFormat : "HH:mm") : "DD.MM.YYYY HH:mm";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return DateTimeFormatter;
}(_react2.default.Component);

var TimeFormatter = function (_React$Component5) {
    _inherits(TimeFormatter, _React$Component5);

    function TimeFormatter() {
        _classCallCheck(this, TimeFormatter);

        return _possibleConstructorReturn(this, (TimeFormatter.__proto__ || Object.getPrototypeOf(TimeFormatter)).apply(this, arguments));
    }

    _createClass(TimeFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.timeFormat != undefined ? window.DWKitLang.common.timeFormat : "HH:mm";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return TimeFormatter;
}(_react2.default.Component);

var jsonEqual = function jsonEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
};

var GridView = function (_React$Component6) {
    _inherits(GridView, _React$Component6);

    function GridView(props) {
        _classCallCheck(this, GridView);

        var _this6 = _possibleConstructorReturn(this, (GridView.__proto__ || Object.getPrototypeOf(GridView)).call(this, props));

        _this6.state = {
            items: [],
            sort: "",
            defaultSort: props.defaultSort,
            filter: props.filter,
            pageSize: 20,
            selectedIndexes: [],
            rowsCount: GridView.staticIsServerMode(props) ? undefined : 0
        };
        return _this6;
    }

    _createClass(GridView, [{
        key: 'isEditFormModal',
        value: function isEditFormModal() {
            return this.props.editFormShowType === "modal";
        }
    }, {
        key: 'isServerMode',
        value: function isServerMode() {
            return GridView.staticIsServerMode(this.props);
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            if (this.isServerMode()) {
                this.setState({
                    items: [],
                    selectedIndexes: [],
                    rowsCount: undefined
                });
            } else {
                var newItems = Array.isArray(this.props.value) ? GridView.staticGetSortedAndFilteredItems(this.props.value, this.state.filter, this.state.sort, this.props.defaultSort) : [];
                this.setState({
                    items: newItems,
                    rowsCount: newItems.length,
                    selectedIndexes: [],
                    originalItems: this.props.value
                });
            }
        }
    }, {
        key: 'resetSelection',
        value: function resetSelection() {
            this.setState({
                selectedIndexes: []
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var className = this.props.className;
            var style = _extends({}, this.props.style);
            var gridProps = this.getGridPropsByPagerType(this.props.pagerType);
            gridProps.columns = this.getColumns();
            gridProps.rowKey = this.props.rowKey;

            if (this.props.rowHeight !== undefined && this.props.rowHeight !== "") gridProps.rowHeight = this.props.rowHeight;

            if (this.props.autoHeight) {
                style.minHeight = this.props.minHeight;
                if (this.props.offSet !== undefined && this.props.offSet !== "") {
                    style.height = 'calc(100vh - ' + this.props.offSet + ')';
                } else {
                    style.height = "100vh";
                }

                className = (className === undefined ? "" : className + " ") + "dwkit-gridview-autoHeight";
            } else {
                if (this.props.minHeight !== undefined && this.props.minHeight !== "") {
                    gridProps.minHeight = this.props.minHeight;
                }
            }

            // if (Boolean(this.props.filterRow)) {
            //     gridProps.toolbar = <Toolbar enableFilter={true}/>;
            //     gridProps.onAddFilter = this.handleFilterChange.bind(this);
            //     gridProps.onClearFilters = this.onClearFilters.bind(this);
            // }

            if (Boolean(this.props.multiselect)) {
                gridProps.rowSelection = {
                    onRowsSelected: this.onRowsSelected.bind(this),
                    onRowsDeselected: this.onRowsDeselected.bind(this),
                    selectBy: {
                        indexes: this.state.selectedIndexes
                    }
                };
            }

            return _react2.default.createElement(
                'div',
                { key: this.props.name, name: this.props.name, className: className, style: style },
                _react2.default.createElement(_reactDataGrid2.default, _extends({ key: 'grid'
                }, gridProps, {
                    rowsCount: this.state.rowsCount,
                    rowGetter: this.gridRowGetter.bind(this),
                    onRowClick: this.gridOnRowClick.bind(this),
                    onGridSort: this.handleGridSort.bind(this) }))
            );
        }
    }, {
        key: 'getColumns',
        value: function getColumns() {
            var me = this;
            var columns = void 0;
            if (this.props.columns === undefined) {
                columns = [];
            } else if (Array.isArray(this.props.columns)) {
                columns = this.props.columns;
            } else {
                columns = JSON.parse(this.props.columns);
            }

            columns.forEach(function (item) {
                if (item.width !== null && item.width !== "" && item.width !== undefined) {
                    item.width = Number(item.width);
                }

                if (item.sortable !== false) {
                    item.sortable = !Boolean(me.props.disableSort);
                }
                item.filterable = Boolean(me.props.filterRow);
                item.resizable = Boolean(item.resizable);

                if (item.type === "number") item.formatter = NumberFormatter;else if (item.type === "checkbox") {
                    item.formatter = CheckBoxFormatter;
                } else if (item.type === "date") {
                    item.formatter = DateFormatter;
                } else if (item.type === "time") {
                    item.formatter = TimeFormatter;
                } else if (item.type === "datetime") {
                    item.formatter = DateTimeFormatter;
                } else if (item.type === "custom") {
                    item.getRowMetaData = function (row) {
                        return row;
                    };
                    item.formatter = function (args) {
                        if (item.customFormatter == undefined || typeof item.customFormatter != "function") {
                            return "";
                        }
                        return item.customFormatter({
                            row: args.dependentValues,
                            value: args.value,
                            column: item
                        });
                    };
                }
            });
            return columns;
        }
    }, {
        key: 'getGridPropsByPagerType',
        value: function getGridPropsByPagerType() {
            var gridProps = {};

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                if (this.props.pageSize !== undefined) {
                    this.state.pageSize = this.props.pageSize;
                }
                gridProps.rowRenderer = RowLoadingRenderer;
                if (this.state.rowsCount === undefined) this.state.rowsCount = 1;
            } else {
                // if (Array.isArray(this.props.value)) {
                //     this.state.items = this.getSortedAndFilteredItems(this.props.value);
                // }
                //this.state.rowsCount = this.state.items.length;
            }
            return gridProps;
        }
    }, {
        key: 'getSeletedRowKeys',
        value: function getSeletedRowKeys() {
            var me = this;
            var selectedKeys = [];

            this.state.selectedIndexes.forEach(function (index) {
                var obj = me.gridRowGetter(index);
                if (obj !== undefined) {
                    selectedKeys.push(obj[me.props.rowKey]);
                }
            });
            return selectedKeys;
        }
    }, {
        key: 'gridRowGetter',
        value: function gridRowGetter(index) {
            if (index < 0) return undefined;

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                if (this.state.items[index] === undefined) {
                    var pageSize = this.state.pageSize;
                    this.loadPage(index, pageSize);
                }
            }

            if (pagerType === "server") {
                return this.state.items[index];
            } else {
                return _extends({}, this.state.items[index]); //DWKIT-115
            }
        }
    }, {
        key: 'loadPage',
        value: function loadPage(startIndex, pageSize) {
            var me = this;
            for (var i = 0; i < pageSize; i++) {
                this.state.items[i + startIndex] = { __loading: true };
            }

            if (this.props.getAdditionalDataForControl === undefined) {
                if (console !== undefined) console.log("GridView: For paging on server need to set getAdditionalDataForControl func!");
            } else {
                var sortString = this.state.sort;
                if (sortString === "" && this.props.defaultSort !== undefined) sortString = this.props.defaultSort;

                this.props.getAdditionalDataForControl(this, {
                    startIndex: startIndex,
                    pageSize: pageSize,
                    filters: this.state.filter !== undefined ? this.state.filter.GetFilterAsObjects() : [],
                    sort: sortString
                }, function (_ref) {
                    var sIndex = _ref.sIndex,
                        pSize = _ref.pSize,
                        rowsCount = _ref.rowsCount,
                        items = _ref.items;

                    if (rowsCount === undefined || items === undefined) {
                        me.state.rowsCount = 0;
                        me.setState({
                            rowsCount: 0,
                            items: []
                        });
                    } else {
                        me.state.rowsCount = rowsCount;
                        for (var _i = 0; _i < pSize; _i++) {
                            if (_i < items.length) {
                                me.state.items[sIndex + _i] = items[_i];
                            } else {
                                me.state.items[sIndex + _i] = undefined;
                            }
                        }
                        me.forceUpdate();
                    }
                });
            }
        }
    }, {
        key: 'gridOnRowClick',
        value: function gridOnRowClick(rowIdx, row) {
            if (row === undefined) return;

            var timenow = Date.now();
            if (this.rowClickTime !== undefined && this.rowClickTime.rowIdx === rowIdx && timenow - this.rowClickTime.time <= 1000) {
                this.rowClickTime = undefined;
                this.onRowDblClick(rowIdx, row);
            } else {
                this.rowClickTime = {
                    rowIdx: rowIdx,
                    time: timenow
                };

                if (this.props.handleEvent !== undefined) {
                    this.props.handleEvent({ key: this.props.name, eventName: "onRowClick", parameters: { rowIdx: rowIdx, row: row } });
                }
            }
        }
    }, {
        key: 'onRowDblClick',
        value: function onRowDblClick(rowIdx, row) {
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onRowDblClick", parameters: { rowIdx: rowIdx, row: row } });
            }
        }
    }, {
        key: 'onRowsSelected',
        value: function onRowsSelected(rows) {
            this.state.selectedIndexes = this.state.selectedIndexes.concat(rows.map(function (r) {
                return r.rowIdx;
            }));
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({
                    key: this.props.name,
                    eventName: "onSelectionChanged",
                    parameters: { selectedIndexes: this.state.selectedIndexes }
                });
            }
            this.forceUpdate();
        }
    }, {
        key: 'onRowsDeselected',
        value: function onRowsDeselected(rows) {
            var rowIndexes = rows.map(function (r) {
                return r.rowIdx;
            });
            this.state.selectedIndexes = this.state.selectedIndexes.filter(function (i) {
                return rowIndexes.indexOf(i) === -1;
            });
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({
                    key: this.props.name,
                    eventName: "onSelectionChanged",
                    parameters: { selectedIndexes: this.state.selectedIndexes }
                });
            }
            this.forceUpdate();
        }
    }, {
        key: 'handleGridSort',
        value: function handleGridSort(sortColumn, sortDirection) {
            var stateDelta = {};
            if (sortDirection === "NONE") stateDelta.sort = "";else stateDelta.sort = sortColumn + " " + sortDirection;

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                stateDelta.items = [];
            } else {
                stateDelta.items = GridView.staticGetSortedAndFilteredItems(this.props.value, this.state.filter, stateDelta.sort, this.props.defaultSort);
            }

            stateDelta.selectedIndexes = [];
            this.setState(stateDelta);
        }
    }, {
        key: 'handleFilterChange',
        value: function handleFilterChange(filter) {
            var stateDelta = {};
            var key = filter.column.key;
            var id = "columnfilter_" + key;
            stateDelta.filter = this.state.filter !== undefined ? this.state.filter : new _functionalfilter.FunctionalFilter([], this.props.columns.map(function (c) {
                return c.key;
            }));
            stateDelta.filter.RemoveFilter({ name: key, id: id });
            if (filter.filterTerm !== "") {
                stateDelta.filter.AddFilter({ names: [key], expected: filter.filterTerm, term: _functionalfilter.FilterTerms.Like, id: id });
            }
            if (GridView.staticIsServerMode(this.props)) {
                stateDelta.items = [];
                stateDelta.selectedIndexes = [];
                stateDelta.rowsCount = undefined;
            } else {
                stateDelta.items = GridView.staticGetSortedAndFilteredItems(this.props.value, stateDelta.filter, this.state.sort, this.props.defaultSort);
                stateDelta.selectedIndexes = [];
                stateDelta.rowsCount = stateDelta.items.length;
            }
            this.setState(stateDelta);
        }
    }, {
        key: 'onClearFilters',
        value: function onClearFilters() {
            this.setState({ filter: this.props.filter });
        }
    }, {
        key: 'componentWillUnmount',


        ///----------
        ///Resize
        ///----------
        value: function componentWillUnmount() {
            this._isMounted = false;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._isMounted = true;
            this.recalcSizeParams();
        }
    }, {
        key: 'recalcSizeParams',
        value: function recalcSizeParams() {
            if (!this._isMounted) return;

            if (Boolean(this.props.autoHeight)) {
                var h = $(window).height();

                this.setState({
                    gridHeight: h - this.props.deltaHeight
                });
            }
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            var newState = null;
            if (!jsonEqual(prevState.filter, nextProps.filter)) {
                newState = { filter: nextProps.filter };
                if (!GridView.staticIsServerMode(nextProps)) {
                    var newItems = Array.isArray(nextProps.value) ? GridView.staticGetSortedAndFilteredItems(nextProps.value, nextProps.filter, prevState.sort, nextProps.defaultSort) : [];
                    newState.items = newItems;
                    newState.selectedIndexes = [];
                    newState.rowsCount = newItems.length;
                } else {
                    newState.items = [];
                    newState.selectedIndexes = [];
                    newState.rowsCount = undefined;
                }
            } else {
                if (!GridView.staticIsServerMode(nextProps) && prevState.originalItems !== nextProps.value) {
                    newState = {};
                    var _newItems = Array.isArray(nextProps.value) ? GridView.staticGetSortedAndFilteredItems(nextProps.value, prevState.filter, prevState.sort, nextProps.defaultSort) : [];

                    newState.items = _newItems;
                    newState.rowsCount = _newItems.length;
                    newState.selectedIndexes = [];
                    newState.originalItems = nextProps.value;
                }
            }
            return newState;
        }
    }, {
        key: 'staticIsServerMode',
        value: function staticIsServerMode(props) {
            return props.pagerType === "server";
        }
    }, {
        key: 'staticGetSortedAndFilteredItems',
        value: function staticGetSortedAndFilteredItems(array, filter, sort, defaultSort) {
            var items = [];
            if (array === undefined) return items;
            if (filter !== undefined) {
                items = array.filter(function (r) {
                    return filter.IsRowMatched(r);
                });
            } else {
                items = array;
            }

            var currentSort = sort;
            if (sort === 'NONE' || sort === "") {
                if (defaultSort === undefined) {
                    return items;
                }
                currentSort = defaultSort;
            }

            var indexSpace = currentSort.indexOf(" ");
            var sortColumn = currentSort.substring(0, indexSpace);
            var sortDirection = currentSort.substring(indexSpace + 1, currentSort.length);

            //Sorting
            var comparer = function comparer(a, b) {
                var aValue = a[sortColumn] !== undefined && a[sortColumn] !== null && a[sortColumn].toLowerCase !== undefined ? a[sortColumn].toLowerCase() : a[sortColumn];
                var bValue = b[sortColumn] !== undefined && b[sortColumn] !== null && b[sortColumn].toLowerCase !== undefined ? b[sortColumn].toLowerCase() : b[sortColumn];

                if (aValue === bValue) {
                    return 0;
                }
                if (aValue === null || aValue === undefined) {
                    return 1;
                }
                if (bValue === null || bValue === undefined) {
                    return -1;
                }
                if (sortDirection === 'ASC') {
                    return aValue > bValue ? 1 : -1;
                } else if (sortDirection === 'DESC') {
                    return aValue < bValue ? 1 : -1;
                }
            };
            return items.slice(0).sort(comparer);
        }
    }]);

    return GridView;
}(_react2.default.Component);

exports.default = GridView;

var RowLoadingRenderer = function (_React$Component7) {
    _inherits(RowLoadingRenderer, _React$Component7);

    function RowLoadingRenderer() {
        _classCallCheck(this, RowLoadingRenderer);

        return _possibleConstructorReturn(this, (RowLoadingRenderer.__proto__ || Object.getPrototypeOf(RowLoadingRenderer)).apply(this, arguments));
    }

    _createClass(RowLoadingRenderer, [{
        key: 'setScrollLeft',
        value: function setScrollLeft(scrollBy) {
            this.row.setScrollLeft(scrollBy);
        }
    }, {
        key: 'getClassName',
        value: function getClassName() {
            return this.props.row.__loading ? 'dwkit-gridview-rowloading' : "";
        }
    }, {
        key: 'render',
        value: function render() {
            var _this8 = this;

            return _react2.default.createElement(
                'div',
                { className: this.getClassName() },
                _react2.default.createElement(_reactDataGrid.Row, _extends({ ref: function ref(node) {
                        return _this8.row = node;
                    } }, this.props))
            );
        }
    }]);

    return RowLoadingRenderer;
}(_react2.default.Component);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(0), __webpack_require__(5));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDataGrid"] = factory(require("react"), require("react-dom"));
	else
		root["ReactDataGrid"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(130);


/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	if (false) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(147)();
	}


/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = {
	  getColumn: function getColumn(columns, idx) {
	    if (Array.isArray(columns)) {
	      return columns[idx];
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.get(idx);
	    }
	  },
	  spliceColumn: function spliceColumn(metrics, idx, column) {
	    if (Array.isArray(metrics.columns)) {
	      metrics.columns.splice(idx, 1, column);
	    } else if (typeof Immutable !== 'undefined') {
	      metrics.columns = metrics.columns.splice(idx, 1, column);
	    }
	    return metrics;
	  },
	  getSize: function getSize(columns) {
	    if (Array.isArray(columns)) {
	      return columns.length;
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.size;
	    }
	  },


	  // Logic extented to allow for functions to be passed down in column.editable
	  // this allows us to deicde whether we can be edting from a cell level
	  canEdit: function canEdit(col, rowData, enableCellSelect) {
	    if (!col) return false;
	    if (col.editable != null && typeof col.editable === 'function') {
	      return enableCellSelect === true && col.editable(rowData);
	    }
	    return enableCellSelect === true && (!!col.editor || !!col.editable);
	  },
	  getValue: function getValue(column, property) {
	    var value = void 0;
	    if (column.toJSON && column.get) {
	      value = column.get(property);
	    } else {
	      value = column[property];
	    }
	    return value;
	  }
	};

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = {
	  selected: _propTypes2['default'].object.isRequired,
	  copied: _propTypes2['default'].object,
	  dragged: _propTypes2['default'].object,
	  onCellClick: _propTypes2['default'].func.isRequired,
	  onCellDoubleClick: _propTypes2['default'].func.isRequired,
	  onCommit: _propTypes2['default'].func.isRequired,
	  onCommitCancel: _propTypes2['default'].func.isRequired,
	  handleDragEnterRow: _propTypes2['default'].func.isRequired,
	  handleTerminateDrag: _propTypes2['default'].func.isRequired,
	  getCellActions: _propTypes2['default'].func
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var ExcelColumnShape = {
	  name: _propTypes2['default'].node.isRequired,
	  key: _propTypes2['default'].string.isRequired,
	  width: _propTypes2['default'].number.isRequired,
	  filterable: _propTypes2['default'].bool
	};

	module.exports = ExcelColumnShape;

/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports) {

	"use strict";

	function createObjectWithProperties(originalObj, properties) {
	  var result = {};
	  for (var _iterator = properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var property = _ref;

	    if (property in originalObj) {
	      result[property] = originalObj[property];
	    }
	  }
	  return result;
	}

	module.exports = createObjectWithProperties;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(141);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-header.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-header.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	'use strict';

	var isFunction = function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	};

	module.exports = isFunction;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(140);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-core.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-core.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-row.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-row.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _keymirror = __webpack_require__(145);

	var _keymirror2 = _interopRequireDefault(_keymirror);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var constants = {
	  UpdateActions: (0, _keymirror2['default'])({
	    CELL_UPDATE: null,
	    COLUMN_FILL: null,
	    COPY_PASTE: null,
	    CELL_DRAG: null
	  }),
	  DragItemTypes: {
	    Column: 'column'
	  },
	  CellExpand: {
	    DOWN_TRIANGLE: String.fromCharCode('9660'),
	    RIGHT_TRIANGLE: String.fromCharCode('9654')
	  }
	};

	module.exports = constants;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var shallowCloneObject = __webpack_require__(52);
	var sameColumn = __webpack_require__(108);
	var ColumnUtils = __webpack_require__(6);
	var getScrollbarSize = __webpack_require__(32);
	var isColumnsImmutable = __webpack_require__(54);

	function setColumnWidths(columns, totalWidth) {
	  return columns.map(function (column) {
	    var colInfo = Object.assign({}, column);
	    if (column.width) {
	      if (/^([0-9]+)%$/.exec(column.width.toString())) {
	        colInfo.width = Math.floor(column.width / 100 * totalWidth);
	      }
	    }
	    return colInfo;
	  });
	}

	function setDefferedColumnWidths(columns, unallocatedWidth, minColumnWidth) {
	  var defferedColumns = columns.filter(function (c) {
	    return !c.width;
	  });
	  return columns.map(function (column) {
	    if (!column.width && column.width !== 0) {
	      if (unallocatedWidth <= 0) {
	        column.width = minColumnWidth;
	      } else {
	        var columnWidth = Math.floor(unallocatedWidth / ColumnUtils.getSize(defferedColumns));
	        if (columnWidth < minColumnWidth) {
	          column.width = minColumnWidth;
	        } else {
	          column.width = columnWidth;
	        }
	      }
	    }
	    return column;
	  });
	}

	function setColumnOffsets(columns) {
	  var left = 0;
	  return columns.map(function (column) {
	    column.left = left;
	    left += column.width;
	    return column;
	  });
	}

	/**
	 * Update column metrics calculation.
	 *
	 * @param {ColumnMetricsType} metrics
	 */
	function recalculate(metrics) {
	  // compute width for columns which specify width
	  var columns = setColumnWidths(metrics.columns, metrics.totalWidth);

	  var unallocatedWidth = columns.filter(function (c) {
	    return c.width;
	  }).reduce(function (w, column) {
	    return w - column.width;
	  }, metrics.totalWidth);
	  unallocatedWidth -= getScrollbarSize();

	  var width = columns.filter(function (c) {
	    return c.width;
	  }).reduce(function (w, column) {
	    return w + column.width;
	  }, 0);

	  // compute width for columns which doesn't specify width
	  columns = setDefferedColumnWidths(columns, unallocatedWidth, metrics.minColumnWidth);

	  // compute left offset
	  columns = setColumnOffsets(columns);

	  return {
	    columns: columns,
	    width: width,
	    totalWidth: metrics.totalWidth,
	    minColumnWidth: metrics.minColumnWidth
	  };
	}

	/**
	 * Update column metrics calculation by resizing a column.
	 *
	 * @param {ColumnMetricsType} metrics
	 * @param {Column} column
	 * @param {number} width
	 */
	function resizeColumn(metrics, index, width) {
	  var column = ColumnUtils.getColumn(metrics.columns, index);
	  var metricsClone = shallowCloneObject(metrics);
	  metricsClone.columns = metrics.columns.slice(0);

	  var updatedColumn = shallowCloneObject(column);
	  updatedColumn.width = Math.max(width, metricsClone.minColumnWidth);

	  metricsClone = ColumnUtils.spliceColumn(metricsClone, index, updatedColumn);

	  return recalculate(metricsClone);
	}

	function areColumnsImmutable(prevColumns, nextColumns) {
	  return isColumnsImmutable(prevColumns) && isColumnsImmutable(nextColumns);
	}

	function compareEachColumn(prevColumns, nextColumns, isSameColumn) {
	  var i = void 0;
	  var len = void 0;
	  var column = void 0;
	  var prevColumnsByKey = {};
	  var nextColumnsByKey = {};

	  if (ColumnUtils.getSize(prevColumns) !== ColumnUtils.getSize(nextColumns)) {
	    return false;
	  }

	  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
	    column = prevColumns[i];
	    prevColumnsByKey[column.key] = column;
	  }

	  for (i = 0, len = ColumnUtils.getSize(nextColumns); i < len; i++) {
	    column = nextColumns[i];
	    nextColumnsByKey[column.key] = column;
	    var prevColumn = prevColumnsByKey[column.key];
	    if (prevColumn === undefined || !isSameColumn(prevColumn, column)) {
	      return false;
	    }
	  }

	  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
	    column = prevColumns[i];
	    var nextColumn = nextColumnsByKey[column.key];
	    if (nextColumn === undefined) {
	      return false;
	    }
	  }
	  return true;
	}

	function sameColumns(prevColumns, nextColumns, isSameColumn) {
	  if (areColumnsImmutable(prevColumns, nextColumns)) {
	    return prevColumns === nextColumns;
	  }

	  return compareEachColumn(prevColumns, nextColumns, isSameColumn);
	}

	module.exports = { recalculate: recalculate, resizeColumn: resizeColumn, sameColumn: sameColumn, sameColumns: sameColumns };

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';

	var size = void 0;

	function getScrollbarSize() {
	  if (size === undefined) {
	    var outer = document.createElement('div');
	    outer.style.width = '50px';
	    outer.style.height = '50px';
	    outer.style.position = 'absolute';
	    outer.style.top = '-200px';
	    outer.style.left = '-200px';

	    var inner = document.createElement('div');
	    inner.style.height = '100px';
	    inner.style.width = '100%';

	    outer.appendChild(inner);
	    document.body.appendChild(outer);

	    var outerWidth = outer.clientWidth;
	    outer.style.overflowY = 'scroll';
	    var innerWidth = inner.clientWidth;

	    document.body.removeChild(outer);

	    size = outerWidth - innerWidth;
	  }

	  return size;
	}

	module.exports = getScrollbarSize;

/***/ }),
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(138);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-cell.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-cell.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _underscore = __webpack_require__(78);

	var _underscore2 = _interopRequireDefault(_underscore);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _CellAction = __webpack_require__(105);

	var _CellAction2 = _interopRequireDefault(_CellAction);

	var _CellExpand = __webpack_require__(106);

	var _CellExpand2 = _interopRequireDefault(_CellExpand);

	var _ChildRowDeleteButton = __webpack_require__(107);

	var _ChildRowDeleteButton2 = _interopRequireDefault(_ChildRowDeleteButton);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var EditorContainer = __webpack_require__(124);
	var ExcelColumn = __webpack_require__(12);
	var isFunction = __webpack_require__(19);
	var CellMetaDataShape = __webpack_require__(11);
	var SimpleCellFormatter = __webpack_require__(51);
	var ColumnUtils = __webpack_require__(6);
	var createObjectWithProperties = __webpack_require__(14);

	__webpack_require__(37);

	// The list of the propTypes that we want to include in the Cell div
	var knownDivPropertyKeys = ['height', 'tabIndex', 'value'];

	var Cell = function (_React$Component) {
	  _inherits(Cell, _React$Component);

	  function Cell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Cell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      isCellValueChanging: false,
	      isLockChanging: false
	    }, _this.onCellClick = function (e) {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellClick && typeof meta.onCellClick === 'function') {
	        meta.onCellClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
	      }
	    }, _this.onCellFocus = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellFocus && typeof meta.onCellFocus === 'function') {
	        meta.onCellFocus({ rowIdx: _this.props.rowIdx, idx: _this.props.idx });
	      }
	    }, _this.onCellContextMenu = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellContextMenu && typeof meta.onCellContextMenu === 'function') {
	        meta.onCellContextMenu({ rowIdx: _this.props.rowIdx, idx: _this.props.idx });
	      }
	    }, _this.onCellDoubleClick = function (e) {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellDoubleClick && typeof meta.onCellDoubleClick === 'function') {
	        meta.onCellDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
	      }
	    }, _this.onCellExpand = function (e) {
	      e.stopPropagation();
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellExpand != null) {
	        meta.onCellExpand({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
	      }
	    }, _this.onCellKeyDown = function (e) {
	      if (_this.canExpand() && e.key === 'Enter') {
	        _this.onCellExpand(e);
	      }
	    }, _this.onDeleteSubRow = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onDeleteSubRow != null) {
	        meta.onDeleteSubRow({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
	      }
	    }, _this.onDragHandleDoubleClick = function (e) {
	      e.stopPropagation();
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onDragHandleDoubleClick && typeof meta.onDragHandleDoubleClick === 'function') {
	        meta.onDragHandleDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.getRowData(), e: e });
	      }
	    }, _this.onDragOver = function (e) {
	      e.preventDefault();
	    }, _this.getStyle = function () {
	      var style = {
	        position: 'absolute',
	        width: _this.props.column.width,
	        height: _this.props.height,
	        left: _this.props.column.left
	      };
	      return style;
	    }, _this.getFormatter = function () {
	      var col = _this.props.column;
	      if (_this.isActive()) {
	        return React.createElement(EditorContainer, { rowData: _this.getRowData(), rowIdx: _this.props.rowIdx, value: _this.props.value, idx: _this.props.idx, cellMetaData: _this.props.cellMetaData, column: col, height: _this.props.height });
	      }

	      return _this.props.column.formatter;
	    }, _this.getRowData = function () {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;

	      return props.rowData.toJSON ? props.rowData.toJSON() : props.rowData;
	    }, _this.getFormatterDependencies = function () {
	      // convention based method to get corresponding Id or Name of any Name or Id property
	      if (typeof _this.props.column.getRowMetaData === 'function') {
	        return _this.props.column.getRowMetaData(_this.getRowData(), _this.props.column);
	      }
	    }, _this.getCellClass = function () {
	      var className = joinClasses(_this.props.column.cellClass, 'react-grid-Cell', _this.props.className, _this.props.column.locked ? 'react-grid-Cell--locked' : null);
	      var extraClasses = joinClasses({
	        'row-selected': _this.props.isRowSelected,
	        editing: _this.isActive(),
	        copied: _this.isCopied() || _this.wasDraggedOver() || _this.isDraggedOverUpwards() || _this.isDraggedOverDownwards(),
	        'is-dragged-over-up': _this.isDraggedOverUpwards(),
	        'is-dragged-over-down': _this.isDraggedOverDownwards(),
	        'was-dragged-over': _this.wasDraggedOver(),
	        'cell-tooltip': _this.props.tooltip ? true : false,
	        'rdg-child-cell': _this.props.expandableOptions && _this.props.expandableOptions.subRowDetails && _this.props.expandableOptions.treeDepth > 0,
	        'last-column': _this.props.column.isLastColumn
	      });
	      return joinClasses(className, extraClasses);
	    }, _this.getUpdateCellClass = function () {
	      return _this.props.column.getUpdateCellClass ? _this.props.column.getUpdateCellClass(_this.props.selectedColumn, _this.props.column, _this.state.isCellValueChanging) : '';
	    }, _this.isColumnSelected = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }

	      return meta.selected && meta.selected.idx === _this.props.idx;
	    }, _this.isSelected = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }

	      return meta.selected && meta.selected.rowIdx === _this.props.rowIdx && meta.selected.idx === _this.props.idx;
	    }, _this.isActive = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      return _this.isSelected() && meta.selected.active === true;
	    }, _this.isCellSelectionChanging = function (nextProps) {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      var nextSelected = nextProps.cellMetaData.selected;
	      if (meta.selected && nextSelected) {
	        return _this.props.idx === nextSelected.idx || _this.props.idx === meta.selected.idx;
	      }

	      return true;
	    }, _this.isCellSelectEnabled = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      return meta.enableCellSelect;
	    }, _this.hasChangedDependentValues = function (nextProps) {
	      var currentColumn = _this.props.column;
	      var hasChangedDependentValues = false;

	      if (currentColumn.getRowMetaData) {
	        var currentRowMetaData = currentColumn.getRowMetaData(_this.getRowData(), currentColumn);
	        var nextColumn = nextProps.column;
	        var nextRowMetaData = nextColumn.getRowMetaData(_this.getRowData(nextProps), nextColumn);

	        hasChangedDependentValues = !_underscore2['default'].isEqual(currentRowMetaData, nextRowMetaData);
	      }

	      return hasChangedDependentValues;
	    }, _this.applyUpdateClass = function () {
	      var updateCellClass = _this.getUpdateCellClass();
	      // -> removing the class
	      if (updateCellClass != null && updateCellClass !== '') {
	        var cellDOMNode = _this.node;
	        if (cellDOMNode.classList) {
	          cellDOMNode.classList.remove(updateCellClass);
	          // -> and re-adding the class
	          cellDOMNode.classList.add(updateCellClass);
	        } else if (cellDOMNode.className.indexOf(updateCellClass) === -1) {
	          // IE9 doesn't support classList, nor (I think) altering element.className
	          // without replacing it wholesale.
	          cellDOMNode.className = cellDOMNode.className + ' ' + updateCellClass;
	        }
	      }
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = _this.node;
	      if (node) {
	        var transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	        node.style.webkitTransform = transform;
	        node.style.transform = transform;
	      }
	    }, _this.removeScroll = function () {
	      var node = _this.node;
	      if (node) {
	        node.style.webkitTransform = null;
	        node.style.transform = null;
	      }
	    }, _this.isCopied = function () {
	      var copied = _this.props.cellMetaData.copied;
	      return copied && copied.rowIdx === _this.props.rowIdx && copied.idx === _this.props.idx;
	    }, _this.isDraggedOver = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return dragged && dragged.overRowIdx === _this.props.rowIdx && dragged.idx === _this.props.idx;
	    }, _this.wasDraggedOver = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return dragged && (dragged.overRowIdx < _this.props.rowIdx && _this.props.rowIdx < dragged.rowIdx || dragged.overRowIdx > _this.props.rowIdx && _this.props.rowIdx > dragged.rowIdx) && dragged.idx === _this.props.idx;
	    }, _this.isDraggedCellChanging = function (nextProps) {
	      var isChanging = void 0;
	      var dragged = _this.props.cellMetaData.dragged;
	      var nextDragged = nextProps.cellMetaData.dragged;
	      if (dragged) {
	        isChanging = nextDragged && _this.props.idx === nextDragged.idx || dragged && _this.props.idx === dragged.idx;
	        return isChanging;
	      }

	      return false;
	    }, _this.isCopyCellChanging = function (nextProps) {
	      var isChanging = void 0;
	      var copied = _this.props.cellMetaData.copied;
	      var nextCopied = nextProps.cellMetaData.copied;
	      if (copied) {
	        isChanging = nextCopied && _this.props.idx === nextCopied.idx || copied && _this.props.idx === copied.idx;
	        return isChanging;
	      }
	      return false;
	    }, _this.isDraggedOverUpwards = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx < dragged.rowIdx;
	    }, _this.isDraggedOverDownwards = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx > dragged.rowIdx;
	    }, _this.isFocusedOnBody = function () {
	      return document.activeElement == null || document.activeElement.nodeName && typeof document.activeElement.nodeName === 'string' && document.activeElement.nodeName.toLowerCase() === 'body';
	    }, _this.isFocusedOnCell = function () {
	      return document.activeElement && document.activeElement.className.indexOf('react-grid-Cell') !== -1;
	    }, _this.checkFocus = function () {
	      if (_this.isSelected() && !_this.isActive()) {
	        if (_this.props.isScrolling && !_this.props.cellMetaData.isScrollingVerticallyWithKeyboard && !_this.props.cellMetaData.isScrollingHorizontallyWithKeyboard) {
	          return;
	        }
	        // If the enableCellAutoFocus is set in the ReactDataGrid props, it will allow the cell to take focus when the browser is focused on the body.
	        // Otherwise, only focus to the current cell if the currently active node in the document is within the data grid.
	        // Meaning focus should not be stolen from elements that the grid doesnt control.
	        var cellAutoFocusEnabled = _this.props.cellMetaData && _this.props.cellMetaData.enableCellAutoFocus;
	        var dataGridDOMNode = _this.props.cellMetaData && _this.props.cellMetaData.getDataGridDOMNode ? _this.props.cellMetaData.getDataGridDOMNode() : null;
	        if (_this.isFocusedOnCell() || cellAutoFocusEnabled && _this.isFocusedOnBody() || dataGridDOMNode && dataGridDOMNode.contains(document.activeElement)) {
	          var cellDOMNode = _this.node;
	          if (cellDOMNode) {
	            cellDOMNode.focus();
	          }
	        }
	      }
	    }, _this.canEdit = function () {
	      return _this.props.column.editor != null || _this.props.column.editable;
	    }, _this.canExpand = function () {
	      return _this.props.expandableOptions && _this.props.expandableOptions.canExpand;
	    }, _this.createColumEventCallBack = function (onColumnEvent, info) {
	      return function (e) {
	        onColumnEvent(e, info);
	      };
	    }, _this.createCellEventCallBack = function (gridEvent, columnEvent) {
	      return function (e) {
	        gridEvent(e);
	        columnEvent(e);
	      };
	    }, _this.createEventDTO = function (gridEvents, columnEvents, onColumnEvent) {
	      var allEvents = Object.assign({}, gridEvents);

	      for (var eventKey in columnEvents) {
	        if (columnEvents.hasOwnProperty(eventKey)) {
	          var event = columnEvents[event];
	          var eventInfo = { idx: _this.props.idx, rowIdx: _this.props.rowIdx, rowId: _this.props.rowData[_this.props.cellMetaData.rowKey], name: eventKey };
	          var eventCallback = _this.createColumEventCallBack(onColumnEvent, eventInfo);

	          if (allEvents.hasOwnProperty(eventKey)) {
	            var currentEvent = allEvents[eventKey];
	            allEvents[eventKey] = _this.createCellEventCallBack(currentEvent, eventCallback);
	          } else {
	            allEvents[eventKey] = eventCallback;
	          }
	        }
	      }

	      return allEvents;
	    }, _this.getEvents = function () {
	      var columnEvents = _this.props.column ? Object.assign({}, _this.props.column.events) : undefined;
	      var onColumnEvent = _this.props.cellMetaData ? _this.props.cellMetaData.onColumnEvent : undefined;
	      var gridEvents = {
	        onClick: _this.onCellClick,
	        onFocus: _this.onCellFocus,
	        onDoubleClick: _this.onCellDoubleClick,
	        onContextMenu: _this.onCellContextMenu,
	        onDragOver: _this.onDragOver
	      };

	      if (!columnEvents || !onColumnEvent) {
	        return gridEvents;
	      }

	      return _this.createEventDTO(gridEvents, columnEvents, onColumnEvent);
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _this.renderCellContent = function (props) {
	      var CellContent = void 0;
	      var Formatter = _this.getFormatter();
	      if (React.isValidElement(Formatter)) {
	        props.dependentValues = _this.getFormatterDependencies();
	        CellContent = React.cloneElement(Formatter, props);
	      } else if (isFunction(Formatter)) {
	        CellContent = React.createElement(Formatter, { value: _this.props.value, dependentValues: _this.getFormatterDependencies() });
	      } else {
	        CellContent = React.createElement(SimpleCellFormatter, { value: _this.props.value });
	      }
	      var isExpandCell = _this.props.expandableOptions ? _this.props.expandableOptions.field === _this.props.column.key : false;
	      var treeDepth = _this.props.expandableOptions ? _this.props.expandableOptions.treeDepth : 0;
	      var marginLeft = _this.props.expandableOptions && isExpandCell ? _this.props.expandableOptions.treeDepth * 30 : 0;
	      var cellExpander = void 0;
	      var cellDeleter = void 0;
	      if (_this.canExpand()) {
	        cellExpander = React.createElement(_CellExpand2['default'], { expandableOptions: _this.props.expandableOptions, onCellExpand: _this.onCellExpand });
	      }

	      var isDeleteSubRowEnabled = _this.props.cellMetaData.onDeleteSubRow ? true : false;

	      if (treeDepth > 0 && isExpandCell) {
	        cellDeleter = React.createElement(_ChildRowDeleteButton2['default'], { treeDepth: treeDepth, cellHeight: _this.props.height, siblingIndex: _this.props.expandableOptions.subRowDetails.siblingIndex, numberSiblings: _this.props.expandableOptions.subRowDetails.numberSiblings, onDeleteSubRow: _this.onDeleteSubRow, isDeleteSubRowEnabled: isDeleteSubRowEnabled });
	      }
	      return React.createElement(
	        'div',
	        { className: 'react-grid-Cell__value' },
	        cellDeleter,
	        React.createElement(
	          'div',
	          { style: { marginLeft: marginLeft } },
	          React.createElement(
	            'span',
	            null,
	            CellContent
	          ),
	          ' ',
	          _this.props.cellControls,
	          ' ',
	          cellExpander
	        )
	      );
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Cell.prototype.componentDidMount = function componentDidMount() {
	    this.checkFocus();
	  };

	  Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    this.setState({
	      isCellValueChanging: this.props.isCellValueChanging(this.props.value, nextProps.value),
	      isLockChanging: this.props.column.locked !== nextProps.column.locked
	    });
	  };

	  Cell.prototype.componentDidUpdate = function componentDidUpdate() {
	    this.checkFocus();
	    var dragged = this.props.cellMetaData.dragged;
	    if (dragged && dragged.complete === true) {
	      this.props.cellMetaData.handleTerminateDrag();
	    }
	    if (this.state.isCellValueChanging && this.props.selectedColumn != null) {
	      this.applyUpdateClass();
	    }
	    if (this.state.isLockChanging && !this.props.column.locked) {
	      this.removeScroll();
	    }
	  };

	  Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    var shouldUpdate = this.props.column.width !== nextProps.column.width || this.props.column.left !== nextProps.column.left || this.props.column.cellClass !== nextProps.column.cellClass || this.props.height !== nextProps.height || this.props.rowIdx !== nextProps.rowIdx || this.isCellSelectionChanging(nextProps) || this.isDraggedCellChanging(nextProps) || this.isCopyCellChanging(nextProps) || this.props.isRowSelected !== nextProps.isRowSelected || this.isSelected() || this.props.isCellValueChanging(this.props.value, nextProps.value) || this.props.forceUpdate === true || this.props.className !== nextProps.className || this.props.expandableOptions !== nextProps.expandableOptions || this.hasChangedDependentValues(nextProps) || this.props.column.locked !== nextProps.column.locked;
	    return shouldUpdate;
	  };

	  Cell.prototype.getCellActions = function getCellActions() {
	    var _props = this.props,
	        cellMetaData = _props.cellMetaData,
	        column = _props.column,
	        rowData = _props.rowData;

	    if (cellMetaData && cellMetaData.getCellActions) {
	      var cellActions = cellMetaData.getCellActions(column, rowData);
	      if (cellActions && cellActions.length) {
	        return cellActions.map(function (action, index) {
	          return React.createElement(_CellAction2['default'], { key: index, action: action, isFirst: index === 0 });
	        });
	      }
	      return null;
	    }
	    return null;
	  };

	  Cell.prototype.render = function render() {
	    var _this2 = this;

	    if (this.props.column.hidden) {
	      return null;
	    }

	    var style = this.getStyle();

	    var className = this.getCellClass();

	    var cellActions = this.getCellActions();

	    var cellContent = this.props.children || this.renderCellContent({
	      value: this.props.value,
	      column: this.props.column,
	      rowIdx: this.props.rowIdx,
	      isExpanded: this.props.isExpanded
	    });

	    var dragHandle = !this.isActive() && ColumnUtils.canEdit(this.props.column, this.props.rowData, this.props.cellMetaData.enableCellSelect) ? React.createElement(
	      'div',
	      { className: 'drag-handle', draggable: 'true', onDoubleClick: this.onDragHandleDoubleClick },
	      React.createElement('span', { style: { display: 'none' } })
	    ) : null;
	    var events = this.getEvents();
	    var tooltip = this.props.tooltip ? React.createElement(
	      'span',
	      { className: 'cell-tooltip-text' },
	      this.props.tooltip
	    ) : null;

	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: className, style: style }, events, { ref: function ref(node) {
	          _this2.node = node;
	        } }),
	      cellActions,
	      cellContent,
	      dragHandle,
	      tooltip
	    );
	  };

	  return Cell;
	}(React.Component);

	Cell.propTypes = {
	  rowIdx: _propTypes2['default'].number.isRequired,
	  idx: _propTypes2['default'].number.isRequired,
	  selected: _propTypes2['default'].shape({
	    idx: _propTypes2['default'].number.isRequired
	  }),
	  selectedColumn: _propTypes2['default'].object,
	  height: _propTypes2['default'].number,
	  tabIndex: _propTypes2['default'].number,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]),
	  isExpanded: _propTypes2['default'].bool,
	  isRowSelected: _propTypes2['default'].bool,
	  cellMetaData: _propTypes2['default'].shape(CellMetaDataShape).isRequired,
	  handleDragStart: _propTypes2['default'].func,
	  className: _propTypes2['default'].string,
	  cellControls: _propTypes2['default'].any,
	  rowData: _propTypes2['default'].object.isRequired,
	  forceUpdate: _propTypes2['default'].bool,
	  expandableOptions: _propTypes2['default'].object.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired,
	  tooltip: _propTypes2['default'].string,
	  isCellValueChanging: _propTypes2['default'].func,
	  children: _propTypes2['default'].oneOfType([_propTypes2['default'].arrayOf(_propTypes2['default'].node), _propTypes2['default'].node])
	};
	Cell.defaultProps = {
	  tabIndex: 0,
	  isExpanded: false,
	  value: '',
	  isCellValueChanging: function isCellValueChanging(value, nextValue) {
	    return value !== nextValue;
	  }
	};


	module.exports = Cell;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var joinClasses = __webpack_require__(5);
	var ExcelColumn = __webpack_require__(12);
	var ResizeHandle = __webpack_require__(120);
	__webpack_require__(15);

	function simpleCellRenderer(objArgs) {
	  var headerText = objArgs.column.rowType === 'header' ? objArgs.column.name : '';
	  return React.createElement(
	    'div',
	    { className: 'widget-HeaderCell__value' },
	    headerText
	  );
	}

	var HeaderCell = function (_React$Component) {
	  _inherits(HeaderCell, _React$Component);

	  function HeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, HeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: false }, _this.onDragStart = function (e) {
	      _this.setState({ resizing: true });
	      // need to set dummy data for FF
	      if (e && e.dataTransfer && e.dataTransfer.setData) e.dataTransfer.setData('text/plain', 'dummy');
	    }, _this.onDrag = function (e) {
	      var resize = _this.props.onResize || null; // for flows sake, doesnt recognise a null check direct
	      if (resize) {
	        var _width = _this.getWidthFromMouseEvent(e);
	        if (_width > 0) {
	          resize(_this.props.column, _width);
	        }
	      }
	    }, _this.onDragEnd = function (e) {
	      var width = _this.getWidthFromMouseEvent(e);
	      _this.props.onResizeEnd(_this.props.column, width);
	      _this.setState({ resizing: false });
	    }, _this.getWidthFromMouseEvent = function (e) {
	      var right = e.pageX || e.touches && e.touches[0] && e.touches[0].pageX || e.changedTouches && e.changedTouches[e.changedTouches.length - 1].pageX;
	      var left = ReactDOM.findDOMNode(_this).getBoundingClientRect().left;
	      return right - left;
	    }, _this.getCell = function () {
	      if (React.isValidElement(_this.props.renderer)) {
	        // if it is a string, it's an HTML element, and column is not a valid property, so only pass height
	        if (typeof _this.props.renderer.type === 'string') {
	          return React.cloneElement(_this.props.renderer, { height: _this.props.height });
	        }
	        return React.cloneElement(_this.props.renderer, { column: _this.props.column, height: _this.props.height });
	      }
	      return _this.props.renderer({ column: _this.props.column });
	    }, _this.getStyle = function () {
	      return {
	        width: _this.props.column.width,
	        left: _this.props.column.left,
	        display: 'inline-block',
	        position: 'absolute',
	        height: _this.props.height,
	        margin: 0,
	        textOverflow: 'ellipsis',
	        whiteSpace: 'nowrap'
	      };
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = ReactDOM.findDOMNode(_this);
	      node.style.webkitTransform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	      node.style.transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	    }, _this.removeScroll = function () {
	      var node = ReactDOM.findDOMNode(_this);
	      if (node) {
	        var transform = 'none';
	        node.style.webkitTransform = transform;
	        node.style.transform = transform;
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  HeaderCell.prototype.render = function render() {
	    var resizeHandle = void 0;
	    if (this.props.column.resizable) {
	      resizeHandle = React.createElement(ResizeHandle, {
	        onDrag: this.onDrag,
	        onDragStart: this.onDragStart,
	        onDragEnd: this.onDragEnd
	      });
	    }
	    var className = joinClasses({
	      'react-grid-HeaderCell': true,
	      'react-grid-HeaderCell--resizing': this.state.resizing,
	      'react-grid-HeaderCell--locked': this.props.column.locked
	    });
	    className = joinClasses(className, this.props.className, this.props.column.cellClass);
	    var cell = this.getCell();
	    return React.createElement(
	      'div',
	      { className: className, style: this.getStyle() },
	      cell,
	      resizeHandle
	    );
	  };

	  return HeaderCell;
	}(React.Component);

	HeaderCell.propTypes = {
	  renderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]).isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  onResize: _propTypes2['default'].func.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  onResizeEnd: _propTypes2['default'].func.isRequired,
	  className: _propTypes2['default'].string
	};
	HeaderCell.defaultProps = {
	  renderer: simpleCellRenderer
	};


	module.exports = HeaderCell;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _OverflowCell = __webpack_require__(116);

	var _OverflowCell2 = _interopRequireDefault(_OverflowCell);

	var _RowComparer = __webpack_require__(43);

	var _RowComparer2 = _interopRequireDefault(_RowComparer);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var Cell = __webpack_require__(40);
	var columnUtils = __webpack_require__(6);
	var cellMetaDataShape = __webpack_require__(11);
	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(29);

	var CellExpander = function (_React$Component) {
	  _inherits(CellExpander, _React$Component);

	  function CellExpander() {
	    _classCallCheck(this, CellExpander);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  CellExpander.prototype.render = function render() {
	    return React.createElement(Cell, this.props);
	  };

	  return CellExpander;
	}(React.Component);

	// The list of the propTypes that we want to include in the Row div


	var knownDivPropertyKeys = ['height'];

	var Row = function (_React$Component2) {
	  _inherits(Row, _React$Component2);

	  function Row() {
	    var _temp, _this2, _ret;

	    _classCallCheck(this, Row);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this2), _this2.handleDragEnter = function () {
	      var handleDragEnterRow = _this2.props.cellMetaData.handleDragEnterRow;
	      if (handleDragEnterRow) {
	        handleDragEnterRow(_this2.props.idx);
	      }
	    }, _this2.getSelectedColumn = function () {
	      if (_this2.props.cellMetaData) {
	        var selected = _this2.props.cellMetaData.selected;
	        if (selected && selected.idx) {
	          return columnUtils.getColumn(_this2.props.columns, selected.idx);
	        }
	      }
	    }, _this2.getCellRenderer = function (columnKey) {
	      var CellRenderer = _this2.props.cellRenderer;
	      if (_this2.props.subRowDetails && _this2.props.subRowDetails.field === columnKey) {
	        return CellExpander;
	      }
	      return CellRenderer;
	    }, _this2.getCell = function (column, i, selectedColumn) {
	      var CellRenderer = _this2.props.cellRenderer;
	      var _this2$props = _this2.props,
	          colVisibleStart = _this2$props.colVisibleStart,
	          colVisibleEnd = _this2$props.colVisibleEnd,
	          idx = _this2$props.idx,
	          cellMetaData = _this2$props.cellMetaData;
	      var key = column.key,
	          formatter = column.formatter,
	          locked = column.locked;

	      var baseCellProps = { key: key + '-' + idx, idx: i, rowIdx: idx, height: _this2.getRowHeight(), column: column, cellMetaData: cellMetaData };

	      if ((i < colVisibleStart || i > colVisibleEnd) && !locked) {
	        return React.createElement(_OverflowCell2['default'], _extends({ ref: function ref(node) {
	            return _this2[key] = node;
	          } }, baseCellProps));
	      }

	      var _this2$props2 = _this2.props,
	          row = _this2$props2.row,
	          isSelected = _this2$props2.isSelected;

	      var cellProps = {
	        ref: function ref(node) {
	          return _this2[key] = node;
	        },
	        value: _this2.getCellValue(key || i),
	        rowData: row,
	        isRowSelected: isSelected,
	        expandableOptions: _this2.getExpandableOptions(key),
	        selectedColumn: selectedColumn,
	        formatter: formatter,
	        isScrolling: _this2.props.isScrolling
	      };

	      return React.createElement(CellRenderer, _extends({}, baseCellProps, cellProps));
	    }, _this2.getCells = function () {
	      var cells = [];
	      var lockedCells = [];
	      var selectedColumn = _this2.getSelectedColumn();
	      var lastColumnIdx = _this2.props.columns.size - 1;
	      if (_this2.props.columns) {
	        _this2.props.columns.forEach(function (column, i) {
	          if (i === lastColumnIdx) {
	            column.isLastColumn = true;
	          }
	          var cell = _this2.getCell(column, i, selectedColumn);
	          if (column.locked) {
	            lockedCells.push(cell);
	          } else {
	            cells.push(cell);
	          }
	        });
	      }

	      return cells.concat(lockedCells);
	    }, _this2.getRowHeight = function () {
	      var rows = _this2.props.expandedRows || null;
	      if (rows && _this2.props.idx) {
	        var row = rows[_this2.props.idx] || null;
	        if (row) {
	          return row.height;
	        }
	      }
	      return _this2.props.height;
	    }, _this2.getCellValue = function (key) {
	      var val = void 0;
	      if (key === 'select-row') {
	        return _this2.props.isSelected;
	      } else if (typeof _this2.props.row.get === 'function') {
	        val = _this2.props.row.get(key);
	      } else {
	        val = _this2.props.row[key];
	      }
	      return val;
	    }, _this2.isContextMenuDisplayed = function () {
	      if (_this2.props.cellMetaData) {
	        var selected = _this2.props.cellMetaData.selected;
	        if (selected && selected.contextMenuDisplayed && selected.rowIdx === _this2.props.idx) {
	          return true;
	        }
	      }
	      return false;
	    }, _this2.getExpandableOptions = function (columnKey) {
	      var subRowDetails = _this2.props.subRowDetails;
	      if (subRowDetails) {
	        return { canExpand: subRowDetails && subRowDetails.field === columnKey && (subRowDetails.children && subRowDetails.children.length > 0 || subRowDetails.group === true), field: subRowDetails.field, expanded: subRowDetails && subRowDetails.expanded, children: subRowDetails && subRowDetails.children, treeDepth: subRowDetails ? subRowDetails.treeDepth : 0, subRowDetails: subRowDetails };
	      }
	      return {};
	    }, _this2.setScrollLeft = function (scrollLeft) {
	      _this2.props.columns.forEach(function (column) {
	        if (column.locked) {
	          if (!_this2[column.key]) return;
	          _this2[column.key].setScrollLeft(scrollLeft);
	        }
	      });
	    }, _this2.getKnownDivProps = function () {
	      return createObjectWithProperties(_this2.props, knownDivPropertyKeys);
	    }, _this2.renderCell = function (props) {
	      if (typeof _this2.props.cellRenderer === 'function') {
	        _this2.props.cellRenderer.call(_this2, props);
	      }
	      if (React.isValidElement(_this2.props.cellRenderer)) {
	        return React.cloneElement(_this2.props.cellRenderer, props);
	      }

	      return _this2.props.cellRenderer(props);
	    }, _temp), _possibleConstructorReturn(_this2, _ret);
	  }

	  Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return (0, _RowComparer2['default'])(nextProps, this.props);
	  };

	  Row.prototype.render = function render() {
	    var className = joinClasses('react-grid-Row', 'react-grid-Row--' + (this.props.idx % 2 === 0 ? 'even' : 'odd'), {
	      'row-selected': this.props.isSelected,
	      'row-context-menu': this.isContextMenuDisplayed()
	    }, this.props.extraClasses);

	    var style = {
	      height: this.getRowHeight(this.props),
	      overflow: 'hidden'
	    };

	    var cells = this.getCells();
	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: className, style: style, onDragEnter: this.handleDragEnter }),
	      React.isValidElement(this.props.row) ? this.props.row : cells
	    );
	  };

	  return Row;
	}(React.Component);

	Row.displayName = 'Row';
	Row.propTypes = {
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  row: _propTypes2['default'].any.isRequired,
	  cellRenderer: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  isSelected: _propTypes2['default'].bool,
	  idx: _propTypes2['default'].number.isRequired,
	  expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
	  extraClasses: _propTypes2['default'].string,
	  forceUpdate: _propTypes2['default'].bool,
	  subRowDetails: _propTypes2['default'].object,
	  isRowHovered: _propTypes2['default'].bool,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired
	};
	Row.defaultProps = {
	  cellRenderer: Cell,
	  isSelected: false,
	  height: 35
	};


	module.exports = Row;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.shouldRowUpdate = undefined;

	var _ColumnMetrics = __webpack_require__(31);

	var _ColumnMetrics2 = _interopRequireDefault(_ColumnMetrics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function doesRowContainSelectedCell(props) {
	  var selected = props.cellMetaData.selected;
	  if (selected && selected.rowIdx === props.idx) {
	    return true;
	  }
	  return false;
	}

	function willRowBeDraggedOver(props) {
	  var dragged = props.cellMetaData.dragged;
	  return dragged != null && (dragged.rowIdx >= 0 || dragged.complete === true);
	}

	function hasRowBeenCopied(props) {
	  var copied = props.cellMetaData.copied;
	  return copied != null && copied.rowIdx === props.idx;
	}

	var shouldRowUpdate = exports.shouldRowUpdate = function shouldRowUpdate(nextProps, currentProps) {
	  return !_ColumnMetrics2['default'].sameColumns(currentProps.columns, nextProps.columns, _ColumnMetrics2['default'].sameColumn) || doesRowContainSelectedCell(currentProps) || doesRowContainSelectedCell(nextProps) || willRowBeDraggedOver(nextProps) || nextProps.row !== currentProps.row || currentProps.colDisplayStart !== nextProps.colDisplayStart || currentProps.colDisplayEnd !== nextProps.colDisplayEnd || currentProps.colVisibleStart !== nextProps.colVisibleStart || currentProps.colVisibleEnd !== nextProps.colVisibleEnd || hasRowBeenCopied(currentProps) || currentProps.isSelected !== nextProps.isSelected || nextProps.height !== currentProps.height || currentProps.isOver !== nextProps.isOver || currentProps.expandedRows !== nextProps.expandedRows || currentProps.canDrop !== nextProps.canDrop || currentProps.forceUpdate === true || currentProps.extraClasses !== nextProps.extraClasses;
	};

	exports['default'] = shouldRowUpdate;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	'use strict';

	var RowUtils = {
	  get: function get(row, property) {
	    if (typeof row.get === 'function') {
	      return row.get(property);
	    }

	    return row[property];
	  },
	  isRowSelected: function isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx) {
	    if (indexes && Object.prototype.toString.call(indexes) === '[object Array]') {
	      return indexes.indexOf(rowIdx) > -1;
	    } else if (keys && keys.rowKey && keys.values && Object.prototype.toString.call(keys.values) === '[object Array]') {
	      return keys.values.indexOf(rowData[keys.rowKey]) > -1;
	    } else if (isSelectedKey && rowData && typeof isSelectedKey === 'string') {
	      return rowData[isSelectedKey];
	    }
	    return false;
	  }
	};

	module.exports = RowUtils;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.SimpleRowsContainer = exports.getNewContextMenuProps = exports.DEFAULT_CONTEXT_MENU_ID = undefined;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DEFAULT_CONTEXT_MENU_ID = exports.DEFAULT_CONTEXT_MENU_ID = 'rgdContextMenu';

	var SimpleRowsContainer = function SimpleRowsContainer(props) {
	  return _react2['default'].createElement(
	    'div',
	    { key: 'rows-container' },
	    props.rows
	  );
	};

	SimpleRowsContainer.propTypes = {
	  width: _propTypes2['default'].number,
	  rows: _propTypes2['default'].array
	};

	var getNewContextMenuProps = exports.getNewContextMenuProps = function getNewContextMenuProps(_ref) {
	  var contextMenu = _ref.contextMenu,
	      rowIdx = _ref.rowIdx,
	      idx = _ref.idx;
	  return {
	    rowIdx: rowIdx, idx: idx, id: contextMenu.props.id || DEFAULT_CONTEXT_MENU_ID
	  };
	};

	var RowsContainer = function (_React$Component) {
	  _inherits(RowsContainer, _React$Component);

	  function RowsContainer(props) {
	    _classCallCheck(this, RowsContainer);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.plugins = props.window ? props.window.ReactDataGridPlugins : window.ReactDataGridPlugins;
	    return _this;
	  }

	  RowsContainer.prototype.validatePlugin = function validatePlugin() {
	    if (!this.plugins) {
	      throw new Error('You need to include ReactDataGrid UiPlugins in order to initialise context menu');
	    }
	  };

	  RowsContainer.prototype.hasContextMenu = function hasContextMenu() {
	    return this.props.contextMenu && _react2['default'].isValidElement(this.props.contextMenu);
	  };

	  RowsContainer.prototype.renderRowsWithContextMenu = function renderRowsWithContextMenu() {
	    var ContextMenuTrigger = this.plugins.Menu.ContextMenuTrigger;

	    var newProps = getNewContextMenuProps(this.props);
	    var contextMenu = _react2['default'].cloneElement(this.props.contextMenu, newProps);
	    // Initialise the context menu if it is available
	    return _react2['default'].createElement(
	      'div',
	      null,
	      _react2['default'].createElement(
	        ContextMenuTrigger,
	        { id: newProps.id },
	        _react2['default'].createElement(SimpleRowsContainer, this.props)
	      ),
	      contextMenu
	    );
	  };

	  RowsContainer.prototype.render = function render() {
	    if (this.hasContextMenu()) {
	      this.validatePlugin();
	      return this.renderRowsWithContextMenu();
	    }

	    return _react2['default'].createElement(SimpleRowsContainer, this.props);
	  };

	  return RowsContainer;
	}(_react2['default'].Component);

	RowsContainer.propTypes = {
	  contextMenu: _propTypes2['default'].element,
	  rowIdx: _propTypes2['default'].number,
	  idx: _propTypes2['default'].number,
	  window: _propTypes2['default'].object
	};

	exports['default'] = RowsContainer;
	exports.SimpleRowsContainer = SimpleRowsContainer;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var DEFINE_SORT = {
	  ASC: 'ASC',
	  DESC: 'DESC',
	  NONE: 'NONE'
	};

	var SortableHeaderCell = function (_React$Component) {
	  _inherits(SortableHeaderCell, _React$Component);

	  function SortableHeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, SortableHeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function () {
	      var direction = void 0;
	      var _this$props = _this.props,
	          sortDirection = _this$props.sortDirection,
	          sortDescendingFirst = _this$props.sortDescendingFirst;

	      switch (sortDirection) {
	        default:
	        case null:
	        case undefined:
	        case DEFINE_SORT.NONE:
	          direction = sortDescendingFirst ? DEFINE_SORT.DESC : DEFINE_SORT.ASC;
	          break;
	        case DEFINE_SORT.ASC:
	          direction = sortDescendingFirst ? DEFINE_SORT.NONE : DEFINE_SORT.DESC;
	          break;
	        case DEFINE_SORT.DESC:
	          direction = sortDescendingFirst ? DEFINE_SORT.ASC : DEFINE_SORT.NONE;
	          break;
	      }
	      _this.props.onSort(_this.props.columnKey, direction);
	    }, _this.getSortByText = function () {
	      var unicodeKeys = {
	        ASC: '9650',
	        DESC: '9660'
	      };
	      return _this.props.sortDirection === 'NONE' ? '' : String.fromCharCode(unicodeKeys[_this.props.sortDirection]);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  SortableHeaderCell.prototype.render = function render() {
	    var className = joinClasses({
	      'react-grid-HeaderCell-sortable': true,
	      'react-grid-HeaderCell-sortable--ascending': this.props.sortDirection === 'ASC',
	      'react-grid-HeaderCell-sortable--descending': this.props.sortDirection === 'DESC'
	    });
	    var content = this.props.headerRenderer ? this.props.headerRenderer : this.props.column.name;
	    return React.createElement(
	      'div',
	      { className: className,
	        onClick: this.onClick,
	        style: { cursor: 'pointer' } },
	      React.createElement(
	        'span',
	        { className: 'pull-right' },
	        this.getSortByText()
	      ),
	      content
	    );
	  };

	  return SortableHeaderCell;
	}(React.Component);

	SortableHeaderCell.propTypes = {
	  columnKey: _propTypes2['default'].string.isRequired,
	  column: _propTypes2['default'].shape({ name: _propTypes2['default'].node }),
	  onSort: _propTypes2['default'].func.isRequired,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(DEFINE_SORT)),
	  headerRenderer: _propTypes2['default'].node,
	  sortDescendingFirst: _propTypes2['default'].bool
	};


	module.exports = SortableHeaderCell;
	module.exports.DEFINE_SORT = DEFINE_SORT;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	__webpack_require__(70);

	var CheckboxEditor = function (_React$Component) {
	  _inherits(CheckboxEditor, _React$Component);

	  function CheckboxEditor() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, CheckboxEditor);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleChange = function (e) {
	      _this.props.column.onCellChange(_this.props.rowIdx, _this.props.column.key, _this.props.dependentValues, e);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  CheckboxEditor.prototype.render = function render() {
	    var checked = this.props.value != null ? this.props.value : false;
	    var checkboxName = 'checkbox' + this.props.rowIdx;
	    return React.createElement(
	      'div',
	      { className: 'react-grid-checkbox-container checkbox-align', onClick: this.handleChange },
	      React.createElement('input', { className: 'react-grid-checkbox', type: 'checkbox', name: checkboxName, checked: checked }),
	      React.createElement('label', { htmlFor: checkboxName, className: 'react-grid-checkbox-label' })
	    );
	  };

	  return CheckboxEditor;
	}(React.Component);

	CheckboxEditor.propTypes = {
	  value: _propTypes2['default'].bool,
	  rowIdx: _propTypes2['default'].number,
	  column: _propTypes2['default'].shape({
	    key: _propTypes2['default'].string,
	    onCellChange: _propTypes2['default'].func
	  }),
	  dependentValues: _propTypes2['default'].object
	};


	module.exports = CheckboxEditor;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var ExcelColumn = __webpack_require__(12);

	var EditorBase = function (_React$Component) {
	  _inherits(EditorBase, _React$Component);

	  function EditorBase() {
	    _classCallCheck(this, EditorBase);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  EditorBase.prototype.getStyle = function getStyle() {
	    return {
	      width: '100%'
	    };
	  };

	  EditorBase.prototype.getValue = function getValue() {
	    var updated = {};
	    updated[this.props.column.key] = this.getInputNode().value;
	    return updated;
	  };

	  EditorBase.prototype.getInputNode = function getInputNode() {
	    var domNode = ReactDOM.findDOMNode(this);
	    if (domNode.tagName === 'INPUT') {
	      return domNode;
	    }

	    return domNode.querySelector('input:not([type=hidden])');
	  };

	  EditorBase.prototype.inheritContainerStyles = function inheritContainerStyles() {
	    return true;
	  };

	  return EditorBase;
	}(React.Component);

	EditorBase.propTypes = {
	  onKeyDown: _propTypes2['default'].func.isRequired,
	  value: _propTypes2['default'].any.isRequired,
	  onBlur: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  commit: _propTypes2['default'].func.isRequired
	};

	module.exports = EditorBase;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var EditorBase = __webpack_require__(48);

	var SimpleTextEditor = function (_EditorBase) {
	  _inherits(SimpleTextEditor, _EditorBase);

	  function SimpleTextEditor() {
	    _classCallCheck(this, SimpleTextEditor);

	    return _possibleConstructorReturn(this, _EditorBase.apply(this, arguments));
	  }

	  SimpleTextEditor.prototype.render = function render() {
	    var _this2 = this;

	    return React.createElement('input', { ref: function ref(node) {
	        return _this2.input = node;
	      }, type: 'text', onBlur: this.props.onBlur, className: 'form-control', defaultValue: this.props.value });
	  };

	  return SimpleTextEditor;
	}(EditorBase);

	module.exports = SimpleTextEditor;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var SelectAll = function SelectAll(props) {
	  return _react2['default'].createElement(
	    'div',
	    { className: 'react-grid-checkbox-container checkbox-align' },
	    _react2['default'].createElement('input', {
	      className: 'react-grid-checkbox',
	      type: 'checkbox',
	      name: 'select-all-checkbox',
	      id: 'select-all-checkbox',
	      ref: props.inputRef,
	      onChange: props.onChange
	    }),
	    _react2['default'].createElement('label', { htmlFor: 'select-all-checkbox', className: 'react-grid-checkbox-label' })
	  );
	};

	SelectAll.propTypes = {
	  onChange: _propTypes2['default'].func,
	  inputRef: _propTypes2['default'].func
	};

	exports['default'] = SelectAll;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var SimpleCellFormatter = function (_React$Component) {
	  _inherits(SimpleCellFormatter, _React$Component);

	  function SimpleCellFormatter() {
	    _classCallCheck(this, SimpleCellFormatter);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  SimpleCellFormatter.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return nextProps.value !== this.props.value;
	  };

	  SimpleCellFormatter.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      { title: this.props.value },
	      this.props.value
	    );
	  };

	  return SimpleCellFormatter;
	}(React.Component);

	SimpleCellFormatter.propTypes = {
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired
	};


	module.exports = SimpleCellFormatter;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	"use strict";

	function shallowCloneObject(obj) {
	  var result = {};
	  for (var k in obj) {
	    if (obj.hasOwnProperty(k)) {
	      result[k] = obj[k];
	    }
	  }
	  return result;
	}

	module.exports = shallowCloneObject;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _immutable = __webpack_require__(18);

	module.exports = {
	  isEmptyArray: __webpack_require__(131),
	  isEmptyObject: __webpack_require__(132),
	  isFunction: __webpack_require__(19),
	  isImmutableCollection: __webpack_require__(133),
	  getMixedTypeValueRetriever: __webpack_require__(135),
	  isColumnsImmutable: __webpack_require__(54),
	  isImmutableMap: __webpack_require__(134),
	  last: function last(arrayOrList) {
	    if (arrayOrList == null) {
	      throw new Error('arrayOrCollection is null');
	    }

	    if (_immutable.List.isList(arrayOrList)) {
	      return arrayOrList.last();
	    }

	    if (Array.isArray(arrayOrList)) {
	      return arrayOrList[arrayOrList.length - 1];
	    }

	    throw new Error('Cant get last of: ' + (typeof arrayOrList === 'undefined' ? 'undefined' : _typeof(arrayOrList)));
	  }
	};

/***/ }),
/* 54 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function isColumnsImmutable(columns) {
	  return typeof Immutable !== 'undefined' && columns instanceof Immutable.List;
	};

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	function isKeyPrintable(keycode) {
	  var valid = keycode > 47 && keycode < 58 || // number keys
	  keycode === 32 || keycode === 13 || // spacebar & return key(s) (if you want to allow carriage returns)
	  keycode > 64 && keycode < 91 || // letter keys
	  keycode > 95 && keycode < 112 || // numpad keys
	  keycode > 185 && keycode < 193 || // ;=,-./` (in order)
	  keycode > 218 && keycode < 223; // [\]' (in order)

	  return valid;
	}

	function isCtrlKeyHeldDown(e) {
	  return (e.ctrlKey === true || e.metaKey === true) && e.key !== 'Control';
	}

	exports.isKeyPrintable = isKeyPrintable;
	exports.isCtrlKeyHeldDown = isCtrlKeyHeldDown;

/***/ }),
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */
/***/ (function(module, exports) {

	module.exports = function shallowEqual(objA, objB, compare, compareContext) {

	    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

	    if(ret !== void 0) {
	        return !!ret;
	    }

	    if(objA === objB) {
	        return true;
	    }

	    if(typeof objA !== 'object' || !objA ||
	       typeof objB !== 'object' || !objB) {
	        return false;
	    }

	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);

	    if(keysA.length !== keysB.length) {
	        return false;
	    }

	    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

	    // Test for A's keys different from B.
	    for(var idx = 0; idx < keysA.length; idx++) {

	        var key = keysA[idx];

	        if(!bHasOwnProperty(key)) {
	            return false;
	        }

	        var valueA = objA[key];
	        var valueB = objB[key];

	        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

	        if(ret === false ||
	           ret === void 0 && valueA !== valueB) {
	            return false;
	        }

	    }

	    return true;

	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(139);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-checkbox.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-checkbox.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ }),
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _scrollUtils = __webpack_require__(136);

	var _shallowequal = __webpack_require__(69);

	var _shallowequal2 = _interopRequireDefault(_shallowequal);

	var _RowsContainer = __webpack_require__(45);

	var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

	var _RowGroup = __webpack_require__(121);

	var _RowGroup2 = _interopRequireDefault(_RowGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var joinClasses = __webpack_require__(5);

	var Row = __webpack_require__(42);
	var cellMetaDataShape = __webpack_require__(11);
	var RowUtils = __webpack_require__(44);

	__webpack_require__(20);

	var Canvas = function (_React$Component) {
	  _inherits(Canvas, _React$Component);

	  function Canvas() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Canvas);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      displayStart: _this.props.displayStart,
	      displayEnd: _this.props.displayEnd,
	      scrollingTimeout: null
	    }, _this._currentRowsLength = 0, _this._currentRowsRange = { start: 0, end: 0 }, _this._scroll = { scrollTop: 0, scrollLeft: 0 }, _this.appendScrollShim = function () {
	      if (!_this._scrollShim) {
	        var size = _this._scrollShimSize();
	        var shim = (0, _scrollUtils.createScrollShim)(size);
	        _this.canvas.appendChild(shim);
	        _this._scrollShim = shim;
	      }
	      _this._scheduleRemoveScrollShim();
	    }, _this._scrollShimSize = function () {
	      return {
	        width: _this.props.width,
	        height: _this.props.length * _this.props.rowHeight
	      };
	    }, _this._scheduleRemoveScrollShim = function () {
	      if (_this._scheduleRemoveScrollShimTimer) {
	        clearTimeout(_this._scheduleRemoveScrollShimTimer);
	      }
	      _this._scheduleRemoveScrollShimTimer = setTimeout(_this._removeScrollShim, 200);
	    }, _this._removeScrollShim = function () {
	      if (_this._scrollShim) {
	        _this._scrollShim.parentNode.removeChild(_this._scrollShim);
	        _this._scrollShim = undefined;
	      }
	    }, _this.onRows = function () {
	      if (_this._currentRowsRange !== { start: 0, end: 0 }) {
	        _this.props.onRows(_this._currentRowsRange);
	        _this._currentRowsRange = { start: 0, end: 0 };
	      }
	    }, _this.onScroll = function (e) {
	      if (_this.canvas !== e.target) {
	        return;
	      }
	      _this.appendScrollShim();
	      var scrollLeft = e.target.scrollLeft;
	      var scrollTop = e.target.scrollTop;
	      var scroll = { scrollTop: scrollTop, scrollLeft: scrollLeft };
	      _this._scroll = scroll;
	      _this.props.onScroll(scroll);
	    }, _this.getRows = function (displayStart, displayEnd) {
	      _this._currentRowsRange = { start: displayStart, end: displayEnd };
	      if (Array.isArray(_this.props.rowGetter)) {
	        return _this.props.rowGetter.slice(displayStart, displayEnd);
	      }
	      var rows = [];
	      var i = displayStart;
	      while (i < displayEnd) {
	        var row = _this.props.rowGetter(i);
	        var subRowDetails = {};
	        if (_this.props.getSubRowDetails) {
	          subRowDetails = _this.props.getSubRowDetails(row);
	        }
	        rows.push({ row: row, subRowDetails: subRowDetails });
	        i++;
	      }
	      return rows;
	    }, _this.getScrollbarWidth = function () {
	      // Get the scrollbar width
	      var scrollbarWidth = _this.canvas.offsetWidth - _this.canvas.clientWidth;
	      return scrollbarWidth;
	    }, _this.getScroll = function () {
	      var _this$canvas = _this.canvas,
	          scrollTop = _this$canvas.scrollTop,
	          scrollLeft = _this$canvas.scrollLeft;

	      return { scrollTop: scrollTop, scrollLeft: scrollLeft };
	    }, _this.isRowSelected = function (idx, row) {
	      // Use selectedRows if set
	      if (_this.props.selectedRows !== null) {
	        var selectedRows = _this.props.selectedRows.filter(function (r) {
	          var rowKeyValue = row.get ? row.get(_this.props.rowKey) : row[_this.props.rowKey];
	          return r[_this.props.rowKey] === rowKeyValue;
	        });
	        return selectedRows.length > 0 && selectedRows[0].isSelected;
	      }

	      // Else use new rowSelection props
	      if (_this.props.rowSelection) {
	        var _this$props$rowSelect = _this.props.rowSelection,
	            keys = _this$props$rowSelect.keys,
	            indexes = _this$props$rowSelect.indexes,
	            isSelectedKey = _this$props$rowSelect.isSelectedKey;

	        return RowUtils.isRowSelected(keys, indexes, isSelectedKey, row, idx);
	      }

	      return false;
	    }, _this.setScrollLeft = function (scrollLeft) {
	      if (_this._currentRowsLength !== 0) {
	        if (!_this.rows) return;
	        for (var i = 0, len = _this._currentRowsLength; i < len; i++) {
	          if (_this.rows[i]) {
	            var row = _this.getRowByRef(i);
	            if (row && row.setScrollLeft) {
	              row.setScrollLeft(scrollLeft);
	            }
	          }
	        }
	      }
	    }, _this.getRowByRef = function (i) {
	      // check if wrapped with React DND drop target
	      var wrappedRow = _this.rows[i].getDecoratedComponentInstance ? _this.rows[i].getDecoratedComponentInstance(i) : null;
	      if (wrappedRow) {
	        return wrappedRow.row;
	      }
	      return _this.rows[i];
	    }, _this.renderRow = function (props) {
	      var row = props.row;
	      if (row.__metaData && row.__metaData.getRowRenderer) {
	        return row.__metaData.getRowRenderer(_this.props, props.idx);
	      }
	      if (row.__metaData && row.__metaData.isGroup) {
	        return React.createElement(_RowGroup2['default'], _extends({}, props, row.__metaData, {
	          name: row.name,
	          renderer: _this.props.rowGroupRenderer }));
	      }
	      var RowsRenderer = _this.props.rowRenderer;
	      if (typeof RowsRenderer === 'function') {
	        return React.createElement(RowsRenderer, props);
	      }

	      if (React.isValidElement(_this.props.rowRenderer)) {
	        return React.cloneElement(_this.props.rowRenderer, props);
	      }
	    }, _this.renderPlaceholder = function (key, height) {
	      // just renders empty cells
	      // if we wanted to show gridlines, we'd need classes and position as with renderScrollingPlaceholder
	      return React.createElement(
	        'div',
	        { key: key, style: { height: height } },
	        _this.props.columns.map(function (column, idx) {
	          return React.createElement('div', { style: { width: column.width }, key: idx });
	        })
	      );
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Canvas.prototype.componentWillMount = function componentWillMount() {
	    this.rows = [];
	    this._currentRowsLength = 0;
	    this._currentRowsRange = { start: 0, end: 0 };
	    this._scroll = { scrollTop: 0, scrollLeft: 0 };
	  };

	  Canvas.prototype.componentDidMount = function componentDidMount() {
	    this.onRows();
	  };

	  Canvas.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.displayStart !== this.state.displayStart || nextProps.displayEnd !== this.state.displayEnd) {
	      this.setState({
	        displayStart: nextProps.displayStart,
	        displayEnd: nextProps.displayEnd
	      });
	    }
	  };

	  Canvas.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	    var shouldUpdate = nextState.displayStart !== this.state.displayStart || nextState.displayEnd !== this.state.displayEnd || nextState.scrollingTimeout !== this.state.scrollingTimeout || this.props.scrollToRowIndex !== nextProps.scrollToRowIndex || nextProps.rowsCount !== this.props.rowsCount || nextProps.rowHeight !== this.props.rowHeight || nextProps.columns !== this.props.columns || nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.cellMetaData !== this.props.cellMetaData || this.props.colDisplayStart !== nextProps.colDisplayStart || this.props.colDisplayEnd !== nextProps.colDisplayEnd || this.props.colVisibleStart !== nextProps.colVisibleStart || this.props.colVisibleEnd !== nextProps.colVisibleEnd || !(0, _shallowequal2['default'])(nextProps.style, this.props.style) || this.props.isScrolling !== nextProps.isScrolling;
	    return shouldUpdate;
	  };

	  Canvas.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._currentRowsLength = 0;
	    this._currentRowsRange = { start: 0, end: 0 };
	    this._scroll = { scrollTop: 0, scrollLeft: 0 };
	  };

	  Canvas.prototype.componentDidUpdate = function componentDidUpdate() {
	    if (this._scroll.scrollTop !== 0 && this._scroll.scrollLeft !== 0) {
	      this.setScrollLeft(this._scroll.scrollLeft);
	    }
	    if (this.props.scrollToRowIndex !== 0) {
	      this.canvas.scrollTop = Math.min(this.props.scrollToRowIndex * this.props.rowHeight, this.props.rowsCount * this.props.rowHeight - this.props.height);
	    }
	    this.onRows();
	  };

	  Canvas.prototype.render = function render() {
	    var _this2 = this;

	    var _state = this.state,
	        displayStart = _state.displayStart,
	        displayEnd = _state.displayEnd;
	    var _props = this.props,
	        rowHeight = _props.rowHeight,
	        rowsCount = _props.rowsCount;


	    var rows = this.getRows(displayStart, displayEnd).map(function (r, idx) {
	      return _this2.renderRow({
	        key: 'row-' + (displayStart + idx),
	        ref: function ref(node) {
	          return _this2.rows[idx] = node;
	        },
	        idx: displayStart + idx,
	        visibleStart: _this2.props.visibleStart,
	        visibleEnd: _this2.props.visibleEnd,
	        row: r.row,
	        height: rowHeight,
	        onMouseOver: _this2.onMouseOver,
	        columns: _this2.props.columns,
	        isSelected: _this2.isRowSelected(displayStart + idx, r.row, displayStart, displayEnd),
	        expandedRows: _this2.props.expandedRows,
	        cellMetaData: _this2.props.cellMetaData,
	        subRowDetails: r.subRowDetails,
	        colVisibleStart: _this2.props.colVisibleStart,
	        colVisibleEnd: _this2.props.colVisibleEnd,
	        colDisplayStart: _this2.props.colDisplayStart,
	        colDisplayEnd: _this2.props.colDisplayEnd,
	        isScrolling: _this2.props.isScrolling
	      });
	    });

	    this._currentRowsLength = rows.length;

	    if (displayStart > 0) {
	      rows.unshift(this.renderPlaceholder('top', displayStart * rowHeight));
	    }

	    if (rowsCount - displayEnd > 0) {
	      rows.push(this.renderPlaceholder('bottom', (rowsCount - displayEnd) * rowHeight));
	    }

	    var style = {
	      position: 'absolute',
	      top: 0,
	      left: 0,
	      overflowX: 'auto',
	      overflowY: 'scroll',
	      width: this.props.totalWidth,
	      height: this.props.height
	    };

	    return React.createElement(
	      'div',
	      {
	        ref: function ref(div) {
	          _this2.canvas = div;
	        },
	        style: style,
	        onScroll: this.onScroll,
	        className: joinClasses('react-grid-Canvas', this.props.className, { opaque: this.props.cellMetaData.selected && this.props.cellMetaData.selected.active }) },
	      React.createElement(_RowsContainer2['default'], {
	        width: this.props.width,
	        rows: rows,
	        contextMenu: this.props.contextMenu,
	        rowIdx: this.props.cellMetaData.selected.rowIdx,
	        idx: this.props.cellMetaData.selected.idx })
	    );
	  };

	  return Canvas;
	}(React.Component);

	Canvas.displayName = 'Canvas';
	Canvas.propTypes = {
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]),
	  rowHeight: _propTypes2['default'].number.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  width: _propTypes2['default'].number,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  style: _propTypes2['default'].string,
	  className: _propTypes2['default'].string,
	  displayStart: _propTypes2['default'].number.isRequired,
	  displayEnd: _propTypes2['default'].number.isRequired,
	  visibleStart: _propTypes2['default'].number.isRequired,
	  visibleEnd: _propTypes2['default'].number.isRequired,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  rowsCount: _propTypes2['default'].number.isRequired,
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].func.isRequired, _propTypes2['default'].array.isRequired]),
	  expandedRows: _propTypes2['default'].array,
	  onRows: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape).isRequired,
	  selectedRows: _propTypes2['default'].array,
	  rowKey: _propTypes2['default'].string,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  rowGroupRenderer: _propTypes2['default'].func,
	  isScrolling: _propTypes2['default'].bool,
	  length: _propTypes2['default'].number
	};
	Canvas.defaultProps = {
	  rowRenderer: Row,
	  onRows: function onRows() {},
	  selectedRows: [],
	  rowScrollTimeout: 0
	};


	module.exports = Canvas;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _CellActionShape = __webpack_require__(117);

	var _CellActionShape2 = _interopRequireDefault(_CellActionShape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellAction = function (_React$Component) {
	  _inherits(CellAction, _React$Component);

	  function CellAction() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, CellAction);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { isMenuOpen: false }, _this.onToggleMenu = function () {
	      _this.setState(function (prevState) {
	        return { isMenuOpen: !prevState.isMenuOpen };
	      });
	    }, _this.onHideMenu = function () {
	      _this.setState({ isMenuOpen: false });
	    }, _this.onGetMenuOptions = function () {
	      return _this.props.action.actions.map(function (action, index) {
	        return _react2['default'].createElement(
	          'span',
	          { key: index, onClick: action.callback },
	          action.text
	        );
	      });
	    }, _this.isActionMenu = function () {
	      return !_this.props.action.callback && _this.props.action.actions && _this.props.action.actions.length;
	    }, _this.onActionButtonBlur = function () {
	      if (_this.isActionMenu()) {
	        _this.onHideMenu();
	      }
	    }, _this.onActionIconClick = function () {
	      if (!_this.isActionMenu()) {
	        _this.props.action.callback();
	      } else if (_this.props.action.actions && _this.props.action.actions.length) {
	        _this.onToggleMenu();
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  CellAction.prototype.render = function render() {
	    var isActionMenu = this.isActionMenu();

	    var cellActionClasses = (0, _classnames2['default'])('rdg-cell-action', {
	      'rdg-cell-action-last': this.props.isFirst
	    });

	    var actionButtonClasses = (0, _classnames2['default'])('rdg-cell-action-button', {
	      'rdg-cell-action-button-toggled': this.state.isMenuOpen
	    });

	    return _react2['default'].createElement(
	      'div',
	      { className: cellActionClasses, onMouseLeave: this.onActionButtonBlur },
	      _react2['default'].createElement(
	        'div',
	        { className: actionButtonClasses, onClick: this.onActionIconClick },
	        _react2['default'].createElement('span', { className: this.props.action.icon })
	      ),
	      isActionMenu && this.state.isMenuOpen && _react2['default'].createElement(
	        'div',
	        { className: 'rdg-cell-action-menu' },
	        this.onGetMenuOptions()
	      )
	    );
	  };

	  return CellAction;
	}(_react2['default'].Component);

	CellAction.propTypes = {
	  action: _propTypes2['default'].shape(_CellActionShape2['default']).isRequired,
	  isFirst: _propTypes2['default'].bool.isRequired
	};
	exports['default'] = CellAction;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _AppConstants = __webpack_require__(30);

	var _AppConstants2 = _interopRequireDefault(_AppConstants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellExpand = function (_React$Component) {
	  _inherits(CellExpand, _React$Component);

	  function CellExpand(props) {
	    _classCallCheck(this, CellExpand);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.onCellExpand = function (e) {
	      _this.setState({ expanded: !_this.state.expanded });
	      _this.props.onCellExpand(e);
	    };

	    var expanded = props.expandableOptions && props.expandableOptions.expanded;
	    _this.state = { expanded: expanded };
	    return _this;
	  }

	  CellExpand.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    var expanded = nextProps.expandableOptions && nextProps.expandableOptions.expanded;
	    if (this.state.expanded !== expanded) {
	      this.setState({ expanded: expanded });
	    }
	  };

	  CellExpand.prototype.render = function render() {
	    return _react2['default'].createElement(
	      'span',
	      { className: 'rdg-cell-expand', onClick: this.onCellExpand },
	      this.state.expanded ? _AppConstants2['default'].CellExpand.DOWN_TRIANGLE : _AppConstants2['default'].CellExpand.RIGHT_TRIANGLE
	    );
	  };

	  return CellExpand;
	}(_react2['default'].Component);

	CellExpand.propTypes = {
	  expandableOptions: _propTypes2['default'].object.isRequired,
	  onCellExpand: _propTypes2['default'].func.isRequired
	};
	exports['default'] = CellExpand;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var ChildRowDeleteButton = function ChildRowDeleteButton(_ref) {
	  var treeDepth = _ref.treeDepth,
	      cellHeight = _ref.cellHeight,
	      siblingIndex = _ref.siblingIndex,
	      numberSiblings = _ref.numberSiblings,
	      onDeleteSubRow = _ref.onDeleteSubRow,
	      isDeleteSubRowEnabled = _ref.isDeleteSubRowEnabled,
	      _ref$allowAddChildRow = _ref.allowAddChildRow,
	      allowAddChildRow = _ref$allowAddChildRow === undefined ? true : _ref$allowAddChildRow;

	  var lastSibling = siblingIndex === numberSiblings - 1;
	  var className = (0, _classnames2['default'])({ 'rdg-child-row-action-cross': allowAddChildRow === true || !lastSibling }, { 'rdg-child-row-action-cross-last': allowAddChildRow === false && (lastSibling || numberSiblings === 1) });
	  var height = 12;
	  var width = 12;
	  var left = treeDepth * 15;
	  var top = (cellHeight - 12) / 2;
	  return _react2['default'].createElement(
	    'div',
	    null,
	    _react2['default'].createElement('div', { className: className }),
	    isDeleteSubRowEnabled && _react2['default'].createElement(
	      'div',
	      { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: onDeleteSubRow },
	      _react2['default'].createElement('div', { className: 'glyphicon glyphicon-remove-sign' })
	    )
	  );
	};

	exports['default'] = ChildRowDeleteButton;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var isValidElement = __webpack_require__(2).isValidElement;

	module.exports = function sameColumn(a, b) {
	  var k = void 0;

	  for (k in a) {
	    if (a.hasOwnProperty(k)) {
	      if (typeof a[k] === 'function' && typeof b[k] === 'function' || isValidElement(a[k]) && isValidElement(b[k])) {
	        continue;
	      }
	      if (!b.hasOwnProperty(k) || a[k] !== b[k]) {
	        return false;
	      }
	    }
	  }

	  for (k in b) {
	    if (b.hasOwnProperty(k) && !a.hasOwnProperty(k)) {
	      return false;
	    }
	  }

	  return true;
	};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(15);

	// The list of the propTypes that we want to include in the Draggable div
	var knownDivPropertyKeys = ['onDragStart', 'onDragEnd', 'onDrag', 'style'];

	var Draggable = function (_React$Component) {
	  _inherits(Draggable, _React$Component);

	  function Draggable() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Draggable);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      drag: null
	    }, _this.onMouseDown = function (e) {
	      var drag = _this.props.onDragStart(e);
	      if (e.preventDefault) {
	        e.preventDefault();
	      }

	      if (drag === null && e.button !== 0) {
	        return;
	      }

	      window.addEventListener('mouseup', _this.onMouseUp);
	      window.addEventListener('mousemove', _this.onMouseMove);
	      window.addEventListener('touchend', _this.onMouseUp);
	      window.addEventListener('touchmove', _this.onMouseMove);

	      _this.setState({ drag: drag });
	    }, _this.onMouseMove = function (e) {
	      if (_this.state.drag === null) {
	        return;
	      }

	      if (e.preventDefault) {
	        e.preventDefault();
	      }

	      _this.props.onDrag(e);
	    }, _this.onMouseUp = function (e) {
	      _this.cleanUp();
	      _this.props.onDragEnd(e, _this.state.drag);
	      _this.setState({ drag: null });
	    }, _this.cleanUp = function () {
	      window.removeEventListener('mouseup', _this.onMouseUp);
	      window.removeEventListener('mousemove', _this.onMouseMove);
	      window.removeEventListener('touchend', _this.onMouseUp);
	      window.removeEventListener('touchmove', _this.onMouseMove);
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Draggable.prototype.componentWillUnmount = function componentWillUnmount() {
	    this.cleanUp();
	  };

	  Draggable.prototype.render = function render() {
	    return React.createElement('div', _extends({}, this.getKnownDivProps(), {
	      onMouseDown: this.onMouseDown,
	      onTouchStart: this.onMouseDown,
	      className: 'react-grid-HeaderCell__draggable' }));
	  };

	  return Draggable;
	}(React.Component);

	Draggable.propTypes = {
	  onDragStart: _propTypes2['default'].func,
	  onDragEnd: _propTypes2['default'].func,
	  onDrag: _propTypes2['default'].func,
	  component: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].constructor]),
	  style: _propTypes2['default'].object
	};
	Draggable.defaultProps = {
	  onDragStart: function onDragStart() {
	    return true;
	  },
	  onDragEnd: function onDragEnd() {},
	  onDrag: function onDrag() {}
	};


	module.exports = Draggable;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EmptyChildRow = function (_React$Component) {
	  _inherits(EmptyChildRow, _React$Component);

	  function EmptyChildRow() {
	    _classCallCheck(this, EmptyChildRow);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this));

	    _this.onAddSubRow = _this.onAddSubRow.bind(_this);
	    return _this;
	  }

	  EmptyChildRow.prototype.onAddSubRow = function onAddSubRow() {
	    this.props.onAddSubRow(this.props.parentRowId);
	  };

	  EmptyChildRow.prototype.getFixedColumnsWidth = function getFixedColumnsWidth() {
	    var fixedWidth = 0;
	    var size = _ColumnUtils2['default'].getSize(this.props.columns);
	    for (var i = 0; i < size; i++) {
	      var column = _ColumnUtils2['default'].getColumn(this.props.columns, i);
	      if (column) {
	        if (_ColumnUtils2['default'].getValue(column, 'locked')) {
	          fixedWidth += _ColumnUtils2['default'].getValue(column, 'width');
	        }
	      }
	    }
	    return fixedWidth;
	  };

	  EmptyChildRow.prototype.render = function render() {
	    var _this2 = this;

	    var _props = this.props,
	        cellHeight = _props.cellHeight,
	        treeDepth = _props.treeDepth;

	    var height = 12;
	    var width = 12;
	    var left = treeDepth * 15;
	    var top = (cellHeight - 12) / 2;
	    var style = {
	      height: cellHeight,
	      borderBottom: '1px solid #dddddd'
	    };
	    var expandColumn = _ColumnUtils2['default'].getColumn(this.props.columns.filter(function (c) {
	      return c.key === _this2.props.expandColumnKey;
	    }), 0);

	    var cellLeft = expandColumn ? expandColumn.left : 0;
	    return _react2['default'].createElement(
	      'div',
	      { className: 'react-grid-Row rdg-add-child-row-container', style: style },
	      _react2['default'].createElement(
	        'div',
	        { className: 'react-grid-Cell', style: { position: 'absolute', height: cellHeight, width: '100%', left: cellLeft } },
	        _react2['default'].createElement(
	          'div',
	          { className: 'rdg-empty-child-row', style: { marginLeft: '30px', lineHeight: cellHeight + 'px' } },
	          _react2['default'].createElement('div', { className: '\'rdg-child-row-action-cross rdg-child-row-action-cross-last' }),
	          _react2['default'].createElement(
	            'div',
	            { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: this.onAddSubRow },
	            _react2['default'].createElement('div', { className: 'glyphicon glyphicon-plus-sign' })
	          )
	        )
	      )
	    );
	  };

	  return EmptyChildRow;
	}(_react2['default'].Component);

	EmptyChildRow.propTypes = {
	  treeDepth: _propTypes2['default'].number.isRequired,
	  cellHeight: _propTypes2['default'].number.isRequired,
	  onAddSubRow: _propTypes2['default'].func.isRequired,
	  parentRowId: _propTypes2['default'].number,
	  columns: _propTypes2['default'].array.isRequired,
	  expandColumnKey: _propTypes2['default'].string.isRequired
	};

	exports['default'] = EmptyChildRow;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);

	var Header = __webpack_require__(112);
	var Viewport = __webpack_require__(122);
	var cellMetaDataShape = __webpack_require__(11);
	__webpack_require__(20);

	var Grid = function (_React$Component) {
	  _inherits(Grid, _React$Component);

	  function Grid() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Grid);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getStyle = function () {
	      return {
	        overflow: 'hidden',
	        outline: 0,
	        position: 'relative',
	        minHeight: _this.props.minHeight
	      };
	    }, _this._onScroll = function () {
	      if (_this._scrollLeft !== undefined) {
	        _this.header.setScrollLeft(_this._scrollLeft);
	        if (_this.viewport) {
	          _this.viewport.setScrollLeft(_this._scrollLeft);
	        }
	      }
	    }, _this.onScroll = function (props) {
	      if (_this._scrollLeft !== props.scrollLeft) {
	        _this._scrollLeft = props.scrollLeft;
	        _this._onScroll();
	      }
	    }, _this.onHeaderScroll = function (e) {
	      var scrollLeft = e.target.scrollLeft;
	      if (_this._scrollLeft !== scrollLeft) {
	        _this._scrollLeft = scrollLeft;
	        _this.header.setScrollLeft(scrollLeft);
	        var canvas = ReactDOM.findDOMNode(_this.viewport.canvas);
	        canvas.scrollLeft = scrollLeft;
	        _this.viewport.canvas.setScrollLeft(scrollLeft);
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Grid.prototype.componentDidMount = function componentDidMount() {
	    this._scrollLeft = this.viewport ? this.viewport.getScroll().scrollLeft : 0;
	    this._onScroll();
	  };

	  Grid.prototype.componentDidUpdate = function componentDidUpdate() {
	    this._onScroll();
	  };

	  Grid.prototype.componentWillMount = function componentWillMount() {
	    this._scrollLeft = undefined;
	  };

	  Grid.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._scrollLeft = undefined;
	  };

	  Grid.prototype.render = function render() {
	    var _this2 = this;

	    var headerRows = this.props.headerRows || [{ ref: function ref(node) {
	        return _this2.row = node;
	      } }];
	    var EmptyRowsView = this.props.emptyRowsView;

	    return React.createElement(
	      'div',
	      { style: this.getStyle(), className: 'react-grid-Grid' },
	      React.createElement(Header, {
	        ref: function ref(input) {
	          _this2.header = input;
	        },
	        columnMetrics: this.props.columnMetrics,
	        onColumnResize: this.props.onColumnResize,
	        height: this.props.rowHeight,
	        totalWidth: this.props.totalWidth,
	        headerRows: headerRows,
	        sortColumn: this.props.sortColumn,
	        sortDirection: this.props.sortDirection,
	        draggableHeaderCell: this.props.draggableHeaderCell,
	        onSort: this.props.onSort,
	        onHeaderDrop: this.props.onHeaderDrop,
	        onScroll: this.onHeaderScroll,
	        getValidFilterValues: this.props.getValidFilterValues,
	        cellMetaData: this.props.cellMetaData
	      }),
	      this.props.rowsCount >= 1 || this.props.rowsCount === 0 && !this.props.emptyRowsView ? React.createElement(
	        'div',
	        {
	          ref: function ref(node) {
	            _this2.viewPortContainer = node;
	          },
	          tabIndex: this.props.tabIndex,
	          onKeyDown: this.props.onViewportKeydown,
	          onKeyUp: this.props.onViewportKeyup,
	          onClick: this.props.onViewportClick,
	          onDoubleClick: this.props.onViewportDoubleClick,
	          onDragStart: this.props.onViewportDragStart,
	          onDragEnd: this.props.onViewportDragEnd },
	        React.createElement(Viewport, {
	          ref: function ref(node) {
	            _this2.viewport = node;
	          },
	          rowKey: this.props.rowKey,
	          width: this.props.columnMetrics.width,
	          rowHeight: this.props.rowHeight,
	          rowRenderer: this.props.rowRenderer,
	          rowGetter: this.props.rowGetter,
	          rowsCount: this.props.rowsCount,
	          selectedRows: this.props.selectedRows,
	          expandedRows: this.props.expandedRows,
	          columnMetrics: this.props.columnMetrics,
	          totalWidth: this.props.totalWidth,
	          onScroll: this.onScroll,
	          onRows: this.props.onRows,
	          cellMetaData: this.props.cellMetaData,
	          rowOffsetHeight: this.props.rowOffsetHeight || this.props.rowHeight * headerRows.length,
	          minHeight: this.props.minHeight,
	          rowScrollTimeout: this.props.rowScrollTimeout,
	          scrollToRowIndex: this.props.scrollToRowIndex,
	          contextMenu: this.props.contextMenu,
	          rowSelection: this.props.rowSelection,
	          getSubRowDetails: this.props.getSubRowDetails,
	          rowGroupRenderer: this.props.rowGroupRenderer,
	          overScan: this.props.overScan
	        })
	      ) : React.createElement(
	        'div',
	        { ref: function ref(node) {
	            _this2.emptyView = node;
	          }, className: 'react-grid-Empty' },
	        React.createElement(EmptyRowsView, null)
	      )
	    );
	  };

	  return Grid;
	}(React.Component);

	Grid.displayName = 'Grid';
	Grid.propTypes = {
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]),
	  tabIndex: _propTypes2['default'].number,
	  columnMetrics: _propTypes2['default'].object,
	  minHeight: _propTypes2['default'].number,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  headerRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  rowHeight: _propTypes2['default'].number,
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
	  emptyRowsView: _propTypes2['default'].func,
	  expandedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  selectedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  rowsCount: _propTypes2['default'].number,
	  onRows: _propTypes2['default'].func,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
	  rowOffsetHeight: _propTypes2['default'].number.isRequired,
	  onViewportKeydown: _propTypes2['default'].func.isRequired,
	  onViewportKeyup: _propTypes2['default'].func,
	  onViewportDragStart: _propTypes2['default'].func.isRequired,
	  onViewportDragEnd: _propTypes2['default'].func.isRequired,
	  onViewportClick: _propTypes2['default'].func.isRequired,
	  onViewportDoubleClick: _propTypes2['default'].func.isRequired,
	  onColumnResize: _propTypes2['default'].func,
	  onSort: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  rowKey: _propTypes2['default'].string.isRequired,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func,
	  overScan: _propTypes2['default'].object
	};
	Grid.defaultProps = {
	  rowHeight: 35,
	  minHeight: 350,
	  tabIndex: 0
	};


	module.exports = Grid;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var joinClasses = __webpack_require__(5);
	var shallowCloneObject = __webpack_require__(52);
	var ColumnMetrics = __webpack_require__(31);
	var ColumnUtils = __webpack_require__(6);
	var HeaderRow = __webpack_require__(114);
	var getScrollbarSize = __webpack_require__(32);

	var createObjectWithProperties = __webpack_require__(14);
	var cellMetaDataShape = __webpack_require__(11);
	__webpack_require__(15);

	// The list of the propTypes that we want to include in the Header div
	var knownDivPropertyKeys = ['height', 'onScroll'];

	var Header = function (_React$Component) {
	  _inherits(Header, _React$Component);

	  function Header() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Header);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: null }, _this.onColumnResize = function (column, width) {
	      var state = _this.state.resizing || _this.props;

	      var pos = _this.getColumnPosition(column);

	      if (pos != null) {
	        var _resizing = {
	          columnMetrics: shallowCloneObject(state.columnMetrics)
	        };
	        _resizing.columnMetrics = ColumnMetrics.resizeColumn(_resizing.columnMetrics, pos, width);

	        // we don't want to influence scrollLeft while resizing
	        if (_resizing.columnMetrics.totalWidth < state.columnMetrics.totalWidth) {
	          _resizing.columnMetrics.totalWidth = state.columnMetrics.totalWidth;
	        }

	        _resizing.column = ColumnUtils.getColumn(_resizing.columnMetrics.columns, pos);
	        _this.setState({ resizing: _resizing });
	      }
	    }, _this.onColumnResizeEnd = function (column, width) {
	      var pos = _this.getColumnPosition(column);
	      if (pos !== null && _this.props.onColumnResize) {
	        _this.props.onColumnResize(pos, width || column.width);
	      }
	    }, _this.getHeaderRows = function () {
	      var columnMetrics = _this.getColumnMetrics();
	      var resizeColumn = void 0;
	      if (_this.state.resizing) {
	        resizeColumn = _this.state.resizing.column;
	      }
	      var headerRows = [];
	      _this.props.headerRows.forEach(function (row, index) {
	        // To allow header filters to be visible
	        var rowHeight = 'auto';
	        if (row.rowType === 'filter') {
	          rowHeight = '500px';
	        }
	        var scrollbarSize = getScrollbarSize() > 0 ? getScrollbarSize() : 0;
	        var updatedWidth = isNaN(_this.props.totalWidth - scrollbarSize) ? _this.props.totalWidth : _this.props.totalWidth - scrollbarSize;
	        var headerRowStyle = {
	          position: 'absolute',
	          top: _this.getCombinedHeaderHeights(index),
	          left: 0,
	          width: updatedWidth,
	          overflowX: 'hidden',
	          minHeight: rowHeight
	        };

	        headerRows.push(React.createElement(HeaderRow, {
	          key: row.ref,
	          ref: function ref(node) {
	            return row.rowType === 'filter' ? _this.filterRow = node : _this.row = node;
	          },
	          rowType: row.rowType,
	          style: headerRowStyle,
	          onColumnResize: _this.onColumnResize,
	          onColumnResizeEnd: _this.onColumnResizeEnd,
	          width: columnMetrics.width,
	          height: row.height || _this.props.height,
	          columns: columnMetrics.columns,
	          resizing: resizeColumn,
	          draggableHeaderCell: _this.props.draggableHeaderCell,
	          filterable: row.filterable,
	          onFilterChange: row.onFilterChange,
	          onHeaderDrop: _this.props.onHeaderDrop,
	          sortColumn: _this.props.sortColumn,
	          sortDirection: _this.props.sortDirection,
	          onSort: _this.props.onSort,
	          onScroll: _this.props.onScroll,
	          getValidFilterValues: _this.props.getValidFilterValues
	        }));
	      });
	      return headerRows;
	    }, _this.getColumnMetrics = function () {
	      var columnMetrics = void 0;
	      if (_this.state.resizing) {
	        columnMetrics = _this.state.resizing.columnMetrics;
	      } else {
	        columnMetrics = _this.props.columnMetrics;
	      }
	      return columnMetrics;
	    }, _this.getColumnPosition = function (column) {
	      var columnMetrics = _this.getColumnMetrics();
	      var pos = -1;
	      columnMetrics.columns.forEach(function (c, idx) {
	        if (c.key === column.key) {
	          pos = idx;
	        }
	      });
	      return pos === -1 ? null : pos;
	    }, _this.getCombinedHeaderHeights = function (until) {
	      var stopAt = _this.props.headerRows.length;
	      if (typeof until !== 'undefined') {
	        stopAt = until;
	      }

	      var height = 0;
	      for (var index = 0; index < stopAt; index++) {
	        height += _this.props.headerRows[index].height || _this.props.height;
	      }
	      return height;
	    }, _this.getStyle = function () {
	      return {
	        position: 'relative',
	        height: _this.getCombinedHeaderHeights()
	      };
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = ReactDOM.findDOMNode(_this.row);
	      node.scrollLeft = scrollLeft;
	      _this.row.setScrollLeft(scrollLeft);
	      if (_this.filterRow) {
	        var nodeFilters = ReactDOM.findDOMNode(_this.filterRow);
	        nodeFilters.scrollLeft = scrollLeft;
	        _this.filterRow.setScrollLeft(scrollLeft);
	      }
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _this.onHeaderClick = function () {
	      _this.props.cellMetaData.onCellClick({ rowIdx: -1, idx: -1 });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Header.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
	    this.setState({ resizing: null });
	  };

	  Header.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	    var update = !ColumnMetrics.sameColumns(this.props.columnMetrics.columns, nextProps.columnMetrics.columns, ColumnMetrics.sameColumn) || this.props.totalWidth !== nextProps.totalWidth || this.props.headerRows.length !== nextProps.headerRows.length || this.state.resizing !== nextState.resizing || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
	    return update;
	  };

	  // Set the cell selection to -1 x -1 when clicking on the header


	  Header.prototype.render = function render() {
	    var className = joinClasses({
	      'react-grid-Header': true,
	      'react-grid-Header--resizing': !!this.state.resizing
	    });
	    var headerRows = this.getHeaderRows();

	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { style: this.getStyle(), className: className, onClick: this.onHeaderClick }),
	      headerRows
	    );
	  };

	  return Header;
	}(React.Component);

	Header.propTypes = {
	  columnMetrics: _propTypes2['default'].shape({ width: _propTypes2['default'].number.isRequired, columns: _propTypes2['default'].any }).isRequired,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number.isRequired,
	  headerRows: _propTypes2['default'].array.isRequired,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
	  onSort: _propTypes2['default'].func,
	  onColumnResize: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape)
	};


	module.exports = Header;

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";

	var HeaderCellType = {
	  SORTABLE: 0,
	  FILTERABLE: 1,
	  NONE: 2,
	  CHECKBOX: 3
	};

	module.exports = HeaderCellType;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var shallowEqual = __webpack_require__(69);
	var BaseHeaderCell = __webpack_require__(41);
	var getScrollbarSize = __webpack_require__(32);
	var ExcelColumn = __webpack_require__(12);
	var columnUtils = __webpack_require__(6);
	var SortableHeaderCell = __webpack_require__(46);
	var FilterableHeaderCell = __webpack_require__(123);
	var HeaderCellType = __webpack_require__(113);
	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(15);

	var HeaderRowStyle = {
	  overflow: _propTypes2['default'].string,
	  width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number,
	  position: _propTypes2['default'].string
	};

	// The list of the propTypes that we want to include in the HeaderRow div
	var knownDivPropertyKeys = ['width', 'height', 'style', 'onScroll'];

	var HeaderRow = function (_React$Component) {
	  _inherits(HeaderRow, _React$Component);

	  function HeaderRow() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, HeaderRow);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getHeaderCellType = function (column) {
	      if (column.filterable) {
	        if (_this.props.filterable) return HeaderCellType.FILTERABLE;
	      }

	      if (column.sortable && column.rowType !== 'filter') return HeaderCellType.SORTABLE;

	      return HeaderCellType.NONE;
	    }, _this.getFilterableHeaderCell = function (column) {
	      var FilterRenderer = FilterableHeaderCell;
	      if (column.filterRenderer !== undefined) {
	        FilterRenderer = column.filterRenderer;
	      }
	      return React.createElement(FilterRenderer, _extends({}, _this.props, { onChange: _this.props.onFilterChange }));
	    }, _this.getSortableHeaderCell = function (column) {
	      var sortDirection = _this.props.sortColumn === column.key ? _this.props.sortDirection : SortableHeaderCell.DEFINE_SORT.NONE;
	      var sortDescendingFirst = column.sortDescendingFirst === undefined ? false : column.sortDescendingFirst;
	      return React.createElement(SortableHeaderCell, { columnKey: column.key, onSort: _this.props.onSort, sortDirection: sortDirection, sortDescendingFirst: sortDescendingFirst, headerRenderer: column.headerRenderer });
	    }, _this.getHeaderRenderer = function (column) {
	      var renderer = void 0;
	      if (column.headerRenderer && !column.sortable && !_this.props.filterable) {
	        renderer = column.headerRenderer;
	      } else {
	        var headerCellType = _this.getHeaderCellType(column);
	        switch (headerCellType) {
	          case HeaderCellType.SORTABLE:
	            renderer = _this.getSortableHeaderCell(column);
	            break;
	          case HeaderCellType.FILTERABLE:
	            renderer = _this.getFilterableHeaderCell(column);
	            break;
	          default:
	            break;
	        }
	      }
	      return renderer;
	    }, _this.getStyle = function () {
	      return {
	        overflow: 'hidden',
	        width: '100%',
	        height: _this.props.height,
	        position: 'absolute'
	      };
	    }, _this.getCells = function () {
	      var cells = [];
	      var lockedCells = [];

	      var _loop = function _loop(i, len) {
	        var column = Object.assign({ rowType: _this.props.rowType }, columnUtils.getColumn(_this.props.columns, i));
	        var _renderer = _this.getHeaderRenderer(column);
	        if (column.key === 'select-row' && _this.props.rowType === 'filter') {
	          _renderer = React.createElement('div', null);
	        }
	        var HeaderCell = column.draggable ? _this.props.draggableHeaderCell : BaseHeaderCell;
	        var cell = React.createElement(HeaderCell, {
	          ref: function ref(node) {
	            return _this.cells[i] = node;
	          },
	          key: i,
	          height: _this.props.height,
	          column: column,
	          renderer: _renderer,
	          resizing: _this.props.resizing === column,
	          onResize: _this.props.onColumnResize,
	          onResizeEnd: _this.props.onColumnResizeEnd,
	          onHeaderDrop: _this.props.onHeaderDrop
	        });
	        if (column.locked) {
	          lockedCells.push(cell);
	        } else {
	          cells.push(cell);
	        }
	      };

	      for (var i = 0, len = columnUtils.getSize(_this.props.columns); i < len; i++) {
	        _loop(i, len);
	      }

	      return cells.concat(lockedCells);
	    }, _this.setScrollLeft = function (scrollLeft) {
	      _this.props.columns.forEach(function (column, i) {
	        if (column.locked) {
	          _this.cells[i].setScrollLeft(scrollLeft);
	        } else {
	          if (_this.cells[i] && _this.cells[i].removeScroll) {
	            _this.cells[i].removeScroll();
	          }
	        }
	      });
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  HeaderRow.prototype.componentWillMount = function componentWillMount() {
	    this.cells = [];
	  };

	  HeaderRow.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.columns !== this.props.columns || !shallowEqual(nextProps.style, this.props.style) || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
	  };

	  HeaderRow.prototype.render = function render() {
	    var cellsStyle = {
	      width: this.props.width ? this.props.width + getScrollbarSize() : '100%',
	      height: this.props.height,
	      whiteSpace: 'nowrap',
	      overflowX: 'hidden',
	      overflowY: 'hidden'
	    };

	    var cells = this.getCells();
	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: 'react-grid-HeaderRow' }),
	      React.createElement(
	        'div',
	        { style: cellsStyle },
	        cells
	      )
	    );
	  };

	  return HeaderRow;
	}(React.Component);

	HeaderRow.displayName = 'HeaderRow';
	HeaderRow.propTypes = {
	  width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]).isRequired,
	  onColumnResize: _propTypes2['default'].func,
	  onSort: _propTypes2['default'].func.isRequired,
	  onColumnResizeEnd: _propTypes2['default'].func,
	  style: _propTypes2['default'].shape(HeaderRowStyle),
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(SortableHeaderCell.DEFINE_SORT)),
	  cellRenderer: _propTypes2['default'].func,
	  headerCellRenderer: _propTypes2['default'].func,
	  filterable: _propTypes2['default'].bool,
	  onFilterChange: _propTypes2['default'].func,
	  resizing: _propTypes2['default'].object,
	  onScroll: _propTypes2['default'].func,
	  rowType: _propTypes2['default'].string,
	  draggableHeaderCell: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func
	};


	module.exports = HeaderRow;

/***/ }),
/* 115 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	  Backspace: 8,
	  Tab: 9,
	  Enter: 13,
	  Shift: 16,
	  Ctrl: 17,
	  Alt: 18,
	  PauseBreak: 19,
	  CapsLock: 20,
	  Escape: 27,
	  PageUp: 33,
	  PageDown: 34,
	  End: 35,
	  Home: 36,
	  LeftArrow: 37,
	  UpArrow: 38,
	  RightArrow: 39,
	  DownArrow: 40,
	  Insert: 45,
	  Delete: 46,
	  0: 48,
	  1: 49,
	  2: 50,
	  3: 51,
	  4: 52,
	  5: 53,
	  6: 54,
	  7: 55,
	  8: 56,
	  9: 57,
	  a: 65,
	  b: 66,
	  c: 67,
	  d: 68,
	  e: 69,
	  f: 70,
	  g: 71,
	  h: 72,
	  i: 73,
	  j: 74,
	  k: 75,
	  l: 76,
	  m: 77,
	  n: 78,
	  o: 79,
	  p: 80,
	  q: 81,
	  r: 82,
	  s: 83,
	  t: 84,
	  u: 85,
	  v: 86,
	  w: 87,
	  x: 88,
	  y: 89,
	  z: 90,
	  LeftWindowKey: 91,
	  RightWindowKey: 92,
	  SelectKey: 93,
	  NumPad0: 96,
	  NumPad1: 97,
	  NumPad2: 98,
	  NumPad3: 99,
	  NumPad4: 100,
	  NumPad5: 101,
	  NumPad6: 102,
	  NumPad7: 103,
	  NumPad8: 104,
	  NumPad9: 105,
	  Multiply: 106,
	  Add: 107,
	  Subtract: 109,
	  DecimalPoint: 110,
	  Divide: 111,
	  F1: 112,
	  F2: 113,
	  F3: 114,
	  F4: 115,
	  F5: 116,
	  F6: 117,
	  F7: 118,
	  F8: 119,
	  F9: 120,
	  F10: 121,
	  F12: 123,
	  NumLock: 144,
	  ScrollLock: 145,
	  SemiColon: 186,
	  EqualSign: 187,
	  Comma: 188,
	  Dash: 189,
	  Period: 190,
	  ForwardSlash: 191,
	  GraveAccent: 192,
	  OpenBracket: 219,
	  BackSlash: 220,
	  CloseBracket: 221,
	  SingleQuote: 222
	};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.OverflowCellComponent = undefined;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _focusableComponentWrapper = __webpack_require__(126);

	var _focusableComponentWrapper2 = _interopRequireDefault(_focusableComponentWrapper);

	__webpack_require__(37);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var OverflowCell = function (_React$Component) {
	  _inherits(OverflowCell, _React$Component);

	  function OverflowCell() {
	    _classCallCheck(this, OverflowCell);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  OverflowCell.prototype.getStyle = function getStyle() {
	    var style = {
	      position: 'absolute',
	      width: this.props.column.width,
	      height: this.props.height,
	      left: this.props.column.left,
	      border: '1px solid #eee'
	    };
	    return style;
	  };

	  OverflowCell.prototype.render = function render() {
	    return _react2['default'].createElement('div', { tabIndex: '-1', style: this.getStyle(), width: '100%', className: 'react-grid-Cell' });
	  };

	  return OverflowCell;
	}(_react2['default'].Component);

	OverflowCell.isSelected = function (props) {
	  var cellMetaData = props.cellMetaData,
	      rowIdx = props.rowIdx,
	      idx = props.idx;

	  if (cellMetaData == null) {
	    return false;
	  }

	  var selected = cellMetaData.selected;


	  return selected && selected.rowIdx === rowIdx && selected.idx === idx;
	};

	OverflowCell.isScrolling = function (props) {
	  return props.cellMetaData.isScrollingHorizontallyWithKeyboard;
	};

	OverflowCell.propTypes = {
	  rowIdx: _propTypes2['default'].number,
	  idx: _propTypes2['default'].number,
	  height: _propTypes2['default'].number,
	  column: _propTypes2['default'].object,
	  cellMetaData: _propTypes2['default'].object
	};

	OverflowCell.displayName = 'Cell';

	var OverflowCellComponent = OverflowCell;
	exports['default'] = (0, _focusableComponentWrapper2['default'])(OverflowCell);
	exports.OverflowCellComponent = OverflowCellComponent;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var CellActionShape = {
	  icon: _propTypes2['default'].string.isRequired,
	  callback: _propTypes2['default'].func,
	  actions: _propTypes2['default'].arrayOf(_propTypes2['default'].shape({
	    text: _propTypes2['default'].string,
	    callback: _propTypes2['default'].func
	  }))
	};

	exports['default'] = CellActionShape;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _ExcelColumn = __webpack_require__(12);

	var _ExcelColumn2 = _interopRequireDefault(_ExcelColumn);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports['default'] = { ExcelColumn: _ExcelColumn2['default'] };

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _SelectAll = __webpack_require__(50);

	var _SelectAll2 = _interopRequireDefault(_SelectAll);

	var _AppConstants = __webpack_require__(30);

	var _AppConstants2 = _interopRequireDefault(_AppConstants);

	var _SortableHeaderCell = __webpack_require__(46);

	var _keyboardUtils = __webpack_require__(55);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var BaseGrid = __webpack_require__(111);
	var CheckboxEditor = __webpack_require__(47);
	var RowUtils = __webpack_require__(44);
	var ColumnUtils = __webpack_require__(6);
	var KeyCodes = __webpack_require__(115);
	var isFunction = __webpack_require__(19);

	var ColumnMetrics = __webpack_require__(31);
	__webpack_require__(20);
	__webpack_require__(70);

	if (!Object.assign) {
	  Object.assign = __webpack_require__(146);
	}

	var ReactDataGrid = function (_React$Component) {
	  _inherits(ReactDataGrid, _React$Component);

	  function ReactDataGrid(props, context) {
	    _classCallCheck(this, ReactDataGrid);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

	    _initialiseProps.call(_this);

	    var columnMetrics = _this.createColumnMetrics();
	    var initialState = { columnMetrics: columnMetrics, selectedRows: [], copied: null, expandedRows: [], canFilter: false, columnFilters: {}, sortDirection: null, sortColumn: null, dragged: null, scrollOffset: 0, lastRowIdxUiSelected: -1 };
	    if (props.enableCellSelect) {
	      initialState.selected = { rowIdx: 0, idx: 0 };
	    } else {
	      initialState.selected = { rowIdx: -1, idx: -1 };
	    }

	    if (_this.props.sortColumn && _this.props.sortDirection) {
	      initialState.sortColumn = _this.props.sortColumn;
	      initialState.sortDirection = _this.props.sortDirection;
	    }

	    _this.state = initialState;
	    return _this;
	  }

	  ReactDataGrid.prototype.componentWillMount = function componentWillMount() {
	    this._mounted = true;
	  };

	  ReactDataGrid.prototype.componentDidMount = function componentDidMount() {
	    if (window.addEventListener) {
	      window.addEventListener('resize', this.metricsUpdated);
	    } else {
	      window.attachEvent('resize', this.metricsUpdated);
	    }
	    this.metricsUpdated();
	  };

	  ReactDataGrid.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._mounted = false;
	    window.removeEventListener('resize', this.metricsUpdated);
	  };

	  ReactDataGrid.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.columns) {
	      if (!ColumnMetrics.sameColumns(this.props.columns, nextProps.columns, this.props.columnEquality) || nextProps.minWidth !== this.props.minWidth) {
	        var columnMetrics = this.createColumnMetrics(nextProps);
	        this.setState({ columnMetrics: columnMetrics });
	      }
	    }
	  };

	  // return false if not a shift select so can be handled as normal row selection


	  // columnKey not used here as this function will select the whole row,
	  // but needed to match the function signature in the CheckboxEditor


	  ReactDataGrid.prototype.render = function render() {
	    var _this2 = this;

	    var cellMetaData = {
	      rowKey: this.props.rowKey,
	      selected: this.state.selected,
	      dragged: this.state.dragged,
	      hoveredRowIdx: this.state.hoveredRowIdx,
	      onCellClick: this.onCellClick,
	      onCellFocus: this.onCellFocus,
	      onCellContextMenu: this.onCellContextMenu,
	      onCellDoubleClick: this.onCellDoubleClick,
	      onCommit: this.onCellCommit,
	      onCommitCancel: this.setInactive,
	      copied: this.state.copied,
	      handleDragEnterRow: this.handleDragEnter,
	      handleTerminateDrag: this.handleTerminateDrag,
	      enableCellSelect: this.props.enableCellSelect,
	      onColumnEvent: this.onColumnEvent,
	      openCellEditor: this.openCellEditor,
	      onDragHandleDoubleClick: this.onDragHandleDoubleClick,
	      onCellExpand: this.onCellExpand,
	      onRowExpandToggle: this.onRowExpandToggle,
	      onRowHover: this.onRowHover,
	      getDataGridDOMNode: this.getDataGridDOMNode,
	      getCellActions: this.props.getCellActions,
	      onDeleteSubRow: this.props.onDeleteSubRow,
	      onAddSubRow: this.props.onAddSubRow,
	      isScrollingVerticallyWithKeyboard: this.isKeyDown(KeyCodes.DownArrow) || this.isKeyDown(KeyCodes.UpArrow),
	      isScrollingHorizontallyWithKeyboard: this.isKeyDown(KeyCodes.LeftArrow) || this.isKeyDown(KeyCodes.RightArrow) || this.isKeyDown(KeyCodes.Tab),
	      enableCellAutoFocus: this.props.enableCellAutoFocus
	    };

	    var toolbar = this.renderToolbar();
	    var containerWidth = this.props.minWidth || this.gridWidth();
	    var gridWidth = containerWidth - this.state.scrollOffset;

	    // depending on the current lifecycle stage, gridWidth() may not initialize correctly
	    // this also handles cases where it always returns undefined -- such as when inside a div with display:none
	    // eg Bootstrap tabs and collapses
	    if (typeof containerWidth === 'undefined' || isNaN(containerWidth) || containerWidth === 0) {
	      containerWidth = '100%';
	    }
	    if (typeof gridWidth === 'undefined' || isNaN(gridWidth) || gridWidth === 0) {
	      gridWidth = '100%';
	    }
	    return React.createElement(
	      'div',
	      { className: 'react-grid-Container', style: { width: containerWidth },
	        ref: function ref(node) {
	          _this2.grid = node;
	        } },
	      toolbar,
	      React.createElement(
	        'div',
	        { className: 'react-grid-Main' },
	        React.createElement(BaseGrid, _extends({
	          ref: function ref(node) {
	            return _this2.base = node;
	          }
	        }, this.props, {
	          rowKey: this.props.rowKey,
	          headerRows: this.getHeaderRows(),
	          columnMetrics: this.state.columnMetrics,
	          rowGetter: this.props.rowGetter,
	          rowsCount: this.props.rowsCount,
	          rowHeight: this.props.rowHeight,
	          cellMetaData: cellMetaData,
	          selectedRows: this.getSelectedRows(),
	          rowSelection: this.getRowSelectionProps(),
	          expandedRows: this.state.expandedRows,
	          rowOffsetHeight: this.getRowOffsetHeight(),
	          sortColumn: this.state.sortColumn,
	          sortDirection: this.state.sortDirection,
	          onSort: this.handleSort,
	          minHeight: this.props.minHeight,
	          totalWidth: gridWidth,
	          onViewportKeydown: this.onKeyDown,
	          onViewportKeyup: this.onKeyUp,
	          onViewportDragStart: this.onDragStart,
	          onViewportDragEnd: this.handleDragEnd,
	          onViewportClick: this.deselect,
	          onViewportDoubleClick: this.deselect,
	          onColumnResize: this.onColumnResize,
	          rowScrollTimeout: this.props.rowScrollTimeout,
	          scrollToRowIndex: this.props.scrollToRowIndex,
	          contextMenu: this.props.contextMenu,
	          overScan: this.props.overScan }))
	      )
	    );
	  };

	  return ReactDataGrid;
	}(React.Component);

	ReactDataGrid.displayName = 'ReactDataGrid';
	ReactDataGrid.propTypes = {
	  rowHeight: _propTypes2['default'].number.isRequired,
	  headerRowHeight: _propTypes2['default'].number,
	  headerFiltersHeight: _propTypes2['default'].number,
	  minHeight: _propTypes2['default'].number.isRequired,
	  minWidth: _propTypes2['default'].number,
	  enableRowSelect: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].string]),
	  onRowUpdated: _propTypes2['default'].func,
	  rowGetter: _propTypes2['default'].func.isRequired,
	  rowsCount: _propTypes2['default'].number.isRequired,
	  toolbar: _propTypes2['default'].element,
	  enableCellSelect: _propTypes2['default'].bool,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  onFilter: _propTypes2['default'].func,
	  onCellCopyPaste: _propTypes2['default'].func,
	  onCellsDragged: _propTypes2['default'].func,
	  getCellActions: _propTypes2['default'].func,
	  onAddFilter: _propTypes2['default'].func,
	  onGridSort: _propTypes2['default'].func,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(_SortableHeaderCell.DEFINE_SORT)),
	  onDragHandleDoubleClick: _propTypes2['default'].func,
	  onGridRowsUpdated: _propTypes2['default'].func,
	  onRowSelect: _propTypes2['default'].func,
	  rowKey: _propTypes2['default'].string,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  onClearFilters: _propTypes2['default'].func,
	  contextMenu: _propTypes2['default'].element,
	  cellNavigationMode: _propTypes2['default'].oneOf(['none', 'loopOverRow', 'changeRow']),
	  onCellSelected: _propTypes2['default'].func,
	  onCellDeSelected: _propTypes2['default'].func,
	  onCellExpand: _propTypes2['default'].func,
	  enableDragAndDrop: _propTypes2['default'].bool,
	  tabIndex: _propTypes2['default'].number,
	  onRowExpandToggle: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  rowSelection: _propTypes2['default'].shape({
	    enableShiftSelect: _propTypes2['default'].bool,
	    onRowsSelected: _propTypes2['default'].func,
	    onRowsDeselected: _propTypes2['default'].func,
	    showCheckbox: _propTypes2['default'].bool,
	    selectBy: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	      indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	    }), _propTypes2['default'].shape({
	      isSelectedKey: _propTypes2['default'].string.isRequired
	    }), _propTypes2['default'].shape({
	      keys: _propTypes2['default'].shape({
	        values: _propTypes2['default'].array.isRequired,
	        rowKey: _propTypes2['default'].string.isRequired
	      }).isRequired
	    })]).isRequired
	  }),
	  onRowClick: _propTypes2['default'].func,
	  onRowDoubleClick: _propTypes2['default'].func,
	  onGridKeyUp: _propTypes2['default'].func,
	  onGridKeyDown: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func,
	  rowActionsCell: _propTypes2['default'].func,
	  onCheckCellIsEditable: _propTypes2['default'].func,
	  /* called before cell is set active, returns a boolean to determine whether cell is editable */
	  overScan: _propTypes2['default'].object,
	  onDeleteSubRow: _propTypes2['default'].func,
	  onAddSubRow: _propTypes2['default'].func,
	  enableCellAutoFocus: _propTypes2['default'].bool,
	  onBeforeEdit: _propTypes2['default'].func,
	  selectAllRenderer: _propTypes2['default'].object,
	  minColumnWidth: _propTypes2['default'].number,
	  columnEquality: _propTypes2['default'].func,
	  onColumnResize: _propTypes2['default'].func
	};
	ReactDataGrid.defaultProps = {
	  enableCellSelect: false,
	  tabIndex: -1,
	  rowHeight: 35,
	  headerFiltersHeight: 45,
	  enableRowSelect: false,
	  minHeight: 350,
	  rowKey: 'id',
	  rowScrollTimeout: 0,
	  scrollToRowIndex: 0,
	  cellNavigationMode: 'none',
	  overScan: {
	    colsStart: 5,
	    colsEnd: 5,
	    rowsStart: 5,
	    rowsEnd: 5
	  },
	  enableCellAutoFocus: true,
	  onBeforeEdit: function onBeforeEdit() {},
	  minColumnWidth: 80,
	  columnEquality: ColumnMetrics.sameColumn
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this3 = this;

	  this.gridWidth = function () {
	    return _this3.grid ? _this3.grid.parentElement.offsetWidth : 0;
	  };

	  this.getTotalWidth = function () {
	    var totalWidth = 0;
	    if (_this3._mounted) {
	      totalWidth = _this3.gridWidth();
	    } else {
	      totalWidth = ColumnUtils.getSize(_this3.props.columns) * _this3.props.minColumnWidth;
	    }
	    return totalWidth;
	  };

	  this.getColumnMetricsType = function (metrics) {
	    var totalWidth = metrics.totalWidth || _this3.getTotalWidth();
	    var currentMetrics = {
	      columns: metrics.columns,
	      totalWidth: totalWidth,
	      minColumnWidth: metrics.minColumnWidth
	    };
	    var updatedMetrics = ColumnMetrics.recalculate(currentMetrics);
	    return updatedMetrics;
	  };

	  this.getColumn = function (idx) {
	    var columns = _this3.state.columnMetrics.columns;
	    if (Array.isArray(columns)) {
	      return columns[idx];
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.get(idx);
	    }
	  };

	  this.getSize = function () {
	    var columns = _this3.state.columnMetrics.columns;
	    if (Array.isArray(columns)) {
	      return columns.length;
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.size;
	    }
	  };

	  this.metricsUpdated = function () {
	    var columnMetrics = _this3.createColumnMetrics();
	    _this3.setState({ columnMetrics: columnMetrics });
	  };

	  this.createColumnMetrics = function () {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;

	    var gridColumns = _this3.setupGridColumns(props);
	    return _this3.getColumnMetricsType({
	      columns: gridColumns,
	      minColumnWidth: _this3.props.minColumnWidth,
	      totalWidth: props.minWidth
	    });
	  };

	  this.onColumnResize = function (index, width) {
	    var columnMetrics = ColumnMetrics.resizeColumn(_this3.state.columnMetrics, index, width);
	    _this3.setState({ columnMetrics: columnMetrics });
	    if (_this3.props.onColumnResize) {
	      _this3.props.onColumnResize(index, width);
	    }
	  };

	  this.onKeyDown = function (e) {
	    if ((0, _keyboardUtils.isCtrlKeyHeldDown)(e)) {
	      _this3.checkAndCall('onPressKeyWithCtrl', e);
	    } else if (_this3.isKeyExplicitlyHandled(e.key)) {
	      // break up individual keyPress events to have their own specific callbacks
	      var callBack = 'onPress' + e.key;
	      _this3.checkAndCall(callBack, e);
	    } else if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this3.checkAndCall('onPressChar', e);
	    }

	    // Track which keys are currently down for shift clicking etc
	    _this3._keysDown = _this3._keysDown || {};
	    _this3._keysDown[e.keyCode] = true;
	    if (isFunction(_this3.props.onGridKeyDown)) {
	      _this3.props.onGridKeyDown(e);
	    }
	  };

	  this.onKeyUp = function (e) {
	    // Track which keys are currently down for shift clicking etc
	    _this3._keysDown = _this3._keysDown || {};
	    delete _this3._keysDown[e.keyCode];

	    if (isFunction(_this3.props.onGridKeyUp)) {
	      _this3.props.onGridKeyUp(e);
	    }
	  };

	  this.isKeyDown = function (keyCode) {
	    if (!_this3._keysDown) return false;
	    return keyCode in _this3._keysDown;
	  };

	  this.isSingleKeyDown = function (keyCode) {
	    if (!_this3._keysDown) return false;
	    return keyCode in _this3._keysDown && Object.keys(_this3._keysDown).length === 1;
	  };

	  this.checkAndCall = function (methodName, args) {
	    if (typeof _this3[methodName] === 'function') {
	      _this3[methodName](args);
	    }
	  };

	  this.isKeyExplicitlyHandled = function (key) {
	    return typeof _this3['onPress' + key] === 'function';
	  };

	  this.hasSelectedCellChanged = function (selected) {
	    var previouslySelected = Object.assign({}, _this3.state.selected);
	    return previouslySelected.rowIdx !== selected.rowIdx || previouslySelected.idx !== selected.idx || previouslySelected.active === false;
	  };

	  this.onContextMenuHide = function () {
	    document.removeEventListener('click', _this3.onContextMenuHide);
	    var newSelected = Object.assign({}, _this3.state.selected, { contextMenuDisplayed: false });
	    _this3.setState({ selected: newSelected });
	  };

	  this.onColumnEvent = function (ev, columnEvent) {
	    var idx = columnEvent.idx,
	        name = columnEvent.name;


	    if (name && typeof idx !== 'undefined') {
	      var column = _this3.getColumn(idx);

	      if (column && column.events && column.events[name] && typeof column.events[name] === 'function') {
	        var eventArgs = {
	          idx: idx,
	          rowIdx: columnEvent.rowIdx,
	          rowId: columnEvent.rowId,
	          column: column
	        };

	        column.events[name](ev, eventArgs);
	      }
	    }
	  };

	  this.onSelect = function (selected) {
	    if (_this3.state.selected.rowIdx !== selected.rowIdx || _this3.state.selected.idx !== selected.idx || _this3.state.selected.active === false) {
	      var _idx = selected.idx;
	      var _rowIdx = selected.rowIdx;
	      if (_this3.isCellWithinBounds(selected)) {
	        var oldSelection = _this3.state.selected;
	        _this3.setState({ selected: selected }, function () {
	          if (typeof _this3.props.onCellDeSelected === 'function') {
	            _this3.props.onCellDeSelected(oldSelection);
	          }
	          if (typeof _this3.props.onCellSelected === 'function') {
	            _this3.props.onCellSelected(selected);
	          }
	        });
	      } else if (_rowIdx === -1 && _idx === -1) {
	        // When it's outside of the grid, set rowIdx anyway
	        _this3.setState({ selected: { idx: _idx, rowIdx: _rowIdx } });
	      }
	    }
	  };

	  this.onCellClick = function (cell, e) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });

	    if (_this3.props.onRowClick && typeof _this3.props.onRowClick === 'function') {
	      _this3.props.onRowClick(cell.rowIdx, _this3.props.rowGetter(cell.rowIdx), _this3.getColumn(cell.idx));
	    }

	    if (e) {
	      e.stopPropagation();
	    }
	  };

	  this.onCellFocus = function (cell) {
	    _this3.onSelect(cell);
	  };

	  this.onCellContextMenu = function (cell) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx, contextMenuDisplayed: _this3.props.contextMenu });
	    if (_this3.props.contextMenu) {
	      document.addEventListener('click', _this3.onContextMenuHide);
	    }
	  };

	  this.onCellDoubleClick = function (cell, e) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });
	    if (_this3.props.onRowDoubleClick && typeof _this3.props.onRowDoubleClick === 'function') {
	      _this3.props.onRowDoubleClick(cell.rowIdx, _this3.props.rowGetter(cell.rowIdx), _this3.getColumn(cell.idx));
	    }
	    _this3.setActive();
	    if (e) {
	      e.stopPropagation();
	    }
	  };

	  this.onPressArrowUp = function (e) {
	    _this3.moveSelectedCell(e, -1, 0);
	  };

	  this.onPressArrowDown = function (e) {
	    _this3.moveSelectedCell(e, 1, 0);
	  };

	  this.onPressArrowLeft = function (e) {
	    _this3.moveSelectedCell(e, 0, -1);
	  };

	  this.onPressArrowRight = function (e) {
	    _this3.moveSelectedCell(e, 0, 1);
	  };

	  this.isFocusedOnCell = function () {
	    return document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('react-grid-Cell');
	  };

	  this.isFocusedOnTable = function () {
	    var domNode = _this3.getDataGridDOMNode();
	    return domNode && domNode.contains(document.activeElement);
	  };

	  this.exitGrid = function (oldSelectedCell, newSelectedValue) {
	    _this3.setState({ selected: newSelectedValue }, function () {
	      if (typeof _this3.props.onCellDeSelected === 'function') {
	        _this3.props.onCellDeSelected(oldSelectedCell);
	      }
	    });
	  };

	  this.enterGrid = function (newSelectedValue) {
	    _this3.setState({ selected: newSelectedValue }, function () {
	      if (typeof _this3.props.onCellSelected === 'function') {
	        _this3.props.onCellSelected(newSelectedValue);
	      }
	    });
	  };

	  this.onPressTab = function (e) {
	    // Scenario 0a: When there are no rows in the grid, pressing tab needs to allow the browser to handle it
	    if (_this3.props.rowsCount === 0) {
	      return;
	    }
	    // Scenario 0b: When we're editing a cell
	    var idx = _this3.state.selected.idx;
	    var rowIdx = _this3.state.selected.rowIdx;
	    if (_this3.state.selected.active === true) {
	      // if we are in a position to leave the grid, stop editing but stay in that cell
	      if (_this3.canExitGrid(e)) {
	        _this3.moveSelectedCell(e, 0, 0);
	        return;
	      }
	      // otherwise move left or right as appropriate
	      _this3.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
	      return;
	    }
	    var shift = e.shiftKey === true;
	    // Scenario 1: we're at a cell where we can exit the grid
	    if (_this3.canExitGrid(e) && _this3.isFocusedOnCell()) {
	      if (shift && idx >= 0) {
	        _this3.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx, exitedLeft: true });
	        return;
	      } else if (!shift && idx >= 0) {
	        _this3.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx });
	        return;
	      }
	    }
	    // Scenario 2: we're on the div surrounding the grid and press shift+Tab
	    // and we just exited left, so we want to let the browser handle it
	    // KNOWN ISSUE: Focus on the table can come from either side and at this point we can't know how
	    // they user arrived, so it is possible that exitLeft gets set and then the user clicks out of the table
	    // and they won't be able to Shift+Tab around the site to re-enter the table from the right.
	    if (_this3.isFocusedOnTable() && !_this3.isFocusedOnCell() && shift && _this3.state.selected.exitedLeft) {
	      _this3.enterGrid({ idx: idx, rowIdx: rowIdx });
	      return;
	    }
	    // Scenario 3: we're on the div surrounding the grid and we want to enter the grid
	    if (!_this3.isFocusedOnCell()) {
	      // Scenario 3A: idx has been set to -1 (eg can happen when clicking into the filter box)
	      // we want to go to the first cell in the row if we press Tab
	      // we want to go to the last cell in the row if we press Shift+Tab
	      if (idx === -1) {
	        _this3.moveSelectedCell(e, rowIdx === -1 ? 1 : 0, shift ? _this3.getNbrColumns() : 1);
	        return;
	      }
	      // otherwise, there is a selected cell in the table already, and
	      // we want to trigger it to focus - setting selected in state will update
	      // the cell props, and checkFocus will be called
	      _this3.enterGrid({ idx: idx, rowIdx: rowIdx, changeSomething: true });
	      // make sure the browser doesn't handle it
	      e.preventDefault();
	      return;
	    }
	    _this3.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
	  };

	  this.onPressEnter = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressDelete = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressEscape = function (e) {
	    _this3.setInactive(e.key);
	    _this3.handleCancelCopy();
	  };

	  this.onPressBackspace = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressChar = function (e) {
	    if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this3.setActive(e.keyCode);
	    }
	  };

	  this.onPressKeyWithCtrl = function (e) {
	    var keys = {
	      KeyCode_c: 99,
	      KeyCode_C: 67,
	      KeyCode_V: 86,
	      KeyCode_v: 118
	    };

	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var col = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect)) {
	      if (e.keyCode === keys.KeyCode_c || e.keyCode === keys.KeyCode_C) {
	        var _value = _this3.getSelectedValue();
	        _this3.handleCopy({ value: _value });
	      } else if (e.keyCode === keys.KeyCode_v || e.keyCode === keys.KeyCode_V) {
	        _this3.handlePaste();
	      }
	    }
	  };

	  this.onGridRowsUpdated = function (cellKey, fromRow, toRow, updated, action, originRow) {
	    var rowIds = [];

	    for (var i = fromRow; i <= toRow; i++) {
	      rowIds.push(_this3.props.rowGetter(i)[_this3.props.rowKey]);
	    }

	    var fromRowData = _this3.props.rowGetter(action === 'COPY_PASTE' ? originRow : fromRow);
	    var fromRowId = fromRowData[_this3.props.rowKey];
	    var toRowId = _this3.props.rowGetter(toRow)[_this3.props.rowKey];
	    _this3.props.onGridRowsUpdated({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, fromRowId: fromRowId, toRowId: toRowId, rowIds: rowIds, updated: updated, action: action, fromRowData: fromRowData });
	  };

	  this.onCellCommit = function (commit) {
	    var selected = Object.assign({}, _this3.state.selected);
	    selected.active = false;
	    var expandedRows = _this3.state.expandedRows;
	    // if(commit.changed && commit.changed.expandedHeight){
	    //   expandedRows = this.expandRow(commit.rowIdx, commit.changed.expandedHeight);
	    // }
	    _this3.setState({ selected: selected, expandedRows: expandedRows });

	    if (_this3.props.onRowUpdated) {
	      _this3.props.onRowUpdated(commit);
	    }

	    var targetRow = commit.rowIdx;

	    if (_this3.props.onGridRowsUpdated) {
	      _this3.onGridRowsUpdated(commit.cellKey, targetRow, targetRow, commit.updated, _AppConstants2['default'].UpdateActions.CELL_UPDATE);
	    }
	  };

	  this.onDragStart = function (e) {
	    var idx = _this3.state.selected.idx;
	    // To prevent dragging down/up when reordering rows.
	    var isViewportDragging = e && e.target && e.target.className;
	    if (idx > -1 && isViewportDragging) {
	      var _value2 = _this3.getSelectedValue();
	      _this3.handleDragStart({ idx: _this3.state.selected.idx, rowIdx: _this3.state.selected.rowIdx, value: _value2 });
	      // need to set dummy data for FF
	      if (e && e.dataTransfer) {
	        if (e.dataTransfer.setData) {
	          e.dataTransfer.dropEffect = 'move';
	          e.dataTransfer.effectAllowed = 'move';
	          e.dataTransfer.setData('text/plain', '');
	        }
	      }
	    }
	  };

	  this.onToggleFilter = function () {
	    // setState() does not immediately mutate this.state but creates a pending state transition.
	    // Therefore if you want to do something after the state change occurs, pass it in as a callback function.
	    _this3.setState({ canFilter: !_this3.state.canFilter }, function () {
	      if (_this3.state.canFilter === false && _this3.props.onClearFilters) {
	        _this3.props.onClearFilters();
	      }
	    });
	  };

	  this.onDragHandleDoubleClick = function (e) {
	    if (_this3.props.onDragHandleDoubleClick) {
	      _this3.props.onDragHandleDoubleClick(e);
	    }

	    if (_this3.props.onGridRowsUpdated) {
	      var _this3$onGridRowsUpda;

	      var cellKey = _this3.getColumn(e.idx).key;
	      _this3.onGridRowsUpdated(cellKey, e.rowIdx, _this3.props.rowsCount - 1, (_this3$onGridRowsUpda = {}, _this3$onGridRowsUpda[cellKey] = e.rowData[cellKey], _this3$onGridRowsUpda), _AppConstants2['default'].UpdateActions.COLUMN_FILL);
	    }
	  };

	  this.onCellExpand = function (args) {
	    if (_this3.props.onCellExpand) {
	      _this3.props.onCellExpand(args);
	    }
	  };

	  this.onRowExpandToggle = function (args) {
	    if (typeof _this3.props.onRowExpandToggle === 'function') {
	      _this3.props.onRowExpandToggle(args);
	    }
	  };

	  this.isCellWithinBounds = function (_ref) {
	    var idx = _ref.idx,
	        rowIdx = _ref.rowIdx;

	    return idx >= 0 && rowIdx >= 0 && idx < ColumnUtils.getSize(_this3.state.columnMetrics.columns) && rowIdx < _this3.props.rowsCount;
	  };

	  this.handleDragStart = function (dragged) {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    if (_this3.isCellWithinBounds(dragged)) {
	      _this3.setState({ dragged: dragged });
	    }
	  };

	  this.handleDragEnd = function () {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    var _state = _this3.state,
	        selected = _state.selected,
	        dragged = _state.dragged;

	    var column = _this3.getColumn(_this3.state.selected.idx);
	    if (selected && dragged && column) {
	      var cellKey = column.key;
	      var fromRow = selected.rowIdx < dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
	      var toRow = selected.rowIdx > dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
	      if (_this3.props.onCellsDragged) {
	        _this3.props.onCellsDragged({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, value: dragged.value });
	      }
	      if (_this3.props.onGridRowsUpdated) {
	        var _this3$onGridRowsUpda2;

	        _this3.onGridRowsUpdated(cellKey, fromRow, toRow, (_this3$onGridRowsUpda2 = {}, _this3$onGridRowsUpda2[cellKey] = dragged.value, _this3$onGridRowsUpda2), _AppConstants2['default'].UpdateActions.CELL_DRAG);
	      }
	    }
	    _this3.setState({ dragged: { complete: true } });
	  };

	  this.handleDragEnter = function (row) {
	    if (!_this3.dragEnabled() || _this3.state.dragged == null) {
	      return;
	    }
	    var dragged = _this3.state.dragged;
	    dragged.overRowIdx = row;
	    _this3.setState({ dragged: dragged });
	  };

	  this.handleTerminateDrag = function () {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    _this3.setState({ dragged: null });
	  };

	  this.handlePaste = function () {
	    if (!_this3.copyPasteEnabled() || !_this3.state.copied) {
	      return;
	    }
	    var selected = _this3.state.selected;
	    var cellKey = _this3.getColumn(_this3.state.selected.idx).key;
	    var textToCopy = _this3.state.textToCopy;
	    var fromRow = _this3.state.copied.rowIdx;
	    var toRow = selected.rowIdx;

	    if (_this3.props.onCellCopyPaste) {
	      _this3.props.onCellCopyPaste({ cellKey: cellKey, rowIdx: toRow, value: textToCopy, fromRow: fromRow, toRow: toRow });
	    }

	    if (_this3.props.onGridRowsUpdated) {
	      var _this3$onGridRowsUpda3;

	      _this3.onGridRowsUpdated(cellKey, toRow, toRow, (_this3$onGridRowsUpda3 = {}, _this3$onGridRowsUpda3[cellKey] = textToCopy, _this3$onGridRowsUpda3), _AppConstants2['default'].UpdateActions.COPY_PASTE, fromRow);
	    }
	  };

	  this.handleCancelCopy = function () {
	    _this3.setState({ copied: null });
	  };

	  this.handleCopy = function (args) {
	    if (!_this3.copyPasteEnabled()) {
	      return;
	    }
	    var textToCopy = args.value;
	    var selected = _this3.state.selected;
	    var copied = { idx: selected.idx, rowIdx: selected.rowIdx };
	    _this3.setState({ textToCopy: textToCopy, copied: copied });
	  };

	  this.handleSort = function (columnKey, direction) {
	    _this3.setState({ sortDirection: direction, sortColumn: columnKey }, function () {
	      this.props.onGridSort(columnKey, direction);
	    });
	  };

	  this.getSelectedRow = function (rows, key) {
	    var selectedRow = rows.filter(function (r) {
	      if (r[_this3.props.rowKey] === key) {
	        return true;
	      }
	      return false;
	    });
	    if (selectedRow.length > 0) {
	      return selectedRow[0];
	    }
	  };

	  this.useNewRowSelection = function () {
	    return _this3.props.rowSelection && _this3.props.rowSelection.selectBy;
	  };

	  this.handleShiftSelect = function (rowIdx) {
	    if (_this3.state.lastRowIdxUiSelected > -1 && _this3.isSingleKeyDown(KeyCodes.Shift)) {
	      var _props$rowSelection$s = _this3.props.rowSelection.selectBy,
	          keys = _props$rowSelection$s.keys,
	          indexes = _props$rowSelection$s.indexes,
	          isSelectedKey = _props$rowSelection$s.isSelectedKey;

	      var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, _this3.props.rowGetter(rowIdx), rowIdx);

	      if (isPreviouslySelected) return false;

	      var handled = false;

	      if (rowIdx > _this3.state.lastRowIdxUiSelected) {
	        var rowsSelected = [];

	        for (var i = _this3.state.lastRowIdxUiSelected + 1; i <= rowIdx; i++) {
	          rowsSelected.push({ rowIdx: i, row: _this3.props.rowGetter(i) });
	        }

	        if (typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	          _this3.props.rowSelection.onRowsSelected(rowsSelected);
	        }

	        handled = true;
	      } else if (rowIdx < _this3.state.lastRowIdxUiSelected) {
	        var _rowsSelected = [];

	        for (var _i = rowIdx; _i <= _this3.state.lastRowIdxUiSelected - 1; _i++) {
	          _rowsSelected.push({ rowIdx: _i, row: _this3.props.rowGetter(_i) });
	        }

	        if (typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	          _this3.props.rowSelection.onRowsSelected(_rowsSelected);
	        }

	        handled = true;
	      }

	      if (handled) {
	        _this3.setState({ lastRowIdxUiSelected: rowIdx });
	      }

	      return handled;
	    }

	    return false;
	  };

	  this.handleNewRowSelect = function (rowIdx, rowData) {
	    if (_this3.selectAllCheckbox && _this3.selectAllCheckbox.checked === true) {
	      _this3.selectAllCheckbox.checked = false;
	    }

	    var _props$rowSelection$s2 = _this3.props.rowSelection.selectBy,
	        keys = _props$rowSelection$s2.keys,
	        indexes = _props$rowSelection$s2.indexes,
	        isSelectedKey = _props$rowSelection$s2.isSelectedKey;

	    var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx);

	    _this3.setState({ lastRowIdxUiSelected: isPreviouslySelected ? -1 : rowIdx, selected: { rowIdx: rowIdx, idx: 0 } });

	    if (isPreviouslySelected && typeof _this3.props.rowSelection.onRowsDeselected === 'function') {
	      _this3.props.rowSelection.onRowsDeselected([{ rowIdx: rowIdx, row: rowData }]);
	    } else if (!isPreviouslySelected && typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	      _this3.props.rowSelection.onRowsSelected([{ rowIdx: rowIdx, row: rowData }]);
	    }
	  };

	  this.handleRowSelect = function (rowIdx, columnKey, rowData, e) {
	    e.stopPropagation();

	    if (_this3.useNewRowSelection()) {
	      if (_this3.props.rowSelection.enableShiftSelect === true) {
	        if (!_this3.handleShiftSelect(rowIdx)) {
	          _this3.handleNewRowSelect(rowIdx, rowData);
	        }
	      } else {
	        _this3.handleNewRowSelect(rowIdx, rowData);
	      }
	    } else {
	      // Fallback to old onRowSelect handler
	      var selectedRows = _this3.props.enableRowSelect === 'single' ? [] : _this3.state.selectedRows.slice(0);
	      var selectedRow = _this3.getSelectedRow(selectedRows, rowData[_this3.props.rowKey]);
	      if (selectedRow) {
	        selectedRow.isSelected = !selectedRow.isSelected;
	      } else {
	        rowData.isSelected = true;
	        selectedRows.push(rowData);
	      }
	      _this3.setState({ selectedRows: selectedRows, selected: { rowIdx: rowIdx, idx: 0 } });
	      if (_this3.props.onRowSelect) {
	        _this3.props.onRowSelect(selectedRows.filter(function (r) {
	          return r.isSelected === true;
	        }));
	      }
	    }
	  };

	  this.handleCheckboxChange = function (e) {
	    var allRowsSelected = void 0;
	    if (e.currentTarget instanceof HTMLInputElement && e.currentTarget.checked === true) {
	      allRowsSelected = true;
	    } else {
	      allRowsSelected = false;
	    }
	    if (_this3.useNewRowSelection()) {
	      var _props$rowSelection$s3 = _this3.props.rowSelection.selectBy,
	          keys = _props$rowSelection$s3.keys,
	          indexes = _props$rowSelection$s3.indexes,
	          isSelectedKey = _props$rowSelection$s3.isSelectedKey;


	      if (allRowsSelected && typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	        var selectedRows = [];
	        for (var i = 0; i < _this3.props.rowsCount; i++) {
	          var rowData = _this3.props.rowGetter(i);
	          if (!RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, i)) {
	            selectedRows.push({ rowIdx: i, row: rowData });
	          }
	        }

	        if (selectedRows.length > 0) {
	          _this3.props.rowSelection.onRowsSelected(selectedRows);
	        }
	      } else if (!allRowsSelected && typeof _this3.props.rowSelection.onRowsDeselected === 'function') {
	        var deselectedRows = [];
	        for (var _i2 = 0; _i2 < _this3.props.rowsCount; _i2++) {
	          var _rowData = _this3.props.rowGetter(_i2);
	          if (RowUtils.isRowSelected(keys, indexes, isSelectedKey, _rowData, _i2)) {
	            deselectedRows.push({ rowIdx: _i2, row: _rowData });
	          }
	        }

	        if (deselectedRows.length > 0) {
	          _this3.props.rowSelection.onRowsDeselected(deselectedRows);
	        }
	      }
	    } else {
	      var _selectedRows = [];
	      for (var _i3 = 0; _i3 < _this3.props.rowsCount; _i3++) {
	        var row = Object.assign({}, _this3.props.rowGetter(_i3), { isSelected: allRowsSelected });
	        _selectedRows.push(row);
	      }
	      _this3.setState({ selectedRows: _selectedRows });
	      if (typeof _this3.props.onRowSelect === 'function') {
	        _this3.props.onRowSelect(_selectedRows.filter(function (r) {
	          return r.isSelected === true;
	        }));
	      }
	    }
	  };

	  this.getScrollOffSet = function () {
	    var scrollOffset = 0;
	    if (_this3.grid) {
	      var canvas = _this3.grid.querySelector('.react-grid-Canvas');
	      if (canvas) {
	        scrollOffset = canvas.offsetWidth - canvas.clientWidth;
	      }
	    }
	    _this3.setState({ scrollOffset: scrollOffset });
	  };

	  this.getRowOffsetHeight = function () {
	    var offsetHeight = 0;
	    _this3.getHeaderRows().forEach(function (row) {
	      return offsetHeight += parseFloat(row.height, 10);
	    });
	    return offsetHeight;
	  };

	  this.getHeaderRows = function () {
	    var rows = [{ ref: function ref(node) {
	        return _this3.row = node;
	      }, height: _this3.props.headerRowHeight || _this3.props.rowHeight, rowType: 'header' }];
	    if (_this3.state.canFilter === true) {
	      rows.push({
	        ref: function ref(node) {
	          return _this3.filterRow = node;
	        },
	        filterable: true,
	        onFilterChange: _this3.props.onAddFilter,
	        height: _this3.props.headerFiltersHeight,
	        rowType: 'filter'
	      });
	    }
	    return rows;
	  };

	  this.getInitialSelectedRows = function () {
	    var selectedRows = [];
	    for (var i = 0; i < _this3.props.rowsCount; i++) {
	      selectedRows.push(false);
	    }
	    return selectedRows;
	  };

	  this.getRowSelectionProps = function () {
	    if (_this3.props.rowSelection) {
	      return _this3.props.rowSelection.selectBy;
	    }

	    return null;
	  };

	  this.getSelectedRows = function () {
	    if (_this3.props.rowSelection) {
	      return null;
	    }

	    return _this3.state.selectedRows.filter(function (r) {
	      return r.isSelected === true;
	    });
	  };

	  this.getSelectedValue = function () {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var idx = _this3.state.selected.idx;
	    var cellKey = _this3.getColumn(idx).key;
	    var row = _this3.props.rowGetter(rowIdx);
	    return RowUtils.get(row, cellKey);
	  };

	  this.canExitGrid = function (e) {
	    // When the cellNavigationMode is 'none', you can exit the grid if you're at the start or end of the row
	    // When the cellNavigationMode is 'changeRow', you can exit the grid if you're at the first or last cell of the grid
	    // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid
	    var atLastCellInRow = _this3.isAtLastCellInRow(_this3.getNbrColumns());
	    var atFirstCellInRow = _this3.isAtFirstCellInRow();
	    var atLastRow = _this3.isAtLastRow();
	    var atFirstRow = _this3.isAtFirstRow();
	    var shift = e.shiftKey === true;
	    var cellNavigationMode = _this3.props.cellNavigationMode;

	    if (shift) {
	      if (cellNavigationMode === 'none') {
	        if (atFirstCellInRow) {
	          return true;
	        }
	      } else if (cellNavigationMode === 'changeRow') {
	        if (atFirstCellInRow && atFirstRow) {
	          return true;
	        }
	      }
	    } else {
	      if (cellNavigationMode === 'none') {
	        if (atLastCellInRow) {
	          return true;
	        }
	      } else if (cellNavigationMode === 'changeRow') {
	        if (atLastCellInRow && atLastRow) {
	          return true;
	        }
	      }
	    }
	    return false;
	  };

	  this.moveSelectedCell = function (e, rowDelta, cellDelta) {
	    // we need to prevent default as we control grid scroll
	    // otherwise it moves every time you left/right which is janky
	    e.preventDefault();
	    var rowIdx = void 0;
	    var idx = void 0;
	    var cellNavigationMode = _this3.props.cellNavigationMode;

	    if (cellNavigationMode !== 'none') {
	      var _calculateNextSelecti = _this3.calculateNextSelectionPosition(cellNavigationMode, cellDelta, rowDelta);

	      idx = _calculateNextSelecti.idx;
	      rowIdx = _calculateNextSelecti.rowIdx;
	    } else {
	      rowIdx = _this3.state.selected.rowIdx + rowDelta;
	      idx = _this3.state.selected.idx + cellDelta;
	    }
	    _this3.scrollToColumn(idx);
	    _this3.onSelect({ idx: idx, rowIdx: rowIdx });
	  };

	  this.getNbrColumns = function () {
	    var _props = _this3.props,
	        columns = _props.columns,
	        enableRowSelect = _props.enableRowSelect;

	    return enableRowSelect ? columns.length + 1 : columns.length;
	  };

	  this.getDataGridDOMNode = function () {
	    return _this3.grid;
	  };

	  this.calculateNextSelectionPosition = function (cellNavigationMode, cellDelta, rowDelta) {
	    var _rowDelta = rowDelta;
	    var idx = _this3.state.selected.idx + cellDelta;
	    var nbrColumns = _this3.getNbrColumns();
	    if (cellDelta > 0) {
	      if (_this3.isAtLastCellInRow(nbrColumns)) {
	        if (cellNavigationMode === 'changeRow') {
	          _rowDelta = _this3.isAtLastRow() ? rowDelta : rowDelta + 1;
	          idx = _this3.isAtLastRow() ? idx : 0;
	        } else {
	          idx = 0;
	        }
	      }
	    } else if (cellDelta < 0) {
	      if (_this3.isAtFirstCellInRow()) {
	        if (cellNavigationMode === 'changeRow') {
	          _rowDelta = _this3.isAtFirstRow() ? rowDelta : rowDelta - 1;
	          idx = _this3.isAtFirstRow() ? 0 : nbrColumns - 1;
	        } else {
	          idx = nbrColumns - 1;
	        }
	      }
	    }
	    var rowIdx = _this3.state.selected.rowIdx + _rowDelta;
	    return { idx: idx, rowIdx: rowIdx };
	  };

	  this.isAtLastCellInRow = function (nbrColumns) {
	    return _this3.state.selected.idx === nbrColumns - 1;
	  };

	  this.isAtLastRow = function () {
	    return _this3.state.selected.rowIdx === _this3.props.rowsCount - 1;
	  };

	  this.isAtFirstCellInRow = function () {
	    return _this3.state.selected.idx === 0;
	  };

	  this.isAtFirstRow = function () {
	    return _this3.state.selected.rowIdx === 0;
	  };

	  this.openCellEditor = function (rowIdx, idx) {
	    var row = _this3.props.rowGetter(rowIdx);
	    var col = _this3.getColumn(idx);

	    if (!ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect)) {
	      return;
	    }

	    var selected = { rowIdx: rowIdx, idx: idx };
	    if (_this3.hasSelectedCellChanged(selected)) {
	      _this3.setState({ selected: selected }, function () {
	        _this3.setActive('Enter');
	      });
	    } else {
	      _this3.setActive('Enter');
	    }
	  };

	  this.scrollToColumn = function (colIdx) {
	    if (_this3.grid) {
	      var canvas = _this3.grid.querySelector('.react-grid-Canvas');
	      if (canvas) {
	        var left = 0;
	        var locked = 0;

	        for (var i = 0; i < colIdx; i++) {
	          var column = _this3.getColumn(i);
	          if (column) {
	            if (column.width) {
	              left += column.width;
	            }
	            if (column.locked) {
	              locked += column.width;
	            }
	          }
	        }

	        var selectedColumn = _this3.getColumn(colIdx);
	        if (selectedColumn) {
	          var scrollLeft = left - locked - canvas.scrollLeft;
	          var scrollRight = left + selectedColumn.width - canvas.scrollLeft;

	          if (scrollLeft < 0) {
	            canvas.scrollLeft += scrollLeft;
	          } else if (scrollRight > canvas.clientWidth) {
	            var scrollAmount = scrollRight - canvas.clientWidth;
	            canvas.scrollLeft += scrollAmount;
	          }
	        }
	      }
	    }
	  };

	  this.deselect = function () {
	    var selected = { rowIdx: -1, idx: -1 };
	    _this3.setState({ selected: selected });
	  };

	  this.setActive = function (keyPressed) {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var column = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(column, row, _this3.props.enableCellSelect) && !_this3.isActive()) {
	      var selected = Object.assign({}, _this3.state.selected, { idx: idx, rowIdx: rowIdx, active: true, initialKeyCode: keyPressed });
	      var showEditor = true;
	      if (typeof _this3.props.onCheckCellIsEditable === 'function') {
	        var args = Object.assign({}, { row: row, column: column }, selected);
	        showEditor = _this3.props.onCheckCellIsEditable(args);
	      }
	      if (showEditor !== false) {
	        if (column.locked) {
	          _this3.setState({ selected: selected });
	        } else {
	          _this3.setState({ selected: selected }, function () {
	            _this3.scrollToColumn(idx);
	          });
	        }
	        _this3.props.onBeforeEdit();
	        _this3.handleCancelCopy();
	      }
	    }
	  };

	  this.setInactive = function () {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var col = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect) && _this3.isActive()) {
	      var selected = Object.assign({}, _this3.state.selected, { idx: idx, rowIdx: rowIdx, active: false });
	      _this3.setState({ selected: selected });
	    }
	  };

	  this.isActive = function () {
	    return _this3.state.selected.active === true;
	  };

	  this.setupGridColumns = function () {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;
	    var columns = props.columns;

	    if (_this3._cachedColumns === columns) {
	      return _this3._cachedComputedColumns;
	    }

	    _this3._cachedColumns = columns;

	    var cols = columns.slice(0);
	    var unshiftedCols = {};
	    if (_this3.props.rowActionsCell || props.enableRowSelect && !_this3.props.rowSelection || props.rowSelection && props.rowSelection.showCheckbox !== false) {
	      var SelectAllComponent = _this3.props.selectAllRenderer || _SelectAll2['default'];
	      var SelectAllRenderer = React.createElement(SelectAllComponent, { onChange: _this3.handleCheckboxChange, inputRef: function inputRef(grid) {
	          return _this3.selectAllCheckbox = grid;
	        } });
	      var headerRenderer = props.enableRowSelect === 'single' ? null : SelectAllRenderer;
	      var Formatter = _this3.props.rowActionsCell ? _this3.props.rowActionsCell : CheckboxEditor;
	      var selectColumn = {
	        key: 'select-row',
	        name: '',
	        formatter: React.createElement(Formatter, { rowSelection: _this3.props.rowSelection }),
	        onCellChange: _this3.handleRowSelect,
	        filterable: false,
	        headerRenderer: headerRenderer,
	        width: 60,
	        locked: true,
	        getRowMetaData: function getRowMetaData(rowData) {
	          return rowData;
	        },
	        cellClass: _this3.props.rowActionsCell ? 'rdg-row-actions-cell' : ''
	      };
	      unshiftedCols = cols.unshift(selectColumn);
	      cols = unshiftedCols > 0 ? cols : unshiftedCols;
	    }
	    _this3._cachedComputedColumns = cols;

	    return _this3._cachedComputedColumns;
	  };

	  this.copyPasteEnabled = function () {
	    return _this3.props.onCellCopyPaste !== null;
	  };

	  this.dragEnabled = function () {
	    return _this3.props.onGridRowsUpdated !== undefined || _this3.props.onCellsDragged !== undefined;
	  };

	  this.renderToolbar = function () {
	    var Toolbar = _this3.props.toolbar;
	    var toolBarProps = { columns: _this3.props.columns, onToggleFilter: _this3.onToggleFilter, numberOfRows: _this3.props.rowsCount };
	    if (React.isValidElement(Toolbar)) {
	      return React.cloneElement(Toolbar, toolBarProps);
	    } else if (isFunction(Toolbar)) {
	      return React.createElement(Toolbar, toolBarProps);
	    }
	  };
	};

	module.exports = ReactDataGrid;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var Draggable = __webpack_require__(109);
	__webpack_require__(15);

	var style = {
	  position: 'absolute',
	  top: 0,
	  right: 0,
	  width: 6,
	  height: '100%'
	};

	var ResizeHandle = function (_React$Component) {
	  _inherits(ResizeHandle, _React$Component);

	  function ResizeHandle() {
	    _classCallCheck(this, ResizeHandle);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  ResizeHandle.prototype.render = function render() {
	    return React.createElement(Draggable, _extends({}, this.props, {
	      className: 'react-grid-HeaderCell__resizeHandle',
	      style: style
	    }));
	  };

	  return ResizeHandle;
	}(React.Component);

	module.exports = ResizeHandle;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _utils = __webpack_require__(53);

	var _utils2 = _interopRequireDefault(_utils);

	__webpack_require__(29);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var cellMetaDataShape = __webpack_require__(11);

	var RowGroup = function (_Component) {
	  _inherits(RowGroup, _Component);

	  function RowGroup(props) {
	    _classCallCheck(this, RowGroup);

	    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

	    _this.onRowExpandToggle = _this.onRowExpandToggle.bind(_this);
	    _this.onRowExpandClick = _this.onRowExpandClick.bind(_this);
	    _this.setScrollLeft = _this.setScrollLeft.bind(_this);
	    return _this;
	  }

	  RowGroup.prototype.onRowExpandToggle = function onRowExpandToggle(expand) {
	    var shouldExpand = expand == null ? !this.props.isExpanded : expand;
	    var meta = this.props.cellMetaData;
	    if (meta != null && meta.onRowExpandToggle && typeof meta.onRowExpandToggle === 'function') {
	      meta.onRowExpandToggle({ rowIdx: this.props.idx, shouldExpand: shouldExpand, columnGroupName: this.props.columnGroupName, name: this.props.name });
	    }
	  };

	  RowGroup.prototype.onRowExpandClick = function onRowExpandClick() {
	    this.onRowExpandToggle(!this.props.isExpanded);
	  };

	  RowGroup.prototype.setScrollLeft = function setScrollLeft(scrollLeft) {
	    if (this.rowGroupRenderer) {
	      this.rowGroupRenderer.setScrollLeft ? this.rowGroupRenderer.setScrollLeft(scrollLeft) : null;
	    }
	  };

	  RowGroup.prototype.render = function render() {
	    var _this2 = this;

	    var lastColumn = _utils2['default'].last(this.props.columns);

	    var style = { width: lastColumn.left + lastColumn.width };

	    return _react2['default'].createElement(
	      'div',
	      { style: style, className: 'react-grid-row-group' },
	      _react2['default'].createElement(this.props.renderer, _extends({ ref: function ref(node) {
	          _this2.rowGroupRenderer = node;
	        } }, this.props, { onRowExpandClick: this.onRowExpandClick, onRowExpandToggle: this.onRowExpandToggle }))
	    );
	  };

	  return RowGroup;
	}(_react.Component);

	RowGroup.propTypes = {
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  row: _propTypes2['default'].any.isRequired,
	  cellRenderer: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  isSelected: _propTypes2['default'].bool,
	  idx: _propTypes2['default'].number.isRequired,
	  expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
	  extraClasses: _propTypes2['default'].string,
	  forceUpdate: _propTypes2['default'].bool,
	  subRowDetails: _propTypes2['default'].object,
	  isRowHovered: _propTypes2['default'].bool,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired,
	  columnGroupName: _propTypes2['default'].string.isRequired,
	  isExpanded: _propTypes2['default'].bool.isRequired,
	  treeDepth: _propTypes2['default'].number.isRequired,
	  name: _propTypes2['default'].string.isRequired,
	  renderer: _propTypes2['default'].func
	};

	var DefaultRowGroupRenderer = function DefaultRowGroupRenderer(props) {
	  var treeDepth = props.treeDepth || 0;
	  var marginLeft = treeDepth * 20;

	  var style = {
	    height: '50px',
	    border: '1px solid #dddddd',
	    paddingTop: '15px',
	    paddingLeft: '5px'
	  };

	  var onKeyDown = function onKeyDown(e) {
	    if (e.key === 'ArrowLeft') {
	      props.onRowExpandToggle(false);
	    }
	    if (e.key === 'ArrowRight') {
	      props.onRowExpandToggle(true);
	    }
	    if (e.key === 'Enter') {
	      props.onRowExpandToggle(!props.isExpanded);
	    }
	  };
	  return _react2['default'].createElement(
	    'div',
	    { style: style, onKeyDown: onKeyDown, tabIndex: 0 },
	    _react2['default'].createElement(
	      'span',
	      { className: 'row-expand-icon', style: { float: 'left', marginLeft: marginLeft, cursor: 'pointer' }, onClick: props.onRowExpandClick },
	      props.isExpanded ? String.fromCharCode('9660') : String.fromCharCode('9658')
	    ),
	    _react2['default'].createElement(
	      'strong',
	      null,
	      props.columnGroupName,
	      ': ',
	      props.name
	    )
	  );
	};

	DefaultRowGroupRenderer.propTypes = {
	  onRowExpandClick: _propTypes2['default'].func.isRequired,
	  onRowExpandToggle: _propTypes2['default'].func.isRequired,
	  isExpanded: _propTypes2['default'].bool.isRequired,
	  treeDepth: _propTypes2['default'].number.isRequired,
	  name: _propTypes2['default'].string.isRequired,
	  columnGroupName: _propTypes2['default'].string.isRequired,
	  hideColumnName: _propTypes2['default'].bool
	};

	RowGroup.defaultProps = {
	  renderer: DefaultRowGroupRenderer
	};

	exports['default'] = RowGroup;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	var _viewportUtils = __webpack_require__(137);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var Canvas = __webpack_require__(104);
	var cellMetaDataShape = __webpack_require__(11);

	var Viewport = function (_React$Component) {
	  _inherits(Viewport, _React$Component);

	  function Viewport() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Viewport);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = (0, _viewportUtils.getGridState)(_this.props), _this.onScroll = function (scroll) {
	      _this.updateScroll(scroll.scrollTop, scroll.scrollLeft, _this.state.height, _this.props.rowHeight, _this.props.rowsCount);

	      if (_this.props.onScroll) {
	        _this.props.onScroll({ scrollTop: scroll.scrollTop, scrollLeft: scroll.scrollLeft });
	      }
	    }, _this.getScroll = function () {
	      return _this.canvas.getScroll();
	    }, _this.setScrollLeft = function (scrollLeft) {
	      _this.canvas.setScrollLeft(scrollLeft);
	    }, _this.getDOMNodeOffsetWidth = function () {
	      return _this.viewport ? _this.viewport.offsetWidth : 0;
	    }, _this.clearScrollTimer = function () {
	      if (_this.resetScrollStateTimeoutId) {
	        clearTimeout(_this.resetScrollStateTimeoutId);
	      }
	    }, _this.resetScrollStateAfterDelay = function () {
	      _this.clearScrollTimer();
	      _this.resetScrollStateTimeoutId = setTimeout(_this.resetScrollStateAfterDelayCallback, 500);
	    }, _this.resetScrollStateAfterDelayCallback = function () {
	      _this.resetScrollStateTimeoutId = null;
	      _this.setState({
	        isScrolling: false
	      });
	    }, _this.updateScroll = function (scrollTop, scrollLeft, height, rowHeight, length, width) {
	      _this.resetScrollStateAfterDelay();
	      var nextScrollState = (0, _viewportUtils.getNextScrollState)(_this.props, _this.getDOMNodeOffsetWidth, scrollTop, scrollLeft, height, rowHeight, length, width);

	      _this.setState(nextScrollState);
	    }, _this.metricsUpdated = function () {
	      var height = _this.viewportHeight();
	      var width = _this.viewportWidth();
	      if (height) {
	        _this.updateScroll(_this.state.scrollTop, _this.state.scrollLeft, height, _this.props.rowHeight, _this.props.rowsCount, width);
	      }
	    }, _this.viewportHeight = function () {
	      return _this.viewport ? _this.viewport.offsetHeight : 0;
	    }, _this.viewportWidth = function () {
	      return _this.viewport ? _this.viewport.offsetWidth : 0;
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Viewport.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (this.props.rowHeight !== nextProps.rowHeight || this.props.minHeight !== nextProps.minHeight) {
	      var newState = (0, _viewportUtils.getGridState)(nextProps);
	      this.updateScroll(newState.scrollTop, newState.scrollLeft, newState.height, nextProps.rowHeight, nextProps.rowsCount);
	    } else if (_ColumnUtils2['default'].getSize(this.props.columnMetrics.columns) !== _ColumnUtils2['default'].getSize(nextProps.columnMetrics.columns)) {
	      this.setState((0, _viewportUtils.getGridState)(nextProps));
	    } else if (this.props.rowsCount !== nextProps.rowsCount) {
	      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height, nextProps.rowHeight, nextProps.rowsCount);
	      // Added to fix the hiding of the bottom scrollbar when showing the filters.
	    } else if (this.props.rowOffsetHeight !== nextProps.rowOffsetHeight) {
	      // The value of height can be positive or negative and will be added to the current height to cater for changes in the header height (due to the filer)
	      var height = this.props.rowOffsetHeight - nextProps.rowOffsetHeight;

	      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height + height, nextProps.rowHeight, nextProps.rowsCount);
	    }
	  };

	  Viewport.prototype.componentDidMount = function componentDidMount() {
	    if (window.addEventListener) {
	      window.addEventListener('resize', this.metricsUpdated);
	    } else {
	      window.attachEvent('resize', this.metricsUpdated);
	    }
	    this.metricsUpdated();
	  };

	  Viewport.prototype.componentWillUnmount = function componentWillUnmount() {
	    window.removeEventListener('resize', this.metricsUpdated);
	    this.clearScrollTimer();
	  };

	  Viewport.prototype.render = function render() {
	    var _this2 = this;

	    var style = {
	      padding: 0,
	      bottom: 0,
	      left: 0,
	      right: 0,
	      overflow: 'hidden',
	      position: 'absolute',
	      top: this.props.rowOffsetHeight
	    };
	    return React.createElement(
	      'div',
	      {
	        className: 'react-grid-Viewport',
	        style: style,
	        ref: function ref(node) {
	          _this2.viewport = node;
	        } },
	      React.createElement(Canvas, {
	        ref: function ref(node) {
	          return _this2.canvas = node;
	        },
	        rowKey: this.props.rowKey,
	        totalWidth: this.props.totalWidth,
	        width: this.props.columnMetrics.width,
	        rowGetter: this.props.rowGetter,
	        rowsCount: this.props.rowsCount,
	        selectedRows: this.props.selectedRows,
	        expandedRows: this.props.expandedRows,
	        columns: this.props.columnMetrics.columns,
	        rowRenderer: this.props.rowRenderer,
	        displayStart: this.state.displayStart,
	        displayEnd: this.state.displayEnd,
	        visibleStart: this.state.visibleStart,
	        visibleEnd: this.state.visibleEnd,
	        colVisibleStart: this.state.colVisibleStart,
	        colVisibleEnd: this.state.colVisibleEnd,
	        colDisplayStart: this.state.colDisplayStart,
	        colDisplayEnd: this.state.colDisplayEnd,
	        cellMetaData: this.props.cellMetaData,
	        height: this.state.height,
	        rowHeight: this.props.rowHeight,
	        onScroll: this.onScroll,
	        onRows: this.props.onRows,
	        rowScrollTimeout: this.props.rowScrollTimeout,
	        scrollToRowIndex: this.props.scrollToRowIndex,
	        contextMenu: this.props.contextMenu,
	        rowSelection: this.props.rowSelection,
	        getSubRowDetails: this.props.getSubRowDetails,
	        rowGroupRenderer: this.props.rowGroupRenderer,
	        isScrolling: this.state.isScrolling || false
	      })
	    );
	  };

	  return Viewport;
	}(React.Component);

	Viewport.displayName = 'Viewport';
	Viewport.propTypes = {
	  rowOffsetHeight: _propTypes2['default'].number.isRequired,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]).isRequired,
	  columnMetrics: _propTypes2['default'].object.isRequired,
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
	  selectedRows: _propTypes2['default'].array,
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  expandedRows: _propTypes2['default'].array,
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
	  rowsCount: _propTypes2['default'].number.isRequired,
	  rowHeight: _propTypes2['default'].number.isRequired,
	  onRows: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  minHeight: _propTypes2['default'].number,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  rowKey: _propTypes2['default'].string.isRequired,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func
	};
	Viewport.defaultProps = {
	  rowHeight: 30
	};


	module.exports = Viewport;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ExcelColumn = __webpack_require__(12);

	var FilterableHeaderCell = function (_React$Component) {
	  _inherits(FilterableHeaderCell, _React$Component);

	  function FilterableHeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, FilterableHeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { filterTerm: '' }, _this.handleChange = function (e) {
	      var val = e.target.value;
	      _this.setState({ filterTerm: val });
	      _this.props.onChange({ filterTerm: val, column: _this.props.column });
	    }, _this.renderInput = function () {
	      if (_this.props.column.filterable === false) {
	        return React.createElement('span', null);
	      }

	      var inputKey = 'header-filter-' + _this.props.column.key;
	      return React.createElement('input', { key: inputKey, type: 'text', className: 'form-control input-sm', placeholder: 'Search', value: _this.state.filterTerm, onChange: _this.handleChange });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  FilterableHeaderCell.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'div',
	        { className: 'form-group' },
	        this.renderInput()
	      )
	    );
	  };

	  return FilterableHeaderCell;
	}(React.Component);

	FilterableHeaderCell.propTypes = {
	  onChange: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn)
	};


	module.exports = FilterableHeaderCell;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _keyboardUtils = __webpack_require__(55);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var SimpleTextEditor = __webpack_require__(49);
	var isFunction = __webpack_require__(19);


	__webpack_require__(20);

	var EditorContainer = function (_React$Component) {
	  _inherits(EditorContainer, _React$Component);

	  function EditorContainer() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, EditorContainer);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  EditorContainer.prototype.componentDidMount = function componentDidMount() {
	    var inputNode = this.getInputNode();
	    if (inputNode !== undefined) {
	      this.setTextInputFocus();
	      if (!this.getEditor().disableContainerStyles) {
	        inputNode.className += ' editor-main';
	        inputNode.style.height = this.props.height - 1 + 'px';
	      }
	    }
	  };

	  EditorContainer.prototype.componentWillUnmount = function componentWillUnmount() {
	    if (!this.changeCommitted && !this.changeCanceled) {
	      this.commit({ key: 'Enter' });
	    }
	  };

	  EditorContainer.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      { className: this.getContainerClass(), onBlur: this.handleBlur, onKeyDown: this.onKeyDown, onContextMenu: this.handleRightClick },
	      this.createEditor(),
	      this.renderStatusIcon()
	    );
	  };

	  return EditorContainer;
	}(React.Component);

	EditorContainer.displayName = 'EditorContainer';
	EditorContainer.propTypes = {
	  rowIdx: _propTypes2['default'].number,
	  rowData: _propTypes2['default'].object.isRequired,
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired,
	  cellMetaData: _propTypes2['default'].shape({
	    selected: _propTypes2['default'].object.isRequired,
	    copied: _propTypes2['default'].object,
	    dragged: _propTypes2['default'].object,
	    onCellClick: _propTypes2['default'].func,
	    onCellDoubleClick: _propTypes2['default'].func,
	    onCommitCancel: _propTypes2['default'].func,
	    onCommit: _propTypes2['default'].func
	  }).isRequired,
	  column: _propTypes2['default'].object.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  onGridKeyDown: _propTypes2['default'].func
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this2 = this;

	  this.state = { isInvalid: false };
	  this.changeCommitted = false;
	  this.changeCanceled = false;

	  this.isKeyExplicitlyHandled = function (key) {
	    return isFunction(_this2['onPress' + key]);
	  };

	  this.checkAndCall = function (methodName, args) {
	    if (isFunction(_this2[methodName])) {
	      _this2[methodName](args);
	    }
	  };

	  this.onKeyDown = function (e) {
	    if ((0, _keyboardUtils.isCtrlKeyHeldDown)(e)) {
	      _this2.checkAndCall('onPressKeyWithCtrl', e);
	    } else if (_this2.isKeyExplicitlyHandled(e.key)) {
	      // break up individual keyPress events to have their own specific callbacks
	      var callBack = 'onPress' + e.key;
	      _this2.checkAndCall(callBack, e);
	    } else if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this2.checkAndCall('onPressChar', e);
	    }

	    // Track which keys are currently down for shift clicking etc
	    _this2._keysDown = _this2._keysDown || {};
	    _this2._keysDown[e.keyCode] = true;
	    if (isFunction(_this2.props.onGridKeyDown)) {
	      _this2.props.onGridKeyDown(e);
	    }
	  };

	  this.createEditorRef = function (ref) {
	    _this2.editor = ref;
	  };

	  this.createEditor = function () {
	    var editorProps = {
	      ref: _this2.createEditorRef,
	      column: _this2.props.column,
	      value: _this2.getInitialValue(),
	      onCommit: _this2.commit,
	      onCommitCancel: _this2.commitCancel,
	      rowMetaData: _this2.getRowMetaData(),
	      rowData: _this2.props.rowData,
	      height: _this2.props.height,
	      onBlur: _this2.commit,
	      onOverrideKeyDown: _this2.onKeyDown
	    };

	    var CustomEditor = _this2.props.column.editor;
	    // return custom column editor or SimpleEditor if none specified
	    if (React.isValidElement(CustomEditor)) {
	      return React.cloneElement(CustomEditor, editorProps);
	    }
	    if (isFunction(CustomEditor)) {
	      return React.createElement(CustomEditor, _extends({ ref: _this2.createEditorRef }, editorProps));
	    }

	    return React.createElement(SimpleTextEditor, { ref: _this2.createEditorRef, column: _this2.props.column, value: _this2.getInitialValue(), onBlur: _this2.commit, rowMetaData: _this2.getRowMetaData(), onKeyDown: function onKeyDown() {}, commit: function commit() {} });
	  };

	  this.onPressEnter = function () {
	    _this2.commit({ key: 'Enter' });
	  };

	  this.onPressTab = function () {
	    _this2.commit({ key: 'Tab' });
	  };

	  this.onPressEscape = function (e) {
	    if (!_this2.editorIsSelectOpen()) {
	      _this2.commitCancel();
	    } else {
	      // prevent event from bubbling if editor has results to select
	      e.stopPropagation();
	    }
	  };

	  this.onPressArrowDown = function (e) {
	    if (_this2.editorHasResults()) {
	      // dont want to propogate as that then moves us round the grid
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowUp = function (e) {
	    if (_this2.editorHasResults()) {
	      // dont want to propogate as that then moves us round the grid
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowLeft = function (e) {
	    // prevent event propogation. this disables left cell navigation
	    if (!_this2.isCaretAtBeginningOfInput()) {
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowRight = function (e) {
	    // prevent event propogation. this disables right cell navigation
	    if (!_this2.isCaretAtEndOfInput()) {
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.editorHasResults = function () {
	    if (isFunction(_this2.getEditor().hasResults)) {
	      return _this2.getEditor().hasResults();
	    }

	    return false;
	  };

	  this.editorIsSelectOpen = function () {
	    if (isFunction(_this2.getEditor().isSelectOpen)) {
	      return _this2.getEditor().isSelectOpen();
	    }

	    return false;
	  };

	  this.getRowMetaData = function () {
	    // clone row data so editor cannot actually change this
	    // convention based method to get corresponding Id or Name of any Name or Id property
	    if (typeof _this2.props.column.getRowMetaData === 'function') {
	      return _this2.props.column.getRowMetaData(_this2.props.rowData, _this2.props.column);
	    }
	  };

	  this.getEditor = function () {
	    return _this2.editor;
	  };

	  this.getInputNode = function () {
	    return _this2.getEditor().getInputNode();
	  };

	  this.getInitialValue = function () {
	    var selected = _this2.props.cellMetaData.selected;
	    var keyCode = selected.initialKeyCode;
	    if (keyCode === 'Delete' || keyCode === 'Backspace') {
	      return '';
	    } else if (keyCode === 'Enter') {
	      return _this2.props.value;
	    }

	    var text = keyCode ? String.fromCharCode(keyCode) : _this2.props.value;
	    return text;
	  };

	  this.getContainerClass = function () {
	    return joinClasses({
	      'has-error': _this2.state.isInvalid === true
	    });
	  };

	  this.commit = function (args) {
	    var opts = args || {};
	    var updated = _this2.getEditor().getValue();
	    if (_this2.isNewValueValid(updated)) {
	      _this2.changeCommitted = true;
	      var cellKey = _this2.props.column.key;
	      _this2.props.cellMetaData.onCommit({ cellKey: cellKey, rowIdx: _this2.props.rowIdx, updated: updated, key: opts.key });
	    }
	  };

	  this.commitCancel = function () {
	    _this2.changeCanceled = true;
	    _this2.props.cellMetaData.onCommitCancel();
	  };

	  this.isNewValueValid = function (value) {
	    if (isFunction(_this2.getEditor().validate)) {
	      var isValid = _this2.getEditor().validate(value);
	      _this2.setState({ isInvalid: !isValid });
	      return isValid;
	    }

	    return true;
	  };

	  this.setCaretAtEndOfInput = function () {
	    var input = _this2.getInputNode();
	    // taken from http://stackoverflow.com/questions/511088/use-javascript-to-place-cursor-at-end-of-text-in-text-input-element
	    var txtLength = input.value.length;
	    if (input.setSelectionRange) {
	      input.setSelectionRange(txtLength, txtLength);
	    } else if (input.createTextRange) {
	      var fieldRange = input.createTextRange();
	      fieldRange.moveStart('character', txtLength);
	      fieldRange.collapse();
	      fieldRange.select();
	    }
	  };

	  this.isCaretAtBeginningOfInput = function () {
	    var inputNode = _this2.getInputNode();
	    return inputNode.selectionStart === inputNode.selectionEnd && inputNode.selectionStart === 0;
	  };

	  this.isCaretAtEndOfInput = function () {
	    var inputNode = _this2.getInputNode();
	    return inputNode.selectionStart === inputNode.value.length;
	  };

	  this.isBodyClicked = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return relatedTarget === null;
	  };

	  this.isViewportClicked = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return relatedTarget.className.indexOf('react-grid-Viewport') > -1;
	  };

	  this.isClickInsideEditor = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return e.currentTarget.contains(relatedTarget) || relatedTarget.className.indexOf('editing') > -1 || relatedTarget.className.indexOf('react-grid-Cell') > -1;
	  };

	  this.getRelatedTarget = function (e) {
	    return e.relatedTarget || e.explicitOriginalTarget || document.activeElement; // IE11
	  };

	  this.handleRightClick = function (e) {
	    e.stopPropagation();
	  };

	  this.handleBlur = function (e) {
	    e.stopPropagation();
	    if (_this2.isBodyClicked(e)) {
	      _this2.commit(e);
	    }

	    if (!_this2.isBodyClicked(e)) {
	      // prevent null reference
	      if (_this2.isViewportClicked(e) || !_this2.isClickInsideEditor(e)) {
	        _this2.commit(e);
	      }
	    }
	  };

	  this.setTextInputFocus = function () {
	    var selected = _this2.props.cellMetaData.selected;
	    var keyCode = selected.initialKeyCode;
	    var inputNode = _this2.getInputNode();
	    inputNode.focus();
	    if (inputNode.tagName === 'INPUT') {
	      if (!(0, _keyboardUtils.isKeyPrintable)(keyCode)) {
	        inputNode.focus();
	        inputNode.select();
	      } else {
	        inputNode.select();
	      }
	    }
	  };

	  this.renderStatusIcon = function () {
	    if (_this2.state.isInvalid === true) {
	      return React.createElement('span', { className: 'glyphicon glyphicon-remove form-control-feedback' });
	    }
	  };
	};

	module.exports = EditorContainer;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  CheckboxEditor: __webpack_require__(47),
	  EditorBase: __webpack_require__(48),
	  SimpleTextEditor: __webpack_require__(49)
	};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(9);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/prop-types */


	var focusableComponentWrapper = function focusableComponentWrapper(WrappedComponent) {
	  return function (_Component) {
	    _inherits(ComponentWrapper, _Component);

	    function ComponentWrapper() {
	      _classCallCheck(this, ComponentWrapper);

	      var _this = _possibleConstructorReturn(this, _Component.call(this));

	      _this.checkFocus = _this.checkFocus.bind(_this);
	      _this.state = { isScrolling: false };
	      return _this;
	    }

	    ComponentWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	      return WrappedComponent.isSelected(this.props) !== WrappedComponent.isSelected(nextProps);
	    };

	    ComponentWrapper.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	      var isScrolling = WrappedComponent.isScrolling(nextProps);
	      if (isScrolling && !this.state.isScrolling) {
	        this.setState({ isScrolling: isScrolling });
	      }
	    };

	    ComponentWrapper.prototype.componentDidMount = function componentDidMount() {
	      this.checkFocus();
	    };

	    ComponentWrapper.prototype.componentDidUpdate = function componentDidUpdate() {
	      this.checkFocus();
	    };

	    ComponentWrapper.prototype.checkFocus = function checkFocus() {
	      if (WrappedComponent.isSelected(this.props) && this.state.isScrolling) {
	        this.focus();
	        this.setState({ isScrolling: false });
	      }
	    };

	    ComponentWrapper.prototype.focus = function focus() {
	      _reactDom2['default'].findDOMNode(this).focus();
	    };

	    ComponentWrapper.prototype.render = function render() {
	      return _react2['default'].createElement(WrappedComponent, _extends({}, this.props, this.state));
	    };

	    return ComponentWrapper;
	  }(_react.Component);
	};

	exports['default'] = focusableComponentWrapper;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  SimpleCellFormatter: __webpack_require__(51),
	  SelectAll: __webpack_require__(50)
	};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _GridPropHelpers = __webpack_require__(129);

	var _GridPropHelpers2 = _interopRequireDefault(_GridPropHelpers);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = {
	  test: { GridPropHelpers: _GridPropHelpers2['default'] }
	};

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	'use strict';

	var _rows = [];
	for (var i = 0; i < 1000; i++) {
	  _rows.push({
	    id: i,
	    title: 'Title ' + i,
	    count: i * 1000
	  });
	}
	module.exports = {
	  columns: [{
	    key: 'id',
	    name: 'ID',
	    width: 100
	  }, {
	    key: 'title',
	    name: 'Title',
	    width: 100
	  }, {
	    key: 'count',
	    name: 'Count',
	    width: 100
	  }],
	  rowGetter: function rowGetter(i) {
	    return _rows[i];
	  },
	  rowsCount: function rowsCount() {
	    return _rows.length;
	  },
	  cellMetaData: {
	    selected: { idx: 2, rowIdx: 3 },
	    dragged: null,
	    copied: null
	  }
	};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _RowComparer = __webpack_require__(43);

	var _RowComparer2 = _interopRequireDefault(_RowComparer);

	var _RowsContainer = __webpack_require__(45);

	var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var Grid = __webpack_require__(119);

	module.exports = Grid;
	module.exports.Row = __webpack_require__(42);
	module.exports.Cell = __webpack_require__(40);
	module.exports.HeaderCell = __webpack_require__(41);
	module.exports.RowComparer = _RowComparer2['default'];
	module.exports.EmptyChildRow = __webpack_require__(110);
	module.exports.RowsContainer = _RowsContainer2['default'];
	module.exports.editors = __webpack_require__(125);
	module.exports.formatters = __webpack_require__(127);
	module.exports.utils = __webpack_require__(53);
	module.exports.shapes = __webpack_require__(118);
	module.exports._constants = __webpack_require__(30);
	module.exports._helpers = __webpack_require__(128);

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	"use strict";

	var isEmptyArray = function isEmptyArray(obj) {
	  return Array.isArray(obj) && obj.length === 0;
	};

	module.exports = isEmptyArray;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

	"use strict";

	function isEmpty(obj) {
	  return Object.keys(obj).length === 0 && obj.constructor === Object;
	}

	module.exports = isEmpty;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _immutable = __webpack_require__(18);

	var isImmutableCollection = function isImmutableCollection(objToVerify) {
	  return _immutable.Iterable.isIterable(objToVerify);
	};

	module.exports = isImmutableCollection;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _immutable = __webpack_require__(18);

	module.exports = _immutable.Map.isMap;

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	"use strict";

	var getMixedTypeValueRetriever = function getMixedTypeValueRetriever(isImmutable) {
	  var retObj = {};
	  var retriever = function retriever(item, key) {
	    return item[key];
	  };
	  var immutableRetriever = function immutableRetriever(immutable, key) {
	    return immutable.get(key);
	  };

	  retObj.getValue = isImmutable ? immutableRetriever : retriever;

	  return retObj;
	};

	module.exports = getMixedTypeValueRetriever;

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	function createScrollShim(size) {
	  var shim = document.createElement('div');
	  if (shim.classList) {
	    shim.classList.add('react-grid-ScrollShim'); // flow - not compatible with HTMLElement
	  } else {
	    shim.className += ' react-grid-ScrollShim';
	  }
	  shim.style.position = 'absolute';
	  shim.style.top = 0;
	  shim.style.left = 0;
	  shim.style.width = size.width + 'px';
	  shim.style.height = size.height + 'px';

	  return shim;
	}

	exports.createScrollShim = createScrollShim;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.getRenderedColumnCount = exports.getNextScrollState = exports.getGridState = undefined;

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var min = Math.min;
	var max = Math.max;
	var floor = Math.floor;
	var ceil = Math.ceil;

	function getGridState(props) {
	  var totalNumberColumns = _ColumnUtils2['default'].getSize(props.columnMetrics.columns);
	  var canvasHeight = props.minHeight - props.rowOffsetHeight;
	  var renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);
	  var totalRowCount = min(renderedRowsCount * 4, props.rowsCount);
	  return {
	    displayStart: 0,
	    displayEnd: totalRowCount,
	    visibleStart: 0,
	    visibleEnd: totalRowCount,
	    height: canvasHeight,
	    scrollTop: 0,
	    scrollLeft: 0,
	    colVisibleStart: 0,
	    colVisibleEnd: totalNumberColumns,
	    colDisplayStart: 0,
	    colDisplayEnd: totalNumberColumns
	  };
	}

	function getRenderedColumnCount(props, getDOMNodeOffsetWidth, displayStart, width) {
	  var remainingWidth = width && width > 0 ? width : props.columnMetrics.totalWidth;
	  if (remainingWidth === 0) {
	    remainingWidth = getDOMNodeOffsetWidth();
	  }
	  var columnIndex = displayStart;
	  var columnCount = 0;
	  while (remainingWidth > 0) {
	    var column = _ColumnUtils2['default'].getColumn(props.columnMetrics.columns, columnIndex);

	    if (!column) {
	      break;
	    }

	    columnCount++;
	    columnIndex++;
	    remainingWidth -= column.width;
	  }
	  return columnCount;
	}

	function getVisibleColStart(props, scrollLeft) {
	  var remainingScroll = scrollLeft;
	  var columnIndex = -1;
	  while (remainingScroll >= 0) {
	    columnIndex++;
	    remainingScroll -= _ColumnUtils2['default'].getColumn(props.columnMetrics.columns, columnIndex).width;
	  }
	  return columnIndex;
	}

	function getNextScrollState(props, getDOMNodeOffsetWidth, scrollTop, scrollLeft, height, rowHeight, length, width) {
	  var isScrolling = true;
	  var renderedRowsCount = ceil(height / rowHeight);
	  var visibleStart = max(0, floor(scrollTop / rowHeight));
	  var visibleEnd = min(visibleStart + renderedRowsCount, length);
	  var displayStart = max(0, visibleStart - props.overScan.rowsStart);
	  var displayEnd = min(visibleEnd + props.overScan.rowsEnd, length);
	  var totalNumberColumns = _ColumnUtils2['default'].getSize(props.columnMetrics.columns);
	  var colVisibleStart = totalNumberColumns > 0 ? max(0, getVisibleColStart(props, scrollLeft)) : 0;
	  var renderedColumnCount = getRenderedColumnCount(props, getDOMNodeOffsetWidth, colVisibleStart, width);
	  var colVisibleEnd = renderedColumnCount !== 0 ? colVisibleStart + renderedColumnCount : totalNumberColumns;
	  var colDisplayStart = max(0, colVisibleStart - props.overScan.colsStart);
	  var colDisplayEnd = min(colVisibleEnd + props.overScan.colsEnd, totalNumberColumns);

	  var nextScrollState = {
	    visibleStart: visibleStart,
	    visibleEnd: visibleEnd,
	    displayStart: displayStart,
	    displayEnd: displayEnd,
	    height: height,
	    scrollTop: scrollTop,
	    scrollLeft: scrollLeft,
	    colVisibleStart: colVisibleStart,
	    colVisibleEnd: colVisibleEnd,
	    colDisplayStart: colDisplayStart,
	    colDisplayEnd: colDisplayEnd,
	    isScrolling: isScrolling
	  };

	  return nextScrollState;
	}

	exports.getGridState = getGridState;
	exports.getNextScrollState = getNextScrollState;
	exports.getRenderedColumnCount = getRenderedColumnCount;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Cell{background-color:#fff;padding-left:8px;padding-right:8px;border-right:1px solid #eee;border-bottom:1px solid #ddd}.react-grid-Cell:focus{outline:2px solid #66afe9;outline-offset:-2px}.react-grid-Cell--locked:focus{z-index:100}.react-grid-Cell:focus .drag-handle{position:absolute;bottom:-5px;right:-4px;background:#66afe9;width:8px;height:8px;border:1px solid #fff;border-right:0;border-bottom:0;z-index:8;cursor:crosshair;cursor:-webkit-grab}.react-grid-Cell:not(.editing) .react-grid-Cell__value{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.react-grid-Cell:not(.editing):not(.rdg-child-cell) .react-grid-Cell__value{position:relative;top:50%;transform:translateY(-50%)}.rdg-child-cell .react-grid-Cell__value{line-height:35px}.react-grid-Cell.readonly{background-color:#000}.react-grid-Cell.copied{background:rgba(0,0,255,.2)!important}.react-grid-Cell--locked:last-of-type{border-right:1px solid #ddd;box-shadow:none}.react-grid-Cell:hover:focus .drag-handle .glyphicon-arrow-down{display:\"block\"}.react-grid-Cell.is-dragged-over-down{border-right:1px dashed #000;border-left:1px dashed #000;border-bottom:1px dashed #000}.react-grid-Cell.is-dragged-over-up{border-right:1px dashed #000;border-left:1px dashed #000;border-top:1px dashed #000}.react-grid-Cell.is-dragged-over-up .drag-handle{top:-5px}.react-grid-Cell:hover{background:#eee}.react-grid-cell .form-control-feedback{color:#a94442;position:absolute;top:0;right:10px;z-index:1000000;display:block;width:34px;height:34px}.react-grid-Cell.was-dragged-over{border-right:1px dashed #000;border-left:1px dashed #000}.react-grid-Cell:hover:focus .drag-handle{position:absolute;bottom:-8px;right:-7px;background:#fff;width:16px;height:16px;border:1px solid #66afe9;z-index:8;cursor:crosshair;cursor:-webkit-grab}.react-grid-Row.row-selected .react-grid-Cell{background-color:#dbecfa}.react-grid-Cell.editing{padding:0;overflow:visible!important}.react-grid-Cell--locked.editing{z-index:100}.react-grid-Cell.editing .has-error input{border:2px solid red!important;border-radius:2px!important}.react-grid-Cell__value ul{margin-top:0;margin-bottom:0;display:inline-block}.react-grid-Cell__value .btn-sm{padding:0}.cell-tooltip{position:relative;display:inline-block}.cell-tooltip:hover{z-index:101}.cell-tooltip .cell-tooltip-text{visibility:hidden;width:150px;background-color:#000;color:#fff;text-align:center;border-radius:6px;padding:5px 0;position:absolute;z-index:1;bottom:-150%;left:50%;margin-left:-60px;opacity:1s}.cell-tooltip:hover .cell-tooltip-text{visibility:visible;opacity:.8}.cell-tooltip .cell-tooltip-text:after{content:\" \";position:absolute;bottom:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:transparent transparent #000}.react-grid-Canvas.opaque .react-grid-Cell.cell-tooltip:hover .cell-tooltip-text{visibility:hidden}.rdg-cell-expand{top:0;right:20px;position:absolute;cursor:pointer}.rdg-child-row-action-cross-last:before,.rdg-child-row-action-cross:before,rdg-child-row-action-cross-last:after,rdg-child-row-action-cross:after{content:\"\";position:absolute;background:grey;height:50%}.rdg-child-row-action-cross:before{left:21px;width:1px;height:35px}.rdg-child-row-action-cross-last:before{left:21px;width:1px}.rdg-child-row-action-cross-last:after,.rdg-child-row-action-cross:after{top:50%;left:20px;height:1px;width:15px;content:\"\";position:absolute;background:grey}.rdg-child-row-action-cross:hover{background:red}.rdg-child-row-btn{position:absolute;cursor:pointer;border:1px solid grey;border-radius:14px;z-index:3;background:#fff}.rdg-child-row-btn div{font-size:12px;text-align:center;line-height:19px;color:grey;height:20px;width:20px;position:absolute;top:60%;left:53%;margin-top:-10px;margin-left:-10px}.rdg-empty-child-row:hover .glyphicon-plus-sign,.rdg-empty-child-row:hover a{color:green}.rdg-child-row-btn .glyphicon-remove-sign:hover{color:red}.last-column .cell-tooltip-text{right:100%;left:0!important}.rdg-cell-action{float:right;height:100%}.rdg-cell-action-last{margin-right:-8px}.rdg-cell-action-button{width:35px;height:100%;text-align:center;position:relative;display:table}.rdg-cell-action-button>span{display:table-cell;vertical-align:middle}.rdg-cell-action-button:hover{background-color:#fff}.rdg-cell-action-button-toggled{background-color:#fff;border-right:1px solid #ccc;border-left:1px solid #ccc}.rdg-cell-action-button-toggled:after{content:\"\";height:1px;position:absolute;bottom:-1px;left:0;right:0;background:inherit;z-index:10001}.rdg-cell-action-menu{position:absolute;top:100%;right:0;z-index:1000;float:left;min-width:160px;padding:5px 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc}.rdg-cell-action-menu>span{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.rdg-cell-action-menu>span:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}", ""]);

	// exports


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".radio-custom,.react-grid-checkbox{opacity:0;position:absolute}.radio-custom,.radio-custom-label,.react-grid-checkbox,.react-grid-checkbox-label{display:inline-block;vertical-align:middle;cursor:pointer}.radio-custom-label,.react-grid-checkbox-label{position:relative}.radio-custom+.radio-custom-label:before,.react-grid-checkbox+.react-grid-checkbox-label:before{content:\"\";background:#fff;border:2px solid #ddd;display:inline-block;vertical-align:middle;width:20px;height:20px;text-align:center}.react-grid-checkbox:checked+.react-grid-checkbox-label:before{background:#005295;box-shadow:inset 0 0 0 4px #fff}.radio-custom:focus+.radio-custom-label,.react-grid-checkbox:focus+.react-grid-checkbox-label{outline:1px solid #ddd}.react-grid-HeaderCell input[type=checkbox]{z-index:99999}.react-grid-HeaderCell>.react-grid-checkbox-container{padding:0 10px;height:100%}.react-grid-HeaderCell>.react-grid-checkbox-container>.react-grid-checkbox-label{margin:0;position:relative;top:50%;transform:translateY(-50%)}.radio-custom+.radio-custom-label:before{border-radius:50%}.radio-custom:checked+.radio-custom-label:before{background:#ccc;box-shadow:inset 0 0 0 4px #fff}.checkbox-align{text-align:center}", ""]);

	// exports


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Container{clear:both;margin-top:0;padding:0}.react-grid-Main{background-color:#fff;color:inherit;padding:0;outline:1px solid #e7eaec;clear:both}.react-grid-Grid{border:1px solid #ddd}.react-grid-Canvas,.react-grid-Grid{background-color:#fff}.react-grid-Cell input.editor-main,select.editor-main{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}input.editor-main:focus,select.editor-main:focus{border-color:#66afe9;border:2px solid #66afe9;background:#eee;border-radius:4px}.react-grid-Cell input.editor-main::-moz-placeholder,select.editor-main::-moz-placeholder{color:#999;opacity:1}.react-grid-Cell input.editor-main:-ms-input-placeholder,select.editor-main:-ms-input-placeholder{color:#999}.react-grid-Cell input.editor-main::-webkit-input-placeholder,select.editor-main::-webkit-input-placeholder{color:#999}.react-grid-Cell input.editor-main[disabled],.react-grid-Cell input.editor-main[readonly],fieldset[disabled] .react-grid-Cell input.editor-main,fieldset[disabled] select.editor-main,select.editor-main[disabled],select.editor-main[readonly]{cursor:not-allowed;background-color:#eee;opacity:1}textarea.react-grid-Cell input.editor-main,textareaselect.editor-main{height:auto}.react-grid-ScrollShim{z-index:10002}", ""]);

	// exports


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Header{box-shadow:0 0 4px 0 #ddd;background:#f9f9f9}.react-grid-Header--resizing{cursor:ew-resize}.react-grid-HeaderCell,.react-grid-HeaderRow{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.react-grid-HeaderCell{background:#f9f9f9;padding:8px;font-weight:700;border-right:1px solid #ddd;border-bottom:1px solid #ddd}.react-grid-HeaderCell__value{white-space:nowrap;text-overflow:ellipsis;overflow:hidden;position:relative;top:50%;transform:translateY(-50%)}.react-grid-HeaderCell__resizeHandle:hover{cursor:ew-resize;background:#ddd}.react-grid-HeaderCell--locked:last-of-type{box-shadow:none}.react-grid-HeaderCell--resizing .react-grid-HeaderCell__resizeHandle{background:#ddd}.react-grid-HeaderCell__draggable{cursor:col-resize}.rdg-can-drop>.react-grid-HeaderCell{background:#ececec}.react-grid-HeaderCell .Select{max-height:30px;font-size:12px;font-weight:400}.react-grid-HeaderCell .Select-control{max-height:30px;border:1px solid #ccc;color:#555;border-radius:3px}.react-grid-HeaderCell .is-focused:not(.is-open)>.Select-control{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.react-grid-HeaderCell .Select-control .Select-placeholder{line-height:20px;color:#999;padding:4px}.react-grid-HeaderCell .Select-control .Select-input{max-height:28px;padding:4px;margin-left:0}.react-grid-HeaderCell .Select-control .Select-input input{padding:0;height:100%}.react-grid-HeaderCell .Select-control .Select-arrow-zone .Select-arrow{border-color:gray transparent transparent;border-width:4px 4px 2.5px}.react-grid-HeaderCell .Select-control .Select-value{padding:4px;line-height:20px!important}.react-grid-HeaderCell .Select--multi .Select-control .Select-value{padding:0;line-height:16px!important;max-height:20px}.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-icon,.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-label{max-height:20px}.react-grid-HeaderCell .Select-control .Select-value .Select-value-label{color:#555!important}.react-grid-HeaderCell .Select-menu-outer .Select-option{padding:4px;line-height:20px}.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-focused,.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-selected{color:#555}", ""]);

	// exports


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Row.row-context-menu .react-grid-Cell,.react-grid-Row:hover .react-grid-Cell{background-color:#f9f9f9}.react-grid-Row:hover .rdg-row-index{display:none}.react-grid-Row:hover .rdg-actions-checkbox{display:block}.react-grid-Row:hover .rdg-drag-row-handle{cursor:move;cursor:grab;cursor:-moz-grab;cursor:-webkit-grab;width:12px;height:30px;margin-left:0;background-image:url(\"data:image/svg+xml;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjlweCIgaGVpZ2h0PSIyOXB4IiB2aWV3Qm94PSIwIDAgOSAyOSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggMzkgKDMxNjY3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5kcmFnIGljb248L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iQWN0dWFsaXNhdGlvbi12MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkRlc2t0b3AiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNS4wMDAwMDAsIC0yNjIuMDAwMDAwKSIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxnIGlkPSJJbnRlcmFjdGlvbnMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjAwMDAwMCwgMjU4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJvdy1Db250cm9scyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9ImRyYWctaWNvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMTIiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjEyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjIiIGN5PSIxNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMTciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iMiIgY3k9IjIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjciIGN5PSIyMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMjciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjI3IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==\");background-repeat:no-repeat}.react-grid-Row.row-selected,.react-grid-Row .row-selected{background-color:#dbecfa}.react-grid-row-group .row-expand-icon:hover{color:#777}.react-grid-row-index{padding:0 18px}.rdg-row-index{display:block;text-align:center}.rdg-row-actions-cell{padding:0}.rdg-actions-checkbox{display:none;text-align:center}.rdg-actions-checkbox.selected{display:block}.rdg-dragging{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.rdg-dragged-row{border-bottom:1px solid #000}", ""]);

	// exports


/***/ }),
/* 143 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (false) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2014 Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */

	"use strict";

	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function(obj) {
	  var ret = {};
	  var key;
	  if (!(obj instanceof Object && !Array.isArray(obj))) {
	    throw new Error('keyMirror(...): Argument must be an object.');
	  }
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};

	module.exports = keyMirror;


/***/ }),
/* 146 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(143);
	var invariant = __webpack_require__(144);
	var ReactPropTypesSecret = __webpack_require__(148);

	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };

	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};


/***/ }),
/* 148 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ })
/******/ ])
});
;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChartView = function (_React$Component) {
    _inherits(ChartView, _React$Component);

    function ChartView(props) {
        _classCallCheck(this, ChartView);

        var _this = _possibleConstructorReturn(this, (ChartView.__proto__ || Object.getPrototypeOf(ChartView)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(ChartView, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            //window.addEventListener("resize", this.redrawChart.bind(this));
            this.redrawChart();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.redrawChart();
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.state.chart != undefined) {
                this.state.chart.destroy();
            }
        }
    }, {
        key: 'redrawChart',
        value: function redrawChart() {
            if (this.state.chart != undefined) {
                this.state.chart.destroy();
                this.state.chart = undefined;
            }

            if (this.state.chart == undefined) {
                var ctx = document.getElementById(this.getDivId()).getContext("2d");
                var data = this.getChartData();
                var yAxes = undefined;
                if (data != undefined && Array.isArray(data.datasets)) {
                    var axis = [];
                    data.datasets.forEach(function (e) {
                        if (e.yAxisID != undefined && e.yAxisID != null) {
                            if (!axis.includes(e.yAxisID)) axis.push(e.yAxisID);
                        }
                    });

                    if (axis.length > 0) {
                        yAxes = [];
                        for (var i = 0; i < axis.length; i++) {
                            if (i == 0) {
                                yAxes.push({ type: 'linear', display: true, position: 'left', id: axis[i] });
                            } else {
                                yAxes.push({ type: 'linear', display: true, position: 'right', id: axis[i], gridLines: {
                                        drawOnChartArea: false
                                    } });
                            }
                        }
                    }
                }

                var config = {
                    type: this.props.chartType,
                    data: data,
                    options: {
                        responsive: Boolean(this.props.responsive),
                        legend: {
                            position: this.props.legendPosition
                        },
                        title: {
                            fontSize: this.props.titleSize == undefined ? 14 : this.props.titleSize,
                            display: this.props.title != undefined && this.props.title != "",
                            text: this.props.title
                        }
                    }
                };

                if (yAxes != undefined) config.options.scales = { yAxes: yAxes };

                this.state.chart = new Chart(ctx, config);
            } else {
                this.state.chart.update();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var style = this.props.style;
            var width = this.props.width != undefined ? this.props.width : "400px";
            if (style.width != undefined) width = style.width;
            var height = this.props.height != undefined ? this.props.height : "300px";
            if (style.height != undefined) {
                height = style.height;
            }

            if ((this.state.width != width || this.state.height != height) && this.state.chart != undefined) {
                this.state.chart.destroy();
                this.state.chart = undefined;
            }

            this.state.width = width;
            this.state.height = height;

            var className = "field";
            if (this.props.className != undefined) className += " " + this.props.className;

            return _react2.default.createElement(
                'div',
                { className: className, style: style },
                _react2.default.createElement('canvas', { id: this.getDivId(), width: width, height: height })
            );
        }
    }, {
        key: 'getDivId',
        value: function getDivId() {
            return "dwkit-chart-" + this.props.name;
        }
    }, {
        key: 'getChartData',
        value: function getChartData() {
            if (this.props.datasetCustom) {
                var me = this;

                var labels = [];
                if (me.props.dataLabels != undefined) {
                    labels = me.props.dataLabels.split(',');
                }

                var res = {
                    labels: labels,
                    datasets: [{
                        label: me.props.datasetLabel,
                        steppedLine: me.props.datasetSteppedLine,
                        borderColor: me.props.datasetBorderColor,
                        backgroundColor: me.props.datasetBackgroundColor,
                        fill: me.props.datasetFill,
                        borderWidth: me.props.datasetBorderWidth,
                        data: me.props.value
                    }]
                };
                return res;
            }

            return this.copyObj(this.props.value);
        }
    }, {
        key: 'copyObj',
        value: function copyObj(obj) {
            if (null == obj || "object" != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;
            var copy = obj.constructor();

            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = this.copyObj(obj[attr]);
            }
            return copy;
        }
    }]);

    return ChartView;
}(_react2.default.Component);

exports.default = ChartView;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WorkflowBar = function (_React$Component) {
  _inherits(WorkflowBar, _React$Component);

  function WorkflowBar(props) {
    _classCallCheck(this, WorkflowBar);

    var _this = _possibleConstructorReturn(this, (WorkflowBar.__proto__ || Object.getPrototypeOf(WorkflowBar)).call(this, props));

    _this.state = {
      commands: props.commands,
      states: props.states
    };

    _this.checkGetAdditionalDataForControl();
    return _this;
  }

  _createClass(WorkflowBar, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.isMount = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.isMount = false;
    }
  }, {
    key: 'checkGetAdditionalDataForControl',
    value: function checkGetAdditionalDataForControl() {
      if (this.props.getAdditionalDataForControl == undefined && this.props.commands == undefined && this.props.states == undefined) {
        if (console != undefined) {
          console.log("WorkflowBar: This control requres getAdditionalDataForControl or commands and states not undefined parameters!");
        }
      } else {
        var me = this;
        this.props.getAdditionalDataForControl(this, {}, function (_ref) {
          var commands = _ref.commands,
              states = _ref.states;

          me.state.commands = commands;
          me.state.states = states;

          if (me.props.handleEvent != undefined) {
            me.props.handleEvent({ key: me.props.name, eventName: "onReceivedCommands",
              parameters: {
                commands: me.state.commands,
                states: me.state.states
              }
            });
          }

          if (me.isMount) me.forceUpdate();
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var className = this.props.className + " dwkit-workflowbar";
      var style = this.props.style;

      var commands = this.state.commands != undefined ? this.state.commands : this.props.commands;
      var states = this.state.states != undefined ? this.state.states : this.props.states;

      return _react2.default.createElement(
        'div',
        { className: className, style: style },
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          null,
          this.renderCommands(commands),
          this.renderSetState(states)
        )
      );
    }
  }, {
    key: 'renderCommands',
    value: function renderCommands(commands) {
      if (Array.isArray(commands) && commands.length > 0) {
        var me = this;
        var res = [];

        commands.forEach(function (b) {
          res.push(_react2.default.createElement(
            _semanticUiReact.Button,
            { key: b.value, className: "buttontype" + b.type, onClick: me.onCommand.bind(me, b) },
            b.text
          ));
        });

        return res;
      }
      return undefined;
    }
  }, {
    key: 'renderSetState',
    value: function renderSetState(states) {
      if (Boolean(this.props.blockSetState)) {
        return;
      }

      if (Array.isArray(states) && states.length > 0) {
        var disableClick = this.state["setstate"] == undefined || this.state["setstate"] == "";

        var setStateButton = "Set state";

        if (this.props.setStateButton != undefined && this.props.setStateButton != "") {
          setStateButton = this.props.setStateButton;
        } else {
          if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.workflowbar != undefined) {
            setStateButton = window.DWKitAdminLang.workflowbar.setstate;
          }
        }

        return [_react2.default.createElement(_semanticUiReact.Form.Dropdown, {
          key: 'setstate',
          name: 'setstate',
          className: 'setstate',
          placeholder: 'States',
          options: states,
          onChange: this.handleChanged.bind(this),
          selection: true, fluid: true, search: true }), _react2.default.createElement(
          _semanticUiReact.Button,
          { key: 'btnsetstate', disabled: disableClick, className: 'buttontype2', onClick: this.onSetState.bind(this) },
          setStateButton
        )];
      }
      return undefined;
    }
  }, {
    key: 'onCommand',
    value: function onCommand(button) {
      if (this.props.handleEvent != undefined) {
        this.props.handleEvent({ key: this.props.name, eventName: "onCommandClick", parameters: { command: button } });
      }
    }
  }, {
    key: 'onSetState',
    value: function onSetState() {
      if (this.props.handleEvent != undefined) {

        var states = this.state.states != undefined ? this.state.states : this.props.states;
        var currentState = undefined;
        for (var i = 0; i < states.length; i++) {
          if (states[i].value == this.state.setstate) {
            currentState = states[i];
            break;
          }
        }

        this.props.handleEvent({ key: this.props.name, eventName: "onSetStateClick", parameters: { state: currentState } });
      }
    }
  }, {
    key: 'handleChanged',
    value: function handleChanged(e, _ref2) {
      var name = _ref2.name,
          value = _ref2.value;

      this.state[name] = value;
      this.forceUpdate();
    }
  }]);

  return WorkflowBar;
}(_react2.default.Component);

exports.default = WorkflowBar;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dictionary = function (_React$Component) {
    _inherits(Dictionary, _React$Component);

    function Dictionary(props) {
        _classCallCheck(this, Dictionary);

        var _this = _possibleConstructorReturn(this, (Dictionary.__proto__ || Object.getPrototypeOf(Dictionary)).call(this, props));

        _this.state = {
            options: []
        };

        _this.pageSize = props.pageSize;
        if (_this.pageSize == undefined || _this.pageSize == "") _this.pageSize = 100;
        return _this;
    }

    _createClass(Dictionary, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.GetAdditionalData();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this.GetAdditionalData();
        }
    }, {
        key: 'GetAdditionalData',
        value: function GetAdditionalData() {
            if (this.state.dataModel === undefined) {
                if (console !== undefined && this.props.buildermode == true) console.log("Dictionary: Set DataModel label!");
            } else if (this.state.getAdditionalDataForControl === undefined) {
                if (console !== undefined && this.props.buildermode == true) console.log("Dictionary: For paging on server need to set getAdditionalDataForControl func!");
            } else {
                if (this.state.needFetch) {
                    var me = this;
                    var settings = { model: this.state.dataModel };
                    var lastLoadPage = 0;
                    if (this.props.paging) {
                        settings.startIndex = 0;
                        settings.pageSize = this.pageSize;
                    }

                    this.state.isFetching = true;
                    this.state.needFetch = false;
                    this.state.getAdditionalDataForControl(this, settings, function (_ref) {
                        var items = _ref.items,
                            rowsCount = _ref.rowsCount;
                        //TODO cancellation token from async request
                        me.setData({ items: items, rowsCount: rowsCount, page: lastLoadPage }, true);
                    });
                }

                if (this.state.needValueFetch) {
                    this.state.needValueFetch = false;
                    this.loadCurrentValue();
                }
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var me = this;

            var controlProps = {};
            for (var p in this.props) {
                if (p == "parentIsForm" || p == "getAdditionalDataForControl" || p == "dataModel" || p == "clearable" || p == "columns" || p == "paging" || p == "pageSize") continue;
                controlProps[p] = this.props[p];
            }

            if (this.props.readOnly) controlProps.disabled = true;

            controlProps.options = this.state.options;
            controlProps.onChange = this.onChange.bind(this);
            if (this.props.paging) {
                controlProps.onSearchChange = this.handleSearchChange.bind(this);
                controlProps.onClose = this.onClose.bind(this);
                if (this.state.open) {
                    controlProps.open = true;
                }
            }

            if (controlProps.multiple) {
                if (controlProps.value == undefined || controlProps.value == null) {
                    controlProps.value = [];
                }

                if (!Array.isArray(controlProps.value)) {
                    controlProps.value = this.getArrayValues(controlProps.value);
                }
            }

            controlProps.loading = this.state.isFetching;
            controlProps.searchQuery = this.state.searchQuery;

            if (this.props.parentIsForm) {
                return _react2.default.createElement(_semanticUiReact.Form.Dropdown, controlProps);
            } else {
                var divClass = "ui labeled input";

                if (this.props.fluid) divClass += " fluid";

                if (this.props.error) divClass += " error";
                return _react2.default.createElement(
                    'div',
                    { className: divClass },
                    this.props.label != undefined && _react2.default.createElement(
                        'div',
                        { className: 'ui label label' },
                        this.props.label
                    ),
                    _react2.default.createElement(_semanticUiReact.Dropdown, controlProps)
                );
            }
        }
    }, {
        key: 'onChange',
        value: function onChange(e, _ref2) {
            var name = _ref2.name,
                value = _ref2.value;

            var loadFlag = false;
            if (this.props.multiple) {
                if (Array.isArray(value)) {
                    var isFind = false;
                    value.forEach(function (v) {
                        if (v === "__load") {
                            isFind = true;
                        }
                    });

                    if (isFind) {
                        loadFlag = true;
                    }
                }
            } else if (value === "__load") {
                loadFlag = true;
            }

            if (loadFlag) {
                this.state.open = true;
                this.setState({ isFetching: true });
                this.loadNextPage();
                value = this.props.value;
            } else if (this.state.open != undefined) {
                this.state.open = undefined;
            }

            if (this.props.onChange != undefined) this.props.onChange(e, { name: this.props.name, value: value });
        }
    }, {
        key: 'onClose',
        value: function onClose() {
            if (this.state.open != true && this.state.searchQuery != "") {
                this.state.isFetching = true;
                this.state.searchQuery = "";
                this.state.lastLoadPage = -1;

                this.loadNextPage(true);
            }
        }
    }, {
        key: 'handleSearchChange',
        value: function handleSearchChange(e, _ref3) {
            var searchQuery = _ref3.searchQuery;

            var me = this;
            setTimeout(function () {
                me.setState({
                    isFetching: true,
                    searchQuery: searchQuery,
                    lastLoadPage: -1
                });

                me.loadNextPage(true);
            }, 100);
        }
    }, {
        key: 'loadNextPage',
        value: function loadNextPage(reset) {
            var me = this;
            var settings = { model: this.state.dataModel };
            var page = this.state.lastLoadPage + 1;

            if (me.state.searchQuery != undefined && me.state.searchQuery != "") {
                settings.filters = [{
                    column: this.getCollumnsForFilter(),
                    term: "like",
                    value: me.state.searchQuery
                }];
            }

            settings.startIndex = page * this.pageSize;
            settings.pageSize = this.pageSize;

            this.state.getAdditionalDataForControl(this, settings, function (_ref4) {
                var items = _ref4.items,
                    rowsCount = _ref4.rowsCount;

                me.setData({ items: items, rowsCount: rowsCount, page: page }, reset);
            });
        }
    }, {
        key: 'setData',
        value: function setData(_ref5, reset) {
            var items = _ref5.items,
                rowsCount = _ref5.rowsCount,
                page = _ref5.page;

            var options = undefined;
            if (reset) {
                options = items;
                if (rowsCount > options.length) {
                    var text = (this.state.searchQuery != undefined ? this.state.searchQuery : "") + "...";
                    options.push({ key: "__load", value: "__load", text: text });
                }

                if (Boolean(this.props.clearable) && !Boolean(this.props.multiple)) {
                    options.unshift({ key: "__reset", value: "", text: "   " });
                }

                if (Boolean(this.props.multiple)) {
                    var values = this.getArrayValues(this.props.value);
                    for (var i = 0; i < values.length; i++) {
                        var value = values[i];
                        for (var j = 0; j < this.state.options.length; j++) {
                            var option = this.state.options[j];
                            if (value == option.value) {
                                options.unshift(option);
                            }
                        }
                    }
                }
            } else {
                options = this.state.options;
                var loadingItem = undefined;
                if (options.length > 0 && options[options.length - 1].key == "__load") {
                    loadingItem = options.pop();
                }

                for (var _i = 0; _i < items.length; _i++) {
                    var item = items[_i];
                    for (var _j = 0; _j < options.length; _j++) {
                        var _option = options[_j];
                        if (_option.key == item.key) {
                            options.splice(_j, 1);
                            break;
                        }
                    }
                    options.push(item);
                }

                if (loadingItem != undefined && rowsCount > options.length) options.push(loadingItem);
            }

            this.setState({
                needFetch: false,
                options: options,
                rowsCount: rowsCount,
                isFetching: false,
                lastLoadPage: page });
        }
    }, {
        key: 'getArrayValues',
        value: function getArrayValues(value) {
            var res = value;
            if (!Array.isArray(res)) {
                var valueArray = void 0;
                try {
                    valueArray = JSON.parse(res);
                } catch (e) {}
                ;

                if (!Array.isArray(valueArray)) {
                    valueArray = [res];
                }

                res = valueArray;
            }
            return res;
        }
    }, {
        key: 'loadCurrentValue',
        value: function loadCurrentValue() {
            var me = this;
            if (this.props.value != undefined && this.props.value != null) {
                if (this.props.multiple) {
                    var values = this.getArrayValues(this.props.value);
                    var unfindedValues = [];
                    for (var i = 0; i < values.length; i++) {
                        var value = values[i];
                        var isFind = false;
                        for (var j = 0; j < this.state.options.length; j++) {
                            var option = this.state.options[j];
                            if (option.value == value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            unfindedValues.push(value);
                        }
                    }

                    if (unfindedValues.length > 0) {
                        var settings = { model: this.state.dataModel };
                        settings.filters = [{
                            column: "__id",
                            term: 'in',
                            value: unfindedValues
                        }];
                        this.state.isFetching = true;

                        this.state.getAdditionalDataForControl(this, settings, function (_ref6) {
                            var items = _ref6.items;

                            me.addAdditionalOptions(items);
                        });
                    }
                } else {
                    var _isFind = false;
                    for (var _i2 = 0; _i2 < this.state.options.length; _i2++) {
                        var _option2 = this.state.options[_i2];
                        if (_option2.value == this.props.value) {
                            _isFind = true;
                            break;
                        }
                    }

                    if (!_isFind) {
                        var settings = { model: this.state.dataModel };
                        settings.filters = [{
                            column: "__id",
                            term: '=',
                            value: me.props.value
                        }];
                        this.state.isFetching = true;

                        this.state.getAdditionalDataForControl(this, settings, function (_ref7) {
                            var items = _ref7.items;

                            me.addAdditionalOptions(items);
                        });
                    }
                }
            }
        }
    }, {
        key: 'addAdditionalOptions',
        value: function addAdditionalOptions(items) {
            if (!Array.isArray(items) || items.length == 0) return;

            var options = this.state.options;

            for (var i = items.length - 1; i >= 0; i--) {
                var isFind = false;
                for (var j = 0; j < options.length; j++) {
                    if (options[j].key == items[i].key) {
                        isFind = true;
                        break;
                    }
                }

                if (!isFind) {
                    options.unshift(items[i]);
                }
            }

            this.state.isFetching = false;
            this.forceUpdate();
        }
    }, {
        key: 'getCollumnsForFilter',
        value: function getCollumnsForFilter() {
            var pattern = new RegExp(' asc', 'gi');
            var res = this.props.columns.replace(pattern, '');

            pattern = new RegExp(' desc', 'gi');
            res = res.replace(pattern, '');

            pattern = new RegExp(' ', 'gi');
            res = res.replace(pattern, '');

            return res;
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (nextProps.dataModel != prevState.dataModel) {
                return {
                    getAdditionalDataForControl: nextProps.getAdditionalDataForControl,
                    dataModel: nextProps.dataModel,
                    needFetch: true,
                    needValueFetch: true
                };
            }

            if (nextProps.paging && nextProps.value != prevState.value && nextProps.value != undefined) {
                return {
                    needValueFetch: true
                };
            }

            return null;
        }
    }]);

    return Dictionary;
}(_react2.default.Component);

exports.default = Dictionary;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(Container, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement('div', this.props);
    }
  }]);

  return Container;
}(_react2.default.Component);

exports.default = Container;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StaticContent = function (_React$Component) {
  _inherits(StaticContent, _React$Component);

  function StaticContent(props) {
    _classCallCheck(this, StaticContent);

    var _this = _possibleConstructorReturn(this, (StaticContent.__proto__ || Object.getPrototypeOf(StaticContent)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(StaticContent, [{
    key: "render",
    value: function render() {
      var spanProps = {
        name: this.props.name,
        className: this.props["style-customcss"],
        style: this.props.style,
        "data-buildertype": this.props["data-buildertype"]
      };

      if (this.props.isHtml) {
        return _react2.default.createElement("span", _extends({}, spanProps, { dangerouslySetInnerHTML: { __html: this.props.content } }));
      } else {
        var content = this.props.content != undefined ? this.props.content.replace('\n', '<br/>') : undefined;
        return _react2.default.createElement(
          "span",
          spanProps,
          content
        );
      }
    }
  }]);

  return StaticContent;
}(_react2.default.Component);

exports.default = StaticContent;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _actions = __webpack_require__(6);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControlBar = function (_React$Component) {
  _inherits(ControlBar, _React$Component);

  function ControlBar() {
    _classCallCheck(this, ControlBar);

    return _possibleConstructorReturn(this, (ControlBar.__proto__ || Object.getPrototypeOf(ControlBar)).apply(this, arguments));
  }

  _createClass(ControlBar, [{
    key: 'onDragStart',
    value: function onDragStart(item, e) {
      var selector = '.dwkit-formbuilder-zone';

      e.dataTransfer.setData('text', '');
      if (item.forContainerType != undefined) {
        var cTypes = item.forContainerType.split(',');
        var subSelector = "";
        cTypes.forEach(function (c) {
          if (subSelector.length > 0) subSelector += ",";
          subSelector += "[data-buildertype='" + c + "'] > " + selector;
        });
        selector = subSelector;
      }

      $(selector).addClass('dwkit-formbuilder-zone-active').on('dragenter', this.onTargetDragEnter.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragleave', this.onTargetDragLeave.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragover', function (e) {
        e.preventDefault();
      }).on('drop', this.onDrop.bind(this, item));
    }
  }, {
    key: 'onTargetDragEnter',
    value: function onTargetDragEnter(item, css, e) {
      $(e.target).addClass(css);
    }
  }, {
    key: 'onTargetDragLeave',
    value: function onTargetDragLeave(item, css, e) {
      $(e.target).removeClass(css);
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(item) {
      var zones = $('.dwkit-formbuilder-zone');

      zones.removeClass('dwkit-formbuilder-zone-active');
      zones.removeClass('dwkit-formbuilder-zone-select');
      zones.off();
    }
  }, {
    key: 'onDrop',
    value: function onDrop(item, e) {
      var el = $(e.target);
      if (el.length > 0) {
        _actions2.default.move(item.key, el[0]);
      }

      this.onDragEnd(item);
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var className = "dwkit-formbuilder-item-toolbar-header";
      if (this.props.isGroup) className += " " + "dwkit-formbuilder-item-toolbar-controlbargroup";

      if (this.props.controlOnRight) {
        className += " " + "dwkit-formbuilder-item-toolbar-right";
      } else {
        className += " " + "dwkit-formbuilder-item-toolbar-left";
      }

      return _react2.default.createElement(
        'div',
        { className: className,
          onMouseOver: this.onMouseOver.bind(this),
          onMouseLeave: this.onMouseLeave.bind(this) },
        _react2.default.createElement(
          'div',
          { className: 'dwkit-formbuilder-item-toolbar-header-buttons' },
          _react2.default.createElement(
            'div',
            { className: 'dwkit-formbuilder-item-toolbar-header-title' },
            this.props.text
          ),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-move.svg', className: 'move', height: '16px', draggable: true,
            onDragStart: this.onDragStart.bind(this, this.props.model),
            onDragEnd: this.onDragEnd.bind(this, this.props.model),
            onDrag: this.onDrag.bind(this) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-edit.svg', height: '16px', onClick: this.props.onEdit.bind(this.props.parent, this.props.model) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-copy.svg', height: '16px', onClick: this.props.onCopy.bind(this.props.parent, this.props.model) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-delete.svg', height: '16px', onClick: this.props.onDelete.bind(this.props.parent, this.props.model) })
        )
      );
    }
  }, {
    key: 'onMouseOver',
    value: function onMouseOver(e) {
      var el = $(e.target).parents(".dwkit-formbuilder-item-toolbar-header");
      if (this.props.controlOnRight) {
        el.prev().addClass("dwkit-formbuilder-item-selected");
      } else {
        el.next().addClass("dwkit-formbuilder-item-selected");
      }
    }
  }, {
    key: 'onMouseLeave',
    value: function onMouseLeave(e) {
      var el = $(e.target);
      var parents = $(e.target).parents(".dwkit-formbuilder-item-toolbar-header");
      if (this.props.controlOnRight) {
        el.prev().removeClass("dwkit-formbuilder-item-selected");
        parents.prev().removeClass("dwkit-formbuilder-item-selected");
      } else {
        el.next().removeClass("dwkit-formbuilder-item-selected");
        parents.next().removeClass("dwkit-formbuilder-item-selected");
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(e) {
      var step = 10;
      if (e.clientY < 150) {
        this.scroll(-step);
      }

      if (e.clientY > $(window).height() - 150) {
        this.scroll(step);
      }
    }
  }, {
    key: 'scroll',
    value: function (_scroll) {
      function scroll(_x) {
        return _scroll.apply(this, arguments);
      }

      scroll.toString = function () {
        return _scroll.toString();
      };

      return scroll;
    }(function (step) {
      var scrollY = $(window).scrollTop();
      $(window).scrollTop(scrollY + step);
      if (!stop) {
        setTimeout(function () {
          scroll(step);
        }, 20);
      }
    })
  }]);

  return ControlBar;
}(_react2.default.Component);

exports.default = ControlBar;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropdownTrigger = function (_React$Component) {
  _inherits(DropdownTrigger, _React$Component);

  function DropdownTrigger(props) {
    _classCallCheck(this, DropdownTrigger);

    var _this = _possibleConstructorReturn(this, (DropdownTrigger.__proto__ || Object.getPrototypeOf(DropdownTrigger)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(DropdownTrigger, [{
    key: 'render',
    value: function render() {
      var me = this;

      var controlProps = {};
      for (var p in this.props) {
        if (p == "imageUrl" || p == "defaultValue" || p == "value" || p == "handleEvent" || p == "items") continue;
        controlProps[p] = this.props[p];
      }

      controlProps.options = [];
      this.props.items.forEach(function (item) {

        var isSkip = false;
        if (item.visibleCondition !== undefined && item.visibleCondition !== null && item.visibleCondition !== "") {
          var args = '';
          var body = 'return ' + item.visibleCondition;
          try {
            if (!new Function(args, body)()) {
              isSkip = true;
            }
          } catch (e) {};
        }

        if (!isSkip) controlProps.options.push({ value: item.target, text: item.title, target: item.target });
      });
      controlProps.onChange = this.onChange.bind(this);
      controlProps.trigger = _react2.default.createElement(
        'span',
        null,
        this.props.imageUrl != undefined && _react2.default.createElement(_semanticUiReact.Image, { avatar: true, src: this.props.imageUrl }),
        ' ',
        this.props.value != undefined ? this.props.value : this.props.defaultValue
      );
      return _react2.default.createElement(_semanticUiReact.Dropdown, _extends({}, controlProps, {
        onMouseDown: this.onMouseDown.bind(this)
      }));
    }
  }, {
    key: 'onChange',
    value: function onChange(e, _ref) {
      var name = _ref.name,
          value = _ref.value;

      if (this.state.opendialog == true) {
        this.state.opendialog = false;
        return;
      }

      if (this.props.handleEvent != undefined) {
        this.props.handleEvent({ e: e, key: this.props.name, eventName: "onItemClick", parameters: { target: value } });
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.state.opendialog = !Boolean(this.state.opendialog);
    }
  }]);

  return DropdownTrigger;
}(_react2.default.Component);

exports.default = DropdownTrigger;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _upload = __webpack_require__(22);

var _upload2 = _interopRequireDefault(_upload);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _datepicker = __webpack_require__(23);

var _datepicker2 = _interopRequireDefault(_datepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SemanticControl = function (_React$Component) {
  _inherits(SemanticControl, _React$Component);

  function SemanticControl(props) {
    _classCallCheck(this, SemanticControl);

    var _this = _possibleConstructorReturn(this, (SemanticControl.__proto__ || Object.getPrototypeOf(SemanticControl)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(SemanticControl, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var me = this;
      var propsControl = {};
      for (var p in this.props) {
        if (p === "additionalParams" || p === "items") continue;

        propsControl[p] = this.props[p];
      }

      var model = this.props.additionalParams.model;
      var data = this.props.additionalParams.data;
      var errors = this.props.additionalParams.errors;
      var children = this.props.additionalParams.children;
      var parentItem = this.props.additionalParams.parentItem;
      var handleEvent = this.props.additionalParams.handleEvent;

      var type = model["data-buildertype"];

      var res;
      if (type === 'header') {
        res = _react2.default.createElement(_semanticUiReact.Header, _extends({}, propsControl, {
          textAlign: model.textAlign,
          size: model.size,
          content: this.props.content,
          subheader: this.props.subheader }));
      } else if (type === 'button') {
        propsControl.floated = model.floated;
        propsControl.size = model.size !== "" ? model.size : null;
        propsControl.content = model.content;
        propsControl.type = model.buttonType;
        propsControl.basic = model.basic;
        propsControl.circular = model.circular;
        propsControl.compact = model.compact;
        propsControl.disabled = model.disabled;
        propsControl.fluid = model.fluid;
        propsControl.inverted = model.inverted;
        propsControl.loading = model.loading;
        propsControl.primary = model.primary;
        propsControl.secondary = model.secondary;
        propsControl.toggle = model.toggle;

        if (handleEvent !== undefined) {
          propsControl.onClick = function (e) {
            return handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onClick" });
          };
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Button, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Button, propsControl);
        }
      } else if (type === 'label') {
        res = _react2.default.createElement(_semanticUiReact.Label, _extends({}, propsControl, {
          size: model.size,
          content: this.props.content,
          attached: model.attached,
          basic: model.basic,
          circular: model.circular,
          corner: model.corner,
          floating: model.floating,
          horizontal: model.horizontal,
          pointing: model.pointing }));
      } else if (type === 'message') {
        res = _react2.default.createElement(_semanticUiReact.Message, _extends({}, propsControl, {
          floated: model.floated,
          size: model.size,
          content: this.props.content,
          compact: model.compact,
          error: model.error,
          floating: model.floating,
          info: model.info,
          negative: model.negative,
          positive: model.positive,
          success: model.success,
          warning: model.warning,
          header: this.props.header
        }));
      } else if (type === 'input') {
        propsControl.defaultValue = model.defaultvalue;
        propsControl.size = model.size;

        if (model.label != undefined && model.label != "") propsControl.label = model.label;

        propsControl.labelPosition = model.labelPosition;
        propsControl.placeholder = model.placeholder;
        propsControl.type = model.type;
        propsControl.loading = model.loading;
        propsControl.inverted = model.inverted;
        propsControl.error = model.error;
        propsControl.disabled = model.disabled;
        propsControl.transparent = model.transparent;
        propsControl.fluid = model.fluid;
        propsControl.readOnly = model.readOnly || this.props.readOnly;

        if (handleEvent != null) {
          propsControl.onChange = function (e, _ref) {
            var name = _ref.name,
                value = _ref.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        if (data != undefined && data != null) {
          propsControl.value = data[propsControl.name];
        } else propsControl.value = "";

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (propsControl.type === "file") {
          propsControl.isForm = this.isForm(parentItem);
          res = _react2.default.createElement(_upload2.default, _extends({}, propsControl, {
            downloadUrl: this.props.additionalParams.downloadUrl,
            uploadUrl: this.props.additionalParams.uploadUrl }));
        } else if (propsControl.type === "date" || propsControl.type === "time" || propsControl.type === "datetime") {
          propsControl.isForm = this.isForm(parentItem);
          // propsControl.dateFormat = model.dateFormat;
          res = _react2.default.createElement(_datepicker2.default, propsControl);
        } else {
          if (this.isForm(parentItem)) {
            res = _react2.default.createElement(_semanticUiReact.Form.Input, propsControl);
          } else {
            res = _react2.default.createElement(_semanticUiReact.Input, propsControl);
          }
        }
      } else if (type === 'textarea') {
        propsControl.placeholder = model.placeholder;
        propsControl.rows = model.rows !== null && model.rows !== undefined ? Number(model.rows) : undefined;

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.autoHeight = model.autoHeight;
        propsControl.readOnly = model.readOnly || this.props.readOnly;

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref2) {
            var name = _ref2.name,
                value = _ref2.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        if (data != undefined) propsControl.value = data[propsControl.name];

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.TextArea, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.TextArea, propsControl);
        }
      } else if (type === 'checkbox') {

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.placeholder = model.placeholder;
        propsControl.type = model.type;
        propsControl.disabled = model.disabled;
        propsControl.fitted = model.fitted;
        propsControl.indeterminate = model.indeterminate;
        propsControl.readOnly = model.readOnly || this.props.readOnly;
        propsControl.slider = model.slider;
        propsControl.toggle = model.toggle;

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref3) {
            var name = _ref3.name,
                checked = _ref3.checked;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: checked });
          };
        }

        if (data !== undefined) {
          if (typeof variable === "boolean") {
            propsControl.checked = data[propsControl.name];
          } else if (data[propsControl.name] === "true" || data[propsControl.name] === "1") {
            propsControl.checked = true;
          } else if (data[propsControl.name] === "false" || data[propsControl.name] === "0") {
            propsControl.checked = false;
          } else {
            propsControl.checked = Boolean(data[propsControl.name]);
          }
        }

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Checkbox, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Checkbox, propsControl);
        }
      } else if (type === 'dropdown') {
        var options = [];
        if (model["data-elements"] !== undefined) {
          if (Array.isArray(model["data-elements"])) {
            options = model["data-elements"];
          } else {
            options = _json2.default.parse(model["data-elements"]);
          }
        }

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.defaultValue = model.defaultvalue;
        propsControl.placeholder = model.placeholder;
        propsControl.options = options;
        propsControl.loading = model.loading;
        propsControl.error = model.error;
        propsControl.fluid = model.fluid;
        propsControl.selection = model.selection;
        propsControl.multiple = model.multiple;
        propsControl.search = model.search;
        propsControl.disabled = model.disabled || model.readOnly || this.props.readOnly;

        if (data !== undefined) propsControl.value = data[propsControl.name];

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref4) {
            var name = _ref4.name,
                value = _ref4.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        propsControl.allowAdditions = model.allowAddItems;
        if (propsControl.allowAdditions) {
          propsControl.onAddItem = function (e, _ref5) {
            var value = _ref5.value;

            var v = propsControl.value;
            if (Array.isArray(v)) v.push(value);else {
              v = [value];
            }

            propsControl.onChange(e, { name: propsControl.name, value: v });
          };
        }

        if (propsControl.multiple) {
          if (propsControl.value === undefined || propsControl.value === null) {
            propsControl.value = [];
          }

          if (!Array.isArray(propsControl.value)) {
            var valueArray = void 0;
            try {
              valueArray = _json2.default.parse(propsControl.value);
            } catch (e) {};

            if (!Array.isArray(valueArray)) {
              valueArray = [propsControl.value];
            }

            propsControl.value = valueArray;
          }

          if (propsControl.allowAdditions) {
            this.dropdownCheckAdditional(propsControl.value, propsControl.options);
          }
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Dropdown, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Dropdown, propsControl);
        }
      } else if (type === 'statistic') {
        var items = [];
        if (model["data-elements"] !== undefined) {
          if (Array.isArray(model["data-elements"])) {
            items = model["data-elements"];
          } else {
            items = _json2.default.parse(model["data-elements"]);
          }
        }

        res = _react2.default.createElement(_semanticUiReact.Statistic.Group, _extends({}, propsControl, {
          floated: model.floated,
          horizontal: model.horizontal,
          size: model.size,
          items: items }));
      } else if (type === 'image') {
        res = _react2.default.createElement(_semanticUiReact.Image, _extends({}, propsControl, {
          avatar: model.avatar,
          bordered: model.bordered,
          centered: model.centered,
          disabled: model.disabled,
          inline: model.inline,
          href: this.props.href,
          src: this.props.src,
          floated: model.floated,
          shape: model.shape,
          spaced: model.spaced,
          verticalAlign: model.verticalAlign,
          height: model.height,
          width: model.width }));
      } else if (type === 'form') {
        res = _react2.default.createElement(_semanticUiReact.Form, _extends({}, propsControl, {
          children: children,
          size: model.size,
          loading: model.loading,
          error: model.error,
          inverted: model.inverted,
          reply: model.reply,
          success: model.success,
          warning: model.warning }));
      } else if (type === 'formgroup') {
        var widths = model.widths;
        if (widths === "custom") widths = model.widthsCustom;

        if (model.orientation) propsControl[model.orientation] = true;

        res = _react2.default.createElement(_semanticUiReact.Form.Group, _extends({}, propsControl, {
          widths: widths,
          children: children }));
      } else if (type === 'breadcrumb') {
        var _children = [];
        if (Array.isArray(this.props.items)) {
          var _loop = function _loop(i) {
            var item = _this2.props.items[i];
            var childProps = { key: i };
            childProps.active = item.active;
            childProps.href = item.url;
            if (handleEvent !== null) {
              childProps.onClick = function (e, _ref6) {
                var name = _ref6.name,
                    checked = _ref6.checked;

                handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onItemClick", parameters: { target: item.url } });
                e.preventDefault();
              };
            }
            _children.push(_react2.default.createElement(
              _semanticUiReact.Breadcrumb.Section,
              childProps,
              item.text === undefined ? "<not set>" : item.text
            ));
            if (i < _this2.props.items.length - 1) {
              var dividerProps = {
                key: i + "_d"
              };
              if (item.divider !== "") dividerProps.icon = item.divider;
              _children.push(_react2.default.createElement(_semanticUiReact.Breadcrumb.Divider, dividerProps));
            }
          };

          for (var i = 0; i < this.props.items.length; i++) {
            _loop(i);
          }
        }
        res = _react2.default.createElement(_semanticUiReact.Breadcrumb, _extends({}, propsControl, { children: _children }));
      } else {
        res = _react2.default.createElement(
          'span',
          null,
          'Unknow type \'',
          type,
          '\' of \'',
          this.props.name,
          '\' element.'
        );
      }
      return res;
    }
  }, {
    key: 'isForm',
    value: function isForm(m) {
      return m != null && (m["data-buildertype"] === "form" || m["data-buildertype"] === "formgroup");
    }
  }, {
    key: 'dropdownCheckAdditional',
    value: function dropdownCheckAdditional(value, options) {
      if (!Array.isArray(value)) return;
      value.forEach(function (v) {
        var isFind = false;
        for (var i = 0; i < options.length; i++) {
          var o = options[i];
          if (v === o.value) {
            isFind = true;
            break;
          }
        }

        if (isFind == false) {
          options.push({ value: v, text: v });
        }
      });
    }
  }]);

  return SemanticControl;
}(_react2.default.Component);

exports.default = SemanticControl;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _reactDropzoneComponent = __webpack_require__(65);

var _reactDropzoneComponent2 = _interopRequireDefault(_reactDropzoneComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dropzone = function (_React$Component) {
  _inherits(Dropzone, _React$Component);

  function Dropzone(props) {
    _classCallCheck(this, Dropzone);

    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this, props));

    _this.state = {
      commands: props.commands,
      states: props.states
    };
    return _this;
  }

  _createClass(Dropzone, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.isMount = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.isMount = false;
    }
  }, {
    key: 'render',
    value: function render() {
      var me = this;

      var data = this.props.additionalParams.data;
      var errors = this.props.additionalParams.errors;
      var parentItem = this.props.additionalParams.parentItem;
      var handleEvent = this.props.additionalParams.handleEvent;

      var iconFiletypes = undefined;
      if (this.props.iconFiletypes != undefined && this.props.iconFiletypes != "") {
        var types = this.props.iconFiletypes.split(",");
        if (Array.isArray(types) && types.length > 0) {
          iconFiletypes = [];
          types.forEach(function (t) {
            iconFiletypes.push(t.trim());
          });
        }
      }

      var djsConfig = {
        addRemoveLinks: this.props.addRemoveLinks,
        autoProcessQueue: this.props.autoProcessQueue && this.props.postUrl != undefined
      };

      var componentConfig = {
        iconFiletypes: iconFiletypes,
        showFiletypeIcon: this.props.showFiletypeIcon,
        postUrl: this.props.postUrl == undefined ? "no-url" : this.props.postUrl
      };

      var eventHandlers = {
        success: me.fileUploadSuccess.bind(this)
      };
      // if(handleEvent != undefined){
      //   var events = this.getEvents();
      //   events.forEach(function(e){
      //     eventHandlers[e] = handleEvent({ key: me.props.name, eventName: e});
      //   });
      // }

      var control = this.props.readOnly ? _react2.default.createElement('div', null) : _react2.default.createElement(_reactDropzoneComponent2.default, { config: componentConfig, eventHandlers: eventHandlers, djsConfig: djsConfig });

      var res = undefined;
      if (this.isForm(parentItem)) {
        res = _react2.default.createElement(
          'div',
          { className: 'field' },
          control
        );
      } else {
        res = control;
      }
      return res;
    }
  }, {
    key: 'isForm',
    value: function isForm(m) {
      return m != null && (m["data-buildertype"] == "form" || m["data-buildertype"] == "formgroup");
    }
  }, {
    key: 'fileUploadSuccess',
    value: function fileUploadSuccess(file, response) {
      var handleEvent = this.props.additionalParams.handleEvent;
      if (handleEvent != undefined) {
        handleEvent({ key: this.props.name,
          eventName: "success",
          name: this.props.name,
          value: response.message,
          parameters: {
            name: file.name,
            size: file.size,
            token: response.message
          }
        });

        setTimeout(function () {
          file._removeLink.click();
        }, 500);
      }
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      return ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "removedfile", "thumbnail", "error", "processing", "uploadprogress", "sending", "success", "complete", "canceled", "maxfilesreached", "maxfilesexceeded", "processingmultiple", "sendingmultiple", "successmultiple", "completemultiple", "canceledmultiple", "totaluploadprogress", "reset", "queuecompleted"];
    }
  }]);

  return Dropzone;
}(_react2.default.Component);

exports.default = Dropzone;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(0),__webpack_require__(5)):"function"==typeof define&&define.amd?define(["react","react-dom"],t):"object"==typeof exports?exports.ReactDropzone=t(require("react"),require("react-dom")):e.ReactDropzone=t(e.React,e.ReactDOM)}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=1)}([function(t,n){t.exports=e},function(e,t,n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.DropzoneComponent=void 0;var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),o=i(n(0)),s=i(n(2)),a=i(n(3)),l=n(4),u=null,c=t.DropzoneComponent=function(e){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.state={files:[]},n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,o.default.Component),r(t,[{key:"getDjsConfig",value:function(){var e={url:this.props.config.postUrl?this.props.config.postUrl:null};return this.props.djsConfig?(0,a.default)(!0,{},e,this.props.djsConfig):e}},{key:"componentDidMount",value:function(){var e=this.getDjsConfig();(u=u||n(5)).autoDiscover=!1,this.props.config.postUrl||this.props.eventHandlers.drop||console.info('Neither postUrl nor a "drop" eventHandler specified, the React-Dropzone component might misbehave.');var t=this.props.config.dropzoneSelector||s.default.findDOMNode(this);this.dropzone=new u(t,e),this.setupEvents()}},{key:"componentWillUnmount",value:function(){var e=this;if(this.dropzone)if(this.dropzone.getActiveFiles().length>0){this.queueDestroy=!0;var t=window.setInterval(function(){return!1===e.queueDestroy?window.clearInterval(t):0===e.dropzone.getActiveFiles().length?(e.dropzone=e.destroy(e.dropzone),window.clearInterval(t)):void 0},500)}else this.dropzone=this.destroy(this.dropzone)}},{key:"componentDidUpdate",value:function(){if(this.queueDestroy=!1,!this.dropzone){var e=this.props.config.dropzoneSelector||s.default.findDOMNode(this);this.dropzone=new u(e,this.getDjsConfig())}}},{key:"componentWillUpdate",value:function(){var e,t=void 0;e=this.props.djsConfig?this.props.djsConfig:{};try{t=this.props.config.postUrl?{url:this.props.config.postUrl}:{}}catch(e){t={}}this.dropzone.options=(0,a.default)(!0,{},this.dropzone.options,e,t)}},{key:"render",value:function(){var e=[],t=this.state.files,n=this.props.config,i=this.props.className?"filepicker dropzone "+this.props.className:"filepicker dropzone";if(n.showFiletypeIcon&&n.iconFiletypes&&(!t||t.length<1))for(var r=0;r<this.props.config.iconFiletypes.length;r+=1)e.push(o.default.createElement(l.Icon,{filetype:n.iconFiletypes[r],key:"icon-component"+r}));return!this.props.config.postUrl&&this.props.action?o.default.createElement("form",{action:this.props.action,className:i},e,this.props.children):o.default.createElement("div",{className:i}," ",e," ",this.props.children," ")}},{key:"setupEvents",value:function(){var e=this,t=this.props.eventHandlers;if(this.dropzone&&t){for(var n in t)if(t.hasOwnProperty(n)&&t[n])if("[object Array]"===Object.prototype.toString.call(t[n]))for(var i=0;i<t[n].length;i+=1)"init"===n?t[n][i](this.dropzone):this.dropzone.on(n,t[n][i]);else"init"===n?t[n](this.dropzone):this.dropzone.on(n,t[n]);this.dropzone.on("addedfile",function(t){if(t){var n=e.state.files||[];n.push(t),e.setState({files:n})}}),this.dropzone.on("removedfile",function(t){if(t){var n=e.state.files||[];n.forEach(function(e,i){e.name===t.name&&e.size===t.size&&n.splice(i,1)}),e.setState({files:n})}})}}},{key:"destroy",value:function(e){return e.off(),e.destroy()}}]),t}();c.defaultProps={djsConfig:{},config:{},eventHandlers:{}},t.default=c},function(e,n){e.exports=t},function(e,t,n){"use strict";var i=Object.prototype.hasOwnProperty,r=Object.prototype.toString,o=function(e){return"function"==typeof Array.isArray?Array.isArray(e):"[object Array]"===r.call(e)},s=function(e){if(!e||"[object Object]"!==r.call(e))return!1;var t,n=i.call(e,"constructor"),o=e.constructor&&e.constructor.prototype&&i.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!n&&!o)return!1;for(t in e);return void 0===t||i.call(e,t)};e.exports=function e(){var t,n,i,r,a,l,u=arguments[0],c=1,d=arguments.length,p=!1;for("boolean"==typeof u&&(p=u,u=arguments[1]||{},c=2),(null==u||"object"!=typeof u&&"function"!=typeof u)&&(u={});c<d;++c)if(null!=(t=arguments[c]))for(n in t)i=u[n],u!==(r=t[n])&&(p&&r&&(s(r)||(a=o(r)))?(a?(a=!1,l=i&&o(i)?i:[]):l=i&&s(i)?i:{},u[n]=e(p,l,r)):void 0!==r&&(u[n]=r));return u}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Icon=void 0;var i,r=n(0),o=(i=r)&&i.__esModule?i:{default:i};t.Icon=function(e){return o.default.createElement("div",{"data-filetype":e.filetype,className:"filepicker-file-icon"})}},function(e,t,n){"use strict";(function(e){function t(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),r=function(){function e(){n(this,e)}return i(e,[{key:"on",value:function(e,t){return this._callbacks=this._callbacks||{},this._callbacks[e]||(this._callbacks[e]=[]),this._callbacks[e].push(t),this}},{key:"emit",value:function(e){this._callbacks=this._callbacks||{};var t=this._callbacks[e];if(t){for(var n=arguments.length,i=Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];for(var o=0,s=s=t;!(o>=s.length);)s[o++].apply(this,i)}return this}},{key:"off",value:function(e,t){if(!this._callbacks||0===arguments.length)return this._callbacks={},this;var n=this._callbacks[e];if(!n)return this;if(1===arguments.length)return delete this._callbacks[e],this;for(var i=0;i<n.length;i++)if(n[i]===t){n.splice(i,1);break}return this}}]),e}(),o=function(e){function o(e,i){n(this,o);var r,s=t(this,(o.__proto__||Object.getPrototypeOf(o)).call(this)),a=void 0;if(s.element=e,s.version=o.version,s.defaultOptions.previewTemplate=s.defaultOptions.previewTemplate.replace(/\n*/g,""),s.clickableElements=[],s.listeners=[],s.files=[],"string"==typeof s.element&&(s.element=document.querySelector(s.element)),!s.element||null==s.element.nodeType)throw new Error("Invalid dropzone element.");if(s.element.dropzone)throw new Error("Dropzone already attached.");o.instances.push(s),s.element.dropzone=s;var l,u=null!=(r=o.optionsForElement(s.element))?r:{};if(s.options=o.extend({},s.defaultOptions,u,null!=i?i:{}),s.options.forceFallback||!o.isBrowserSupported())return l=s.options.fallback.call(s),t(s,l);if(null==s.options.url&&(s.options.url=s.element.getAttribute("action")),!s.options.url)throw new Error("No URL provided.");if(s.options.acceptedFiles&&s.options.acceptedMimeTypes)throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");if(s.options.uploadMultiple&&s.options.chunking)throw new Error("You cannot set both: uploadMultiple and chunking.");return s.options.acceptedMimeTypes&&(s.options.acceptedFiles=s.options.acceptedMimeTypes,delete s.options.acceptedMimeTypes),null!=s.options.renameFilename&&(s.options.renameFile=function(e){return s.options.renameFilename.call(s,e.name,e)}),s.options.method=s.options.method.toUpperCase(),(a=s.getExistingFallback())&&a.parentNode&&a.parentNode.removeChild(a),!1!==s.options.previewsContainer&&(s.options.previewsContainer?s.previewsContainer=o.getElement(s.options.previewsContainer,"previewsContainer"):s.previewsContainer=s.element),s.options.clickable&&(!0===s.options.clickable?s.clickableElements=[s.element]:s.clickableElements=o.getElements(s.options.clickable,"clickable")),s.init(),s}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(o,r),i(o,null,[{key:"initClass",value:function(){this.prototype.Emitter=r,this.prototype.events=["drop","dragstart","dragend","dragenter","dragover","dragleave","addedfile","addedfiles","removedfile","thumbnail","error","errormultiple","processing","processingmultiple","uploadprogress","totaluploadprogress","sending","sendingmultiple","success","successmultiple","canceled","canceledmultiple","complete","completemultiple","reset","maxfilesexceeded","maxfilesreached","queuecomplete"],this.prototype.defaultOptions={url:null,method:"post",withCredentials:!1,timeout:3e4,parallelUploads:2,uploadMultiple:!1,chunking:!1,forceChunking:!1,chunkSize:2e6,parallelChunkUploads:!1,retryChunks:!1,retryChunksLimit:3,maxFilesize:256,paramName:"file",createImageThumbnails:!0,maxThumbnailFilesize:10,thumbnailWidth:120,thumbnailHeight:120,thumbnailMethod:"crop",resizeWidth:null,resizeHeight:null,resizeMimeType:null,resizeQuality:.8,resizeMethod:"contain",filesizeBase:1e3,maxFiles:null,headers:null,clickable:!0,ignoreHiddenFiles:!0,acceptedFiles:null,acceptedMimeTypes:null,autoProcessQueue:!0,autoQueue:!0,addRemoveLinks:!1,previewsContainer:null,hiddenInputContainer:"body",capture:null,renameFilename:null,renameFile:null,forceFallback:!1,dictDefaultMessage:"Drop files here to upload",dictFallbackMessage:"Your browser does not support drag'n'drop file uploads.",dictFallbackText:"Please use the fallback form below to upload your files like in the olden days.",dictFileTooBig:"File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",dictInvalidFileType:"You can't upload files of this type.",dictResponseError:"Server responded with {{statusCode}} code.",dictCancelUpload:"Cancel upload",dictUploadCanceled:"Upload canceled.",dictCancelUploadConfirmation:"Are you sure you want to cancel this upload?",dictRemoveFile:"Remove file",dictRemoveFileConfirmation:null,dictMaxFilesExceeded:"You can not upload any more files.",dictFileSizeUnits:{tb:"TB",gb:"GB",mb:"MB",kb:"KB",b:"b"},init:function(){},params:function(e,t,n){if(n)return{dzuuid:n.file.upload.uuid,dzchunkindex:n.index,dztotalfilesize:n.file.size,dzchunksize:this.options.chunkSize,dztotalchunkcount:n.file.upload.totalChunkCount,dzchunkbyteoffset:n.index*this.options.chunkSize}},accept:function(e,t){return t()},chunksUploaded:function(e,t){t()},fallback:function(){var e=void 0;this.element.className=this.element.className+" dz-browser-not-supported";for(var t=0,n=n=this.element.getElementsByTagName("div");!(t>=n.length);){var i=n[t++];if(/(^| )dz-message($| )/.test(i.className)){e=i,i.className="dz-message";break}}e||(e=o.createElement('<div class="dz-message"><span></span></div>'),this.element.appendChild(e));var r=e.getElementsByTagName("span")[0];return r&&(null!=r.textContent?r.textContent=this.options.dictFallbackMessage:null!=r.innerText&&(r.innerText=this.options.dictFallbackMessage)),this.element.appendChild(this.getFallbackForm())},resize:function(e,t,n,i){var r={srcX:0,srcY:0,srcWidth:e.width,srcHeight:e.height},o=e.width/e.height;null==t&&null==n?(t=r.srcWidth,n=r.srcHeight):null==t?t=n*o:null==n&&(n=t/o);var s=(t=Math.min(t,r.srcWidth))/(n=Math.min(n,r.srcHeight));if(r.srcWidth>t||r.srcHeight>n)if("crop"===i)o>s?(r.srcHeight=e.height,r.srcWidth=r.srcHeight*s):(r.srcWidth=e.width,r.srcHeight=r.srcWidth/s);else{if("contain"!==i)throw new Error("Unknown resizeMethod '"+i+"'");o>s?n=t/o:t=n*o}return r.srcX=(e.width-r.srcWidth)/2,r.srcY=(e.height-r.srcHeight)/2,r.trgWidth=t,r.trgHeight=n,r},transformFile:function(e,t){return(this.options.resizeWidth||this.options.resizeHeight)&&e.type.match(/image.*/)?this.resizeImage(e,this.options.resizeWidth,this.options.resizeHeight,this.options.resizeMethod,t):t(e)},previewTemplate:'<div class="dz-preview dz-file-preview">\n  <div class="dz-image"><img data-dz-thumbnail /></div>\n  <div class="dz-details">\n    <div class="dz-size"><span data-dz-size></span></div>\n    <div class="dz-filename"><span data-dz-name></span></div>\n  </div>\n  <div class="dz-progress"><span class="dz-upload" data-dz-uploadprogress></span></div>\n  <div class="dz-error-message"><span data-dz-errormessage></span></div>\n  <div class="dz-success-mark">\n    <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n      <title>Check</title>\n      <defs></defs>\n      <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <path d="M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" id="Oval-2" stroke-opacity="0.198794158" stroke="#747474" fill-opacity="0.816519475" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>\n      </g>\n    </svg>\n  </div>\n  <div class="dz-error-mark">\n    <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n      <title>Error</title>\n      <defs></defs>\n      <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <g id="Check-+-Oval-2" sketch:type="MSLayerGroup" stroke="#747474" stroke-opacity="0.198794158" fill="#FFFFFF" fill-opacity="0.816519475">\n          <path d="M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" id="Oval-2" sketch:type="MSShapeGroup"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>',drop:function(e){return this.element.classList.remove("dz-drag-hover")},dragstart:function(e){},dragend:function(e){return this.element.classList.remove("dz-drag-hover")},dragenter:function(e){return this.element.classList.add("dz-drag-hover")},dragover:function(e){return this.element.classList.add("dz-drag-hover")},dragleave:function(e){return this.element.classList.remove("dz-drag-hover")},paste:function(e){},reset:function(){return this.element.classList.remove("dz-started")},addedfile:function(e){var t=this;if(this.element===this.previewsContainer&&this.element.classList.add("dz-started"),this.previewsContainer){e.previewElement=o.createElement(this.options.previewTemplate.trim()),e.previewTemplate=e.previewElement,this.previewsContainer.appendChild(e.previewElement);for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-name]");!(n>=i.length);){var r=i[n++];r.textContent=e.name}for(var s=0,a=a=e.previewElement.querySelectorAll("[data-dz-size]");!(s>=a.length);)(r=a[s++]).innerHTML=this.filesize(e.size);this.options.addRemoveLinks&&(e._removeLink=o.createElement('<a class="dz-remove" href="javascript:undefined;" data-dz-remove>'+this.options.dictRemoveFile+"</a>"),e.previewElement.appendChild(e._removeLink));for(var l=function(n){return n.preventDefault(),n.stopPropagation(),e.status===o.UPLOADING?o.confirm(t.options.dictCancelUploadConfirmation,function(){return t.removeFile(e)}):t.options.dictRemoveFileConfirmation?o.confirm(t.options.dictRemoveFileConfirmation,function(){return t.removeFile(e)}):t.removeFile(e)},u=0,c=c=e.previewElement.querySelectorAll("[data-dz-remove]");!(u>=c.length);)c[u++].addEventListener("click",l)}},removedfile:function(e){return null!=e.previewElement&&null!=e.previewElement.parentNode&&e.previewElement.parentNode.removeChild(e.previewElement),this._updateMaxFilesReachedClass()},thumbnail:function(e,t){if(e.previewElement){e.previewElement.classList.remove("dz-file-preview");for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-thumbnail]");!(n>=i.length);){var r=i[n++];r.alt=e.name,r.src=t}return setTimeout(function(){return e.previewElement.classList.add("dz-image-preview")},1)}},error:function(e,t){if(e.previewElement){e.previewElement.classList.add("dz-error"),"String"!=typeof t&&t.error&&(t=t.error);for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-errormessage]");!(n>=i.length);)i[n++].textContent=t}},errormultiple:function(){},processing:function(e){if(e.previewElement&&(e.previewElement.classList.add("dz-processing"),e._removeLink))return e._removeLink.textContent=this.options.dictCancelUpload},processingmultiple:function(){},uploadprogress:function(e,t,n){if(e.previewElement)for(var i=0,r=r=e.previewElement.querySelectorAll("[data-dz-uploadprogress]");!(i>=r.length);){var o=r[i++];"PROGRESS"===o.nodeName?o.value=t:o.style.width=t+"%"}},totaluploadprogress:function(){},sending:function(){},sendingmultiple:function(){},success:function(e){if(e.previewElement)return e.previewElement.classList.add("dz-success")},successmultiple:function(){},canceled:function(e){return this.emit("error",e,this.options.dictUploadCanceled)},canceledmultiple:function(){},complete:function(e){if(e._removeLink&&(e._removeLink.textContent=this.options.dictRemoveFile),e.previewElement)return e.previewElement.classList.add("dz-complete")},completemultiple:function(){},maxfilesexceeded:function(){},maxfilesreached:function(){},queuecomplete:function(){},addedfiles:function(){}},this.prototype._thumbnailQueue=[],this.prototype._processingThumbnail=!1}},{key:"extend",value:function(e){for(var t=arguments.length,n=Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];for(var r=0,o=o=n;!(r>=o.length);){var s=o[r++];for(var a in s){var l=s[a];e[a]=l}}return e}}]),i(o,[{key:"getAcceptedFiles",value:function(){return this.files.filter(function(e){return e.accepted}).map(function(e){return e})}},{key:"getRejectedFiles",value:function(){return this.files.filter(function(e){return!e.accepted}).map(function(e){return e})}},{key:"getFilesWithStatus",value:function(e){return this.files.filter(function(t){return t.status===e}).map(function(e){return e})}},{key:"getQueuedFiles",value:function(){return this.getFilesWithStatus(o.QUEUED)}},{key:"getUploadingFiles",value:function(){return this.getFilesWithStatus(o.UPLOADING)}},{key:"getAddedFiles",value:function(){return this.getFilesWithStatus(o.ADDED)}},{key:"getActiveFiles",value:function(){return this.files.filter(function(e){return e.status===o.UPLOADING||e.status===o.QUEUED}).map(function(e){return e})}},{key:"init",value:function(){var e=this;"form"===this.element.tagName&&this.element.setAttribute("enctype","multipart/form-data"),this.element.classList.contains("dropzone")&&!this.element.querySelector(".dz-message")&&this.element.appendChild(o.createElement('<div class="dz-default dz-message"><span>'+this.options.dictDefaultMessage+"</span></div>")),this.clickableElements.length&&function t(){return e.hiddenFileInput&&e.hiddenFileInput.parentNode.removeChild(e.hiddenFileInput),e.hiddenFileInput=document.createElement("input"),e.hiddenFileInput.setAttribute("type","file"),(null===e.options.maxFiles||e.options.maxFiles>1)&&e.hiddenFileInput.setAttribute("multiple","multiple"),e.hiddenFileInput.className="dz-hidden-input",null!==e.options.acceptedFiles&&e.hiddenFileInput.setAttribute("accept",e.options.acceptedFiles),null!==e.options.capture&&e.hiddenFileInput.setAttribute("capture",e.options.capture),e.hiddenFileInput.style.visibility="hidden",e.hiddenFileInput.style.position="absolute",e.hiddenFileInput.style.top="0",e.hiddenFileInput.style.left="0",e.hiddenFileInput.style.height="0",e.hiddenFileInput.style.width="0",document.querySelector(e.options.hiddenInputContainer).appendChild(e.hiddenFileInput),e.hiddenFileInput.addEventListener("change",function(){var n=e.hiddenFileInput.files;if(n.length)for(var i=0,r=r=n;!(i>=r.length);){var o=r[i++];e.addFile(o)}return e.emit("addedfiles",n),t()})}(),this.URL=null!==window.URL?window.URL:window.webkitURL;for(var t=0,n=n=this.events;!(t>=n.length);){var i=n[t++];this.on(i,this.options[i])}this.on("uploadprogress",function(){return e.updateTotalUploadProgress()}),this.on("removedfile",function(){return e.updateTotalUploadProgress()}),this.on("canceled",function(t){return e.emit("complete",t)}),this.on("complete",function(t){if(0===e.getAddedFiles().length&&0===e.getUploadingFiles().length&&0===e.getQueuedFiles().length)return setTimeout(function(){return e.emit("queuecomplete")},0)});var r=function(e){return e.stopPropagation(),e.preventDefault?e.preventDefault():e.returnValue=!1};return this.listeners=[{element:this.element,events:{dragstart:function(t){return e.emit("dragstart",t)},dragenter:function(t){return r(t),e.emit("dragenter",t)},dragover:function(t){var n=void 0;try{n=t.dataTransfer.effectAllowed}catch(e){}return t.dataTransfer.dropEffect="move"===n||"linkMove"===n?"move":"copy",r(t),e.emit("dragover",t)},dragleave:function(t){return e.emit("dragleave",t)},drop:function(t){return r(t),e.drop(t)},dragend:function(t){return e.emit("dragend",t)}}}],this.clickableElements.forEach(function(t){return e.listeners.push({element:t,events:{click:function(n){return(t!==e.element||n.target===e.element||o.elementInside(n.target,e.element.querySelector(".dz-message")))&&e.hiddenFileInput.click(),!0}}})}),this.enable(),this.options.init.call(this)}},{key:"destroy",value:function(){return this.disable(),this.removeAllFiles(!0),(null!=this.hiddenFileInput?this.hiddenFileInput.parentNode:void 0)&&(this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput),this.hiddenFileInput=null),delete this.element.dropzone,o.instances.splice(o.instances.indexOf(this),1)}},{key:"updateTotalUploadProgress",value:function(){var e=void 0,t=0,n=0;if(this.getActiveFiles().length){for(var i=0,r=r=this.getActiveFiles();!(i>=r.length);){var o=r[i++];t+=o.upload.bytesSent,n+=o.upload.total}e=100*t/n}else e=100;return this.emit("totaluploadprogress",e,n,t)}},{key:"_getParamName",value:function(e){return"function"==typeof this.options.paramName?this.options.paramName(e):this.options.paramName+(this.options.uploadMultiple?"["+e+"]":"")}},{key:"_renameFile",value:function(e){return"function"!=typeof this.options.renameFile?e.name:this.options.renameFile(e)}},{key:"getFallbackForm",value:function(){var e,t=void 0;if(e=this.getExistingFallback())return e;var n='<div class="dz-fallback">';this.options.dictFallbackText&&(n+="<p>"+this.options.dictFallbackText+"</p>"),n+='<input type="file" name="'+this._getParamName(0)+'" '+(this.options.uploadMultiple?'multiple="multiple"':void 0)+' /><input type="submit" value="Upload!"></div>';var i=o.createElement(n);return"FORM"!==this.element.tagName?(t=o.createElement('<form action="'+this.options.url+'" enctype="multipart/form-data" method="'+this.options.method+'"></form>')).appendChild(i):(this.element.setAttribute("enctype","multipart/form-data"),this.element.setAttribute("method",this.options.method)),null!=t?t:i}},{key:"getExistingFallback",value:function(){for(var e=["div","form"],t=0;t<e.length;t++){var n,i=e[t];if(n=function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];if(/(^| )fallback($| )/.test(i.className))return i}}(this.element.getElementsByTagName(i)))return n}}},{key:"setupEventListeners",value:function(){return this.listeners.map(function(e){return function(){var t=[];for(var n in e.events){var i=e.events[n];t.push(e.element.addEventListener(n,i,!1))}return t}()})}},{key:"removeEventListeners",value:function(){return this.listeners.map(function(e){return function(){var t=[];for(var n in e.events){var i=e.events[n];t.push(e.element.removeEventListener(n,i,!1))}return t}()})}},{key:"disable",value:function(){var e=this;return this.clickableElements.forEach(function(e){return e.classList.remove("dz-clickable")}),this.removeEventListeners(),this.disabled=!0,this.files.map(function(t){return e.cancelUpload(t)})}},{key:"enable",value:function(){return delete this.disabled,this.clickableElements.forEach(function(e){return e.classList.add("dz-clickable")}),this.setupEventListeners()}},{key:"filesize",value:function(e){var t=0,n="b";if(e>0){for(var i=["tb","gb","mb","kb","b"],r=0;r<i.length;r++){var o=i[r];if(e>=Math.pow(this.options.filesizeBase,4-r)/10){t=e/Math.pow(this.options.filesizeBase,4-r),n=o;break}}t=Math.round(10*t)/10}return"<strong>"+t+"</strong> "+this.options.dictFileSizeUnits[n]}},{key:"_updateMaxFilesReachedClass",value:function(){return null!=this.options.maxFiles&&this.getAcceptedFiles().length>=this.options.maxFiles?(this.getAcceptedFiles().length===this.options.maxFiles&&this.emit("maxfilesreached",this.files),this.element.classList.add("dz-max-files-reached")):this.element.classList.remove("dz-max-files-reached")}},{key:"drop",value:function(e){if(e.dataTransfer){this.emit("drop",e);for(var t=[],n=0;n<e.dataTransfer.files.length;n++)t[n]=e.dataTransfer.files[n];if(this.emit("addedfiles",t),t.length){var i=e.dataTransfer.items;i&&i.length&&null!=i[0].webkitGetAsEntry?this._addFilesFromItems(i):this.handleFiles(t)}}}},{key:"paste",value:function(e){if(null!=(void 0!==(t=null!=e?e.clipboardData:void 0)&&null!==t?function(e){return e.items}(t):void 0)){var t;this.emit("paste",e);var n=e.clipboardData.items;return n.length?this._addFilesFromItems(n):void 0}}},{key:"handleFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];this.addFile(i)}}},{key:"_addFilesFromItems",value:function(e){var t=this;return function(){for(var n=[],i=0,r=r=e;!(i>=r.length);){var o,s=r[i++];null!=s.webkitGetAsEntry&&(o=s.webkitGetAsEntry())?o.isFile?n.push(t.addFile(s.getAsFile())):o.isDirectory?n.push(t._addFilesFromDirectory(o,o.name)):n.push(void 0):null==s.getAsFile||null!=s.kind&&"file"!==s.kind?n.push(void 0):n.push(t.addFile(s.getAsFile()))}return n}()}},{key:"_addFilesFromDirectory",value:function(e,t){var n=this,i=e.createReader(),r=function(e){return t=console,n="log",i=function(t){return t.log(e)},void 0!==t&&null!==t&&"function"==typeof t[n]?i(t,n):void 0;var t,n,i};return function e(){return i.readEntries(function(i){if(i.length>0){for(var r=0,o=o=i;!(r>=o.length);){var s=o[r++];s.isFile?s.file(function(e){if(!n.options.ignoreHiddenFiles||"."!==e.name.substring(0,1))return e.fullPath=t+"/"+e.name,n.addFile(e)}):s.isDirectory&&n._addFilesFromDirectory(s,t+"/"+s.name)}e()}return null},r)}()}},{key:"accept",value:function(e,t){return e.size>1024*this.options.maxFilesize*1024?t(this.options.dictFileTooBig.replace("{{filesize}}",Math.round(e.size/1024/10.24)/100).replace("{{maxFilesize}}",this.options.maxFilesize)):o.isValidFile(e,this.options.acceptedFiles)?null!=this.options.maxFiles&&this.getAcceptedFiles().length>=this.options.maxFiles?(t(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}",this.options.maxFiles)),this.emit("maxfilesexceeded",e)):this.options.accept.call(this,e,t):t(this.options.dictInvalidFileType)}},{key:"addFile",value:function(e){var t=this;return e.upload={uuid:o.uuidv4(),progress:0,total:e.size,bytesSent:0,filename:this._renameFile(e),chunked:this.options.chunking&&(this.options.forceChunking||e.size>this.options.chunkSize),totalChunkCount:Math.ceil(e.size/this.options.chunkSize)},this.files.push(e),e.status=o.ADDED,this.emit("addedfile",e),this._enqueueThumbnail(e),this.accept(e,function(n){return n?(e.accepted=!1,t._errorProcessing([e],n)):(e.accepted=!0,t.options.autoQueue&&t.enqueueFile(e)),t._updateMaxFilesReachedClass()})}},{key:"enqueueFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];this.enqueueFile(i)}return null}},{key:"enqueueFile",value:function(e){var t=this;if(e.status!==o.ADDED||!0!==e.accepted)throw new Error("This file can't be queued because it has already been processed or was rejected.");if(e.status=o.QUEUED,this.options.autoProcessQueue)return setTimeout(function(){return t.processQueue()},0)}},{key:"_enqueueThumbnail",value:function(e){var t=this;if(this.options.createImageThumbnails&&e.type.match(/image.*/)&&e.size<=1024*this.options.maxThumbnailFilesize*1024)return this._thumbnailQueue.push(e),setTimeout(function(){return t._processThumbnailQueue()},0)}},{key:"_processThumbnailQueue",value:function(){var e=this;if(!this._processingThumbnail&&0!==this._thumbnailQueue.length){this._processingThumbnail=!0;var t=this._thumbnailQueue.shift();return this.createThumbnail(t,this.options.thumbnailWidth,this.options.thumbnailHeight,this.options.thumbnailMethod,!0,function(n){return e.emit("thumbnail",t,n),e._processingThumbnail=!1,e._processThumbnailQueue()})}}},{key:"removeFile",value:function(e){if(e.status===o.UPLOADING&&this.cancelUpload(e),this.files=s(this.files,e),this.emit("removedfile",e),0===this.files.length)return this.emit("reset")}},{key:"removeAllFiles",value:function(e){null==e&&(e=!1);for(var t=0,n=n=this.files.slice();!(t>=n.length);){var i=n[t++];(i.status!==o.UPLOADING||e)&&this.removeFile(i)}return null}},{key:"resizeImage",value:function(e,t,n,i,r){var s=this;return this.createThumbnail(e,t,n,i,!1,function(t,n){if(null==n)return r(e);var i=s.options.resizeMimeType;null==i&&(i=e.type);var a=n.toDataURL(i,s.options.resizeQuality);return"image/jpeg"!==i&&"image/jpg"!==i||(a=u.restore(e.dataURL,a)),r(o.dataURItoBlob(a))})}},{key:"createThumbnail",value:function(e,t,n,i,r,o){var s=this,a=new FileReader;return a.onload=function(){if(e.dataURL=a.result,"image/svg+xml"!==e.type)return s.createThumbnailFromUrl(e,t,n,i,r,o);null!=o&&o(a.result)},a.readAsDataURL(e)}},{key:"createThumbnailFromUrl",value:function(e,t,n,i,r,o,s){var a=this,u=document.createElement("img");return s&&(u.crossOrigin=s),u.onload=function(){var s=function(e){return e(1)};return"undefined"!=typeof EXIF&&null!==EXIF&&r&&(s=function(e){return EXIF.getData(u,function(){return e(EXIF.getTag(this,"Orientation"))})}),s(function(r){e.width=u.width,e.height=u.height;var s=a.options.resize.call(a,e,t,n,i),c=document.createElement("canvas"),d=c.getContext("2d");switch(c.width=s.trgWidth,c.height=s.trgHeight,r>4&&(c.width=s.trgHeight,c.height=s.trgWidth),r){case 2:d.translate(c.width,0),d.scale(-1,1);break;case 3:d.translate(c.width,c.height),d.rotate(Math.PI);break;case 4:d.translate(0,c.height),d.scale(1,-1);break;case 5:d.rotate(.5*Math.PI),d.scale(1,-1);break;case 6:d.rotate(.5*Math.PI),d.translate(0,-c.height);break;case 7:d.rotate(.5*Math.PI),d.translate(c.width,-c.height),d.scale(-1,1);break;case 8:d.rotate(-.5*Math.PI),d.translate(-c.width,0)}l(d,u,null!=s.srcX?s.srcX:0,null!=s.srcY?s.srcY:0,s.srcWidth,s.srcHeight,null!=s.trgX?s.trgX:0,null!=s.trgY?s.trgY:0,s.trgWidth,s.trgHeight);var p=c.toDataURL("image/png");if(null!=o)return o(p,c)})},null!=o&&(u.onerror=o),u.src=e.dataURL}},{key:"processQueue",value:function(){var e=this.options.parallelUploads,t=this.getUploadingFiles().length,n=t;if(!(t>=e)){var i=this.getQueuedFiles();if(i.length>0){if(this.options.uploadMultiple)return this.processFiles(i.slice(0,e-t));for(;n<e;){if(!i.length)return;this.processFile(i.shift()),n++}}}}},{key:"processFile",value:function(e){return this.processFiles([e])}},{key:"processFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];i.processing=!0,i.status=o.UPLOADING,this.emit("processing",i)}return this.options.uploadMultiple&&this.emit("processingmultiple",e),this.uploadFiles(e)}},{key:"_getFilesWithXhr",value:function(e){return this.files.filter(function(t){return t.xhr===e}).map(function(e){return e})}},{key:"cancelUpload",value:function(e){if(e.status===o.UPLOADING){for(var t=this._getFilesWithXhr(e.xhr),n=0,i=i=t;!(n>=i.length);)i[n++].status=o.CANCELED;void 0!==e.xhr&&e.xhr.abort();for(var r=0,s=s=t;!(r>=s.length);){var a=s[r++];this.emit("canceled",a)}this.options.uploadMultiple&&this.emit("canceledmultiple",t)}else e.status!==o.ADDED&&e.status!==o.QUEUED||(e.status=o.CANCELED,this.emit("canceled",e),this.options.uploadMultiple&&this.emit("canceledmultiple",[e]));if(this.options.autoProcessQueue)return this.processQueue()}},{key:"resolveOption",value:function(e){if("function"==typeof e){for(var t=arguments.length,n=Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return e.apply(this,n)}return e}},{key:"uploadFile",value:function(e){return this.uploadFiles([e])}},{key:"uploadFiles",value:function(e){var t=this;this._transformFiles(e,function(n){if(e[0].upload.chunked){var i=e[0],r=n[0];i.upload.chunks=[];var s=function(){for(var n=0;void 0!==i.upload.chunks[n];)n++;if(!(n>=i.upload.totalChunkCount)){var s=n*t.options.chunkSize,a=Math.min(s+t.options.chunkSize,i.size),l={name:t._getParamName(0),data:r.webkitSlice?r.webkitSlice(s,a):r.slice(s,a),filename:i.upload.filename,chunkIndex:n};i.upload.chunks[n]={file:i,index:n,dataBlock:l,status:o.UPLOADING,progress:0,retries:0},t._uploadData(e,[l])}};if(i.upload.finishedChunkUpload=function(n){var r=!0;n.status=o.SUCCESS,n.dataBlock=null;for(var a=0;a<i.upload.totalChunkCount;a++){if(void 0===i.upload.chunks[a])return s();i.upload.chunks[a].status!==o.SUCCESS&&(r=!1)}r&&t.options.chunksUploaded(i,function(){t._finished(e,"",null)})},t.options.parallelChunkUploads)for(var a=0;a<i.upload.totalChunkCount;a++)s();else s()}else{for(var l=[],u=0;u<e.length;u++)l[u]={name:t._getParamName(u),data:n[u],filename:e[u].upload.filename};t._uploadData(e,l)}})}},{key:"_getChunk",value:function(e,t){for(var n=0;n<e.upload.totalChunkCount;n++)if(void 0!==e.upload.chunks[n]&&e.upload.chunks[n].xhr===t)return e.upload.chunks[n]}},{key:"_uploadData",value:function(e,t){for(var n=this,i=new XMLHttpRequest,r=0,s=s=e;!(r>=s.length);)s[r++].xhr=i;e[0].upload.chunked&&(e[0].upload.chunks[t[0].chunkIndex].xhr=i);var a=this.resolveOption(this.options.method,e),l=this.resolveOption(this.options.url,e);i.open(a,l,!0),i.timeout=this.resolveOption(this.options.timeout,e),i.withCredentials=!!this.options.withCredentials,i.onload=function(t){n._finishedUploading(e,i,t)},i.onerror=function(){n._handleUploadError(e,i)},(null!=i.upload?i.upload:i).onprogress=function(t){return n._updateFilesUploadProgress(e,i,t)};var u={Accept:"application/json","Cache-Control":"no-cache","X-Requested-With":"XMLHttpRequest"};for(var c in this.options.headers&&o.extend(u,this.options.headers),u){var d=u[c];d&&i.setRequestHeader(c,d)}var p=new FormData;if(this.options.params){var h=this.options.params;for(var f in"function"==typeof h&&(h=h.call(this,e,i,e[0].upload.chunked?this._getChunk(e[0],i):null)),h){var m=h[f];p.append(f,m)}}for(var v=0,g=g=e;!(v>=g.length);){var y=g[v++];this.emit("sending",y,i,p)}this.options.uploadMultiple&&this.emit("sendingmultiple",e,i,p),this._addFormElementData(p);for(var k=0;k<t.length;k++){var b=t[k];p.append(b.name,b.data,b.filename)}this.submitRequest(i,p,e)}},{key:"_transformFiles",value:function(e,t){for(var n=this,i=[],r=0,o=0;o<e.length;o++)!function(o){n.options.transformFile.call(n,e[o],function(n){i[o]=n,++r===e.length&&t(i)})}(o)}},{key:"_addFormElementData",value:function(e){if("FORM"===this.element.tagName)for(var t=0,n=n=this.element.querySelectorAll("input, textarea, select, button");!(t>=n.length);){var i=n[t++],r=i.getAttribute("name"),o=i.getAttribute("type");if(o&&(o=o.toLowerCase()),void 0!==r&&null!==r)if("SELECT"===i.tagName&&i.hasAttribute("multiple"))for(var s=0,a=a=i.options;!(s>=a.length);){var l=a[s++];l.selected&&e.append(r,l.value)}else(!o||"checkbox"!==o&&"radio"!==o||i.checked)&&e.append(r,i.value)}}},{key:"_updateFilesUploadProgress",value:function(e,t,n){var i=void 0;if(void 0!==n){if(i=100*n.loaded/n.total,e[0].upload.chunked){var r=e[0],o=this._getChunk(r,t);o.progress=i,o.total=n.total,o.bytesSent=n.loaded,r.upload.progress=0,r.upload.total=0,r.upload.bytesSent=0;for(var s=0;s<r.upload.totalChunkCount;s++)void 0!==r.upload.chunks[s]&&void 0!==r.upload.chunks[s].progress&&(r.upload.progress+=r.upload.chunks[s].progress,r.upload.total+=r.upload.chunks[s].total,r.upload.bytesSent+=r.upload.chunks[s].bytesSent);r.upload.progress=r.upload.progress/r.upload.totalChunkCount}else for(var a=0,l=l=e;!(a>=l.length);){var u=l[a++];u.upload.progress=i,u.upload.total=n.total,u.upload.bytesSent=n.loaded}for(var c=0,d=d=e;!(c>=d.length);){var p=d[c++];this.emit("uploadprogress",p,p.upload.progress,p.upload.bytesSent)}}else{var h=!0;i=100;for(var f=0,m=m=e;!(f>=m.length);){var v=m[f++];100===v.upload.progress&&v.upload.bytesSent===v.upload.total||(h=!1),v.upload.progress=i,v.upload.bytesSent=v.upload.total}if(h)return;for(var g=0,y=y=e;!(g>=y.length);){var k=y[g++];this.emit("uploadprogress",k,i,k.upload.bytesSent)}}}},{key:"_finishedUploading",value:function(e,t,n){var i=void 0;if(e[0].status!==o.CANCELED&&4===t.readyState){if("arraybuffer"!==t.responseType&&"blob"!==t.responseType&&(i=t.responseText,t.getResponseHeader("content-type")&&~t.getResponseHeader("content-type").indexOf("application/json")))try{i=JSON.parse(i)}catch(e){n=e,i="Invalid JSON response from server."}this._updateFilesUploadProgress(e),200<=t.status&&t.status<300?e[0].upload.chunked?e[0].upload.finishedChunkUpload(this._getChunk(e[0],t)):this._finished(e,i,n):this._handleUploadError(e,t,i)}}},{key:"_handleUploadError",value:function(e,t,n){if(e[0].status!==o.CANCELED){if(e[0].upload.chunked&&this.options.retryChunks){var i=this._getChunk(e[0],t);if(i.retries++<this.options.retryChunksLimit)return void this._uploadData(e,[i.dataBlock]);console.warn("Retried this chunk too often. Giving up.")}for(var r=0,s=s=e;!(r>=s.length);)s[r++],this._errorProcessing(e,n||this.options.dictResponseError.replace("{{statusCode}}",t.status),t)}}},{key:"submitRequest",value:function(e,t,n){e.send(t)}},{key:"_finished",value:function(e,t,n){for(var i=0,r=r=e;!(i>=r.length);){var s=r[i++];s.status=o.SUCCESS,this.emit("success",s,t,n),this.emit("complete",s)}if(this.options.uploadMultiple&&(this.emit("successmultiple",e,t,n),this.emit("completemultiple",e)),this.options.autoProcessQueue)return this.processQueue()}},{key:"_errorProcessing",value:function(e,t,n){for(var i=0,r=r=e;!(i>=r.length);){var s=r[i++];s.status=o.ERROR,this.emit("error",s,t,n),this.emit("complete",s)}if(this.options.uploadMultiple&&(this.emit("errormultiple",e,t,n),this.emit("completemultiple",e)),this.options.autoProcessQueue)return this.processQueue()}}],[{key:"uuidv4",value:function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)})}}]),o}();o.initClass(),o.version="5.4.0",o.options={},o.optionsForElement=function(e){return e.getAttribute("id")?o.options[a(e.getAttribute("id"))]:void 0},o.instances=[],o.forElement=function(e){if("string"==typeof e&&(e=document.querySelector(e)),null==(null!=e?e.dropzone:void 0))throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");return e.dropzone},o.autoDiscover=!0,o.discover=function(){var e=void 0;if(document.querySelectorAll)e=document.querySelectorAll(".dropzone");else{e=[];var t=function(t){return function(){for(var n=[],i=0,r=r=t;!(i>=r.length);){var o=r[i++];/(^| )dropzone($| )/.test(o.className)?n.push(e.push(o)):n.push(void 0)}return n}()};t(document.getElementsByTagName("div")),t(document.getElementsByTagName("form"))}return function(){for(var t=[],n=0,i=i=e;!(n>=i.length);){var r=i[n++];!1!==o.optionsForElement(r)?t.push(new o(r)):t.push(void 0)}return t}()},o.blacklistedBrowsers=[/opera.*(Macintosh|Windows Phone).*version\/12/i],o.isBrowserSupported=function(){var e=!0;if(window.File&&window.FileReader&&window.FileList&&window.Blob&&window.FormData&&document.querySelector)if("classList"in document.createElement("a"))for(var t=0,n=n=o.blacklistedBrowsers;!(t>=n.length);)n[t++].test(navigator.userAgent)&&(e=!1);else e=!1;else e=!1;return e},o.dataURItoBlob=function(e){for(var t=atob(e.split(",")[1]),n=e.split(",")[0].split(":")[1].split(";")[0],i=new ArrayBuffer(t.length),r=new Uint8Array(i),o=0,s=t.length,a=0<=s;a?o<=s:o>=s;a?o++:o--)r[o]=t.charCodeAt(o);return new Blob([i],{type:n})};var s=function(e,t){return e.filter(function(e){return e!==t}).map(function(e){return e})},a=function(e){return e.replace(/[\-_](\w)/g,function(e){return e.charAt(1).toUpperCase()})};o.createElement=function(e){var t=document.createElement("div");return t.innerHTML=e,t.childNodes[0]},o.elementInside=function(e,t){if(e===t)return!0;for(;e=e.parentNode;)if(e===t)return!0;return!1},o.getElement=function(e,t){var n=void 0;if("string"==typeof e?n=document.querySelector(e):null!=e.nodeType&&(n=e),null==n)throw new Error("Invalid `"+t+"` option provided. Please provide a CSS selector or a plain HTML element.");return n},o.getElements=function(e,t){var n=void 0,i=void 0;if(e instanceof Array){i=[];try{for(var r=0,o=o=e;!(r>=o.length);)n=o[r++],i.push(this.getElement(n,t))}catch(e){i=null}}else if("string"==typeof e){i=[];for(var s=0,a=a=document.querySelectorAll(e);!(s>=a.length);)n=a[s++],i.push(n)}else null!=e.nodeType&&(i=[e]);if(null==i||!i.length)throw new Error("Invalid `"+t+"` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");return i},o.confirm=function(e,t,n){return window.confirm(e)?t():null!=n?n():void 0},o.isValidFile=function(e,t){if(!t)return!0;t=t.split(",");for(var n=e.type,i=n.replace(/\/.*$/,""),r=0,o=o=t;!(r>=o.length);){var s=o[r++];if("."===(s=s.trim()).charAt(0)){if(-1!==e.name.toLowerCase().indexOf(s.toLowerCase(),e.name.length-s.length))return!0}else if(/\/\*$/.test(s)){if(i===s.replace(/\/.*$/,""))return!0}else if(n===s)return!0}return!1},"undefined"!=typeof jQuery&&null!==jQuery&&(jQuery.fn.dropzone=function(e){return this.each(function(){return new o(this,e)})}),void 0!==e&&null!==e?e.exports=o:window.Dropzone=o,o.ADDED="added",o.QUEUED="queued",o.ACCEPTED=o.QUEUED,o.UPLOADING="uploading",o.PROCESSING=o.UPLOADING,o.CANCELED="canceled",o.ERROR="error",o.SUCCESS="success";var l=function(e,t,n,i,r,o,s,a,l,u){var c=function(e){e.naturalWidth;var t=e.naturalHeight,n=document.createElement("canvas");n.width=1,n.height=t;var i=n.getContext("2d");i.drawImage(e,0,0);for(var r=i.getImageData(1,0,1,t).data,o=0,s=t,a=t;a>o;)0===r[4*(a-1)+3]?s=a:o=a,a=s+o>>1;var l=a/t;return 0===l?1:l}(t);return e.drawImage(t,n,i,r,o,s,a,l,u/c)},u=function(){function e(){n(this,e)}return i(e,null,[{key:"initClass",value:function(){this.KEY_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}},{key:"encode64",value:function(e){for(var t="",n=void 0,i=void 0,r="",o=void 0,s=void 0,a=void 0,l="",u=0;o=(n=e[u++])>>2,s=(3&n)<<4|(i=e[u++])>>4,a=(15&i)<<2|(r=e[u++])>>6,l=63&r,isNaN(i)?a=l=64:isNaN(r)&&(l=64),t=t+this.KEY_STR.charAt(o)+this.KEY_STR.charAt(s)+this.KEY_STR.charAt(a)+this.KEY_STR.charAt(l),n=i=r="",o=s=a=l="",u<e.length;);return t}},{key:"restore",value:function(e,t){if(!e.match("data:image/jpeg;base64,"))return t;var n=this.decode64(e.replace("data:image/jpeg;base64,","")),i=this.slice2Segments(n),r=this.exifManipulation(t,i);return"data:image/jpeg;base64,"+this.encode64(r)}},{key:"exifManipulation",value:function(e,t){var n=this.getExifArray(t),i=this.insertExif(e,n);return new Uint8Array(i)}},{key:"getExifArray",value:function(e){for(var t=void 0,n=0;n<e.length;){if(255===(t=e[n])[0]&225===t[1])return t;n++}return[]}},{key:"insertExif",value:function(e,t){var n=e.replace("data:image/jpeg;base64,",""),i=this.decode64(n),r=i.indexOf(255,3),o=i.slice(0,r),s=i.slice(r),a=o;return a=(a=a.concat(t)).concat(s)}},{key:"slice2Segments",value:function(e){for(var t=0,n=[];!(255===e[t]&218===e[t+1]);){if(255===e[t]&216===e[t+1])t+=2;else{var i=t+(256*e[t+2]+e[t+3])+2,r=e.slice(t,i);n.push(r),t=i}if(t>e.length)break}return n}},{key:"decode64",value:function(e){var t=void 0,n=void 0,i="",r=void 0,o=void 0,s="",a=0,l=[];for(/[^A-Za-z0-9\+\/\=]/g.exec(e)&&console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding."),e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");t=this.KEY_STR.indexOf(e.charAt(a++))<<2|(r=this.KEY_STR.indexOf(e.charAt(a++)))>>4,n=(15&r)<<4|(o=this.KEY_STR.indexOf(e.charAt(a++)))>>2,i=(3&o)<<6|(s=this.KEY_STR.indexOf(e.charAt(a++))),l.push(t),64!==o&&l.push(n),64!==s&&l.push(i),t=n=i="",r=o=s="",a<e.length;);return l}}]),e}();u.initClass(),o._autoDiscoverFunction=function(){if(o.autoDiscover)return o.discover()},function(e,t){var n=!1,i=!0,r=e.document,o=r.documentElement,s=r.addEventListener?"addEventListener":"attachEvent",a=r.addEventListener?"removeEventListener":"detachEvent",l=r.addEventListener?"":"on",u=function i(o){if("readystatechange"!==o.type||"complete"===r.readyState)return("load"===o.type?e:r)[a](l+o.type,i,!1),!n&&(n=!0)?t.call(e,o.type||o):void 0};if("complete"!==r.readyState){if(r.createEventObject&&o.doScroll){try{i=!e.frameElement}catch(e){}i&&function e(){try{o.doScroll("left")}catch(t){return void setTimeout(e,50)}return u("poll")}()}r[s](l+"DOMContentLoaded",u,!1),r[s](l+"readystatechange",u,!1),e[s](l+"load",u,!1)}}(window,o._autoDiscoverFunction)}).call(t,n(6)(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}}])});
//# sourceMappingURL=react-dropzone.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchControl = function (_React$Component) {
  _inherits(SearchControl, _React$Component);

  function SearchControl(props) {
    _classCallCheck(this, SearchControl);

    var _this = _possibleConstructorReturn(this, (SearchControl.__proto__ || Object.getPrototypeOf(SearchControl)).call(this, props));

    _this.state = { value: '' };
    return _this;
  }

  _createClass(SearchControl, [{
    key: 'render',
    value: function render() {
      var me = this;

      var controlProps = {};
      for (var p in this.props) {
        if (p == "value" || p == "handleEvent") continue;
        controlProps[p] = this.props[p];
      }

      return _react2.default.createElement(_semanticUiReact.Search, _extends({}, controlProps, {
        fluid: true,
        loading: this.state.isLoading,
        onResultSelect: this.handleResultSelect.bind(this),
        onSearchChange: this.handleSearchChange.bind(this),
        results: this.state.results,
        value: this.state.value
      }));
    }
  }, {
    key: 'resetSearch',
    value: function resetSearch() {
      this.setState({ isLoading: false, results: [] });
    }
  }, {
    key: 'handleResultSelect',
    value: function handleResultSelect(e, _ref) {
      var result = _ref.result;

      if (this.props.handleEvent !== undefined) {
        this.props.handleEvent({ key: this.props.name, eventName: "onSelect", parameters: result });
      }
    }
  }, {
    key: 'handleSearchChange',
    value: function handleSearchChange(e, _ref2) {
      var value = _ref2.value;

      var me = this;
      me.setState({ isLoading: true, value: value });

      setTimeout(function () {
        if (me.state.value === null || me.state.value === undefined || me.state.value.length < 2) {
          return me.resetSearch();
        }
        me.search(me.state.value);
      }, 200);
    }
  }, {
    key: 'search',
    value: function search(searchStr) {
      var me = this;
      var url = this.props.url;
      url += this.props.url.includes('?') ? "&" : "?";
      url += "term=" + searchStr;
      fetch(url, {
        credentials: 'same-origin'
      }).then(function (response) {
        return response.json();
      }).then(function (results) {
        me.setState({
          isLoading: false,
          results: results
        });
      }).catch(function (error) {
        if (console == undefined) alert(error);else console.error(error);
      });
    }
  }]);

  return SearchControl;
}(_react2.default.Component);

exports.default = SearchControl;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(9);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(6);

var _actions2 = _interopRequireDefault(_actions);

var _controls = __webpack_require__(7);

var _controls2 = _interopRequireDefault(_controls);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Preview = function (_React$Component) {
  _inherits(Preview, _React$Component);

  function Preview(props) {
    _classCallCheck(this, Preview);

    var _this = _possibleConstructorReturn(this, (Preview.__proto__ || Object.getPrototypeOf(Preview)).call(this, props));

    _this.state = {
      data: [],
      editElement: null
    };

    _store2.default.listen(_this.dataChanged.bind(_this));
    return _this;
  }

  _createClass(Preview, [{
    key: 'dataChanged',
    value: function dataChanged(data) {
      this.setState({
        data: data,
        editElement: null
      });
    }
  }, {
    key: '_onEdit',
    value: function _onEdit(item) {
      _actions2.default.showEditForm(item.key);
    }
  }, {
    key: '_onCopy',
    value: function _onCopy(item) {
      _store2.default.copy(item);
    }
  }, {
    key: '_onDestroy',
    value: function _onDestroy(item) {
      _store2.default.remove(item);
    }
  }, {
    key: '_handleEvent',
    value: function _handleEvent(p) {
      // if(console != undefined){
      //   console.log("DWKitFormBuilder: handleEvent", p);
      // }
    }
  }, {
    key: 'render',
    value: function render() {
      var items = _controls2.default.createControls(this, {
        model: this.state.data,
        data: undefined,
        buildermode: true,
        eventOnEdit: this._onEdit,
        eventOnDelete: this._onDestroy,
        eventOnCopy: this._onCopy,
        parentItem: undefined,
        handleEvent: this._handleEvent,
        getFormFunc: this.props.getFormFunc,
        getFormFist: this.props.getFormFist,
        getAdditionalDataForControl: this.props.getAdditionalDataForControl,
        disableRefs: true,
        downloadUrl: this.props.downloadUrl,
        uploadUrl: this.props.uploadUrl,
        controlsToReplace: [],
        needCheckReplace: false
      });

      var dropzonetext = undefined;
      if (this.props.localization != undefined && this.props.localization.preview != undefined) {
        dropzonetext = this.props.localization.preview.dropzonetext;
      }
      var dropzone = _controls2.default.createBuilderDropzone("dropzone_header", undefined, undefined, dropzonetext);
      var dropzone_footer = items.length > 0 ? _controls2.default.createBuilderDropzone("dropzone_footer", undefined, undefined, dropzonetext) : '';

      return _react2.default.createElement(
        'div',
        { className: 'dwkit-formbuilder-preview' },
        dropzone,
        items,
        dropzone_footer
      );
    }
  }]);

  return Preview;
}(_react2.default.Component);

exports.default = Preview;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(5);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _store = __webpack_require__(9);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(6);

var _actions2 = _interopRequireDefault(_actions);

var _controls = __webpack_require__(7);

var _controls2 = _interopRequireDefault(_controls);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditForm = function (_React$Component) {
  _inherits(EditForm, _React$Component);

  function EditForm(props) {
    _classCallCheck(this, EditForm);

    var _this = _possibleConstructorReturn(this, (EditForm.__proto__ || Object.getPrototypeOf(EditForm)).call(this, props));

    _this.state = {
      key: undefined,
      item: undefined,
      open: false
    };

    _store2.default.listenTo(_actions2.default.showEditForm, _this.onShow.bind(_this));
    return _this;
  }

  _createClass(EditForm, [{
    key: "handleChange",
    value: function handleChange(e, _ref) {
      var name = _ref.name,
          value = _ref.value,
          checked = _ref.checked;

      var data = this.state.item;

      if (value == undefined) data[name] = checked;else data[name] = value;

      this.setState({ item: data });
    }
  }, {
    key: "onShow",
    value: function onShow(key) {
      var data = _store2.default.getByKey(key);
      var item = {};
      for (var i in data) {
        if (_typeof(data[i]) == "object") {
          item[i] = JSON.parse(JSON.stringify(data[i]));
        } else {
          item[i] = data[i];
        }
      }

      this.setState({
        key: key,
        item: item,
        open: true
      });
    }
  }, {
    key: "isChangedItem",
    value: function isChangedItem() {
      var data = _store2.default.getByKey(this.state.key);
      var item = this.state.item;

      for (var i in item) {
        if (JSON.stringify(item[i]) != JSON.stringify(data[i])) if (i == "events" && (item[i] == undefined || JSON.stringify(item[i]) == "{}") && (data[i] == undefined || JSON.stringify(data[i]) == "{}")) {
          continue;
        } else {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "getControlsList",
    value: function getControlsList() {
      return _store2.default.getAllKeys(_store2.default.getData());
    }
  }, {
    key: "showConfirm",
    value: function showConfirm(text, confirmHandle) {
      this.setState({ confirm: true, confirmtext: text, confirmHandle: confirmHandle });
    }
  }, {
    key: "onClose",
    value: function onClose() {
      var ischanged = this.isChangedItem();
      if (ischanged) {
        var msg = "Close without save?";
        if (this.props.localization != undefined) {
          msg = this.props.localization.base.closewithoutsavequestion;
        }

        this.showConfirm(msg, this.onCloseConfirmed.bind(this));
      } else {
        this.onCloseConfirmed();
      }
    }
  }, {
    key: "onSave",
    value: function onSave() {
      _store2.default.updateItemByKey(this.state.key, this.state.item);
      this.onCloseConfirmed();
    }
  }, {
    key: "onCloseConfirmed",
    value: function onCloseConfirmed() {
      this.setState({ open: false, confirm: false });
    }
  }, {
    key: "createError",
    value: function createError(text) {

      var closebtn = "Close";
      if (this.props.localization != undefined) {
        closebtn = this.props.localization.base.closebutton;
      }

      return _react2.default.createElement(
        _semanticUiReact.Modal,
        { open: this.state.open, onClose: this.onClose.bind(this) },
        _react2.default.createElement(
          _semanticUiReact.Modal.Header,
          null,
          "Error"
        ),
        _react2.default.createElement(
          _semanticUiReact.Modal.Content,
          null,
          _react2.default.createElement(
            "p",
            null,
            text
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Modal.Actions,
          null,
          _react2.default.createElement(
            _semanticUiReact.Button,
            { onClick: this.onClose.bind(this) },
            closebtn
          )
        )
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      if (this.state.item == undefined) return _react2.default.createElement("div", null);

      var editForm = _controls2.default.getEditControlByType(this.state.item["data-buildertype"]);
      if (editForm == undefined) {
        return this.createError("EditForm is not found for this control!");
      }

      var okbtn = "OK";
      if (this.props.localization != undefined) {
        okbtn = this.props.localization.base.okbutton;
      }
      var cancelbtn = "Cancel";
      if (this.props.localization != undefined) {
        cancelbtn = this.props.localization.base.cancelbutton;
      }
      var questiontitle = "Question";
      if (this.props.localization != undefined) {
        questiontitle = this.props.localization.base.questiontitle;
      }

      var confirmHandleCancel = function confirmHandleCancel() {
        return _this2.setState({ confirm: false });
      };
      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(editForm, { key: "editform",
          data: this.state.item,
          parent: this,
          open: this.state.open,
          onSave: this.onSave,
          onClose: this.onClose,
          actions: this.props.actions,
          className: "dwkit-formbuilder-editform",
          localization: this.props.localization
        }),
        _react2.default.createElement(
          _semanticUiReact.Modal,
          { size: "small", open: this.state.confirm, dimmer: "inverted", onClose: confirmHandleCancel },
          _react2.default.createElement(
            _semanticUiReact.Modal.Header,
            null,
            questiontitle
          ),
          _react2.default.createElement(
            _semanticUiReact.Modal.Content,
            null,
            _react2.default.createElement(
              "p",
              null,
              this.state.confirmtext
            )
          ),
          _react2.default.createElement(
            _semanticUiReact.Modal.Actions,
            null,
            _react2.default.createElement(
              _semanticUiReact.Button,
              { className: "buttontype1", onClick: this.state.confirmHandle },
              okbtn
            ),
            _react2.default.createElement(
              _semanticUiReact.Button,
              { className: "buttontype2", onClick: confirmHandleCancel },
              cancelbtn
            )
          )
        )
      );
    }
  }]);

  return EditForm;
}(_react2.default.Component);

exports.default = EditForm;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _base, _labelform;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var lang = {
  clearbutton: "Clear",
  uploadbutton: "Upload",
  downloadbutton: "Download",
  toolbar: {
    sepContainers: "Containers",
    container: "DIV",
    form: "Form",
    formgroup: "Form Group",
    menu: "Menu",
    workflowbar: "Workflow bar",
    customblock: "Custom block",
    sepCollection: "Collections",
    gridview: "GridView",
    collectioneditor: "Collection Editor",
    sepControls: "Controls",
    header: "Header",
    input: "Input",
    textarea: "TextArea",
    dictionary: "Dictionary",
    dropdown: "Dropdown",
    checkbox: "CheckBox",
    radiogroup: "Radio group",
    button: "Button",
    label: "Label",
    message: "Message",
    image: "Image",
    statistic: "Statistic",
    customcontrol: "Custom control",
    staticcontent: "Static Content",
    dropdowntrigger: "Dropdown trigger",
    sepCharts: "Charts",
    barchart: "Bar",
    linechart: "Line",
    scatterchart: "Scatter",
    doughnutchart: "Doughnut",
    piechart: "Pie",
    radarchart: "Radar"
  },
  preview: {
    dropzonetext: "DROP ZONE"
  },
  editforms: {
    base: (_base = {
      generaltab: "General",
      styletab: "Style",
      eventstab: "Events",
      othertab: "Other",
      widthfield: "Width",
      heightfield: "Height",
      margintopfield: "Margin Top",
      marginbottomfield: "Margin Bottom",
      marginleftfield: "Margin Left",
      marginrightfield: "Margin Right",
      customcssclassfield: "Custom CSS class",
      stylefield: "Style",
      hiddenfield: "Hidden",
      controlhasnoeventsmsg: "This control has no events.",
      eventsinfomsg: "These flags enable processing from this element.",

      requiredfield: "Required",
      defaultvaluefield: "Default value"
    }, _defineProperty(_base, "defaultvaluefield", "Default value"), _defineProperty(_base, "customvalidationfield", "Custom Validation"), _defineProperty(_base, "visibleconditionfield", "Visible condition"), _defineProperty(_base, "readonlyconditionfield", "ReadOnly condition"), _defineProperty(_base, "savebutton", "Save"), _defineProperty(_base, "cancelbutton", "Cancel"), _defineProperty(_base, "okbutton", "OK"), _defineProperty(_base, "closebutton", "Close"), _defineProperty(_base, "sizedefault", "Default"), _defineProperty(_base, "sizemini", "Mini"), _defineProperty(_base, "sizetiny", "Tiny"), _defineProperty(_base, "sizesmall", "Small"), _defineProperty(_base, "sizemedium", "Medium"), _defineProperty(_base, "sizelarge", "Large"), _defineProperty(_base, "sizebig", "Big"), _defineProperty(_base, "sizehuge", "Huge"), _defineProperty(_base, "sizemassive", "Massive"), _defineProperty(_base, "attachednone", "None"), _defineProperty(_base, "attachedtop", "Top"), _defineProperty(_base, "attachedbottom", "Bottom"), _defineProperty(_base, "attachedtopright", "Top right"), _defineProperty(_base, "attachedtopleft", "Top left"), _defineProperty(_base, "attachedbottomleft", "Bottom left"), _defineProperty(_base, "attachedbottomright", "Bottom right"), _defineProperty(_base, "labeldefault", "Default"), _defineProperty(_base, "labelleft", "Left"), _defineProperty(_base, "labelright", "Right"), _defineProperty(_base, "labelleftcorner", "Left corner"), _defineProperty(_base, "labelrightcorner", "Right corner"), _defineProperty(_base, "closewithoutsavequestion", "Close without save?"), _defineProperty(_base, "questiontitle", "Question"), _defineProperty(_base, "onchangetimeout", "onChange timeout"), _base),
    headerform: {
      namefield: "Name",
      sizefield: "Size",
      contentfield: "Content",
      textalignfield: "Text Align",
      textalignleft: "Left",
      textaligncenter: "Center",
      textalignright: "Right",
      subheaderfield: "Subheader"
    },
    buttonform: {
      namefield: "Name",
      typefield: "Type",
      typenonefield: "None",
      typesubmitfield: "Submit",
      sizefield: "Size",
      contentfield: "Content",
      optionsfield: "Options",
      basicfield: "Basic",
      circularfield: "Circular",
      compactfield: "Compact",
      disabledfield: "Disabled",
      fluidfield: "Fluid",
      invertedfield: "Inverted",
      loadingfield: "Loading",
      primaryfield: "Primary",
      secondaryfield: "Secondary",
      togglefield: "Toggle",
      floatedfield: "Floated",
      floateddefaultfield: "Default",
      floatedleftfield: "Left",
      floatedrightfield: "Right"
    },
    labelform: (_labelform = {
      namefield: "Name",
      attachedfield: "Attached",
      contentfield: "Content",
      sizefield: "Size",
      optionsfield: "Options"
    }, _defineProperty(_labelform, "contentfield", "Content"), _defineProperty(_labelform, "basicfield", "Basic"), _defineProperty(_labelform, "circularfield", "Circular"), _defineProperty(_labelform, "cornerfield", "Corner"), _defineProperty(_labelform, "floatingfield", "Floating"), _defineProperty(_labelform, "horizontalfield", "Horizontal"), _defineProperty(_labelform, "pointingfield", "Pointing"), _labelform),
    staticcontentform: {
      namefield: "Name",
      fontsizefield: "Font size",
      contentfield: "Content",
      allowhtmlfield: "Allow HTML"
    },
    messageform: {
      namefield: "Name",
      headerfield: "Header",
      optionsfield: "Options",
      compactfield: "Compact",
      errorfield: "Error",
      floatingfield: "Floating",
      infofield: "Info",
      negativefield: "Negative",
      positivefield: "Positive",
      successfield: "Success",
      warningfield: "Warning",
      contentfield: "Content",
      sizefield: "Size"
    },
    inputform: {
      namefield: "Name",
      labelfield: "Label",
      typefield: "Type",
      typetext: "Text",
      typenumber: "Number",
      typedate: "Date",
      typetime: "Time",
      typedatetime: "Date & Time",
      typepasswod: "Password",
      labelpositionfield: "Label position",
      optionsfield: "Options",
      loadingfield: "Loading",
      invertedfield: "Inverted",
      errorfield: "Error",
      disabledfield: "Disabled",
      transparentfield: "Transparent",
      fluidfield: "Fluid",
      readonlyfield: "Read only",
      placeholderfield: "Placeholder",
      sizefield: "Size",
      dateformatfield: "Date Format"
    },
    textareaform: {
      namefield: "Name",
      labelfield: "Label",
      rowsfield: "Rows",
      optionsfield: "Options",
      placeholderfield: "Placeholder",
      autoheightfield: "Auto height",
      readonlyfield: "Read only"
    },
    checkboxform: {
      namefield: "Name",
      labelfield: "Label",
      optionsfield: "Options",
      fittedfield: "Fitted",
      indeterminatefield: "Indeterminate",
      readonlyfield: "ReadOnly",
      disabledfield: "Disabled",
      sliderfield: "Slider",
      togglefield: "Toggle"
    },
    dropdownform: {
      namefield: "Name",
      labelfield: "Label",
      datafield: "Data",
      datakeycolumn: "Key",
      datavaluecolumn: "Value",
      datatextcolumn: "Text",
      optionsfield: "Options",
      loadingfield: "Loading",
      errorfield: "Error",
      disabledfield: "Disabled",
      fluidfield: "Fluid",
      multiplefield: "Multiple",
      searchfield: "Search",
      selectionfield: "Selection",
      readonlyfield: "Read only",
      clearablefield: "Clearable",
      allowAddItemsfield: "Allow add items"
    },
    dictionaryform: {
      namefield: "Name",
      labelfield: "Label",
      datamodelfield: "Data model",
      placeholderfield: "Placeholder",
      columnsfield: "Columns (Name ASC, Email)",
      optionsfield: "Options",
      loadingfield: "Loading",
      errorfield: "Error",
      disabledfield: "Disabled",
      fluidfield: "Fluid",
      multiplefield: "Multiple",
      searchfield: "Search",
      selectionfield: "Selection",
      readonlyfield: "Read only",
      clearablefield: "Clearable",
      pagingfield: "Server pagination",
      pagesizefield: "Page Size",
      parentidField: "Parent Field"
    },
    radiogroupform: {
      namefield: "Name",
      labelfield: "Label",
      datafield: "Data",
      datakeycolumn: "Key",
      datavaluecolumn: "Value",
      datatextcolumn: "Text",
      groupdirectfield: "Group direct",
      directiongorizontalfield: "Gorizontal",
      directionverticalfield: "Vertical",
      readonlyfield: "Read only"
    },
    form: {
      namefield: "Name",
      sizefield: "Size",
      optionsfield: "Options",
      loadingfield: "Loading",
      errorfield: "Error",
      invertedfield: "Inverted",
      replyfield: "Reply",
      successfield: "Success",
      warningfield: "Warning"
    },
    formgroupform: {
      namefield: "Name",
      widthsfield: "Widths",
      widthsdefaultfield: "Default",
      widthsequalfield: "Equal",
      widthscustomfield: "Custom (1 - 16)",
      typefield: "Type",
      orientationcolumnsfield: "Columns",
      orientationrowsfield: "Rows"
    },
    containerform: {
      namefield: "Name",
      floatfield: "Float",
      floatnonefield: "None",
      floatleftfield: "Left",
      floatrightfield: "Right"
    },
    imageform: {
      namefield: "Name",
      srcfield: "Src",
      hreffield: "Href",
      optionsfield: "Options",
      avatarfield: "Avatar",
      borderedfield: "Bordered",
      centeredfield: "Centered",
      disabledfield: "Disabled",
      inlinefield: "Inline",
      spacedfield: "Spaced",
      floatedfield: "Floated",
      floatedleftfield: "Left",
      floatedrightfield: "Right",
      verticalalignfield: "Vertical align",
      verticalaligntopfield: "Top",
      verticalalignmiddlefield: "Middle",
      verticalalignbottomfield: "Bottom"
    },
    statisticform: {
      namefield: "Name",
      optionsfield: "Options",
      floatedfield: "Floated",
      horizontalfield: "Horizontal",
      datafield: "Data",
      sizefield: "Size"
    },
    gridform: {
      namefield: "Name",
      optionsfield: "Options",
      multiselectfield: "Multiselect",
      filterrowfield: "Filter row",
      disablesortfield: "Disable sorting",
      editformfield: "Edit form",
      editformshowtypefield: "Edit form show type",
      editformtypedefaultfield: "Default",
      editformtypemodalfield: "Modal",
      columnsfield: "Columns",
      keycolumn: "Key",
      namecolumn: "Name",
      typecolumn: "Type",
      widthcolumn: "Width",
      resizablecolumn: "Resizable",
      rowkeyfield: "Row key",
      pagertypefield: "Pagination type",
      pagertypenonefield: "None",
      pagertypeserverfield: "Server",
      pagesizefield: "Page size",
      defaultsortfield: "Default sort",
      rowheightfield: "Row height",
      minheightfield: "Min height",
      autoheightfield: "Auto Height",
      offsetfield: "OffSet",
      editType: "Edit type",
      editflowfield: "Edit flow"
    },
    collectioneditorform: {
      namefield: "Name",
      idfield: "Id field",
      optionsfield: "Options",
      readonlyfield: "ReadOnly",
      draggablefield: "Draggable",
      hierarchicalfield: "Hierarchical",
      collapseallfield: "Collapse all",
      parentidfield: "ParentId field",
      columnsfield: "Columns",
      keycolumn: "Key",
      namecolumn: "Name",
      controlcolumn: "Control",
      widthcolumn: "Width",
      disableAdd: "Disable Add",
      childrenField: "Children field"
    },
    customform: {
      namefield: "Name",
      typefield: "Type control",
      propsfield: "Props",
      childrenfield: "Children"
    },
    customblockform: {
      namefield: "Name",
      sourcetypefield: "Source type",
      sourcetypeformfield: "Form name",
      sourcetypejsonfield: "JSON source",
      formnamefield: "Form name",
      sourcefield: "JSON source",
      placeholderfield: "Placeholder"
    },
    menuform: {
      namefield: "Name",
      activeitemfield: "Active Item",
      itemsfield: "Items",
      itemstargetcolumn: "Target",
      itemstitlecolumn: "Title",
      optionsfield: "Options",
      pointingfield: "Pointing",
      secondaryfield: "Secondary",
      tabularfield: "Tabular",
      fluidfield: "Fluid",
      verticalfield: "Vertical",
      linkfield: "Link",
      visibleConditioncolumn: "Visible Condition"
    },
    dropdowntriggerform: {
      namefield: "Name",
      defaultvaluefield: "Default Value",
      itemsfield: "Items",
      itemstargetcolumn: "Target",
      itemstitlecolumn: "Title",
      itemsvisibleconditioncolumn: "Visible Condition",
      imageurlfield: "ImageUrl"
    },
    chartform: {
      namefield: "Name",
      titlefield: "Title",
      titlesizefield: "Title size",
      legendpositionfield: "Legend position",
      responsivefield: "Responsive",
      datasetcustomfield: "Dataset custom",
      datalabelsplaceholder: "Q1, Q2, Q3, Q4",
      datalabelsfield: "Data labels",
      datasetlabelfield: "Dataset Label",
      datasetbackgroundcolorfield: "Dataset BackgroundColor"
    },
    workflowform: {
      namefield: "Name",
      setstatebuttonfield: "Set state button",
      blocksetstatefield: "Block SetState"
    },
    uploadform: {
      namefield: "Name",
      iconFiletypes: "Icon file types",
      customPostUrl: "Custom post url",
      showFiletypeIcon: "Show file type icon",
      autoProcessQueue: "Auto process queue",
      addRemoveLinks: "Add remove links",
      multile: "Multiple file upload"
    },
    breadcrumbform: {
      namefield: "Name",
      itemsfield: "Items",
      itemstextcolumn: "Text",
      itemsurlcolumn: "Url",
      itemsactivecolumn: "Active",
      itemsiconcolumn: "Divider Icon"
    },
    searchform: {
      namefield: "Name",
      urlfield: "Url",
      categoryfield: "Enable Categories"
    }
  }
};

module.exports = lang;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(5);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _store = __webpack_require__(9);

var _store2 = _interopRequireDefault(_store);

var _controls = __webpack_require__(7);

var _controls2 = _interopRequireDefault(_controls);

var _timeout = __webpack_require__(71);

var _timeout2 = _interopRequireDefault(_timeout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DWKitForm = function (_React$Component) {
    _inherits(DWKitForm, _React$Component);

    function DWKitForm(props) {
        _classCallCheck(this, DWKitForm);

        var _this = _possibleConstructorReturn(this, (DWKitForm.__proto__ || Object.getPrototypeOf(DWKitForm)).call(this, props));

        _this._asyncGetData = null;
        _this._asyncGetModel = null;

        _this.state = {
            data: props.data,
            model: props.model,
            extendedData: props.extendedData,
            controlsToReplace: null
        };
        // this.controlsToReplace = null;

        _this.checkLoadedState(_this.state.data, _this.state.model);
        return _this;
    }

    _createClass(DWKitForm, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.PrepareState();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this.PrepareState();
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._asyncGetData) {
                this._asyncGetData.abort();
            }
            if (this._asyncGetModel) {
                this._asyncGetModel.abort();
            }
        }
    }, {
        key: 'PrepareState',
        value: function PrepareState() {
            var me = this;
            if (this.state.needFetchModel) {
                me.setState({ needFetchModel: false });
                this._asyncGetModel = $.getJSON(this.state.modelurl).done(function (data) {
                    me._asyncGetModel = null;
                    me.modelChanged(data);
                }).fail(function (jqxhr, textStatus, error) {
                    me._asyncGetModel = null;
                    var err = textStatus + ", " + error;
                    me.handleErrEvent(err);
                });
            }

            if (this.state.needFetchData) {
                me.setState({ needFetchData: false });
                this._asyncGetData = $.getJSON(this.state.dataurl).done(function (data) {
                    me._asyncGetData = null;
                    me.dataChanged(data);
                }).fail(function (jqxhr, textStatus, error) {
                    me._asyncGetData = null;
                    var err = textStatus + ", " + error;
                    me.handleErrEvent(err);
                });
            }

            this.checkConditions(this.state.model);
            this.checkLoadedState(this.state.data, this.state.model);
        }
    }, {
        key: 'modelChanged',
        value: function modelChanged(model) {
            this.setState({
                model: model,
                controlsToReplace: null
            });

            this.checkConditions(model);
        }
    }, {
        key: 'dataChanged',
        value: function dataChanged(data) {
            this.setState({
                data: data
            });

            this.checkLoadedState(data, this.state.model);
        }
    }, {
        key: 'checkLoadedState',
        value: function checkLoadedState(data, model) {
            if (!this.state.isLoaded && data !== undefined && data !== null && model !== undefined && model !== null) {
                this.setState({ isLoaded: true });
                this.props.eventFunc({
                    key: undefined,
                    controlRef: this,
                    formName: this.props.formName,
                    component: this,
                    eventName: "init",
                    actions: ["initSystem", "init"],
                    parameters: undefined
                });
            }
        }
    }, {
        key: 'handleEvent',
        value: function handleEvent(_ref) {
            var e = _ref.e,
                key = _ref.key,
                eventName = _ref.eventName,
                parameters = _ref.parameters,
                name = _ref.name,
                value = _ref.value;

            var me = this;
            var isOnchange = eventName === "onChange";
            if (isOnchange) {
                if (!Boolean(this.props.onlyExternalDataChanged)) {
                    if (this.state.data === undefined) {
                        this.state.data = {};
                    }
                    var data = this.state.data;
                    data[key] = value;
                    this.setState({ data: data });
                }

                if (this.props.dataChanged !== undefined) this.props.dataChanged(this, { key: key, value: value });

                this.onConditions(key, eventName, parameters, name, value);
            }

            if (this.props.eventFunc === undefined) return;

            var item = this.findModelItembyKey(key);
            if (item === undefined) return;

            if (item.events !== undefined && item.events[eventName] !== undefined && item.events[eventName].active) {
                var event = item.events[eventName];

                var eventParameters = _extends({}, parameters);
                if (Array.isArray(event.parameters) && event.parameters.length > 0) {
                    event.parameters.forEach(function (p) {
                        eventParameters[p.name] = p.value;
                    });
                }
                var sourceControl = me.refs[key];
                var sourceControlValue = value;
                var fireEvent = void 0;
                if (Array.isArray(event.targets) && event.targets.length > 0) {

                    fireEvent = function fireEvent() {
                        return event.targets.forEach(function (t) {
                            me.props.eventFunc({
                                key: t,
                                sourceControlRef: sourceControl,
                                sourceControlValue: sourceControlValue,
                                controlRef: me.refs[t],
                                formName: me.props.formName,
                                component: me,
                                eventName: eventName,
                                actions: event.actions,
                                parameters: eventParameters
                            });
                        });
                    };
                } else {
                    fireEvent = function fireEvent() {
                        return me.props.eventFunc({
                            key: key,
                            sourceControlRef: sourceControl,
                            sourceControlValue: sourceControlValue,
                            controlRef: sourceControl,
                            formName: me.props.formName,
                            component: me,
                            eventName: eventName,
                            actions: event.actions,
                            parameters: eventParameters
                        });
                    };
                }
                if (!isOnchange || item.onChangeTimeout === undefined || item.onChangeTimeout === "" || Number(item.onChangeTimeout) < 1) {
                    fireEvent();
                } else {
                    _timeout2.default.Set(key, fireEvent, Number(item.onChangeTimeout));
                }
            }
        }
    }, {
        key: 'checkConditions',
        value: function checkConditions(model, child) {
            var enableCheckConditions = false;
            if (Array.isArray(model)) {
                for (var i = 0; i < model.length; i++) {
                    if (model[i]["other-visibleConition"] !== undefined && model[i]["other-visibleConition"] !== "" || model[i]["other-readOnlyConition"] !== undefined && model[i]["other-readOnlyConition"] !== "") {
                        enableCheckConditions = true;
                    }

                    if (Array.isArray(model[i].children)) {
                        enableCheckConditions = this.checkConditions(model[i].children, true);
                    }

                    if (enableCheckConditions) break;
                }
            }

            if (child) {
                return enableCheckConditions;
            }

            this.state.enableCheckConditions = enableCheckConditions;
        }
    }, {
        key: 'onConditions',
        value: function onConditions(key, eventName, parameters, name, value) {
            if (this.state.enableCheckConditions) {
                this.props.eventFunc({
                    key: key,
                    controlRef: this.refs[key],
                    formName: this.props.formName,
                    component: this,
                    eventName: eventName,
                    actions: ["checkConditions"],
                    parameters: parameters
                });
            }
        }
    }, {
        key: 'handleErrEvent',
        value: function handleErrEvent(message) {
            if (this.props.eventErrFunc) {
                this.props.eventErrFunc(this, message);
            }
        }
    }, {
        key: 'findModelItembyKey',
        value: function findModelItembyKey(key, array) {
            if (array === undefined) {
                array = this.state.model;
            }

            for (var i = 0; i < array.length; i++) {
                if (array[i].key === key) return array[i];

                if (array[i].children !== undefined) {
                    var item = this.findModelItembyKey(key, array[i].children);
                    if (item !== undefined) return item;
                }

                if (array[i].placeholders !== undefined) {
                    for (var ph in array[i].placeholders) {
                        var item = this.findModelItembyKey(key, array[i].placeholders[ph]);
                        if (item !== undefined) return item;
                    }
                }
            }
            return undefined;
        }
    }, {
        key: 'render',
        value: function render() {
            var controlsToReplace = [];
            var needCheckReplace = false;

            if (this.state.model !== null && this.state.model !== undefined) {
                controlsToReplace = this.state.controlsToReplace === null ? [] : this.state.controlsToReplace;
                needCheckReplace = this.state.controlsToReplace === null;
            }

            var items = _controls2.default.createControls(this, {
                model: this.state.model,
                data: this.state.data,
                errors: this.props.errors,
                handleEvent: this.handleEvent.bind(this),
                getFormFunc: this.props.getFormFunc,
                getAdditionalDataForControl: this.props.getAdditionalDataForControl,
                hideControls: this.props.hideControls,
                readOnlyControls: this.props.readOnlyControls,
                readOnly: this.props.readOnly,
                uploadUrl: this.props.uploadUrl,
                downloadUrl: this.props.downloadUrl,
                extendedData: this.props.extendedData,
                controlsToReplace: controlsToReplace,
                needCheckReplace: needCheckReplace
            });

            if (needCheckReplace) {
                this.state.controlsToReplace = controlsToReplace;
            }

            var className = "dwkit-form" + (this.props.className === undefined ? "" : " " + this.props.className);

            return _react2.default.createElement(
                'div',
                { className: className },
                items
            );
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            var stateDelta = {};
            if (nextProps.modelurl !== undefined && nextProps.modelurl !== "" && nextProps.modelurl !== prevState.modelurl) {
                stateDelta.modelurl = nextProps.modelurl;
                stateDelta.needFetchModel = true;
            }
            //TODO add json equal?
            if (nextProps.model !== undefined && nextProps.model !== prevState.model) {
                stateDelta.controlsToReplace = null;
                stateDelta.model = nextProps.model;
            }

            if (nextProps.dataurl !== undefined && nextProps.dataurl !== "" && nextProps.dataurl !== prevState.dataurl) {
                stateDelta.dataurl = nextProps.dataurl;
                stateDelta.needFetchData = true;
            }
            if (nextProps.data !== undefined) {
                stateDelta.data = nextProps.data;
            }

            return stateDelta;
        }
    }]);

    return DWKitForm;
}(_react2.default.Component);

exports.default = DWKitForm;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var timeoutsIdNameMap = {};

var Timeout = function () {
    function Timeout() {
        _classCallCheck(this, Timeout);
    }

    _createClass(Timeout, null, [{
        key: "Set",
        value: function Set(name, callback, delay) {
            if (timeoutsIdNameMap.hasOwnProperty(name)) {
                clearTimeout(timeoutsIdNameMap[name]);
            }

            var timeoutId = setTimeout(callback, delay);
            timeoutsIdNameMap[name] = timeoutId;
        }
    }, {
        key: "Clear",
        value: function Clear(name) {
            if (timeoutsIdNameMap.hasOwnProperty(name)) {
                clearTimeout(timeoutsIdNameMap[name]);
                delete timeoutsIdNameMap[name];
            }
        }
    }]);

    return Timeout;
}();

exports.default = Timeout;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwN2I4NTViNTU0ODQ2Y2M5ZTJlNCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInNlbWFudGljLXVpLXJlYWN0XCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL0xpc3RlbmVyTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbjUvbGliL2pzb241LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0LWRvbVwiIiwid2VicGFjazovLy8uL3NyYy9hY3Rpb25zLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbHMuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yZS5qc3giLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL0tlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9QdWJsaXNoZXJNZXRob2RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL0xpc3RlbmVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvY29sbGVjdGlvbmVkaXRvci5qc3giLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibW9tZW50XCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9BY3Rpb25NZXRob2RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvam9pbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9jcmVhdGVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL1N0b3JlTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGZvcm0tY29udHJvbHMuanN4Iiwid2VicGFjazovLy8uL3NyYy9jb250cm9sL3VwbG9hZC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvZGF0ZXBpY2tlci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvcmFkaW9ncm91cC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z1bmN0aW9uYWxmaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1aWxkZXIuanN4Iiwid2VicGFjazovLy8uL3NyYy90b29sYmFyLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL21peGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvYmluZE1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9jcmVhdGVBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC9zcmMvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4L3NyYy9jb25uZWN0RmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL2xpc3RlblRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL2xpc3RlblRvTWFueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbHV4L3NyYy9hZGRFUzYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZmx1eC9zcmMvZGVmaW5lUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGVwaWNrZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtb25jbGlja291dHNpZGUvZGlzdC9yZWFjdC1vbmNsaWNrb3V0c2lkZS5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcG9wcGVyL2xpYi9yZWFjdC1wb3BwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcG9wcGVyL2xpYi9UYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvUG9wcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvQXJyb3cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvZXZlbnRzZWRpdG9yLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbC9tZW51Z3JvdXAuanN4Iiwid2VicGFjazovLy8uL3NyYy9jb250cm9sL2dyaWR2aWV3LmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0YS1ncmlkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvZGlzdC9yZWFjdC1kYXRhLWdyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvY2hhcnR2aWV3LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbC93b3JrZmxvd2Jhci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvZGljdGlvbmFyeS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvY29udGFpbmVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbC9zdGF0aWNjb250ZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbGJhci5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvZHJvcGRvd250cmlnZ2VyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbC9zZW1hbnRpY2NvbnRyb2wuanN4Iiwid2VicGFjazovLy8uL3NyYy9jb250cm9sL2Ryb3B6b25lLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJvcHpvbmUtY29tcG9uZW50L2Rpc3QvcmVhY3QtZHJvcHpvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2wvc2VhcmNoLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcHJldmlldy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRmb3JtLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvbGFuZy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0uanN4Iiwid2VicGFjazovLy8uL3NyYy90aW1lb3V0LmpzIl0sIm5hbWVzIjpbIlJlZmx1eCIsInJlcXVpcmUiLCJCdWlsZGVyQWN0aW9ucyIsImNyZWF0ZUFjdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIiwiRFdLaXRGb3JtQ29udHJvbHMiLCJJdGVtcyIsImtleSIsInRpdGxlIiwiaXNzZXBhcmF0ZSIsImRlZmF1bHRvcGVuIiwiY29udHJvbCIsIkNvbnRhaW5lciIsImVkaXRDb250cm9sIiwiQ29udGFpbmVyRWRpdENvbnRyb2wiLCJTZW1hbnRpY0NvbnRyb2wiLCJGb3JtRWRpdENvbnRyb2wiLCJGb3JtR3JvdXBFZGl0Q29udHJvbCIsImRlZmF1bHRWYWx1ZXMiLCJ3aWR0aHMiLCJNZW51R3JvdXAiLCJNZW51RWRpdENvbnRyb2wiLCJpdGVtcyIsInRhcmdldCIsIldvcmtmbG93QmFyIiwiV29ya2Zsb3dCYXJFZGl0Q29udHJvbCIsImV2ZW50cyIsIm9uQ29tbWFuZENsaWNrIiwiYWN0aXZlIiwiYWN0aW9ucyIsIm9uU2V0U3RhdGVDbGljayIsInVuZGVmaW5lZCIsIkN1c3RvbUJsb2NrRWRpdENvbnRyb2wiLCJzb3VyY2VUeXBlIiwiR3JpZFZpZXciLCJHcmlkRWRpdENvbnRyb2wiLCJjb2x1bW5zIiwibmFtZSIsIkNvbGxlY3Rpb25FZGl0b3IiLCJDb2xsZWN0aW9uRWRpdG9yRWRpdENvbnRyb2wiLCJpZEZpZWxkIiwicGFyZW50SWRGaWVsZCIsIkhlYWRlckVkaXRDb250cm9sIiwiY29udGVudCIsInNpemUiLCJJbnB1dEVkaXRDb250cm9sIiwibGFiZWwiLCJmbHVpZCIsIm9uQ2hhbmdlVGltZW91dCIsIlRleHRBcmVhRWRpdENvbnRyb2wiLCJEaWN0aW9uYXJ5IiwiRGljdGlvbmFyeUVkaXRDb250cm9sIiwic2VsZWN0aW9uIiwiRHJvcGRvd25FZGl0Q29udHJvbCIsInZhbHVlIiwidGV4dCIsIkNoZWNrYm94RWRpdENvbnRyb2wiLCJSYWRpb0dyb3VwIiwiUmFkaW9Hcm91cEVkaXRDb250cm9sIiwiQnV0dG9uRWRpdENvbnRyb2wiLCJMYWJlbEVkaXRDb250cm9sIiwiTWVzc2FnZUVkaXRDb250cm9sIiwiaGVhZGVyIiwiSW1hZ2VFZGl0Q29udHJvbCIsInNyYyIsIlN0YXRpc3RpY0VkaXRDb250cm9sIiwiQ3VzdG9tRWRpdENvbnRyb2wiLCJwcm9wcyIsIlN0YXRpY0NvbnRlbnQiLCJTdGF0aWNDb250ZW50RWRpdENvbnRyb2wiLCJEcm9wZG93blRyaWdnZXIiLCJEcm9wZG93blRyaWdnZXJFZGl0Q29udHJvbCIsImRlZmF1bHRWYWx1ZSIsIkRyb3B6b25lQ29udHJvbCIsIkRyb3B6b25lRWRpdENvbnRyb2wiLCJzaG93RmlsZXR5cGVJY29uIiwiYXV0b1Byb2Nlc3NRdWV1ZSIsImFkZFJlbW92ZUxpbmtzIiwibXVsdGlsZSIsIkJyZWFkY3J1bWJFZGl0Q29udHJvbCIsIm9uSXRlbUNsaWNrIiwiU2VhcmNoIiwiU2VhcmNoRWRpdENvbnRyb2wiLCJDaGFydFZpZXciLCJDaGFydEVkaXRDb250cm9sIiwiY2hhcnRUeXBlIiwiZGF0YXNldExhYmVsIiwiY3JlYXRlQ29udHJvbHMiLCJwYXJlbnRDb21wb25lbnQiLCJtb2RlbCIsImRhdGEiLCJlcnJvcnMiLCJldmVudE9uRWRpdCIsImV2ZW50T25EZWxldGUiLCJldmVudE9uQ29weSIsImhhbmRsZUV2ZW50IiwicGFyZW50SXRlbSIsImdldEZvcm1GdW5jIiwiZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sIiwiYnVpbGRlcm1vZGUiLCJoaWRlQ29udHJvbHMiLCJyZWFkT25seUNvbnRyb2xzIiwicmVhZE9ubHkiLCJkaXNhYmxlUmVmcyIsInVwbG9hZFVybCIsImRvd25sb2FkVXJsIiwiZXh0ZW5kZWREYXRhIiwiY29udHJvbHNUb1JlcGxhY2UiLCJuZWVkQ2hlY2tSZXBsYWNlIiwicGFyZW50UGxhY2Vob2xkZXIiLCJmb3JtSXRlbSIsImNvbnRyb2xCYXJSaWdodCIsInJlcyIsImkiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJpbmNsdWRlcyIsIml0ZW0iLCJkYnR5cGUiLCJ0eXBlIiwiY29udHJvbFByb3BzSW5pdCIsIkpTT041IiwicGFyc2UiLCJjb250cm9sUHJvcHMiLCJjbGFzc05hbWUiLCJzdHlsZSIsImdldFN0eWxlIiwiY2hpbGRyZW4iLCJlIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiY2hpbGRyZW5fc291cmNlIiwicmVuZGVyZW1wdHkiLCJjYmJ1aWxkZXJtb2RlIiwiYWRkRHJvcFpvbmVzIiwibmV3UGFyZW50SXRlbSIsIm5ld1BhcmVudFBsYWNlaG9sZGVyIiwibmV3Rm9ybUl0ZW0iLCJjb25zb2xlIiwiZXJyb3IiLCJmb3JtbmFtZSIsInBsYWNlaG9sZGVycyIsInNvdXJjZSIsImZvcm1Qcm9wcyIsImR6X2Zvb3RlciIsImNyZWF0ZUJ1aWxkZXJEcm9wem9uZSIsInB1c2giLCJkeiIsInVuc2hpZnQiLCJnZXRDb250cm9sQnlUeXBlIiwiaXNDb250YWluZXIiLCJpc0dvcml6b250YWxHcm91cCIsIm9yaWVudGF0aW9uIiwidGV4dERaIiwiZHJvcHpvbmVfZm9vdGVyIiwiZHJvcHpvbmVfaGVhZGVyIiwiY3JlYXRlQ29udHJvbCIsImRyb3B6b25lX2J3IiwiYnVpbGRlcmNvbnRyb2wiLCJidWlsZGVydHlwZSIsImdldEVkaXRDb250cm9sQnlUeXBlIiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJmbG9hdCIsIm9wYWNpdHkiLCJkaXNwbGF5IiwicHJvcGVydGllcyIsInNwbGl0IiwiZm9yRWFjaCIsInByb3BlcnR5IiwidHVwIiwicCIsInJlcGxhY2UiLCJyZWdleEZvclJlcGxhY2UiLCJvYmoiLCJkYXRhQnVpbGRlclR5cGUiLCJuZWVkUmVwbGFjZSIsInJlZiIsInJlcGxhY2VDb250cm9sVmFsdWUiLCJvcmlnaW5hbFZhbHVlIiwicmVwbGFjZUZyb21EYXRhIiwibSIsInNsaWNlIiwibmV3VmFsdWUiLCJuZWVkUHVzaEtleSIsInYiLCJuZXdWIiwiaGFzT3duUHJvcGVydHkiLCJzdWJoZWFkZXIiLCJocmVmIiwiZGVmYXVsdHZhbHVlIiwicGxhY2Vob2xkZXIiLCJsb2FkaW5nIiwiZGlzYWJsZWQiLCJtdWx0aXBsZSIsInNlYXJjaCIsImRhdGFNb2RlbCIsImNsZWFyYWJsZSIsInBhZ2luZyIsInBhZ2VTaXplIiwib25DaGFuZ2UiLCJzeW50aGV0aWNFdmVudCIsImV2ZW50TmFtZSIsInBhcmVudElzRm9ybSIsImlzRm9ybSIsImltYWdlVXJsIiwidXJsIiwiY2F0ZWdvcnkiLCJkaXJlY3Rpb24iLCJkcmFnZ2FibGUiLCJoaWVyYXJjaGljYWwiLCJjaGlsZHJlbkZpZWxkIiwiY29sbGFwc2VBbGwiLCJkaXNhYmxlQWRkIiwicGFyZW50Q29udHJvbCIsImRhdGFidWlsZGVydHlwZSIsInBhcmFtZXRlcnMiLCJjb2x1bW5OYW1lIiwiQm9vbGVhbiIsInBhcmVudCIsImoiLCJjaGlsZCIsIm11bHRpc2VsZWN0Iiwicm93S2V5IiwiZWRpdEZvcm0iLCJlZGl0RmxvdyIsImVkaXRUeXBlIiwicGFnZXJUeXBlIiwicm93SGVpZ2h0IiwibWluSGVpZ2h0IiwiYXV0b0hlaWdodCIsIm9mZlNldCIsImRpc2FibGVTb3J0IiwicmVzaXplQ29sdW1ucyIsImVkaXRGb3JtU2hvd1R5cGUiLCJkZWZhdWx0U29ydCIsImMiLCJmaWx0ZXJzIiwiZmlsdGVyIiwiRnVuY3Rpb25hbEZpbHRlciIsIm1hcCIsInBvaW50aW5nIiwic2Vjb25kYXJ5IiwidGFidWxhciIsInZlcnRpY2FsIiwiYWN0aXZlaXRlbSIsImxpbmsiLCJyZXNwb25zaXZlIiwibGVnZW5kUG9zaXRpb24iLCJ0aXRsZVNpemUiLCJkYXRhc2V0Q3VzdG9tIiwiZGF0YUxhYmVscyIsImRhdGFzZXRTdGVwcGVkTGluZSIsImRhdGFzZXRCb3JkZXJDb2xvciIsImRhdGFzZXRGaWxsIiwiZGF0YXNldEJvcmRlcldpZHRoIiwiZGF0YXNldEJhY2tncm91bmRDb2xvciIsInRlc3REYXRhIiwieCIsInkiLCJsYWJlbHMiLCJkYXRhc2V0cyIsImJsb2NrU2V0U3RhdGUiLCJzZXRTdGF0ZUJ1dHRvbiIsImNvbW1hbmRzIiwic3RhdGVzIiwiaXNIdG1sIiwiaWNvbkZpbGV0eXBlcyIsInBvc3RVcmwiLCJlbGVtZW50VG9JbnNlcnQiLCJlbGVtZW50YWZ0ZXIiLCJwbGFjZWhvbGRlcktleSIsImZpbGxEZWZhdWx0VmFsdWVzIiwiayIsIl9kYXRhIiwiRFdLaXRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiaW5pdCIsImxpc3RlblRvIiwiYWRkIiwibW92ZSIsInJlbW92ZSIsInNhdmUiLCJzYXZlRGF0YSIsIl91cGRhdGVPcmRlciIsImVsIiwiZmluZEl0ZW1CeUtleSIsInNvcnRlZEFycmF5IiwiX2V4Y2x1ZGVJdGVtQnlLZXkiLCJhdHRyaWJ1dGVzIiwiaW5zZXJ0SW5kZXgiLCJwYXJlbnRLZXkiLCJjb250YWluZXIiLCJhZnRlcktleSIsImFmdGVyQ29udHJvbCIsInNwbGljZSIsImluZGV4T2YiLCJzZXREYXRhIiwicGgiLCJnZXREZWZhdWx0S2V5IiwiYnVpbGRlclR5cGUiLCJ0cmlnZ2VyIiwicmVtb3ZlSXRlbUJ5S2V5IiwiY29weSIsIm5ld0l0ZW0iLCJjb3B5T2JqIiwiaW5zZXJ0QWZ0ZXJLZXkiLCJtYWtlVW5pcXVlS2V5cyIsImdldERhdGEiLCJlbGVtZW50cyIsImluZGV4IiwidG1wIiwiYWxsS2V5cyIsImdldEFsbEtleXMiLCJjaGlsZGtleXMiLCJjb25jYXQiLCJwaGtleXMiLCJnZXRCeUtleSIsImluc2VydEl0ZW0iLCJ1cGRhdGVJdGVtQnlLZXkiLCJyZXBsYWNlRGVwZW5zS2V5cyIsIm9sZEtleSIsIm5ld0tleSIsInRhcmdldHMiLCJjb25zdHJ1Y3RvciIsImF0dHIiLCJtZSIsInN0YXRlIiwiZXhwYW5kZWQiLCJhcHBseUNvbGxhcHNlQWxsIiwiZ2V0Q29weVJvd3NGcm9tUHJvcHMiLCJyZW5kZXJIZWFkZXJSb3ciLCJyZW5kZXJSb3dzIiwiZGF0YUxpc3RPcHRpb25zIiwiZGF0YUxpc3QiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImRhdGFMaXN0Q29udHJvbCIsImRhdGFMaXN0SWQiLCJvcHRWYWx1ZSIsIm8iLCJhZGRjb250ZW50Iiwid2luZG93IiwiRFdLaXRBZG1pbkxhbmciLCJjb2xsZWN0aW9uZWRpdG9yIiwiYnRuQWRkIiwiYmluZCIsInJvd3MiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsIm9uRHJhZ092ZXIiLCJvbkRyb3AiLCJvbkV4cGFuZCIsInBhcmVudElkVmFsdWUiLCJsZXZlbCIsInByZWZpeCIsImRyYWdjb2wiLCJnZXREcmFnQ29sdW1uIiwiZXhwYW5kIiwiaWNvbiIsInBhcmVudFByZWZpeCIsIlN0cmluZyIsInBhcmVudElkIiwiaXNleHBhbmRlZCIsInJvdyIsImVycm9yT25Sb3ciLCJjb2xOYW1lIiwib3B0aW9ucyIsImVycm9yRmxhZyIsImVsZW1lbnQiLCJoYW5kbGVDaGFuZ2UiLCJhcmdzIiwiY2hlY2tlZCIsInBhZGRpbmdMZWZ0IiwiYnRuQWRkQ2hpbGQiLCJidG5EZWxldGUiLCJzZW5kQ2hhbmdlc1RvUGFyZW50IiwiZGF0YWUiLCJvYmpQYXJlbnQiLCJkZWZhdWx0cm93Iiwicm93SWR4IiwiZm9yY2VVcGRhdGUiLCJwcmV2ZW50RGVmYXVsdCIsImRhdGFUcmFuc2ZlciIsImRyYWdFbGVtZW50SW5kZXgiLCJkcmFnUm93cyIsInJvd0luZGV4QSIsInJvd3NBIiwicm93SW5kZXhCIiwicm93c0IiLCJzdHJpbmdtb2RlIiwic3RyaW5naWZ5IiwiQ29tcG9uZW50IiwiQmFzZUVkaXRDb250cm9sIiwiYWN0aXZlSXRlbSIsIm1lbnVJdGVtcyIsImdldExvY2FsVmFsdWUiLCJvbkNsaWNrIiwiaGFuZGxlSXRlbUNsaWNrIiwibG9jYWwiLCJsb2NhbGl6YXRpb24iLCJibG9jayIsInNldFN0YXRlIiwiZ2V0RGV0YWlsRGVzY3JpcHRpb24iLCJzZWdtZW50IiwiZ2V0R2VuZXJhbERlc2NyaXB0aW9uIiwiZ2V0U3R5bGVEZXNjcmlwdGlvbiIsImdldEV2ZW50c0Rlc2NyaXB0aW9uIiwiZ2V0T3RoZXJEZXNjcmlwdGlvbiIsInN0eWxlc291cmNlX3BzIiwiZ2V0RXZlbnRzTGlzdCIsImNvbnRyb2xzT25Gb3JtIiwiZ2V0Q29udHJvbHNMaXN0IiwibGlzdENvbnRyb2xzIiwiaGFuZGxlQWRkaXRpb25BY3Rpb25zIiwidGltZW90IiwiY3VzdG9tdmFsaWRhdGlvbl9wcyIsInZpc2libGVjb25pdGlvbl9wcyIsInJlYWRPbmx5Y29uaXRpb25fcHMiLCJvcGVuIiwib25DbG9zZSIsImdldERlc2NyaXB0aW9uIiwib25TYXZlIiwiaXNFeGlzdHMiLCJjaGVja0FjdGlvbnNMaXN0Iiwic2l6ZWRhdGEiLCJ0ZXh0QWxpZ24iLCJidXR0b25UeXBlIiwiYmFzaWMiLCJjaXJjdWxhciIsImNvbXBhY3QiLCJpbnZlcnRlZCIsInByaW1hcnkiLCJ0b2dnbGUiLCJmbG9hdGVkIiwiYXR0YWNoZWRkYXRhIiwiYXR0YWNoZWQiLCJjb3JuZXIiLCJmbG9hdGluZyIsImhvcml6b250YWwiLCJpbmZvIiwibmVnYXRpdmUiLCJwb3NpdGl2ZSIsInN1Y2Nlc3MiLCJ3YXJuaW5nIiwibGFiZWxQb3NpdGlvbnMiLCJkaXNhYmxlRGF0ZUZvcm1hdCIsImxhYmVsUG9zaXRpb24iLCJ0cmFuc3BhcmVudCIsImZpdHRlZCIsImluZGV0ZXJtaW5hdGUiLCJzbGlkZXIiLCJkYXRhQ29sdW1ucyIsImFsbG93QWRkSXRlbXMiLCJyZXBseSIsIndpZHRoc0N1c3RvbSIsImZsb2F0ZGF0YSIsImF2YXRhciIsImJvcmRlcmVkIiwiY2VudGVyZWQiLCJpbmxpbmUiLCJzcGFjZWQiLCJ2ZXJ0aWNhbEFsaWduIiwiZGF0YWNvbHVtbnMiLCJwYWdlcnR5cGUiLCJlZGl0Zm9ybXR5cGUiLCJlZGl0VHlwZUl0ZW1zIiwibGVnZW5kUG9zaXRpb25PcHRpb25zIiwiZGlzYWJsZUN1c3RvbSIsInBhZGRpbmdUb3AiLCJVcGxvYWQiLCJjb250cm9scyIsInRva2VuIiwiZG93bmxvYWR0ZXh0IiwiY2xlYXJ0ZXh0IiwiYnV0dG9uIiwiZG93bmxvYWQiLCJjbGVhciIsImlzSGlkZUNsZWFyIiwiaGlkZUNsZWFyQnV0dG9uIiwib25DbGVhciIsImZvcm1kYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJmaWxlcyIsIiQiLCJhamF4IiwicHJvY2Vzc0RhdGEiLCJjb250ZW50VHlwZSIsImRhdGFUeXBlIiwianNvbkRhdGEiLCJtZXNzYWdlIiwiRGF0ZVBpY2tlciIsImRhdGUiLCJEV0tpdExhbmciLCJjb21tb24iLCJkYXRlRm9ybWF0Iiwic2hvd1RpbWVTZWxlY3QiLCJzaG93VGltZVNlbGVjdE9ubHkiLCJ0aW1lSW50ZXJ2YWxzIiwidGltZUZvcm1hdCIsImV2ZW50IiwiaGFuZGxlQ2hhbmdlUmF3IiwiZGl2Q2xhc3MiLCJmb3JtYXQiLCJ0b0pTT04iLCJmaWVsZHMiLCJGaWx0ZXJUZXJtcyIsIkdyZWF0ZXIiLCJMZXNzIiwiRXF1YWwiLCJHcmVhdGVyT3JFcXVhbCIsIkxlc3NPckVxdWFsIiwiTm90RXF1YWwiLCJ0b0xvd2VyQ2FzZSIsIkxpa2UiLCJTdGFydHNXaXRoIiwiRW5kc1dpdGgiLCJleHBlY3RlZCIsInRlcm0iLCJJc0dyZWF0ZXIiLCJjb21wYXJlV2l0aFR5cGVDaGVjayIsIklzTGVzcyIsIklzRXF1YWwiLCJJc0dyZWF0ZXJPckVxdWFsIiwiSXNMZXNzT3JFcXVhbCIsIklzTm90RXF1YWwiLCJJc0xpa2UiLCJsaWtlQ29tcGFyZSIsIklzU3RhcnRzV2l0aCIsInN0YXJ0c1dpdGgiLCJJc0VuZHNXaXRoIiwiZW5kc1dpdGgiLCJjb21wYXJhdG9yIiwidG9TdHJpbmciLCJwYXJzZUZsb2F0Iiwib2JqZWN0RmlsdGVyIiwiX2lubmVyRmlsdGVyIiwiYXBwbHlUb0NvbHVtbnMiLCJjb2x1bW4iLCJuIiwidHJpbSIsIkFkZEZpbHRlciIsIm5hbWVzIiwiaWQiLCJmaWx0ZXJJZCIsInNvcnQiLCJqb2luIiwiZnVuY3MiLCJ0ZXN0IiwiciIsImV2ZXJ5IiwiZiIsImNvbXBGdW5jIiwic2luZ2xlQ29tcEZ1bmMiLCJwcm9wTmFtZSIsIk9iamVjdCIsImtleXMiLCJmaW5kIiwicmVzdWx0IiwiRXZhbHVhdGUiLCJzb21lIiwicmVjcmVhdGVQcm9wZXJ0eSIsIm5ld0l0ZW1zIiwibmkiLCJhbGxGaWx0ZXJJZHMiLCJhbGxOYW1lcyIsInBuIiwiRFdLaXRGb3JtQnVpZGVyIiwiRFdLaXRGb3JtIiwiZGVmYXVsdEZvcm0iLCJhcGl1cmwiLCJpbWFnZWZvbGRlciIsImRyb3B6b25lYWN0aXZlIiwibG9hZCIsImNvZGUiLCJTdG9yZSIsImV4aXN0cyIsImVuYWJsZWQiLCJzaG93IiwiaGlkZSIsInNldEJ1aWxkZXJNb2RlIiwianNvbkNvbnRlbnQiLCJKU09OIiwiZW5jb2RlZFVyaSIsImRvY3VtZW50Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJmb3JtIiwic3VjY2Vzc0Z1bmMiLCJmaWxlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInRoZUZpbGUiLCJyZWFkQXNUZXh0IiwidXBsb2FkIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRDdXJyZW50TG9jYWxpemF0aW9uIiwic3BhblNlbGVjdG9yU3R5bGUiLCJjcmVhdGUiLCJjbGVhcmJ1dHRvbiIsInNob3dzYW1wbGUxIiwic2hvd3NhbXBsZTIiLCJoYW5kbGVTaG93RHJvcHpvbmVzQ2xpY2siLCJvbkNob29zZUZpbGVVcGxvYWQiLCJ1cGxvYWRidXR0b24iLCJvbkRvd25sb2FkIiwiZG93bmxvYWRidXR0b24iLCJvblVwbG9hZCIsIm9uQ2hhbmdlRmlsZVVwbG9hZCIsImJ1aWxkZXIiLCJnZXRGb3JtRmlzdCIsInByZXZpZXciLCJlZGl0Zm9ybXMiLCJ0b29sYmFyIiwidGVtcGxhdGVzIiwic2hvd0hlYWRlciIsImdldEhlYWRlciIsIkxhbmciLCJUb29sYmFyIiwidGVtcGxhdGUiLCJtYWtlTG9jYWxpemF0aW9uIiwic2VsZWN0b3IiLCJmb3JDb250YWluZXJUeXBlIiwiY1R5cGVzIiwic3ViU2VsZWN0b3IiLCJhZGRDbGFzcyIsIm9uIiwib25UYXJnZXREcmFnRW50ZXIiLCJvblRhcmdldERyYWdMZWF2ZSIsImNzcyIsInJlbW92ZUNsYXNzIiwic3RvcCIsInpvbmVzIiwib2ZmIiwic2V0Q29va2llIiwiZXhwYW5kZWRib2NrIiwib25jbGljayIsImNvb2tpZXZhbHVlIiwiZ2V0Q29va2llIiwidyIsImltYWdld2lkdGgiLCJoIiwiaW1hZ2VoZWlnaHQiLCJvbkRvdWJsZUNsaWNrIiwib25EcmFnIiwic3RlcCIsImNsaWVudFkiLCJzY3JvbGwiLCJzY3JvbGxZIiwic2Nyb2xsVG9wIiwic2V0VGltZW91dCIsIm1hdGNoZXMiLCJjb29raWUiLCJtYXRjaCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsImV4cGlyZXMiLCJkIiwiRGF0ZSIsInNldFRpbWUiLCJnZXRUaW1lIiwidG9VVENTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1cGRhdGVkQ29va2llIiwicHJvcFZhbHVlIiwiRXZlbnRzRWRpdG9yIiwiYWN0aW9uT3B0aW9ucyIsImEiLCJ0YXJnZXRPcHRpb25zIiwiaXNGaW5kIiwiYWN0aW9uc09uQWRkSXRlbSIsIm9uQWRkaXRpb25BY3Rpb25zIiwicmVuZGVySXRlbXMiLCJrZXlQcmVmaXgiLCJ2aXNpYmxlQ29uZGl0aW9uIiwiRnVuY3Rpb24iLCJ0aXRsZVNwYW4iLCJfX2h0bWwiLCJjb2xvciIsImhhbmRsZUl0ZW1DbGljazIiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJDaGVja0JveEZvcm1hdHRlciIsIk51bWJlckZvcm1hdHRlciIsIkRhdGVGb3JtYXR0ZXIiLCJzdHJWYWx1ZSIsImlzVmFsaWQiLCJEYXRlVGltZUZvcm1hdHRlciIsIlRpbWVGb3JtYXR0ZXIiLCJqc29uRXF1YWwiLCJiIiwic2VsZWN0ZWRJbmRleGVzIiwicm93c0NvdW50Iiwic3RhdGljSXNTZXJ2ZXJNb2RlIiwiaXNTZXJ2ZXJNb2RlIiwic3RhdGljR2V0U29ydGVkQW5kRmlsdGVyZWRJdGVtcyIsIm9yaWdpbmFsSXRlbXMiLCJncmlkUHJvcHMiLCJnZXRHcmlkUHJvcHNCeVBhZ2VyVHlwZSIsImdldENvbHVtbnMiLCJyb3dTZWxlY3Rpb24iLCJvblJvd3NTZWxlY3RlZCIsIm9uUm93c0Rlc2VsZWN0ZWQiLCJzZWxlY3RCeSIsImluZGV4ZXMiLCJncmlkUm93R2V0dGVyIiwiZ3JpZE9uUm93Q2xpY2siLCJoYW5kbGVHcmlkU29ydCIsIk51bWJlciIsInNvcnRhYmxlIiwiZmlsdGVyYWJsZSIsImZpbHRlclJvdyIsInJlc2l6YWJsZSIsImZvcm1hdHRlciIsImdldFJvd01ldGFEYXRhIiwiY3VzdG9tRm9ybWF0dGVyIiwiZGVwZW5kZW50VmFsdWVzIiwicm93UmVuZGVyZXIiLCJSb3dMb2FkaW5nUmVuZGVyZXIiLCJzZWxlY3RlZEtleXMiLCJsb2FkUGFnZSIsInN0YXJ0SW5kZXgiLCJfX2xvYWRpbmciLCJsb2ciLCJzb3J0U3RyaW5nIiwiR2V0RmlsdGVyQXNPYmplY3RzIiwic0luZGV4IiwicFNpemUiLCJ0aW1lbm93Iiwibm93Iiwicm93Q2xpY2tUaW1lIiwidGltZSIsIm9uUm93RGJsQ2xpY2siLCJyb3dJbmRleGVzIiwic29ydENvbHVtbiIsInNvcnREaXJlY3Rpb24iLCJzdGF0ZURlbHRhIiwiUmVtb3ZlRmlsdGVyIiwiZmlsdGVyVGVybSIsIl9pc01vdW50ZWQiLCJyZWNhbGNTaXplUGFyYW1zIiwiZ3JpZEhlaWdodCIsImRlbHRhSGVpZ2h0IiwibmV3U3RhdGUiLCJhcnJheSIsIklzUm93TWF0Y2hlZCIsImN1cnJlbnRTb3J0IiwiaW5kZXhTcGFjZSIsInN1YnN0cmluZyIsImNvbXBhcmVyIiwiYVZhbHVlIiwiYlZhbHVlIiwic2Nyb2xsQnkiLCJzZXRTY3JvbGxMZWZ0IiwiZ2V0Q2xhc3NOYW1lIiwibm9kZSIsInJlZHJhd0NoYXJ0IiwiY2hhcnQiLCJkZXN0cm95IiwiY3R4IiwiZ2V0RGl2SWQiLCJnZXRDb250ZXh0IiwiZ2V0Q2hhcnREYXRhIiwieUF4ZXMiLCJheGlzIiwieUF4aXNJRCIsInBvc2l0aW9uIiwiZ3JpZExpbmVzIiwiZHJhd09uQ2hhcnRBcmVhIiwiY29uZmlnIiwibGVnZW5kIiwiZm9udFNpemUiLCJzY2FsZXMiLCJDaGFydCIsInVwZGF0ZSIsInN0ZXBwZWRMaW5lIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmaWxsIiwiYm9yZGVyV2lkdGgiLCJjaGVja0dldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCIsImlzTW91bnQiLCJyZW5kZXJDb21tYW5kcyIsInJlbmRlclNldFN0YXRlIiwib25Db21tYW5kIiwiZGlzYWJsZUNsaWNrIiwid29ya2Zsb3diYXIiLCJzZXRzdGF0ZSIsImhhbmRsZUNoYW5nZWQiLCJvblNldFN0YXRlIiwiY29tbWFuZCIsImN1cnJlbnRTdGF0ZSIsIkdldEFkZGl0aW9uYWxEYXRhIiwicHJldlByb3BzIiwibmVlZEZldGNoIiwic2V0dGluZ3MiLCJsYXN0TG9hZFBhZ2UiLCJpc0ZldGNoaW5nIiwicGFnZSIsIm5lZWRWYWx1ZUZldGNoIiwibG9hZEN1cnJlbnRWYWx1ZSIsIm9uU2VhcmNoQ2hhbmdlIiwiaGFuZGxlU2VhcmNoQ2hhbmdlIiwiZ2V0QXJyYXlWYWx1ZXMiLCJzZWFyY2hRdWVyeSIsImxvYWRGbGFnIiwibG9hZE5leHRQYWdlIiwicmVzZXQiLCJnZXRDb2xsdW1uc0ZvckZpbHRlciIsInZhbHVlcyIsIm9wdGlvbiIsImxvYWRpbmdJdGVtIiwicG9wIiwidmFsdWVBcnJheSIsInVuZmluZGVkVmFsdWVzIiwiYWRkQWRkaXRpb25hbE9wdGlvbnMiLCJwYXR0ZXJuIiwic3BhblByb3BzIiwiQ29udHJvbEJhciIsImlzR3JvdXAiLCJjb250cm9sT25SaWdodCIsIm9uTW91c2VPdmVyIiwib25Nb3VzZUxlYXZlIiwib25FZGl0Iiwib25Db3B5Iiwib25EZWxldGUiLCJwYXJlbnRzIiwicHJldiIsIm5leHQiLCJpc1NraXAiLCJvbk1vdXNlRG93biIsIm9wZW5kaWFsb2ciLCJwcm9wc0NvbnRyb2wiLCJhZGRpdGlvbmFsUGFyYW1zIiwidmFyaWFibGUiLCJhbGxvd0FkZGl0aW9ucyIsIm9uQWRkSXRlbSIsImRyb3Bkb3duQ2hlY2tBZGRpdGlvbmFsIiwic2hhcGUiLCJjaGlsZFByb3BzIiwiZGl2aWRlclByb3BzIiwiZGl2aWRlciIsIkRyb3B6b25lIiwidHlwZXMiLCJ0IiwiZGpzQ29uZmlnIiwiY29tcG9uZW50Q29uZmlnIiwiZXZlbnRIYW5kbGVycyIsImZpbGVVcGxvYWRTdWNjZXNzIiwicmVzcG9uc2UiLCJfcmVtb3ZlTGluayIsIlNlYXJjaENvbnRyb2wiLCJpc0xvYWRpbmciLCJoYW5kbGVSZXN1bHRTZWxlY3QiLCJyZXN1bHRzIiwicmVzZXRTZWFyY2giLCJzZWFyY2hTdHIiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsImpzb24iLCJjYXRjaCIsImFsZXJ0IiwiUHJldmlldyIsImVkaXRFbGVtZW50IiwibGlzdGVuIiwiZGF0YUNoYW5nZWQiLCJzaG93RWRpdEZvcm0iLCJfb25FZGl0IiwiX29uRGVzdHJveSIsIl9vbkNvcHkiLCJfaGFuZGxlRXZlbnQiLCJkcm9wem9uZXRleHQiLCJkcm9wem9uZSIsIkVkaXRGb3JtIiwib25TaG93IiwiY29uZmlybUhhbmRsZSIsImNvbmZpcm0iLCJjb25maXJtdGV4dCIsImlzY2hhbmdlZCIsImlzQ2hhbmdlZEl0ZW0iLCJtc2ciLCJiYXNlIiwiY2xvc2V3aXRob3V0c2F2ZXF1ZXN0aW9uIiwic2hvd0NvbmZpcm0iLCJvbkNsb3NlQ29uZmlybWVkIiwiY2xvc2VidG4iLCJjbG9zZWJ1dHRvbiIsImNyZWF0ZUVycm9yIiwib2tidG4iLCJva2J1dHRvbiIsImNhbmNlbGJ0biIsImNhbmNlbGJ1dHRvbiIsInF1ZXN0aW9udGl0bGUiLCJjb25maXJtSGFuZGxlQ2FuY2VsIiwibGFuZyIsInNlcENvbnRhaW5lcnMiLCJmb3JtZ3JvdXAiLCJtZW51IiwiY3VzdG9tYmxvY2siLCJzZXBDb2xsZWN0aW9uIiwiZ3JpZHZpZXciLCJzZXBDb250cm9scyIsImlucHV0IiwidGV4dGFyZWEiLCJkaWN0aW9uYXJ5IiwiZHJvcGRvd24iLCJjaGVja2JveCIsInJhZGlvZ3JvdXAiLCJpbWFnZSIsInN0YXRpc3RpYyIsImN1c3RvbWNvbnRyb2wiLCJzdGF0aWNjb250ZW50IiwiZHJvcGRvd250cmlnZ2VyIiwic2VwQ2hhcnRzIiwiYmFyY2hhcnQiLCJsaW5lY2hhcnQiLCJzY2F0dGVyY2hhcnQiLCJkb3VnaG51dGNoYXJ0IiwicGllY2hhcnQiLCJyYWRhcmNoYXJ0IiwiZ2VuZXJhbHRhYiIsInN0eWxldGFiIiwiZXZlbnRzdGFiIiwib3RoZXJ0YWIiLCJ3aWR0aGZpZWxkIiwiaGVpZ2h0ZmllbGQiLCJtYXJnaW50b3BmaWVsZCIsIm1hcmdpbmJvdHRvbWZpZWxkIiwibWFyZ2lubGVmdGZpZWxkIiwibWFyZ2lucmlnaHRmaWVsZCIsImN1c3RvbWNzc2NsYXNzZmllbGQiLCJzdHlsZWZpZWxkIiwiaGlkZGVuZmllbGQiLCJjb250cm9saGFzbm9ldmVudHNtc2ciLCJldmVudHNpbmZvbXNnIiwicmVxdWlyZWRmaWVsZCIsImRlZmF1bHR2YWx1ZWZpZWxkIiwiaGVhZGVyZm9ybSIsIm5hbWVmaWVsZCIsInNpemVmaWVsZCIsImNvbnRlbnRmaWVsZCIsInRleHRhbGlnbmZpZWxkIiwidGV4dGFsaWdubGVmdCIsInRleHRhbGlnbmNlbnRlciIsInRleHRhbGlnbnJpZ2h0Iiwic3ViaGVhZGVyZmllbGQiLCJidXR0b25mb3JtIiwidHlwZWZpZWxkIiwidHlwZW5vbmVmaWVsZCIsInR5cGVzdWJtaXRmaWVsZCIsIm9wdGlvbnNmaWVsZCIsImJhc2ljZmllbGQiLCJjaXJjdWxhcmZpZWxkIiwiY29tcGFjdGZpZWxkIiwiZGlzYWJsZWRmaWVsZCIsImZsdWlkZmllbGQiLCJpbnZlcnRlZGZpZWxkIiwibG9hZGluZ2ZpZWxkIiwicHJpbWFyeWZpZWxkIiwic2Vjb25kYXJ5ZmllbGQiLCJ0b2dnbGVmaWVsZCIsImZsb2F0ZWRmaWVsZCIsImZsb2F0ZWRkZWZhdWx0ZmllbGQiLCJmbG9hdGVkbGVmdGZpZWxkIiwiZmxvYXRlZHJpZ2h0ZmllbGQiLCJsYWJlbGZvcm0iLCJhdHRhY2hlZGZpZWxkIiwic3RhdGljY29udGVudGZvcm0iLCJmb250c2l6ZWZpZWxkIiwiYWxsb3dodG1sZmllbGQiLCJtZXNzYWdlZm9ybSIsImhlYWRlcmZpZWxkIiwiZXJyb3JmaWVsZCIsImZsb2F0aW5nZmllbGQiLCJpbmZvZmllbGQiLCJuZWdhdGl2ZWZpZWxkIiwicG9zaXRpdmVmaWVsZCIsInN1Y2Nlc3NmaWVsZCIsIndhcm5pbmdmaWVsZCIsImlucHV0Zm9ybSIsImxhYmVsZmllbGQiLCJ0eXBldGV4dCIsInR5cGVudW1iZXIiLCJ0eXBlZGF0ZSIsInR5cGV0aW1lIiwidHlwZWRhdGV0aW1lIiwidHlwZXBhc3N3b2QiLCJsYWJlbHBvc2l0aW9uZmllbGQiLCJ0cmFuc3BhcmVudGZpZWxkIiwicmVhZG9ubHlmaWVsZCIsInBsYWNlaG9sZGVyZmllbGQiLCJkYXRlZm9ybWF0ZmllbGQiLCJ0ZXh0YXJlYWZvcm0iLCJyb3dzZmllbGQiLCJhdXRvaGVpZ2h0ZmllbGQiLCJjaGVja2JveGZvcm0iLCJmaXR0ZWRmaWVsZCIsImluZGV0ZXJtaW5hdGVmaWVsZCIsInNsaWRlcmZpZWxkIiwiZHJvcGRvd25mb3JtIiwiZGF0YWZpZWxkIiwiZGF0YWtleWNvbHVtbiIsImRhdGF2YWx1ZWNvbHVtbiIsImRhdGF0ZXh0Y29sdW1uIiwibXVsdGlwbGVmaWVsZCIsInNlYXJjaGZpZWxkIiwic2VsZWN0aW9uZmllbGQiLCJjbGVhcmFibGVmaWVsZCIsImFsbG93QWRkSXRlbXNmaWVsZCIsImRpY3Rpb25hcnlmb3JtIiwiZGF0YW1vZGVsZmllbGQiLCJjb2x1bW5zZmllbGQiLCJwYWdpbmdmaWVsZCIsInBhZ2VzaXplZmllbGQiLCJwYXJlbnRpZEZpZWxkIiwicmFkaW9ncm91cGZvcm0iLCJncm91cGRpcmVjdGZpZWxkIiwiZGlyZWN0aW9uZ29yaXpvbnRhbGZpZWxkIiwiZGlyZWN0aW9udmVydGljYWxmaWVsZCIsInJlcGx5ZmllbGQiLCJmb3JtZ3JvdXBmb3JtIiwid2lkdGhzZmllbGQiLCJ3aWR0aHNkZWZhdWx0ZmllbGQiLCJ3aWR0aHNlcXVhbGZpZWxkIiwid2lkdGhzY3VzdG9tZmllbGQiLCJvcmllbnRhdGlvbmNvbHVtbnNmaWVsZCIsIm9yaWVudGF0aW9ucm93c2ZpZWxkIiwiY29udGFpbmVyZm9ybSIsImZsb2F0ZmllbGQiLCJmbG9hdG5vbmVmaWVsZCIsImZsb2F0bGVmdGZpZWxkIiwiZmxvYXRyaWdodGZpZWxkIiwiaW1hZ2Vmb3JtIiwic3JjZmllbGQiLCJocmVmZmllbGQiLCJhdmF0YXJmaWVsZCIsImJvcmRlcmVkZmllbGQiLCJjZW50ZXJlZGZpZWxkIiwiaW5saW5lZmllbGQiLCJzcGFjZWRmaWVsZCIsInZlcnRpY2FsYWxpZ25maWVsZCIsInZlcnRpY2FsYWxpZ250b3BmaWVsZCIsInZlcnRpY2FsYWxpZ25taWRkbGVmaWVsZCIsInZlcnRpY2FsYWxpZ25ib3R0b21maWVsZCIsInN0YXRpc3RpY2Zvcm0iLCJob3Jpem9udGFsZmllbGQiLCJncmlkZm9ybSIsIm11bHRpc2VsZWN0ZmllbGQiLCJmaWx0ZXJyb3dmaWVsZCIsImRpc2FibGVzb3J0ZmllbGQiLCJlZGl0Zm9ybWZpZWxkIiwiZWRpdGZvcm1zaG93dHlwZWZpZWxkIiwiZWRpdGZvcm10eXBlZGVmYXVsdGZpZWxkIiwiZWRpdGZvcm10eXBlbW9kYWxmaWVsZCIsImtleWNvbHVtbiIsIm5hbWVjb2x1bW4iLCJ0eXBlY29sdW1uIiwid2lkdGhjb2x1bW4iLCJyZXNpemFibGVjb2x1bW4iLCJyb3drZXlmaWVsZCIsInBhZ2VydHlwZWZpZWxkIiwicGFnZXJ0eXBlbm9uZWZpZWxkIiwicGFnZXJ0eXBlc2VydmVyZmllbGQiLCJkZWZhdWx0c29ydGZpZWxkIiwicm93aGVpZ2h0ZmllbGQiLCJtaW5oZWlnaHRmaWVsZCIsIm9mZnNldGZpZWxkIiwiZWRpdGZsb3dmaWVsZCIsImNvbGxlY3Rpb25lZGl0b3Jmb3JtIiwiaWRmaWVsZCIsImRyYWdnYWJsZWZpZWxkIiwiaGllcmFyY2hpY2FsZmllbGQiLCJjb2xsYXBzZWFsbGZpZWxkIiwicGFyZW50aWRmaWVsZCIsImNvbnRyb2xjb2x1bW4iLCJjdXN0b21mb3JtIiwicHJvcHNmaWVsZCIsImNoaWxkcmVuZmllbGQiLCJjdXN0b21ibG9ja2Zvcm0iLCJzb3VyY2V0eXBlZmllbGQiLCJzb3VyY2V0eXBlZm9ybWZpZWxkIiwic291cmNldHlwZWpzb25maWVsZCIsImZvcm1uYW1lZmllbGQiLCJzb3VyY2VmaWVsZCIsIm1lbnVmb3JtIiwiYWN0aXZlaXRlbWZpZWxkIiwiaXRlbXNmaWVsZCIsIml0ZW1zdGFyZ2V0Y29sdW1uIiwiaXRlbXN0aXRsZWNvbHVtbiIsInBvaW50aW5nZmllbGQiLCJ0YWJ1bGFyZmllbGQiLCJ2ZXJ0aWNhbGZpZWxkIiwibGlua2ZpZWxkIiwidmlzaWJsZUNvbmRpdGlvbmNvbHVtbiIsImRyb3Bkb3dudHJpZ2dlcmZvcm0iLCJpdGVtc3Zpc2libGVjb25kaXRpb25jb2x1bW4iLCJpbWFnZXVybGZpZWxkIiwiY2hhcnRmb3JtIiwidGl0bGVmaWVsZCIsInRpdGxlc2l6ZWZpZWxkIiwibGVnZW5kcG9zaXRpb25maWVsZCIsInJlc3BvbnNpdmVmaWVsZCIsImRhdGFzZXRjdXN0b21maWVsZCIsImRhdGFsYWJlbHNwbGFjZWhvbGRlciIsImRhdGFsYWJlbHNmaWVsZCIsImRhdGFzZXRsYWJlbGZpZWxkIiwiZGF0YXNldGJhY2tncm91bmRjb2xvcmZpZWxkIiwid29ya2Zsb3dmb3JtIiwic2V0c3RhdGVidXR0b25maWVsZCIsImJsb2Nrc2V0c3RhdGVmaWVsZCIsInVwbG9hZGZvcm0iLCJjdXN0b21Qb3N0VXJsIiwiYnJlYWRjcnVtYmZvcm0iLCJpdGVtc3RleHRjb2x1bW4iLCJpdGVtc3VybGNvbHVtbiIsIml0ZW1zYWN0aXZlY29sdW1uIiwiaXRlbXNpY29uY29sdW1uIiwic2VhcmNoZm9ybSIsInVybGZpZWxkIiwiY2F0ZWdvcnlmaWVsZCIsIl9hc3luY0dldERhdGEiLCJfYXN5bmNHZXRNb2RlbCIsImNoZWNrTG9hZGVkU3RhdGUiLCJQcmVwYXJlU3RhdGUiLCJhYm9ydCIsIm5lZWRGZXRjaE1vZGVsIiwiZ2V0SlNPTiIsIm1vZGVsdXJsIiwiZG9uZSIsIm1vZGVsQ2hhbmdlZCIsImZhaWwiLCJqcXhociIsInRleHRTdGF0dXMiLCJlcnIiLCJoYW5kbGVFcnJFdmVudCIsIm5lZWRGZXRjaERhdGEiLCJkYXRhdXJsIiwiY2hlY2tDb25kaXRpb25zIiwiaXNMb2FkZWQiLCJldmVudEZ1bmMiLCJjb250cm9sUmVmIiwiZm9ybU5hbWUiLCJjb21wb25lbnQiLCJpc09uY2hhbmdlIiwib25seUV4dGVybmFsRGF0YUNoYW5nZWQiLCJvbkNvbmRpdGlvbnMiLCJmaW5kTW9kZWxJdGVtYnlLZXkiLCJldmVudFBhcmFtZXRlcnMiLCJzb3VyY2VDb250cm9sIiwicmVmcyIsInNvdXJjZUNvbnRyb2xWYWx1ZSIsImZpcmVFdmVudCIsInNvdXJjZUNvbnRyb2xSZWYiLCJUaW1lb3V0IiwiU2V0IiwiZW5hYmxlQ2hlY2tDb25kaXRpb25zIiwiZXZlbnRFcnJGdW5jIiwidGltZW91dHNJZE5hbWVNYXAiLCJjYWxsYmFjayIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwidGltZW91dElkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBLCtDOzs7Ozs7QUNBQSwrQzs7Ozs7OztBQ0FhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9HQUFv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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwREFBMEQ7QUFDMUQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYywyQ0FBMkMsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdGRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEwQjtBQUNTO0FBQ0M7QUFDYztBQUN0QjtBQUMy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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0EsdUNBQXVDLDhDQUFNO0FBQzdDOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsOENBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsS0FBSztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRkFBb0YseUNBQXlDO0FBQzdIO0FBQ0E7QUFDQSxrRkFBa0YseUNBQXlDO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQsc0VBQXNFLHFCQUFxQjtBQUMzRjs7QUFFQSx5REFBeUQ7QUFDekQsc0VBQXNFLHFCQUFxQjtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUM7QUFDdkMsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUMsNERBQTRELHNCQUFzQjtBQUNsRjtBQUNBLFFBQVE7QUFDUjs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQsbURBQW1ELHdCQUF3QjtBQUMzRTs7QUFFQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hELFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYyxFQUFFO0FBQ2xFO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlLEVBQUU7QUFDeEQ7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQSxNQUFNOztBQUVOO0FBQ0EsMENBQTBDLDhCQUE4QjtBQUN4RSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0Esa0ZBQWtGLFlBQVk7QUFDOUYsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0UsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE1BQU07O0FBRU4seUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7Ozs7QUFJOUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNB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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0I7O0FBRWxCO0FBQ0EsbURBQW1ELEVBQUUsaUJBQWlCOztBQUV0RTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxFQUFFOzs7QUFHRixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRS9QOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRyxrREFBa0QsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV4SixrREFBa0QsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRS9PLDJDQUEyQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTdlO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyREFBMkQsbUJBQW1CLG1CQUFtQiw4QkFBOEI7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBLG9DQUFvQztBQUNwQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQixpQkFBaUIsRUFBRTtBQUNoRDtBQUNBLDhDQUE4QyxTQUFTLHNCQUFzQixZQUFZO0FBQ3pGLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEVBQTRFLHNGQUFzRixHQUFHO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRyxrREFBa0QsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV4SixrREFBa0QsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRS9PLDJDQUEyQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTdlO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBOztBQUVBLGtLQUFrSyxvQkFBb0I7QUFDdEw7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLE1BQU07QUFDTix1QkFBdUIsb0JBQW9CO0FBQzNDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLFFBQVEsc0VBQXNFO0FBQzlFO0FBQ0E7QUFDQSxVQUFVLGtFQUFrRTtBQUM1RSxtREFBbUQsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRyxrREFBa0QsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV4SixrREFBa0QsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRS9PLDJDQUEyQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTdlO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUEyRDtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxrQkFBa0I7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCwwRUFBMEUsR0FBRyx5R0FBeUc7QUFDdk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQSxRQUFRLFNBQVMscURBQXFELDJEQUEyRDtBQUNqSSxnREFBZ0QsK0NBQStDO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUUvUDs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGtCQUFrQjs7QUFFaEcsa0RBQWtELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFeEosa0RBQWtELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUUvTywyQ0FBMkMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU3ZTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUNBQXFDO0FBQ3JDO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRyxrREFBa0QsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV4SixrREFBa0QsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRS9PLDJDQUEyQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTdlO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBd0U7QUFDaEY7QUFDQTtBQUNBLFVBQVUsdUNBQXVDLDBFQUEwRSxFQUFFO0FBQzdIO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQyxvREFBb0QsRUFBRTtBQUM3RyxvREFBb0QsNEVBQTRFO0FBQ2hJO0FBQ0E7QUFDQSxjQUFjLFNBQVMscURBQXFELDZEQUE2RDtBQUN6SSxzREFBc0QsNkNBQTZDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxrQkFBa0I7O0FBRWhHLGtEQUFrRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXhKLGtEQUFrRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFL08sMkNBQTJDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFN2U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0VBQW9FLGFBQWE7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBLFFBQVEsRUFBRTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHVEQUF1RDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRS9QOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRyxrREFBa0QsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV4SixrREFBa0QsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRS9PLDJDQUEyQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTdlO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7O0FBRUEsa0tBQWtLLGlCQUFpQjtBQUNuTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sNkNBQTZDLHNCQUFzQjtBQUNuRSxNQUFNO0FBQ047O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0Qiw0RUFBNEU7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdEQUFnRCx1RkFBdUY7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUUvUDs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGtCQUFrQjs7QUFFaEcsa0RBQWtELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFeEosa0RBQWtELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUUvTywyQ0FBMkMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU3ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQix1Q0FBdUM7QUFDcEgsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1REFBdUQsbUtBQW1LO0FBQzFOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEIsb0NBQW9DO0FBQ2xGO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGtCQUFrQjs7QUFFaEcsa0RBQWtELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFeEosa0RBQWtELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUUvTywyQ0FBMkMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU3ZTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxzRkFBc0Y7QUFDM0k7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsa0JBQWtCOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxrQkFBa0I7O0FBRWhHLHVCQUF1Qjs7QUFFdkIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFL1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxrQkFBa0I7O0FBRWhHLGtEQUFrRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXhKLGtEQUFrRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFL08sMkNBQTJDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFN2U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG9IQUFvSDtBQUM3STtBQUNBLGdDQUFnQztBQUNoQyxNQUFNO0FBQ04sZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQTRDLHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlGQUFpRjtBQUM1SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNB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Ozs7Ozs7Ozs7Ozs7O0FDTnJCLElBQU1pbEIsb0JBQW9CLEVBQTFCOztJQUVxQkosTzs7Ozs7Ozs0QkFDTHRtQyxJLEVBQUsybUMsUSxFQUFTQyxLLEVBQzFCO0FBQ0ksZ0JBQUlGLGtCQUFrQi84QixjQUFsQixDQUFpQzNKLElBQWpDLENBQUosRUFDQTtBQUNJNm1DLDZCQUFhSCxrQkFBa0IxbUMsSUFBbEIsQ0FBYjtBQUNIOztBQUVELGdCQUFNOG1DLFlBQVloZ0IsV0FBWTZmLFFBQVosRUFBcUJDLEtBQXJCLENBQWxCO0FBQ0FGLDhCQUFrQjFtQyxJQUFsQixJQUEwQjhtQyxTQUExQjtBQUNIOzs7OEJBRWE5bUMsSSxFQUNkO0FBQ0ksZ0JBQUkwbUMsa0JBQWtCLzhCLGNBQWxCLENBQWlDM0osSUFBakMsQ0FBSixFQUNBO0FBQ0k2bUMsNkJBQWFILGtCQUFrQjFtQyxJQUFsQixDQUFiO0FBQ0EsdUJBQU8wbUMsa0JBQWtCMW1DLElBQWxCLENBQVA7QUFDSDtBQUNKOzs7Ozs7a0JBbkJnQnNtQyxPIiwiZmlsZSI6Im9wdGltYWpldC1idWlsZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJzZW1hbnRpYy11aS1yZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSwgcmVxdWlyZShcIm1vbWVudFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiLCBcInNlbWFudGljLXVpLXJlYWN0XCIsIFwicmVhY3QtZG9tXCIsIFwibW9tZW50XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm9wdGltYWpldC1idWlsZGVyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJzZW1hbnRpYy11aS1yZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSwgcmVxdWlyZShcIm1vbWVudFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wib3B0aW1hamV0LWJ1aWxkZXJcIl0gPSBmYWN0b3J5KHJvb3RbXCJyZWFjdFwiXSwgcm9vdFtcInNlbWFudGljLXVpLXJlYWN0XCJdLCByb290W1wicmVhY3QtZG9tXCJdLCByb290W1wibW9tZW50XCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzE1X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDA3Yjg1NWI1NTQ4NDZjYzllMmU0IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlYWN0XCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInNlbWFudGljLXVpLXJlYWN0XCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuZXhwb3J0cy5jYWxsYmFja05hbWUgPSBjYWxsYmFja05hbWU7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbmV4cG9ydHMuaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbmV4cG9ydHMudGhyb3dJZiA9IHRocm93SWY7XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNrTmFtZShzdHJpbmcsIHByZWZpeCkge1xuICAgIHByZWZpeCA9IHByZWZpeCB8fCBcIm9uXCI7XG4gICAgcmV0dXJuIHByZWZpeCArIGV4cG9ydHMuY2FwaXRhbGl6ZShzdHJpbmcpO1xufVxuXG4vKlxyXG4gKiBpc09iamVjdCwgZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc0FyZ3VtZW50cyBhcmUgdGFrZW4gZnJvbSB1bmRlcnNjb3JlL2xvZGFzaCBpblxyXG4gKiBvcmRlciB0byByZW1vdmUgdGhlIGRlcGVuZGVuY3lcclxuICovXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xuICAgIHJldHVybiB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhIW9iajtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBrZXlzLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwcm9wID0ga2V5c1tqXTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgcHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdChrZXlzLCB2YWxzKSB7XG4gICAgdmFyIG8gPSB7fSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9ba2V5c1tpXV0gPSB2YWxzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIgJiYgXCJjYWxsZWVcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSBcIm51bWJlclwiO1xufVxuXG5mdW5jdGlvbiB0aHJvd0lmKHZhbCwgbXNnKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgICB0aHJvdyBFcnJvcihtc2cgfHwgdmFsKTtcbiAgICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmpvaW5TdHJpY3QgPSBleHBvcnRzLmpvaW5Db25jYXQgPSBleHBvcnRzLmpvaW5MZWFkaW5nID0gZXhwb3J0cy5qb2luVHJhaWxpbmcgPSBleHBvcnRzLmZldGNoSW5pdGlhbFN0YXRlID0gZXhwb3J0cy5zdG9wTGlzdGVuaW5nVG9BbGwgPSBleHBvcnRzLnN0b3BMaXN0ZW5pbmdUbyA9IGV4cG9ydHMubGlzdGVuVG8gPSBleHBvcnRzLnZhbGlkYXRlTGlzdGVuaW5nID0gZXhwb3J0cy5saXN0ZW5Ub01hbnkgPSBleHBvcnRzLmhhc0xpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9qb2lucyA9IHJlcXVpcmUoXCIuL2pvaW5zXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKipcclxuICogRXh0cmFjdCBjaGlsZCBsaXN0ZW5hYmxlcyBmcm9tIGEgcGFyZW50IGZyb20gdGhlaXJcclxuICogY2hpbGRyZW4gcHJvcGVydHkgYW5kIHJldHVybiB0aGVtIGluIGEga2V5ZWQgT2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5hYmxlIFRoZSBwYXJlbnQgbGlzdGVuYWJsZVxyXG4gKi9cbnZhciBtYXBDaGlsZExpc3RlbmFibGVzID0gZnVuY3Rpb24gbWFwQ2hpbGRMaXN0ZW5hYmxlcyhsaXN0ZW5hYmxlKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBjaGlsZHJlbiA9IHt9LFxuICAgICAgICBjaGlsZE5hbWU7XG4gICAgZm9yICg7IGkgPCAobGlzdGVuYWJsZS5jaGlsZHJlbiB8fCBbXSkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2hpbGROYW1lID0gbGlzdGVuYWJsZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGxpc3RlbmFibGVbY2hpbGROYW1lXSkge1xuICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGROYW1lXSA9IGxpc3RlbmFibGVbY2hpbGROYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG4vKipcclxuICogTWFrZSBhIGZsYXQgZGljdGlvbmFyeSBvZiBhbGwgbGlzdGVuYWJsZXMgaW5jbHVkaW5nIHRoZWlyXHJcbiAqIHBvc3NpYmxlIGNoaWxkcmVuIChyZWN1cnNpdmVseSksIGNvbmNhdGVuYXRpbmcgbmFtZXMgaW4gY2FtZWxDYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGlzdGVuYWJsZXMgVGhlIHRvcC1sZXZlbCBsaXN0ZW5hYmxlc1xyXG4gKi9cbnZhciBmbGF0dGVuTGlzdGVuYWJsZXMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuYWJsZXMobGlzdGVuYWJsZXMpIHtcbiAgICB2YXIgZmxhdHRlbmVkID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGxpc3RlbmFibGVzKSB7XG4gICAgICAgIHZhciBsaXN0ZW5hYmxlID0gbGlzdGVuYWJsZXNba2V5XTtcbiAgICAgICAgdmFyIGNoaWxkTWFwID0gbWFwQ2hpbGRMaXN0ZW5hYmxlcyhsaXN0ZW5hYmxlKTtcblxuICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGNoaWxkcmVuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGZsYXR0ZW5MaXN0ZW5hYmxlcyhjaGlsZE1hcCk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBwcmltYXJ5IGxpc3RlbmFibGUgYW5kIGNoaWxyZW5cbiAgICAgICAgZmxhdHRlbmVkW2tleV0gPSBsaXN0ZW5hYmxlO1xuICAgICAgICBmb3IgKHZhciBjaGlsZEtleSBpbiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIGNoaWxkTGlzdGVuYWJsZSA9IGNoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFtrZXkgKyBfLmNhcGl0YWxpemUoY2hpbGRLZXkpXSA9IGNoaWxkTGlzdGVuYWJsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmbGF0dGVuZWQ7XG59O1xuXG4vKipcclxuICogQW4gaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbiB1c2VkIGJ5IGB2YWxpZGF0ZUxpc3RlbmluZ2BcclxuICpcclxuICogQHBhcmFtIHtBY3Rpb258U3RvcmV9IGxpc3RlbmFibGUgVGhlIGxpc3RlbmFibGUgd2Ugd2FudCB0byBzZWFyY2ggZm9yXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUaGUgcmVzdWx0IG9mIGEgcmVjdXJzaXZlIHNlYXJjaCBhbW9uZyBgdGhpcy5zdWJzY3JpcHRpb25zYFxyXG4gKi9cbnZhciBoYXNMaXN0ZW5lciA9IGV4cG9ydHMuaGFzTGlzdGVuZXIgPSBmdW5jdGlvbiBoYXNMaXN0ZW5lcihsaXN0ZW5hYmxlKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqLFxuICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgbGlzdGVuYWJsZXM7XG4gICAgZm9yICg7IGkgPCAodGhpcy5zdWJzY3JpcHRpb25zIHx8IFtdKS5sZW5ndGg7ICsraSkge1xuICAgICAgICBsaXN0ZW5hYmxlcyA9IFtdLmNvbmNhdCh0aGlzLnN1YnNjcmlwdGlvbnNbaV0ubGlzdGVuYWJsZSk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsaXN0ZW5hYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5hYmxlc1tqXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuYWJsZSB8fCBsaXN0ZW5lci5oYXNMaXN0ZW5lciAmJiBsaXN0ZW5lci5oYXNMaXN0ZW5lcihsaXN0ZW5hYmxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxyXG4gKiBBIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGxpc3RlbnMgdG8gYWxsIGxpc3RlbmFibGVzIGluIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5hYmxlcyBBbiBvYmplY3Qgb2YgbGlzdGVuYWJsZXMuIEtleXMgd2lsbCBiZSB1c2VkIGFzIGNhbGxiYWNrIG1ldGhvZCBuYW1lcy5cclxuICovXG52YXIgbGlzdGVuVG9NYW55ID0gZXhwb3J0cy5saXN0ZW5Ub01hbnkgPSBmdW5jdGlvbiBsaXN0ZW5Ub01hbnkobGlzdGVuYWJsZXMpIHtcbiAgICB2YXIgYWxsTGlzdGVuYWJsZXMgPSBmbGF0dGVuTGlzdGVuYWJsZXMobGlzdGVuYWJsZXMpO1xuICAgIGZvciAodmFyIGtleSBpbiBhbGxMaXN0ZW5hYmxlcykge1xuICAgICAgICB2YXIgY2JuYW1lID0gXy5jYWxsYmFja05hbWUoa2V5KSxcbiAgICAgICAgICAgIGxvY2FsbmFtZSA9IHRoaXNbY2JuYW1lXSA/IGNibmFtZSA6IHRoaXNba2V5XSA/IGtleSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxvY2FsbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhhbGxMaXN0ZW5hYmxlc1trZXldLCBsb2NhbG5hbWUsIHRoaXNbY2JuYW1lICsgXCJEZWZhdWx0XCJdIHx8IHRoaXNbbG9jYWxuYW1lICsgXCJEZWZhdWx0XCJdIHx8IGxvY2FsbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IGNvbnRleHQgY2FuIGxpc3RlbiB0byB0aGUgc3VwcGxpZWQgbGlzdGVuYWJsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0FjdGlvbnxTdG9yZX0gbGlzdGVuYWJsZSBBbiBBY3Rpb24gb3IgU3RvcmUgdGhhdCBzaG91bGQgYmVcclxuICogIGxpc3RlbmVkIHRvLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gQW4gZXJyb3IgbWVzc2FnZSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIHdhcyBubyBwcm9ibGVtLlxyXG4gKi9cbnZhciB2YWxpZGF0ZUxpc3RlbmluZyA9IGV4cG9ydHMudmFsaWRhdGVMaXN0ZW5pbmcgPSBmdW5jdGlvbiB2YWxpZGF0ZUxpc3RlbmluZyhsaXN0ZW5hYmxlKSB7XG4gICAgaWYgKGxpc3RlbmFibGUgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIFwiTGlzdGVuZXIgaXMgbm90IGFibGUgdG8gbGlzdGVuIHRvIGl0c2VsZlwiO1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihsaXN0ZW5hYmxlLmxpc3RlbikpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmFibGUgKyBcIiBpcyBtaXNzaW5nIGEgbGlzdGVuIG1ldGhvZFwiO1xuICAgIH1cbiAgICBpZiAobGlzdGVuYWJsZS5oYXNMaXN0ZW5lciAmJiBsaXN0ZW5hYmxlLmhhc0xpc3RlbmVyKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBcIkxpc3RlbmVyIGNhbm5vdCBsaXN0ZW4gdG8gdGhpcyBsaXN0ZW5hYmxlIGJlY2F1c2Ugb2YgY2lyY3VsYXIgbG9vcFwiO1xuICAgIH1cbn07XG5cbi8qKlxyXG4gKiBTZXRzIHVwIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBnaXZlbiBsaXN0ZW5hYmxlIGZvciB0aGUgY29udGV4dCBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtBY3Rpb258U3RvcmV9IGxpc3RlbmFibGUgQW4gQWN0aW9uIG9yIFN0b3JlIHRoYXQgc2hvdWxkIGJlXHJcbiAqICBsaXN0ZW5lZCB0by5cclxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byByZWdpc3RlciBhcyBldmVudCBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBkZWZhdWx0Q2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJlZ2lzdGVyIGFzIGRlZmF1bHQgaGFuZGxlclxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHN1YnNjcmlwdGlvbiBvYmogd2hlcmUgYHN0b3BgIGlzIGFuIHVuc3ViIGZ1bmN0aW9uIGFuZCBgbGlzdGVuYWJsZWAgaXMgdGhlIG9iamVjdCBiZWluZyBsaXN0ZW5lZCB0b1xyXG4gKi9cbnZhciBsaXN0ZW5UbyA9IGV4cG9ydHMubGlzdGVuVG8gPSBmdW5jdGlvbiBsaXN0ZW5UbyhsaXN0ZW5hYmxlLCBjYWxsYmFjaywgZGVmYXVsdENhbGxiYWNrKSB7XG4gICAgdmFyIGRlc3ViLFxuICAgICAgICB1bnN1YnNjcmliZXIsXG4gICAgICAgIHN1YnNjcmlwdGlvbm9iaixcbiAgICAgICAgc3VicyA9IHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucyB8fCBbXTtcbiAgICBfLnRocm93SWYodGhpcy52YWxpZGF0ZUxpc3RlbmluZyhsaXN0ZW5hYmxlKSk7XG4gICAgdGhpcy5mZXRjaEluaXRpYWxTdGF0ZShsaXN0ZW5hYmxlLCBkZWZhdWx0Q2FsbGJhY2spO1xuICAgIGRlc3ViID0gbGlzdGVuYWJsZS5saXN0ZW4odGhpc1tjYWxsYmFja10gfHwgY2FsbGJhY2ssIHRoaXMpO1xuICAgIHVuc3Vic2NyaWJlciA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlcigpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3Vicy5pbmRleE9mKHN1YnNjcmlwdGlvbm9iaik7XG4gICAgICAgIF8udGhyb3dJZihpbmRleCA9PT0gLTEsIFwiVHJpZWQgdG8gcmVtb3ZlIGxpc3RlbiBhbHJlYWR5IGdvbmUgZnJvbSBzdWJzY3JpcHRpb25zIGxpc3QhXCIpO1xuICAgICAgICBzdWJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGRlc3ViKCk7XG4gICAgfTtcbiAgICBzdWJzY3JpcHRpb25vYmogPSB7XG4gICAgICAgIHN0b3A6IHVuc3Vic2NyaWJlcixcbiAgICAgICAgbGlzdGVuYWJsZTogbGlzdGVuYWJsZVxuICAgIH07XG4gICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbm9iaik7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbm9iajtcbn07XG5cbi8qKlxyXG4gKiBTdG9wcyBsaXN0ZW5pbmcgdG8gYSBzaW5nbGUgbGlzdGVuYWJsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0FjdGlvbnxTdG9yZX0gbGlzdGVuYWJsZSBUaGUgYWN0aW9uIG9yIHN0b3JlIHdlIG5vIGxvbmdlciB3YW50IHRvIGxpc3RlbiB0b1xyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhIHN1YnNjcmlwdGlvbiB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIG90aGVyd2lzZSBmYWxzZS5cclxuICovXG52YXIgc3RvcExpc3RlbmluZ1RvID0gZXhwb3J0cy5zdG9wTGlzdGVuaW5nVG8gPSBmdW5jdGlvbiBzdG9wTGlzdGVuaW5nVG8obGlzdGVuYWJsZSkge1xuICAgIHZhciBzdWIsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBzdWJzID0gdGhpcy5zdWJzY3JpcHRpb25zIHx8IFtdO1xuICAgIGZvciAoOyBpIDwgc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdWIgPSBzdWJzW2ldO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmFibGUgPT09IGxpc3RlbmFibGUpIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBfLnRocm93SWYoc3Vicy5pbmRleE9mKHN1YikgIT09IC0xLCBcIkZhaWxlZCB0byByZW1vdmUgbGlzdGVuIGZyb20gc3Vic2NyaXB0aW9ucyBsaXN0IVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxyXG4gKiBTdG9wcyBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgZW1wdGllcyBzdWJzY3JpcHRpb25zIGFycmF5XHJcbiAqL1xudmFyIHN0b3BMaXN0ZW5pbmdUb0FsbCA9IGV4cG9ydHMuc3RvcExpc3RlbmluZ1RvQWxsID0gZnVuY3Rpb24gc3RvcExpc3RlbmluZ1RvQWxsKCkge1xuICAgIHZhciByZW1haW5pbmcsXG4gICAgICAgIHN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMgfHwgW107XG4gICAgd2hpbGUgKHJlbWFpbmluZyA9IHN1YnMubGVuZ3RoKSB7XG4gICAgICAgIHN1YnNbMF0uc3RvcCgpO1xuICAgICAgICBfLnRocm93SWYoc3Vicy5sZW5ndGggIT09IHJlbWFpbmluZyAtIDEsIFwiRmFpbGVkIHRvIHJlbW92ZSBsaXN0ZW4gZnJvbSBzdWJzY3JpcHRpb25zIGxpc3QhXCIpO1xuICAgIH1cbn07XG5cbi8qKlxyXG4gKiBVc2VkIGluIGBsaXN0ZW5Ub2AuIEZldGNoZXMgaW5pdGlhbCBkYXRhIGZyb20gYSBwdWJsaXNoZXIgaWYgaXQgaGFzIGEgYGdldEluaXRpYWxTdGF0ZWAgbWV0aG9kLlxyXG4gKiBAcGFyYW0ge0FjdGlvbnxTdG9yZX0gbGlzdGVuYWJsZSBUaGUgcHVibGlzaGVyIHdlIHdhbnQgdG8gZ2V0IGluaXRpYWwgc3RhdGUgZnJvbVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZGVmYXVsdENhbGxiYWNrIFRoZSBtZXRob2QgdG8gcmVjZWl2ZSB0aGUgZGF0YVxyXG4gKi9cbnZhciBmZXRjaEluaXRpYWxTdGF0ZSA9IGV4cG9ydHMuZmV0Y2hJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiBmZXRjaEluaXRpYWxTdGF0ZShsaXN0ZW5hYmxlLCBkZWZhdWx0Q2FsbGJhY2spIHtcbiAgICBkZWZhdWx0Q2FsbGJhY2sgPSBkZWZhdWx0Q2FsbGJhY2sgJiYgdGhpc1tkZWZhdWx0Q2FsbGJhY2tdIHx8IGRlZmF1bHRDYWxsYmFjaztcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmYXVsdENhbGxiYWNrKSAmJiBfLmlzRnVuY3Rpb24obGlzdGVuYWJsZS5nZXRJbml0aWFsU3RhdGUpKSB7XG4gICAgICAgIHZhciBkYXRhID0gbGlzdGVuYWJsZS5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgaWYgKGRhdGEgJiYgXy5pc0Z1bmN0aW9uKGRhdGEudGhlbikpIHtcbiAgICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENhbGxiYWNrLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2FsbGJhY2suY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxyXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbGwgbGlzdGVuYWJsZXMgaGF2ZSB0cmlnZ2VyZWQgYXQgbGVhc3Qgb25jZS5cclxuICogSXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGxhc3QgZW1pc3Npb24gZnJvbSBlYWNoIGxpc3RlbmFibGUuXHJcbiAqIEBwYXJhbSB7Li4uUHVibGlzaGVyc30gcHVibGlzaGVycyBQdWJsaXNoZXJzIHRoYXQgc2hvdWxkIGJlIHRyYWNrZWQuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBhbGwgcHVibGlzaGVycyBoYXZlIGVtaXR0ZWRcclxuICogQHJldHVybnMge09iamVjdH0gQSBzdWJzY3JpcHRpb24gb2JqIHdoZXJlIGBzdG9wYCBpcyBhbiB1bnN1YiBmdW5jdGlvbiBhbmQgYGxpc3RlbmFibGVgIGlzIGFuIGFycmF5IG9mIGxpc3RlbmFibGVzXHJcbiAqL1xudmFyIGpvaW5UcmFpbGluZyA9IGV4cG9ydHMuam9pblRyYWlsaW5nID0gKDAsIF9qb2lucy5pbnN0YW5jZUpvaW5DcmVhdG9yKShcImxhc3RcIik7XG5cbi8qKlxyXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbGwgbGlzdGVuYWJsZXMgaGF2ZSB0cmlnZ2VyZWQgYXQgbGVhc3Qgb25jZS5cclxuICogSXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZpcnN0IGVtaXNzaW9uIGZyb20gZWFjaCBsaXN0ZW5hYmxlLlxyXG4gKiBAcGFyYW0gey4uLlB1Ymxpc2hlcnN9IHB1Ymxpc2hlcnMgUHVibGlzaGVycyB0aGF0IHNob3VsZCBiZSB0cmFja2VkLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIHdoZW4gYWxsIHB1Ymxpc2hlcnMgaGF2ZSBlbWl0dGVkXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgc3Vic2NyaXB0aW9uIG9iaiB3aGVyZSBgc3RvcGAgaXMgYW4gdW5zdWIgZnVuY3Rpb24gYW5kIGBsaXN0ZW5hYmxlYCBpcyBhbiBhcnJheSBvZiBsaXN0ZW5hYmxlc1xyXG4gKi9cbnZhciBqb2luTGVhZGluZyA9IGV4cG9ydHMuam9pbkxlYWRpbmcgPSAoMCwgX2pvaW5zLmluc3RhbmNlSm9pbkNyZWF0b3IpKFwiZmlyc3RcIik7XG5cbi8qKlxyXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbGwgbGlzdGVuYWJsZXMgaGF2ZSB0cmlnZ2VyZWQgYXQgbGVhc3Qgb25jZS5cclxuICogSXQgd2lsbCBiZSBpbnZva2VkIHdpdGggYWxsIGVtaXNzaW9uIGZyb20gZWFjaCBsaXN0ZW5hYmxlLlxyXG4gKiBAcGFyYW0gey4uLlB1Ymxpc2hlcnN9IHB1Ymxpc2hlcnMgUHVibGlzaGVycyB0aGF0IHNob3VsZCBiZSB0cmFja2VkLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIHdoZW4gYWxsIHB1Ymxpc2hlcnMgaGF2ZSBlbWl0dGVkXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgc3Vic2NyaXB0aW9uIG9iaiB3aGVyZSBgc3RvcGAgaXMgYW4gdW5zdWIgZnVuY3Rpb24gYW5kIGBsaXN0ZW5hYmxlYCBpcyBhbiBhcnJheSBvZiBsaXN0ZW5hYmxlc1xyXG4gKi9cbnZhciBqb2luQ29uY2F0ID0gZXhwb3J0cy5qb2luQ29uY2F0ID0gKDAsIF9qb2lucy5pbnN0YW5jZUpvaW5DcmVhdG9yKShcImFsbFwiKTtcblxuLyoqXHJcbiAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbmNlIGFsbCBsaXN0ZW5hYmxlcyBoYXZlIHRyaWdnZXJlZC5cclxuICogSWYgYSBjYWxsYmFjayB0cmlnZ2VycyB0d2ljZSBiZWZvcmUgdGhhdCBoYXBwZW5zLCBhbiBlcnJvciBpcyB0aHJvd24uXHJcbiAqIEBwYXJhbSB7Li4uUHVibGlzaGVyc30gcHVibGlzaGVycyBQdWJsaXNoZXJzIHRoYXQgc2hvdWxkIGJlIHRyYWNrZWQuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBhbGwgcHVibGlzaGVycyBoYXZlIGVtaXR0ZWRcclxuICogQHJldHVybnMge09iamVjdH0gQSBzdWJzY3JpcHRpb24gb2JqIHdoZXJlIGBzdG9wYCBpcyBhbiB1bnN1YiBmdW5jdGlvbiBhbmQgYGxpc3RlbmFibGVgIGlzIGFuIGFycmF5IG9mIGxpc3RlbmFibGVzXHJcbiAqL1xudmFyIGpvaW5TdHJpY3QgPSBleHBvcnRzLmpvaW5TdHJpY3QgPSAoMCwgX2pvaW5zLmluc3RhbmNlSm9pbkNyZWF0b3IpKFwic3RyaWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9MaXN0ZW5lck1ldGhvZHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8ganNvbjUuanNcbi8vIE1vZGVybiBKU09OLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuLy9cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBkaXJlY3RseSBvZmYgb2YgRG91Z2xhcyBDcm9ja2ZvcmQncyBqc29uX3BhcnNlLmpzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9qc29uX3BhcnNlLmpzXG5cbnZhciBKU09ONSA9ICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDoge30pO1xuXG5KU09ONS5wYXJzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBwYXJzZSBhIEpTT041IHRleHQsIHByb2R1Y2luZyBhIEphdmFTY3JpcHRcbi8vIGRhdGEgc3RydWN0dXJlLiBJdCBpcyBhIHNpbXBsZSwgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyLiBJdCBkb2VzIG5vdCB1c2Vcbi8vIGV2YWwgb3IgcmVndWxhciBleHByZXNzaW9ucywgc28gaXQgY2FuIGJlIHVzZWQgYXMgYSBtb2RlbCBmb3IgaW1wbGVtZW50aW5nXG4vLyBhIEpTT041IHBhcnNlciBpbiBvdGhlciBsYW5ndWFnZXMuXG5cbi8vIFdlIGFyZSBkZWZpbmluZyB0aGUgZnVuY3Rpb24gaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24gdG8gYXZvaWQgY3JlYXRpbmdcbi8vIGdsb2JhbCB2YXJpYWJsZXMuXG5cbiAgICB2YXIgYXQsICAgICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGxpbmVOdW1iZXIsICAgLy8gVGhlIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgY29sdW1uTnVtYmVyLCAvLyBUaGUgY3VycmVudCBjb2x1bW4gbnVtYmVyXG4gICAgICAgIGNoLCAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICAgICBcIidcIjogIFwiJ1wiLFxuICAgICAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgICAgICcvJzogICcvJyxcbiAgICAgICAgICAgICdcXG4nOiAnJywgICAgICAgLy8gUmVwbGFjZSBlc2NhcGVkIG5ld2xpbmVzIGluIHN0cmluZ3Mgdy8gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgICAgIHQ6ICAgICdcXHQnXG4gICAgICAgIH0sXG4gICAgICAgIHdzID0gW1xuICAgICAgICAgICAgJyAnLFxuICAgICAgICAgICAgJ1xcdCcsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXG4nLFxuICAgICAgICAgICAgJ1xcdicsXG4gICAgICAgICAgICAnXFxmJyxcbiAgICAgICAgICAgICdcXHhBMCcsXG4gICAgICAgICAgICAnXFx1RkVGRidcbiAgICAgICAgXSxcbiAgICAgICAgdGV4dCxcblxuICAgICAgICByZW5kZXJDaGFyID0gZnVuY3Rpb24gKGNocikge1xuICAgICAgICAgICAgcmV0dXJuIGNociA9PT0gJycgPyAnRU9GJyA6IFwiJ1wiICsgY2hyICsgXCInXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuXG4vLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiBtZXNzYWdlIHN1ZmZpeCB0byBhZ3JlZSB3aXRoIHRoYXQgcHJvdmlkZWQgYnkgR2Vja28gLSBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZVxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IG0gKyBcIiBhdCBsaW5lIFwiICsgbGluZU51bWJlciArIFwiIGNvbHVtbiBcIiArIGNvbHVtbk51bWJlciArIFwiIG9mIHRoZSBKU09ONSBkYXRhLiBTdGlsbCB0byByZWFkOiBcIiArIEpTT04uc3RyaW5naWZ5KHRleHQuc3Vic3RyaW5nKGF0IC0gMSwgYXQgKyAxOSkpO1xuICAgICAgICAgICAgZXJyb3IuYXQgPSBhdDtcbiAgICAgICAgICAgIC8vIFRoZXNlIHR3byBwcm9wZXJ0eSBuYW1lcyBoYXZlIGJlZW4gY2hvc2VuIHRvIGFncmVlIHdpdGggdGhlIG9uZXMgaW4gR2Vja28sIHRoZSBvbmx5IHBvcHVsYXJcbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IHdoaWNoIHNlZW1zIHRvIHN1cHBseSB0aGlzIGluZm8gb24gSlNPTi5wYXJzZVxuICAgICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICBlcnJvci5jb2x1bW5OdW1iZXIgPSBjb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcblxuLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG5cbiAgICAgICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCBcIiArIHJlbmRlckNoYXIoYykgKyBcIiBpbnN0ZWFkIG9mIFwiICsgcmVuZGVyQ2hhcihjaCkpO1xuICAgICAgICAgICAgfVxuXG4vLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4vLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgICAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgICAgICBhdCsrO1xuICAgICAgICAgICAgY29sdW1uTnVtYmVyKys7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJyAmJiBwZWVrKCkgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVlayA9IGZ1bmN0aW9uICgpIHtcblxuLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3RlciB3aXRob3V0IGNvbnN1bWluZyBpdCBvclxuLy8gYXNzaWduaW5nIGl0IHRvIHRoZSBjaCB2YXJhaWJsZS5cblxuICAgICAgICAgICAgcmV0dXJuIHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBpZGVudGlmaWVyLiBOb3JtYWxseSwgcmVzZXJ2ZWQgd29yZHMgYXJlIGRpc2FsbG93ZWQgaGVyZSwgYnV0IHdlXG4vLyBvbmx5IHVzZSB0aGlzIGZvciB1bnF1b3RlZCBvYmplY3Qga2V5cywgd2hlcmUgcmVzZXJ2ZWQgd29yZHMgYXJlIGFsbG93ZWQsXG4vLyBzbyB3ZSBkb24ndCBjaGVjayBmb3IgdGhvc2UgaGVyZS4gUmVmZXJlbmNlczpcbi8vIC0gaHR0cDovL2VzNS5naXRodWIuY29tLyN4Ny42XG4vLyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfR3VpZGUvQ29yZV9MYW5ndWFnZV9GZWF0dXJlcyNWYXJpYWJsZXNcbi8vIC0gaHR0cDovL2RvY3N0b3JlLm1pay51YS9vcmVsbHkvd2VicHJvZy9qc2NyaXB0L2NoMDJfMDcuaHRtXG4vLyBUT0RPIElkZW50aWZpZXJzIGNhbiBoYXZlIFVuaWNvZGUgXCJsZXR0ZXJzXCIgaW4gdGhlbTsgYWRkIHN1cHBvcnQgZm9yIHRob3NlLlxuXG4gICAgICAgICAgICB2YXIga2V5ID0gY2g7XG5cbiAgICAgICAgICAgIC8vIElkZW50aWZpZXJzIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciwgXyBvciAkLlxuICAgICAgICAgICAgaWYgKChjaCAhPT0gJ18nICYmIGNoICE9PSAnJCcpICYmXG4gICAgICAgICAgICAgICAgICAgIChjaCA8ICdhJyB8fCBjaCA+ICd6JykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNoIDwgJ0EnIHx8IGNoID4gJ1onKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiQmFkIGlkZW50aWZpZXIgYXMgdW5xdW90ZWQga2V5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJzZXF1ZW50IGNoYXJhY3RlcnMgY2FuIGNvbnRhaW4gZGlnaXRzLlxuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIGNoID09PSAnXycgfHwgY2ggPT09ICckJyB8fFxuICAgICAgICAgICAgICAgICAgICAoY2ggPj0gJ2EnICYmIGNoIDw9ICd6JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNoID49ICdBJyAmJiBjaCA8PSAnWicpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gY2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cblxuICAgICAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgICAgICBzaWduID0gJycsXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgYmFzZSA9IDEwO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoY2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBJbmZpbml0eSAoY291bGQgdHdlYWsgdG8gYWxsb3cgb3RoZXIgd29yZHMpOlxuICAgICAgICAgICAgaWYgKGNoID09PSAnSScpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgPSB3b3JkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInIHx8IGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgd29yZCBmb3IgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoc2lnbiA9PT0gJy0nKSA/IC1udW1iZXIgOiBudW1iZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIE5hTlxuICAgICAgICAgICAgaWYgKGNoID09PSAnTicgKSB7XG4gICAgICAgICAgICAgIG51bWJlciA9IHdvcmQoKTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ2V4cGVjdGVkIHdvcmQgdG8gYmUgTmFOJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWdub3JlIHNpZ24gYXMgLU5hTiBhbHNvIGlzIE5hTlxuICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICcwJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignT2N0YWwgbGl0ZXJhbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChiYXNlKSB7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknICkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknIHx8IGNoID49ICdBJyAmJiBjaCA8PSAnRicgfHwgY2ggPj0gJ2EnICYmIGNoIDw9ICdmJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNpZ24gPT09ICctJykge1xuICAgICAgICAgICAgICAgIG51bWJlciA9IC1zdHJpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuXG4gICAgICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgZGVsaW0sICAgICAgLy8gZG91YmxlIHF1b3RlIG9yIHNpbmdsZSBxdW90ZVxuICAgICAgICAgICAgICAgIHVmZmZmO1xuXG4vLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgJyBvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cblxuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGRlbGltID0gY2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IGRlbGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5lc2NhcGVkIG5ld2xpbmVzIGFyZSBpbnZhbGlkOyBzZWU6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXNlZW1rL2pzb241L2lzc3Vlcy8yNFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGZlZWxzIHNwZWNpYWwtY2FzZWQ7IGFyZSB0aGVyZSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCB1bmVzY2FwZWQgY2hhcnM/XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmxpbmVDb21tZW50ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIGFuIGlubGluZSBjb21tZW50LCBhc3N1bWluZyB0aGlzIGlzIG9uZS4gVGhlIGN1cnJlbnQgY2hhcmFjdGVyIHNob3VsZFxuLy8gYmUgdGhlIHNlY29uZCAvIGNoYXJhY3RlciBpbiB0aGUgLy8gcGFpciB0aGF0IGJlZ2lucyB0aGlzIGlubGluZSBjb21tZW50LlxuLy8gVG8gZmluaXNoIHRoZSBpbmxpbmUgY29tbWVudCwgd2UgbG9vayBmb3IgYSBuZXdsaW5lIG9yIHRoZSBlbmQgb2YgdGhlIHRleHQuXG5cbiAgICAgICAgICAgIGlmIChjaCAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJOb3QgYW4gaW5saW5lIGNvbW1lbnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY2gpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCBhIGJsb2NrIGNvbW1lbnQsIGFzc3VtaW5nIHRoaXMgaXMgb25lLiBUaGUgY3VycmVudCBjaGFyYWN0ZXIgc2hvdWxkIGJlXG4vLyB0aGUgKiBjaGFyYWN0ZXIgaW4gdGhlIC8qIHBhaXIgdGhhdCBiZWdpbnMgdGhpcyBibG9jayBjb21tZW50LlxuLy8gVG8gZmluaXNoIHRoZSBibG9jayBjb21tZW50LCB3ZSBsb29rIGZvciBhbiBlbmRpbmcgKi8gcGFpciBvZiBjaGFyYWN0ZXJzLFxuLy8gYnV0IHdlIGFsc28gd2F0Y2ggZm9yIHRoZSBlbmQgb2YgdGV4dCBiZWZvcmUgdGhlIGNvbW1lbnQgaXMgdGVybWluYXRlZC5cblxuICAgICAgICAgICAgaWYgKGNoICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcIk5vdCBhIGJsb2NrIGNvbW1lbnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnKicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY2gpO1xuXG4gICAgICAgICAgICBlcnJvcihcIlVudGVybWluYXRlZCBibG9jayBjb21tZW50XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgYSBjb21tZW50LCB3aGV0aGVyIGlubGluZSBvciBibG9jay1sZXZlbCwgYXNzdW1pbmcgdGhpcyBpcyBvbmUuXG4vLyBDb21tZW50cyBhbHdheXMgYmVnaW4gd2l0aCBhIC8gY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICBpZiAoY2ggIT09ICcvJykge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiTm90IGEgY29tbWVudFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dCgnLycpO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGlubGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcIlVucmVjb2duaXplZCBjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLlxuLy8gTm90ZSB0aGF0IHdlJ3JlIGRldGVjdGluZyBjb21tZW50cyBieSBvbmx5IGEgc2luZ2xlIC8gY2hhcmFjdGVyLlxuLy8gVGhpcyB3b3JrcyBzaW5jZSByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBub3QgdmFsaWQgSlNPTig1KSwgYnV0IHRoaXMgd2lsbFxuLy8gYnJlYWsgaWYgdGhlcmUgYXJlIG90aGVyIHZhbGlkIHZhbHVlcyB0aGF0IGJlZ2luIHdpdGggYSAvIGNoYXJhY3RlciFcblxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod3MuaW5kZXhPZihjaCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgICAgICBuZXh0KCdJJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdpJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2knKTtcbiAgICAgICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICAgICAgbmV4dCgneScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICBuZXh0KCAnTicgKTtcbiAgICAgICAgICAgICAgbmV4dCggJ2EnICk7XG4gICAgICAgICAgICAgIG5leHQoICdOJyApO1xuICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgcmVuZGVyQ2hhcihjaCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICAgICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBQb3RlbnRpYWxseSBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTNSBhbGxvd3Mgb21pdHRpbmcgZWxlbWVudHMgaW4gYXJyYXlzLCBlLmcuIFssXSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gWyxudWxsXS4gV2UgZG9uJ3QgYWxsb3cgdGhpcyBpbiBKU09ONS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiTWlzc2luZyBhcnJheSBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbW1hIGFmdGVyIHRoaXMgdmFsdWUsIHRoaXMgbmVlZHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBQb3RlbnRpYWxseSBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEtleXMgY2FuIGJlIHVucXVvdGVkLiBJZiB0aGV5IGFyZSwgdGhleSBuZWVkIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkIEpTIGlkZW50aWZpZXJzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbW1hIGFmdGVyIHRoaXMgcGFpciwgdGhpcyBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgICAgIH07XG5cbiAgICB2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGV4dCA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgICBhdCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAxO1xuICAgICAgICBjb2x1bW5OdW1iZXIgPSAxO1xuICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4vLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4vLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4vLyByZXN1bHQuXG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG4gICAgfTtcbn0oKSk7XG5cbi8vIEpTT041IHN0cmluZ2lmeSB3aWxsIG5vdCBxdW90ZSBrZXlzIHdoZXJlIGFwcHJvcHJpYXRlXG5KU09ONS5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICBpZiAocmVwbGFjZXIgJiYgKHR5cGVvZihyZXBsYWNlcikgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNBcnJheShyZXBsYWNlcikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVwbGFjZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIHZhciBnZXRSZXBsYWNlZFZhbHVlT3JVbmRlZmluZWQgPSBmdW5jdGlvbihob2xkZXIsIGtleSwgaXNUb3BMZXZlbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIGl0cyB0b0pTT04gdmFsdWUgZmlyc3QsIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50b0pTT04gJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXItc3VwcGxpZWQgcmVwbGFjZXIgaWYgYSBmdW5jdGlvbiwgY2FsbCBpdC4gSWYgaXQncyBhbiBhcnJheSwgY2hlY2sgb2JqZWN0cycgc3RyaW5nIGtleXMgZm9yXG4gICAgICAgIC8vIHByZXNlbmNlIGluIHRoZSBhcnJheSAocmVtb3ZpbmcgdGhlIGtleS92YWx1ZSBwYWlyIGZyb20gdGhlIHJlc3VsdGluZyBKU09OIGlmIHRoZSBrZXkgaXMgbWlzc2luZykuXG4gICAgICAgIGlmICh0eXBlb2YocmVwbGFjZXIpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZihyZXBsYWNlcikge1xuICAgICAgICAgICAgaWYgKGlzVG9wTGV2ZWwgfHwgaXNBcnJheShob2xkZXIpIHx8IHJlcGxhY2VyLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzV29yZENoYXIoYykge1xuICAgICAgICByZXR1cm4gKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSB8fFxuICAgICAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuICAgICAgICAgICAgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB8fFxuICAgICAgICAgICAgYyA9PT0gJ18nIHx8IGMgPT09ICckJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1dvcmRTdGFydChjKSB7XG4gICAgICAgIHJldHVybiAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG4gICAgICAgICAgICAoYyA+PSAnQScgJiYgYyA8PSAnWicpIHx8XG4gICAgICAgICAgICBjID09PSAnXycgfHwgYyA9PT0gJyQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzV29yZChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1dvcmRTdGFydChrZXlbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAxLCBsZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc1dvcmRDaGFyKGtleVtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IGZvciB1c2UgaW4gdGVzdHNcbiAgICBKU09ONS5pc1dvcmQgPSBpc1dvcmQ7XG5cbiAgICAvLyBwb2x5ZmlsbHNcbiAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgdmFyIG9ialN0YWNrID0gW107XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JDaXJjdWxhcihvYmopIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9ialN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VJbmRlbnQoc3RyLCBudW0sIG5vTmV3TGluZSkge1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5kZW50YXRpb24gbm8gbW9yZSB0aGFuIDEwIGNoYXJzXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGVudCA9IG5vTmV3TGluZSA/IFwiXCIgOiBcIlxcblwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gc3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50U3RyO1xuICAgIGlmIChzcGFjZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbmRlbnRTdHIgPSBzcGFjZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09IFwibnVtYmVyXCIgJiYgc3BhY2UgPj0gMCkge1xuICAgICAgICAgICAgaW5kZW50U3RyID0gbWFrZUluZGVudChcIiBcIiwgc3BhY2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWdub3JlIHNwYWNlIHBhcmFtZXRlclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29waWVkIGZyb20gQ3Jva2ZvcmQncyBpbXBsZW1lbnRhdGlvbiBvZiBKU09OXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9lMzlkYjRiN2U2MjQ5ZjA0YTE5NWU3ZGQwODQwZTYxMGNjOWU5NDFlL2pzb24yLmpzI0wxOTVcbiAgICAvLyBCZWdpblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfTtcbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG5cbi8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbi8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4vLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbi8vIHNlcXVlbmNlcy5cbiAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgIGMgOlxuICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICB9XG4gICAgLy8gRW5kXG5cbiAgICBmdW5jdGlvbiBpbnRlcm5hbFN0cmluZ2lmeShob2xkZXIsIGtleSwgaXNUb3BMZXZlbCkge1xuICAgICAgICB2YXIgYnVmZmVyLCByZXM7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgdmFsdWUsIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgb2JqX3BhcnQgPSBnZXRSZXBsYWNlZFZhbHVlT3JVbmRlZmluZWQoaG9sZGVyLCBrZXksIGlzVG9wTGV2ZWwpO1xuXG4gICAgICAgIGlmIChvYmpfcGFydCAmJiAhaXNEYXRlKG9ial9wYXJ0KSkge1xuICAgICAgICAgICAgLy8gdW5ib3ggb2JqZWN0c1xuICAgICAgICAgICAgLy8gZG9uJ3QgdW5ib3ggZGF0ZXMsIHNpbmNlIHdpbGwgdHVybiBpdCBpbnRvIG51bWJlclxuICAgICAgICAgICAgb2JqX3BhcnQgPSBvYmpfcGFydC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHR5cGVvZiBvYmpfcGFydCkge1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqX3BhcnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmIChpc05hTihvYmpfcGFydCkgfHwgIWlzRmluaXRlKG9ial9wYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpfcGFydC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhvYmpfcGFydC50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGlmIChvYmpfcGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KG9ial9wYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0ZvckNpcmN1bGFyKG9ial9wYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJbXCI7XG4gICAgICAgICAgICAgICAgICAgIG9ialN0YWNrLnB1c2gob2JqX3BhcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqX3BhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGludGVybmFsU3RyaW5naWZ5KG9ial9wYXJ0LCBpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gbWFrZUluZGVudChpbmRlbnRTdHIsIG9ialN0YWNrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzID09PSBudWxsIHx8IHR5cGVvZiByZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG9ial9wYXJ0Lmxlbmd0aC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRlbnRTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmpTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ial9wYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IG1ha2VJbmRlbnQoaW5kZW50U3RyLCBvYmpTdGFjay5sZW5ndGgsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IFwiXVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yQ2lyY3VsYXIob2JqX3BhcnQpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBcIntcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG9ialN0YWNrLnB1c2gob2JqX3BhcnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9ial9wYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqX3BhcnQuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnRlcm5hbFN0cmluZ2lmeShvYmpfcGFydCwgcHJvcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG9wTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBtYWtlSW5kZW50KGluZGVudFN0ciwgb2JqU3RhY2subGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBpc1dvcmQocHJvcCkgPyBwcm9wIDogZXNjYXBlU3RyaW5nKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0ga2V5ICsgXCI6XCIgKyAoaW5kZW50U3RyID8gJyAnIDogJycpICsgdmFsdWUgKyBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub25FbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YnN0cmluZygwLCBidWZmZXIubGVuZ3RoLTEpICsgbWFrZUluZGVudChpbmRlbnRTdHIsIG9ialN0YWNrLmxlbmd0aCkgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9ICd7fSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCB1bmRlZmluZWQgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lhbCBjYXNlLi4ud2hlbiB1bmRlZmluZWQgaXMgdXNlZCBpbnNpZGUgb2ZcbiAgICAvLyBhIGNvbXBvdW5kIG9iamVjdC9hcnJheSwgcmV0dXJuIG51bGwuXG4gICAgLy8gYnV0IHdoZW4gdG9wLWxldmVsLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgdmFyIHRvcExldmVsSG9sZGVyID0ge1wiXCI6b2JqfTtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlcGxhY2VkVmFsdWVPclVuZGVmaW5lZCh0b3BMZXZlbEhvbGRlciwgJycsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZXJuYWxTdHJpbmdpZnkodG9wTGV2ZWxIb2xkZXIsICcnLCB0cnVlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qc29uNS9saWIvanNvbjUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlYWN0LWRvbVwiXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWZsdXggPSByZXF1aXJlKCdyZWZsdXgnKTtcclxuXHJcbnZhciBCdWlsZGVyQWN0aW9ucyA9IFJlZmx1eC5jcmVhdGVBY3Rpb25zKFtcclxuICAnYWRkJyxcclxuICAnc2hvd0VkaXRGb3JtJyxcclxuICAncmVtb3ZlJyxcclxuICAnc2F2ZURhdGEnLFxyXG4gICdzYXZlJyxcclxuICAnbW92ZSdcclxuXSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXJBY3Rpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hY3Rpb25zLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7QmFzZUVkaXRDb250cm9sLCBIZWFkZXJFZGl0Q29udHJvbCwgQnV0dG9uRWRpdENvbnRyb2wsIExhYmVsRWRpdENvbnRyb2wsIE1lc3NhZ2VFZGl0Q29udHJvbCwgU3RhdGljQ29udGVudEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgSW5wdXRFZGl0Q29udHJvbCwgVGV4dEFyZWFFZGl0Q29udHJvbCwgRHJvcGRvd25FZGl0Q29udHJvbCwgRGljdGlvbmFyeUVkaXRDb250cm9sLCBDaGVja2JveEVkaXRDb250cm9sLCBSYWRpb0dyb3VwRWRpdENvbnRyb2wsIERyb3Bkb3duVHJpZ2dlckVkaXRDb250cm9sLFxyXG4gICAgICAgICAgRm9ybUVkaXRDb250cm9sLCBGb3JtR3JvdXBFZGl0Q29udHJvbCwgQ3VzdG9tQmxvY2tFZGl0Q29udHJvbCwgQ3VzdG9tRWRpdENvbnRyb2wsIE1lbnVFZGl0Q29udHJvbCwgQ29udGFpbmVyRWRpdENvbnRyb2wsIENvbGxlY3Rpb25FZGl0b3JFZGl0Q29udHJvbCxcclxuICAgICAgICBJbWFnZUVkaXRDb250cm9sLCBTdGF0aXN0aWNFZGl0Q29udHJvbCwgVGFiRWRpdENvbnRyb2wsIEdyaWRFZGl0Q29udHJvbCwgQ2hhcnRFZGl0Q29udHJvbCwgV29ya2Zsb3dCYXJFZGl0Q29udHJvbCwgRHJvcHpvbmVFZGl0Q29udHJvbCwgQnJlYWRjcnVtYkVkaXRDb250cm9sLCBTZWFyY2hFZGl0Q29udHJvbH0gZnJvbSAnLi9lZGl0Zm9ybS1jb250cm9scydcclxuaW1wb3J0IFJhZGlvR3JvdXAgZnJvbSAnLi9jb250cm9sL3JhZGlvZ3JvdXAnXHJcbmltcG9ydCBNZW51R3JvdXAgZnJvbSAnLi9jb250cm9sL21lbnVncm91cCdcclxuaW1wb3J0IEpTT041IGZyb20gJ2pzb241J1xyXG5pbXBvcnQgR3JpZFZpZXcgZnJvbSAnLi9jb250cm9sL2dyaWR2aWV3JztcclxuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuL2NvbnRyb2wvY2hhcnR2aWV3JztcclxuaW1wb3J0IFdvcmtmbG93QmFyIGZyb20gJy4vY29udHJvbC93b3JrZmxvd2Jhcic7XHJcbmltcG9ydCBEaWN0aW9uYXJ5IGZyb20gJy4vY29udHJvbC9kaWN0aW9uYXJ5JztcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbnRyb2wvY29udGFpbmVyJztcclxuaW1wb3J0IFN0YXRpY0NvbnRlbnQgZnJvbSAnLi9jb250cm9sL3N0YXRpY2NvbnRlbnQnO1xyXG5pbXBvcnQgQ29sbGVjdGlvbkVkaXRvciBmcm9tICcuL2NvbnRyb2wvY29sbGVjdGlvbmVkaXRvcic7XHJcbmltcG9ydCBDb250cm9sQmFyIGZyb20gJy4vY29udHJvbGJhcic7XHJcbmltcG9ydCBEcm9wZG93blRyaWdnZXIgZnJvbSAnLi9jb250cm9sL2Ryb3Bkb3dudHJpZ2dlcidcclxuaW1wb3J0IFNlbWFudGljQ29udHJvbCBmcm9tICcuL2NvbnRyb2wvc2VtYW50aWNjb250cm9sJztcclxuaW1wb3J0IERyb3B6b25lQ29udHJvbCBmcm9tICcuL2NvbnRyb2wvZHJvcHpvbmUnO1xyXG5pbXBvcnQge0Z1bmN0aW9uYWxGaWx0ZXIsRmlsdGVyVGVybXN9IGZyb20gJy4vZnVuY3Rpb25hbGZpbHRlci5qcydcclxuaW1wb3J0IFNlYXJjaCBmcm9tICcuL2NvbnRyb2wvc2VhcmNoLmpzeCdcclxuXHJcbi8vLS0tLS0tRFdLaXRGb3JtQ29udHJvbHMtLS0tLS0tLS0tLVxyXG5sZXQgRFdLaXRGb3JtQ29udHJvbHMgPSB7XHJcbiAgICBJdGVtczogW1xyXG4gICAgICAgIHtrZXk6IFwic2VwQ29udGFpbmVyc1wiLCB0aXRsZTogJ0NvbnRhaW5lcnMnLCBpc3NlcGFyYXRlOiB0cnVlLCBkZWZhdWx0b3BlbjogdHJ1ZX0sXHJcbiAgICAgICAge2tleTogXCJjb250YWluZXJcIiwgdGl0bGU6ICdESVYnLCBjb250cm9sOiBDb250YWluZXIsIGVkaXRDb250cm9sOiBDb250YWluZXJFZGl0Q29udHJvbH0sXHJcbiAgICAgICAge2tleTogXCJmb3JtXCIsIHRpdGxlOiAnRm9ybScsIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCwgZWRpdENvbnRyb2w6IEZvcm1FZGl0Q29udHJvbH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiZm9ybWdyb3VwXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnRm9ybSBHcm91cCcsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IEZvcm1Hcm91cEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7d2lkdGhzOiBcImVxdWFsXCJ9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogXCJtZW51XCIsIHRpdGxlOiAnTWVudScsIGNvbnRyb2w6IE1lbnVHcm91cCwgZWRpdENvbnRyb2w6IE1lbnVFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge1xyXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7dGFyZ2V0OiAnbWVudTEnLCB0aXRsZTogJ01lbnUgMSd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHt0YXJnZXQ6ICdtZW51MicsIHRpdGxlOiAnTWVudSAyJ30sXHJcbiAgICAgICAgICAgICAgICAgICAge3RhcmdldDogJ21lbnUzJywgdGl0bGU6ICdNZW51IDMnfV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwid29ya2Zsb3diYXJcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdXb3JrZmxvdyBiYXInLFxyXG4gICAgICAgICAgICBjb250cm9sOiBXb3JrZmxvd0JhcixcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IFdvcmtmbG93QmFyRWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtcclxuICAgICAgICAgICAgICAgIGV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tbWFuZENsaWNrOiB7YWN0aXZlOiB0cnVlLCBhY3Rpb25zOiBbXCJ3b3JrZmxvd0V4ZWN1dGVDb21tYW5kXCJdfSxcclxuICAgICAgICAgICAgICAgICAgICBvblNldFN0YXRlQ2xpY2s6IHthY3RpdmU6IHRydWUsIGFjdGlvbnM6IFtcIndvcmtmbG93U2V0U3RhdGVcIl19XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImN1c3RvbWJsb2NrXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnQ3VzdG9tIGJsb2NrJyxcclxuICAgICAgICAgICAgY29udHJvbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBlZGl0Q29udHJvbDogQ3VzdG9tQmxvY2tFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge3NvdXJjZVR5cGU6ICdmb3JtJ31cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtrZXk6IFwic2VwQ29sbGVjdGlvblwiLCB0aXRsZTogJ0NvbGxlY3Rpb25zJywgaXNzZXBhcmF0ZTogdHJ1ZX0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiZ3JpZHZpZXdcIiwgdGl0bGU6ICdHcmlkVmlldycsIGNvbnRyb2w6IEdyaWRWaWV3LCBlZGl0Q29udHJvbDogR3JpZEVkaXRDb250cm9sLCBkZWZhdWx0VmFsdWVzOiB7XHJcbiAgICAgICAgICAgIGNvbHVtbnM6IFtcclxuICAgICAgICAgICAgICAgIHtrZXk6ICdpZCcsIG5hbWU6ICdJRCd9LFxyXG4gICAgICAgICAgICAgICAge2tleTogJ3RpdGxlJywgbmFtZTogJ1RpdGxlJ30sXHJcbiAgICAgICAgICAgICAgICB7a2V5OiAnY291bnQnLCBuYW1lOiAnQ291bnQnfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiY29sbGVjdGlvbmVkaXRvclwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0NvbGxlY3Rpb24gRWRpdG9yJyxcclxuICAgICAgICAgICAgY29udHJvbDogQ29sbGVjdGlvbkVkaXRvcixcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IENvbGxlY3Rpb25FZGl0b3JFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge1xyXG4gICAgICAgICAgICAgICAgaWRGaWVsZDogXCJJZFwiLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50SWRGaWVsZDogXCJQYXJlbnRJZFwiLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdJZCcsIG5hbWU6ICdJRCd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdUaXRsZScsIG5hbWU6ICdUaXRsZSd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdDb3VudCcsIG5hbWU6ICdDb3VudCd9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtrZXk6IFwic2VwQ29udHJvbHNcIiwgdGl0bGU6ICdDb250cm9scycsIGlzc2VwYXJhdGU6IHRydWV9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0hlYWRlcicsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IEhlYWRlckVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7Y29udGVudDogXCJIZWFkZXJcIiwgc2l6ZTogXCJtZWRpdW1cIn1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImlucHV0XCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnSW5wdXQnLFxyXG4gICAgICAgICAgICBjb250cm9sOiBTZW1hbnRpY0NvbnRyb2wsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBJbnB1dEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7bGFiZWw6IFwiSW5wdXRcIiwgZmx1aWQ6IHRydWUsIG9uQ2hhbmdlVGltZW91dDogMjAwfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwidGV4dGFyZWFcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdUZXh0QXJlYScsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IFRleHRBcmVhRWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtsYWJlbDogXCJUZXh0QXJlYVwiLCBmbHVpZDogdHJ1ZX1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImRpY3Rpb25hcnlcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdEaWN0aW9uYXJ5JyxcclxuICAgICAgICAgICAgY29udHJvbDogRGljdGlvbmFyeSxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IERpY3Rpb25hcnlFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge2xhYmVsOiBcIkRpY3Rpb25hcnlcIiwgZmx1aWQ6IHRydWUsIHNlbGVjdGlvbjogdHJ1ZX1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImRyb3Bkb3duXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnRHJvcGRvd24nLFxyXG4gICAgICAgICAgICBjb250cm9sOiBTZW1hbnRpY0NvbnRyb2wsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBEcm9wZG93bkVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJEcm9wZG93blwiLCBmbHVpZDogdHJ1ZSwgc2VsZWN0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgXCJkYXRhLWVsZW1lbnRzXCI6IFtcclxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAxLCB2YWx1ZTogMSwgdGV4dDogJ0l0ZW0gMSd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6IDIsIHZhbHVlOiAyLCB0ZXh0OiAnSXRlbSAyJ30sXHJcbiAgICAgICAgICAgICAgICAgICAge2tleTogMywgdmFsdWU6IDMsIHRleHQ6ICdJdGVtIDMnfV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiY2hlY2tib3hcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdDaGVja0JveCcsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IENoZWNrYm94RWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtsYWJlbDogXCJDaGVja2JveFwifVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwicmFkaW9ncm91cFwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ1JhZGlvIGdyb3VwJyxcclxuICAgICAgICAgICAgY29udHJvbDogUmFkaW9Hcm91cCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IFJhZGlvR3JvdXBFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiUmFkaW9cIixcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1lbGVtZW50c1wiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge2tleTogMSwgdmFsdWU6IDEsIHRleHQ6ICdJdGVtIDEnfSxcclxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAyLCB2YWx1ZTogMiwgdGV4dDogJ0l0ZW0gMid9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6IDMsIHZhbHVlOiAzLCB0ZXh0OiAnSXRlbSAzJ31dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0J1dHRvbicsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IFNlbWFudGljQ29udHJvbCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IEJ1dHRvbkVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7Y29udGVudDogXCJCdXR0b25cIn1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImxhYmVsXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnTGFiZWwnLFxyXG4gICAgICAgICAgICBjb250cm9sOiBTZW1hbnRpY0NvbnRyb2wsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBMYWJlbEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7Y29udGVudDogXCJMYWJlbFwifVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZVwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ01lc3NhZ2UnLFxyXG4gICAgICAgICAgICBjb250cm9sOiBTZW1hbnRpY0NvbnRyb2wsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBNZXNzYWdlRWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtoZWFkZXI6IFwiTWVzc2FnZVwiLCBjb250ZW50OiBcIkRlc2NyaXB0aW9uLi4uXCJ9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogXCJpbWFnZVwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0ltYWdlJyxcclxuICAgICAgICAgICAgY29udHJvbDogU2VtYW50aWNDb250cm9sLFxyXG4gICAgICAgICAgICBlZGl0Q29udHJvbDogSW1hZ2VFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge3NyYzogJy9pbWFnZXMvdW5rbm93bi5wbmcnfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwic3RhdGlzdGljXCIsIHRpdGxlOiAnU3RhdGlzdGljJywgY29udHJvbDogU2VtYW50aWNDb250cm9sLCBlZGl0Q29udHJvbDogU3RhdGlzdGljRWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1lbGVtZW50c1wiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsOiAnU2NvcmUnLCB2YWx1ZTogJzIyLDElJ30sXHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsOiAnVmlld3MnLCB2YWx1ZTogJzMwLDAwMCd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbDogJ1BvaW50cycsIHZhbHVlOiAnNTAwJ31dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcImN1c3RvbWNvbnRyb2xcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdDdXN0b20gY29udHJvbCcsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IEN1c3RvbUVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7cHJvcHM6IFwieyAgfVwifVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwic3RhdGljY29udGVudFwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ1N0YXRpYyBDb250ZW50JyxcclxuICAgICAgICAgICAgY29udHJvbDogU3RhdGljQ29udGVudCxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IFN0YXRpY0NvbnRlbnRFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge2NvbnRlbnQ6IFwiVGV4dC4uLlwifVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiZHJvcGRvd250cmlnZ2VyXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnRHJvcGRvd24gdHJpZ2dlcicsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IERyb3Bkb3duVHJpZ2dlcixcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IERyb3Bkb3duVHJpZ2dlckVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFwiVXNlclwiLFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7dGFyZ2V0OiAnIzEnLCB0aXRsZTogJ0l0ZW0gMSd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHt0YXJnZXQ6ICcjMicsIHRpdGxlOiAnSXRlbSAyJ30sXHJcbiAgICAgICAgICAgICAgICAgICAge3RhcmdldDogJyMzJywgdGl0bGU6ICdJdGVtIDMnfV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiZHJvcHpvbmVjb250cm9sXCIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnRHJvcHpvbmUnLFxyXG4gICAgICAgICAgICBjb250cm9sOiBEcm9wem9uZUNvbnRyb2wsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBEcm9wem9uZUVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93RmlsZXR5cGVJY29uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGF1dG9Qcm9jZXNzUXVldWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhZGRSZW1vdmVMaW5rczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG11bHRpbGU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiYnJlYWRjcnVtYlwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0JyZWFkY3J1bWJzJyxcclxuICAgICAgICAgICAgY29udHJvbDogU2VtYW50aWNDb250cm9sLFxyXG4gICAgICAgICAgICBlZGl0Q29udHJvbDogQnJlYWRjcnVtYkVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcInRleHRcIjogXCJIb21lXCIsIFwidXJsXCI6IFwiL1wifSxcclxuICAgICAgICAgICAgICAgICAgICB7XCJkaXZpZGVyXCI6IFwicmlnaHQgYW5nbGVcIiwgXCJ0ZXh0XCI6IFwiUGFnZTFcIiwgXCJ1cmxcIjogXCIvcGFnZTFcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAge1widGV4dFwiOiBcIlBhZ2UyXCIsIFwiYWN0aXZlXCI6IHRydWV9XSxcclxuICAgICAgICAgICAgICAgIGV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkl0ZW1DbGljazoge2FjdGl2ZTogdHJ1ZSwgYWN0aW9uczogW1wicmVkaXJlY3RcIl19XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogXCJzZWFyY2hcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdTZWFyY2gnLFxyXG4gICAgICAgICAgICBjb250cm9sOiBTZWFyY2gsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBTZWFyY2hFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtrZXk6IFwic2VwQ2hhcnRzXCIsIHRpdGxlOiAnQ2hhcnRzJywgaXNzZXBhcmF0ZTogdHJ1ZX0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiYmFyY2hhcnRcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdCYXInLFxyXG4gICAgICAgICAgICBjb250cm9sOiBDaGFydFZpZXcsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBDaGFydEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7Y2hhcnRUeXBlOiBcImJhclwiLCBkYXRhc2V0TGFiZWw6IFwiXCJ9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogXCJsaW5lY2hhcnRcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdMaW5lJyxcclxuICAgICAgICAgICAgY29udHJvbDogQ2hhcnRWaWV3LFxyXG4gICAgICAgICAgICBlZGl0Q29udHJvbDogQ2hhcnRFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge2NoYXJ0VHlwZTogXCJsaW5lXCIsIGRhdGFzZXRMYWJlbDogXCJcIn1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcInNjYXR0ZXJjaGFydFwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ1NjYXR0ZXInLFxyXG4gICAgICAgICAgICBjb250cm9sOiBDaGFydFZpZXcsXHJcbiAgICAgICAgICAgIGVkaXRDb250cm9sOiBDaGFydEVkaXRDb250cm9sLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiB7Y2hhcnRUeXBlOiBcInNjYXR0ZXJcIiwgZGF0YXNldExhYmVsOiBcIlwifVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXk6IFwiZG91Z2hudXRjaGFydFwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ0RvdWdobnV0JyxcclxuICAgICAgICAgICAgY29udHJvbDogQ2hhcnRWaWV3LFxyXG4gICAgICAgICAgICBlZGl0Q29udHJvbDogQ2hhcnRFZGl0Q29udHJvbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge2NoYXJ0VHlwZTogXCJkb3VnaG51dFwiLCBkYXRhc2V0TGFiZWw6IFwiXCJ9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleTogXCJwaWVjaGFydFwiLFxyXG4gICAgICAgICAgICB0aXRsZTogJ1BpZScsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IENoYXJ0VmlldyxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IENoYXJ0RWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtjaGFydFR5cGU6IFwicGllXCIsIGRhdGFzZXRMYWJlbDogXCJcIn1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiBcInJhZGFyY2hhcnRcIixcclxuICAgICAgICAgICAgdGl0bGU6ICdSYWRhcicsXHJcbiAgICAgICAgICAgIGNvbnRyb2w6IENoYXJ0VmlldyxcclxuICAgICAgICAgICAgZWRpdENvbnRyb2w6IENoYXJ0RWRpdENvbnRyb2wsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IHtjaGFydFR5cGU6IFwicmFkYXJcIiwgZGF0YXNldExhYmVsOiBcIlwifVxyXG4gICAgICAgIH0sXHJcbiAgICBdLFxyXG5cclxuICAgIGNyZWF0ZUNvbnRyb2xzOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbW9kZWwsIGRhdGEsIGVycm9ycyxcclxuICAgICAgICAgICAgZXZlbnRPbkVkaXQsIGV2ZW50T25EZWxldGUsIGV2ZW50T25Db3B5LCBoYW5kbGVFdmVudCxcclxuICAgICAgICAgICAgcGFyZW50SXRlbSxcclxuICAgICAgICAgICAgZ2V0Rm9ybUZ1bmMsIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCxcclxuICAgICAgICAgICAgYnVpbGRlcm1vZGUsXHJcbiAgICAgICAgICAgIGhpZGVDb250cm9scywgcmVhZE9ubHlDb250cm9scyxcclxuICAgICAgICAgICAgcmVhZE9ubHksIGRpc2FibGVSZWZzLFxyXG4gICAgICAgICAgICB1cGxvYWRVcmwsIGRvd25sb2FkVXJsLCBleHRlbmRlZERhdGEsY29udHJvbHNUb1JlcGxhY2UsbmVlZENoZWNrUmVwbGFjZSxcclxuICAgICAgICAgICAgcGFyZW50UGxhY2Vob2xkZXIsXHJcbiAgICAgICAgICAgIGZvcm1JdGVtLFxyXG4gICAgICAgICAgICBjb250cm9sQmFyUmlnaHRcclxuICAgICAgICB9KXtcclxuICAgICAgIFxyXG4gICAgICAgIGxldCByZXMgPSBbXTtcclxuICAgICAgICBpZiAobW9kZWwgPT09IG51bGwgfHwgbW9kZWwgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoaWRlQ29udHJvbHMpICYmIGhpZGVDb250cm9scy5pbmNsdWRlcyhtb2RlbFtpXS5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGl0ZW07XHJcbiAgICAgICAgICAgIGNvbnN0IGRidHlwZSA9IG1vZGVsW2ldW1wiZGF0YS1idWlsZGVydHlwZVwiXTtcclxuICAgICAgICAgICAgaWYgKGRidHlwZSA9PT0gXCJjdXN0b21jb250cm9sXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFtpXS50eXBlID09PSB1bmRlZmluZWQgfHwgbW9kZWxbaV0udHlwZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLWVtcHR5XCIga2V5PXttb2RlbFtpXS5rZXl9PkZpbGwgVHlwZSBwcm9wZXJ0eSBmb3IgcmVuZGVyaW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC48L2Rpdj47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sUHJvcHNJbml0ID0gbW9kZWxbaV0ucHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogSlNPTjUucGFyc2UobW9kZWxbaV0ucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cm9sUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2xQcm9wc0luaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbW9kZWxbaV0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtb2RlbFtpXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbW9kZWxbaV1bXCJzdHlsZS1jdXN0b21jc3NcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLmdldFN0eWxlKG1vZGVsW2ldLCBidWlsZGVybW9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1idWlsZGVydHlwZVwiOiBtb2RlbFtpXVtcImRhdGEtYnVpbGRlcnR5cGVcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDogZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRVcmwsIGRvd25sb2FkVXJsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRPbmx5IHx8IChBcnJheS5pc0FycmF5KHJlYWRPbmx5Q29udHJvbHMpICYmIHJlYWRPbmx5Q29udHJvbHMuaW5jbHVkZXMoY29udHJvbFByb3BzLmtleSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvcHMucmVhZE9ubHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBtb2RlbFtpXS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxbaV0uY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBKU09ONS5wYXJzZShtb2RlbFtpXS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFtpXS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFByb3BzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gUmVhY3QuY3JlYXRlRWxlbWVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsW2ldLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYnR5cGUgPT09IFwiY3VzdG9tYmxvY2tcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuX3NvdXJjZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2JidWlsZGVybW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFkZERyb3Bab25lcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1BhcmVudEl0ZW0gPSBtb2RlbFtpXTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdQYXJlbnRQbGFjZWhvbGRlciA9IHBhcmVudFBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0Zvcm1JdGVtID0gZm9ybUl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsW2ldLnNvdXJjZVR5cGUgPT09ICdmb3JtJyB8fCBtb2RlbFtpXS5zb3VyY2VUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxbaV0uY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBtb2RlbFtpXS5jaGlsZHJlbiAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbl9zb3VyY2UgPSBtb2RlbFtpXS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRGb3JtRnVuYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogXCJnZXRGb3JtRnVuY1wiIHBhcmFtZXRlciBpcyB1bmRlZmluZWQhLiBQbGVhc2UsIHNldCBcImdldEZvcm1GdW5jXCIgcGFyYW1ldGVyIGZvciBEV0tpdEJ1aWxkZXIgb3IgRFdLaXRGb3JtIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFtpXS5mb3JtbmFtZSAhPT0gdW5kZWZpbmVkICYmIG1vZGVsW2ldLmZvcm1uYW1lICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbl9zb3VyY2UgPSBnZXRGb3JtRnVuYyhtb2RlbFtpXS5mb3JtbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlbFtpXS5zb3VyY2VUeXBlID09PSAncGxhY2Vob2xkZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JidWlsZGVybW9kZSA9IGV2ZW50T25FZGl0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRHJvcFpvbmVzID0gZXZlbnRPbkVkaXQgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnRJdGVtID0gcGFyZW50SXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BhcmVudFBsYWNlaG9sZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudFBsYWNlaG9sZGVyID0gbW9kZWxbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld0Zvcm1JdGVtID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtSXRlbSA9IHBhcmVudEl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Rm9ybUl0ZW0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtSXRlbS5wbGFjZWhvbGRlcnMgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtSXRlbS5wbGFjZWhvbGRlcnNbbW9kZWxbaV0ua2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbl9zb3VyY2UgPSBuZXdGb3JtSXRlbS5wbGFjZWhvbGRlcnNbbW9kZWxbaV0ua2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxbaV0uc291cmNlICE9PSB1bmRlZmluZWQgJiYgbW9kZWxbaV0uc291cmNlICE9PSBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbl9zb3VyY2UgPSBKU09ONS5wYXJzZShtb2RlbFtpXS5zb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZW1wdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSA8ZGl2IGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLWVtcHR5XCIga2V5PXttb2RlbFtpXS5rZXl9PlNldCBhIGZvcm0gbmFtZSBvciBzb3VyY2UgaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVwcmllcy48L2Rpdj47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNyZWF0ZUNvbnRyb2xzKHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGNoaWxkcmVuX3NvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkZXJtb2RlOiBjYmJ1aWxkZXJtb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRPbkVkaXQ6IGV2ZW50T25FZGl0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRPbkRlbGV0ZTogZXZlbnRPbkRlbGV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T25Db3B5OiBldmVudE9uQ29weSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEl0ZW06IG5ld1BhcmVudEl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRGb3JtRnVuYzogZ2V0Rm9ybUZ1bmMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2w6IGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVDb250cm9sczogaGlkZUNvbnRyb2xzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHlDb250cm9sczogcmVhZE9ubHlDb250cm9scyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiByZWFkT25seSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZWZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkVXJsLCBkb3dubG9hZFVybCwgY29udHJvbHNUb1JlcGxhY2UsIG5lZWRDaGVja1JlcGxhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQbGFjZWhvbGRlcjogbmV3UGFyZW50UGxhY2Vob2xkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtSXRlbTogbmV3Rm9ybUl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBtb2RlbFtpXVtcInN0eWxlLWN1c3RvbWNzc1wiXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihidWlsZGVybW9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IChjbGFzc05hbWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IChjbGFzc05hbWUrXCIgXCIpKSArIFwiZHdraXQtZm9ybWJ1aWxkZXItaXRlbS1jb250YWluZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JtUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbW9kZWxbaV0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtb2RlbFtpXS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZShtb2RlbFtpXSwgYnVpbGRlcm1vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtYnVpbGRlcnR5cGVcIjogbW9kZWxbaV1bXCJkYXRhLWJ1aWxkZXJ0eXBlXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZERyb3Bab25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGR6X2Zvb3RlciA9IERXS2l0Rm9ybUNvbnRyb2xzLmNyZWF0ZUJ1aWxkZXJEcm9wem9uZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFtpXS5rZXkgKyBcIl9kcm9wem9uZV9mb290ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdGb3JtSXRlbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbmV3Rm9ybUl0ZW0ua2V5LC8vcGFyZW50SXRlbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcGFyZW50SXRlbS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsW2ldLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFtpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChkel9mb290ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZHogPSBEV0tpdEZvcm1Db250cm9scy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFtpXS5rZXkgKyBcIl9kcm9wem9uZV9oZWFkZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1JdGVtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBuZXdGb3JtSXRlbS5rZXksLy9wYXJlbnRJdGVtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBwYXJlbnRJdGVtLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsW2ldLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsW2ldLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoZHopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gdGhpcy5nZXRDb250cm9sQnlUeXBlKGRidHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSA8ZGl2IGtleT17bW9kZWxbaV0ua2V5fT57ZGJ0eXBlfSBpcyB1bnN1cHBvcnRlZDwvZGl2PjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29udGFpbmVyKGRidHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGb3JtSXRlbSA9IGZvcm1JdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdGb3JtSXRlbSA9PSB1bmRlZmluZWQgJiYgcGFyZW50SXRlbSAhPSB1bmRlZmluZWQgJiYgcGFyZW50SXRlbS5zb3VyY2VUeXBlID09IFwiZm9ybVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1JdGVtID0gcGFyZW50SXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzR29yaXpvbnRhbEdyb3VwID0gYnVpbGRlcm1vZGUgJiYgbW9kZWxbaV1bXCJkYXRhLWJ1aWxkZXJ0eXBlXCJdID09PSBcImZvcm1ncm91cFwiICYmIG1vZGVsW2ldLm9yaWVudGF0aW9uICE9PSBcImdyb3VwZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jcmVhdGVDb250cm9scyhwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsW2ldLmNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlcm1vZGU6IGJ1aWxkZXJtb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T25FZGl0OiBldmVudE9uRWRpdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE9uRGVsZXRlOiBldmVudE9uRGVsZXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T25Db3B5OiBldmVudE9uQ29weSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJdGVtOiBtb2RlbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Rm9ybUZ1bmM6IGdldEZvcm1GdW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDogZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVDb250cm9sczogaGlkZUNvbnRyb2xzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5Q29udHJvbHM6IHJlYWRPbmx5Q29udHJvbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk6IHJlYWRPbmx5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZWZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZFVybCwgZG93bmxvYWRVcmwsIGNvbnRyb2xzVG9SZXBsYWNlLCBuZWVkQ2hlY2tSZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUl0ZW06IG5ld0Zvcm1JdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xCYXJSaWdodDogaXNHb3Jpem9udGFsR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbGRlcm1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHREWiA9IGlzR29yaXpvbnRhbEdyb3VwID8gXCIuLi5cIiA6IFwiLi4uIFwiICsgbW9kZWxbaV0ua2V5ICsgXCIgZG93biAuLi5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcHpvbmVfZm9vdGVyID0gdGhpcy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUobW9kZWxbaV0ua2V5ICsgXCItZHJvcHpvbmVfZm9vdGVyXCIsIG1vZGVsW2ldLmtleSwgdW5kZWZpbmVkLCB0ZXh0RFopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZHJvcHpvbmVfZm9vdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dERaID0gaXNHb3Jpem9udGFsR3JvdXAgPyBcIi4uLlwiIDogXCIuLi4gXCIgKyBtb2RlbFtpXS5rZXkgKyBcIiB1cCAuLi5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wem9uZV9oZWFkZXIgPSB0aGlzLmNyZWF0ZUJ1aWxkZXJEcm9wem9uZShtb2RlbFtpXS5rZXkgKyBcIi1kcm9wem9uZV9oZWFkZXJcIiwgbW9kZWxbaV0ua2V5LCB1bmRlZmluZWQsIHRleHREWik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KGRyb3B6b25lX2hlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3JlYXRlQ29udHJvbChwYXJlbnRDb21wb25lbnQsIGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlcm1vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5Q29udHJvbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlZnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UGxhY2Vob2xkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHNUb1JlcGxhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZENoZWNrUmVwbGFjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE9uRWRpdCwgZXZlbnRPbkRlbGV0ZSwgZXZlbnRPbkNvcHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3JlYXRlQ29udHJvbChwYXJlbnRDb21wb25lbnQsIGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlcm1vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5Q29udHJvbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlZnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sc1RvUmVwbGFjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2hlY2tSZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T25FZGl0LCBldmVudE9uRGVsZXRlLCBldmVudE9uQ29weVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYnVpbGRlcm1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBpIDwgbW9kZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3B6b25lX2J3ID0gdGhpcy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUobW9kZWxbaV0ua2V5ICsgXCItZHJvcHpvbmVfYndcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SXRlbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcGFyZW50SXRlbS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsW2ldLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIuLi5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UGxhY2Vob2xkZXIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHBhcmVudFBsYWNlaG9sZGVyLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZHJvcHpvbmVfYncpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBidWlsZGVyY29udHJvbCA9IChcclxuICAgICAgICAgICAgICAgICAgICA8Q29udHJvbEJhciBrZXk9e21vZGVsW2ldLmtleSArIFwiX2NvbnRyb2xiYXJcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0PXttb2RlbFtpXVtcImRhdGEtYnVpbGRlcnR5cGVcIl19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw9e21vZGVsW2ldfSBwYXJlbnQ9e3BhcmVudENvbXBvbmVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17ZXZlbnRPbkRlbGV0ZX0gb25FZGl0PXtldmVudE9uRWRpdH0gb25Db3B5PXtldmVudE9uQ29weX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0dyb3VwPXttb2RlbFtpXVtcImRhdGEtYnVpbGRlcnR5cGVcIl0gPT09IFwiZm9ybWdyb3VwXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbE9uUmlnaHQ9e2NvbnRyb2xCYXJSaWdodH0gLz4pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihjb250cm9sQmFyUmlnaHQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGJ1aWxkZXJjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYnVpbGRlcmNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbnRyb2xCeVR5cGU6IGZ1bmN0aW9uIChidWlsZGVydHlwZSkge1xyXG4gICAgICAgIHZhciBjb250cm9sID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5JdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5JdGVtc1tpXS5rZXkgPT09IGJ1aWxkZXJ0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sID0gdGhpcy5JdGVtc1tpXS5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XHJcbiAgICB9LFxyXG4gICAgZ2V0RWRpdENvbnRyb2xCeVR5cGU6IGZ1bmN0aW9uIChidWlsZGVydHlwZSkge1xyXG4gICAgICAgIHZhciBjb250cm9sID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5JdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5JdGVtc1tpXS5rZXkgPT09IGJ1aWxkZXJ0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sID0gdGhpcy5JdGVtc1tpXS5lZGl0Q29udHJvbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250cm9sO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdHlsZShtb2RlbCwgYnVpbGRlcm1vZGUpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIG1hcmdpblRvcDogbW9kZWxbXCJzdHlsZS1tYXJnaW5Ub3BcIl0sXHJcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogbW9kZWxbXCJzdHlsZS1tYXJnaW5Cb3R0b21cIl0sXHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IG1vZGVsW1wic3R5bGUtbWFyZ2luTGVmdFwiXSxcclxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IG1vZGVsW1wic3R5bGUtbWFyZ2luUmlnaHRcIl0sXHJcbiAgICAgICAgICAgIHdpZHRoOiBtb2RlbFtcInN0eWxlLXdpZHRoXCJdLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG1vZGVsW1wic3R5bGUtaGVpZ2h0XCJdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKG1vZGVsW1wic3R5bGUtZmxvYXRcIl0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdHlsZS5mbG9hdCA9IG1vZGVsW1wic3R5bGUtZmxvYXRcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobW9kZWxbXCJzdHlsZS1oaWRkZW5cIl0pIHtcclxuICAgICAgICAgICAgaWYgKGJ1aWxkZXJtb2RlKVxyXG4gICAgICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuMjtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vZGVsW1wic3R5bGUtc291cmNlXCJdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBtb2RlbFtcInN0eWxlLXNvdXJjZVwiXS5zcGxpdCgnOycpO1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHVwID0gcHJvcGVydHkuc3BsaXQoJzonKTtcclxuICAgICAgICAgICAgICAgIGlmICh0dXAubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0dXBbMF0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlW3BdID0gdHVwWzFdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobW9kZWxbXCJzdHlsZS1mb250LXNpemVcIl0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdHlsZVtcImZvbnQtc2l6ZVwiXSA9IG1vZGVsW1wic3R5bGUtZm9udC1zaXplXCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWdleEZvclJlcGxhY2U6IC97XFxTK30vZ20sXHJcblxyXG4gICAgY3JlYXRlQ29udHJvbChwYXJlbnRDb21wb25lbnQsIGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLCBkYXRhLCBlcnJvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYnVpbGRlcm1vZGUsIGNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQsIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5Q29udHJvbHMsIHJlYWRPbmx5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlZnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRVcmwsIGRvd25sb2FkVXJsLCBleHRlbmRlZERhdGEsIGNvbnRyb2xzVG9SZXBsYWNlLCBuZWVkQ2hlY2tSZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnRPbkVkaXQsIGV2ZW50T25EZWxldGUsIGV2ZW50T25Db3B5XHJcbiAgICAgICAgICAgICAgICAgIH0pIHtcclxuXHJcbiAgICAgICAgbGV0IG9iajtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICB2YXIgcmVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICAgICAga2V5OiBtb2RlbC5rZXksXHJcbiAgICAgICAgICAgIG5hbWU6IG1vZGVsLmtleSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBtb2RlbFtcInN0eWxlLWN1c3RvbWNzc1wiXSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuZ2V0U3R5bGUobW9kZWwsIGJ1aWxkZXJtb2RlKSxcclxuICAgICAgICAgICAgXCJkYXRhLWJ1aWxkZXJ0eXBlXCI6IG1vZGVsW1wiZGF0YS1idWlsZGVydHlwZVwiXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGRhdGFCdWlsZGVyVHlwZSA9IHByb3BzW1wiZGF0YS1idWlsZGVydHlwZVwiXTtcclxuICAgICAgICBjb25zdCBuZWVkUmVwbGFjZSA9IG5lZWRDaGVja1JlcGxhY2UgfHwgY29udHJvbHNUb1JlcGxhY2UuaW5jbHVkZXMobW9kZWwua2V5KTtcclxuXHJcbiAgICAgICAgaWYoYnVpbGRlcm1vZGUgJiYgdGhpcy5pc0NvbnRhaW5lcihwcm9wc1tcImRhdGEtYnVpbGRlcnR5cGVcIl0pKXtcclxuICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gKHByb3BzLmNsYXNzTmFtZSA9PSB1bmRlZmluZWQgPyBcIlwiOiAocHJvcHMuY2xhc3NOYW1lICsgXCIgXCIpKVxyXG4gICAgICAgICAgICAgICAgKyBcImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tY29udGFpbmVyXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWRpc2FibGVSZWZzKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJlZiA9IG1vZGVsLmtleTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb2RlbC5yZWFkT25seSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnJlYWRPbmx5ID0gbW9kZWwucmVhZE9ubHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVhZE9ubHkgfHwgQXJyYXkuaXNBcnJheShyZWFkT25seUNvbnRyb2xzKSAmJiByZWFkT25seUNvbnRyb2xzLmluY2x1ZGVzKG1vZGVsLmtleSkpIHtcclxuICAgICAgICAgICAgcHJvcHMucmVhZE9ubHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWdleEZvclJlcGxhY2UgPSAgdGhpcy5yZWdleEZvclJlcGxhY2U7XHJcbiAgICAgICAgY29uc3QgcmVwbGFjZUNvbnRyb2xWYWx1ZSA9IGZ1bmN0aW9uIChvcmlnaW5hbFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghbmVlZFJlcGxhY2UgfHwgb3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbmFsVmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUZyb21EYXRhID0gKG0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVttLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5hbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgIGxldCBuZWVkUHVzaEtleSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3ViA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eShwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2W3BdICE9PSB1bmRlZmluZWQgJiYgdltwXSAhPT0gbnVsbCAmJiB0eXBlb2YgdltwXSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZbcF0gPSB2W3BdLnJlcGxhY2UocmVnZXhGb3JSZXBsYWNlLCAobSkgPT4gcmVwbGFjZUZyb21EYXRhKG0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5lZWRQdXNoS2V5ICYmIG5lZWRDaGVja1JlcGxhY2UgJiYgbmV3VltwXSAhPT0gdltwXSkgbmVlZFB1c2hLZXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHZbcF0pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWW3BdID0gcmVwbGFjZUNvbnRyb2xWYWx1ZSh2W3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZbcF0gPSB2W3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnB1c2gobmV3Vik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUHVzaEtleSkgY29udHJvbHNUb1JlcGxhY2UucHVzaChtb2RlbC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFZhbHVlICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gb3JpZ2luYWxWYWx1ZS5yZXBsYWNlKHJlZ2V4Rm9yUmVwbGFjZSwgKG0pID0+IHJlcGxhY2VGcm9tRGF0YShtKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVlZENoZWNrUmVwbGFjZSAmJiBvcmlnaW5hbFZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzVG9SZXBsYWNlLnB1c2gobW9kZWwua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sID09PSBTZW1hbnRpY0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFCdWlsZGVyVHlwZSA9PT0gXCJoZWFkZXJcIil7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5jb250ZW50ID0gcmVwbGFjZUNvbnRyb2xWYWx1ZShtb2RlbC5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIHByb3BzLnN1YmhlYWRlciA9IHJlcGxhY2VDb250cm9sVmFsdWUobW9kZWwuc3ViaGVhZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGRhdGFCdWlsZGVyVHlwZSA9PT0gXCJsYWJlbFwiKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5jb250ZW50ID0gcmVwbGFjZUNvbnRyb2xWYWx1ZShtb2RlbC5jb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhQnVpbGRlclR5cGUgPT09IFwibWVzc2FnZVwiKXtcclxuICAgICAgICAgICAgICAgIHByb3BzLmNvbnRlbnQgPSByZXBsYWNlQ29udHJvbFZhbHVlKG1vZGVsLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuaGVhZGVyID0gcmVwbGFjZUNvbnRyb2xWYWx1ZShtb2RlbC5oZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YUJ1aWxkZXJUeXBlID09PSBcImltYWdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnNyYyA9IHJlcGxhY2VDb250cm9sVmFsdWUobW9kZWwuc3JjKTtcclxuICAgICAgICAgICAgICAgIHByb3BzLmhyZWYgPSByZXBsYWNlQ29udHJvbFZhbHVlKG1vZGVsLmhyZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFCdWlsZGVyVHlwZSA9PT0gXCJicmVhZGNydW1iXCIpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLml0ZW1zID0gcmVwbGFjZUNvbnRyb2xWYWx1ZShtb2RlbC5pdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlcyA9IDxTZW1hbnRpY0NvbnRyb2wgey4uLnByb3BzfSBhZGRpdGlvbmFsUGFyYW1zPXt7XHJcbiAgICAgICAgICAgICAgICBtb2RlbCwgZGF0YSwgZXJyb3JzLCBjaGlsZHJlbiwgaGFuZGxlRXZlbnQsIHBhcmVudEl0ZW0sIHVwbG9hZFVybCwgZG93bmxvYWRVcmxcclxuICAgICAgICAgICAgfX0vPjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gRGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgICBwcm9wcy5sYWJlbCA9IG1vZGVsLmxhYmVsO1xyXG4gICAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUgPSBtb2RlbC5kZWZhdWx0dmFsdWU7XHJcbiAgICAgICAgICAgIHByb3BzLnBsYWNlaG9sZGVyID0gbW9kZWwucGxhY2Vob2xkZXI7XHJcbiAgICAgICAgICAgIHByb3BzLmxvYWRpbmcgPSBtb2RlbC5sb2FkaW5nO1xyXG4gICAgICAgICAgICBwcm9wcy5lcnJvciA9IG1vZGVsLmVycm9yO1xyXG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlZCA9IG1vZGVsLmRpc2FibGVkO1xyXG4gICAgICAgICAgICBwcm9wcy5mbHVpZCA9IG1vZGVsLmZsdWlkO1xyXG4gICAgICAgICAgICBwcm9wcy5zZWxlY3Rpb24gPSBtb2RlbC5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgIHByb3BzLm11bHRpcGxlID0gbW9kZWwubXVsdGlwbGU7XHJcbiAgICAgICAgICAgIHByb3BzLnNlYXJjaCA9IG1vZGVsLnNlYXJjaDtcclxuICAgICAgICAgICAgcHJvcHMuZGF0YU1vZGVsID0gbW9kZWwuZGF0YU1vZGVsO1xyXG4gICAgICAgICAgICBwcm9wcy5jbGVhcmFibGUgPSBtb2RlbC5jbGVhcmFibGU7XHJcbiAgICAgICAgICAgIHByb3BzLmNvbHVtbnMgPSBtb2RlbC5jb2x1bW5zO1xyXG4gICAgICAgICAgICBwcm9wcy5wYWdpbmcgPSBtb2RlbC5wYWdpbmc7XHJcbiAgICAgICAgICAgIHByb3BzLnBhZ2VTaXplID0gbW9kZWwucGFnZVNpemU7XHJcbiAgICAgICAgICAgIHByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCA9IGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JzID09PSBcIm9iamVjdFwiICYmIGVycm9yc1ttb2RlbC5rZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmVycm9yID0gZXJyb3JzW21vZGVsLmtleV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVFdmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UgPSBmdW5jdGlvbiAoZSwge25hbWUsIHZhbHVlfSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KHtzeW50aGV0aWNFdmVudDogZSwga2V5OiBwcm9wcy5rZXksIGV2ZW50TmFtZTogXCJvbkNoYW5nZVwiLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMucGFyZW50SXNGb3JtID0gdGhpcy5pc0Zvcm0ocGFyZW50SXRlbSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudmFsdWUgPSBkYXRhW3Byb3BzLmtleV07XHJcblxyXG4gICAgICAgICAgICByZXMgPSAoPERpY3Rpb25hcnkgey4uLnByb3BzfSAvPik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnRyb2wgPT09IERyb3Bkb3duVHJpZ2dlcikge1xyXG4gICAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUgPSBtb2RlbC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIHByb3BzLml0ZW1zID0gbW9kZWwuaXRlbXM7XHJcbiAgICAgICAgICAgIHByb3BzLmltYWdlVXJsID0gbW9kZWwuaW1hZ2VVcmw7XHJcbiAgICAgICAgICAgIHByb3BzLmhhbmRsZUV2ZW50ID0gaGFuZGxlRXZlbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudmFsdWUgPSBkYXRhW3Byb3BzLmtleV07XHJcblxyXG4gICAgICAgICAgICByZXMgPSAoPERyb3Bkb3duVHJpZ2dlciB7Li4ucHJvcHN9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gU2VhcmNoKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnVybCA9IG1vZGVsLnVybDtcclxuICAgICAgICAgICAgcHJvcHMuY2F0ZWdvcnkgPSBtb2RlbC5jYXRlZ29yeTtcclxuICAgICAgICAgICAgcHJvcHMuaGFuZGxlRXZlbnQgPSBoYW5kbGVFdmVudDtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IGRhdGFbcHJvcHMua2V5XTtcclxuXHJcbiAgICAgICAgICAgIHJlcyA9ICg8U2VhcmNoIHsuLi5wcm9wc30gLz4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb250cm9sID09PSBSYWRpb0dyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAobW9kZWxbXCJkYXRhLWVsZW1lbnRzXCJdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gSlNPTjUucGFyc2UobW9kZWxbXCJkYXRhLWVsZW1lbnRzXCJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZUV2ZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChlLCB7bmFtZSwgdmFsdWV9KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoe3N5bnRoZXRpY0V2ZW50OiBlLCBrZXk6IHByb3BzLmtleSwgZXZlbnROYW1lOiBcIm9uQ2hhbmdlXCIsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvcnMgPT09IFwib2JqZWN0XCIgJiYgZXJyb3JzW21vZGVsLmtleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuZXJyb3IgPSBlcnJvcnNbbW9kZWwua2V5XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlID0gZGF0YVtwcm9wcy5rZXldO1xyXG5cclxuICAgICAgICAgICAgcmVzID0gKDxSYWRpb0dyb3VwIHsuLi5wcm9wc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXttb2RlbC5sYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbj17bW9kZWwuZGlyZWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e21vZGVsLnBsYWNlaG9sZGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfT5cclxuICAgICAgICAgICAgPC9SYWRpb0dyb3VwPik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnRyb2wgPT09IENvbGxlY3Rpb25FZGl0b3IpIHtcclxuICAgICAgICAgICAgcHJvcHMuY29sdW1ucyA9IG1vZGVsLmNvbHVtbnM7XHJcbiAgICAgICAgICAgIHByb3BzLmRyYWdnYWJsZSA9IG1vZGVsLmRyYWdnYWJsZTtcclxuICAgICAgICAgICAgcHJvcHMuaGllcmFyY2hpY2FsID0gbW9kZWwuaGllcmFyY2hpY2FsO1xyXG4gICAgICAgICAgICBwcm9wcy5wYXJlbnRJZEZpZWxkID0gbW9kZWwucGFyZW50SWRGaWVsZDtcclxuICAgICAgICAgICAgcHJvcHMuaWRGaWVsZCA9IG1vZGVsLmlkRmllbGQ7XHJcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuRmllbGQgPSBtb2RlbC5jaGlsZHJlbkZpZWxkO1xyXG4gICAgICAgICAgICBwcm9wcy5jb2xsYXBzZUFsbCA9IG1vZGVsLmNvbGxhcHNlQWxsO1xyXG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlQWRkID0gbW9kZWwuZGlzYWJsZUFkZDtcclxuICAgICAgICAgICAgcHJvcHMucGxhY2Vob2xkZXJzID0gbW9kZWwucGxhY2Vob2xkZXJzO1xyXG4gICAgICAgICAgICBpZihwcm9wcy5wbGFjZWhvbGRlcnMgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIHByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCA9IGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDtcclxuICAgICAgICAgICAgICAgIHByb3BzLmNyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbihwYXJlbnRDb250cm9sLCBkYXRhYnVpbGRlcnR5cGUsIHBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cm9sID0gRFdLaXRGb3JtQ29udHJvbHMuZ2V0Q29udHJvbEJ5VHlwZShkYXRhYnVpbGRlcnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbnRyb2wgPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRyb2wgaXMgdW5zdXBwb3J0ZWQhXCIsIGRhdGFidWlsZGVydHlwZSwgcGFyZW50Q29udHJvbCwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gRFdLaXRGb3JtQ29udHJvbHMuY3JlYXRlQ29udHJvbChwYXJlbnRDb250cm9sLCBjb250cm9sLCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocGFyYW1ldGVycy5idWlsZGVybW9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWlsZGVyY29udHJvbCA9IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENvbnRyb2xCYXIga2V5PXtwYXJhbWV0ZXJzLm1vZGVsLmtleSArIFwiX2NvbnRyb2xiYXJcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw9e3BhcmFtZXRlcnMubW9kZWx9IHBhcmVudD17cGFyZW50Q29tcG9uZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17ZXZlbnRPbkRlbGV0ZX0gb25FZGl0PXtldmVudE9uRWRpdH0gb25Db3B5PXtldmVudE9uQ29weX0vPik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGJ1aWxkZXJjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5oYW5kbGVFdmVudCA9IGhhbmRsZUV2ZW50O1xyXG4gICAgICAgICAgICBwcm9wcy5kb3dubG9hZFVybCA9IGRvd25sb2FkVXJsO1xyXG4gICAgICAgICAgICBwcm9wcy51cGxvYWRVcmwgPSB1cGxvYWRVcmw7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVFdmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UgPSBmdW5jdGlvbiAoZSwge25hbWUsIHZhbHVlfSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KHtzeW50aGV0aWNFdmVudDogZSwga2V5OiBwcm9wcy5rZXksIGV2ZW50TmFtZTogXCJvbkNoYW5nZVwiLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYnVpbGRlcm1vZGUpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGUsIHtuYW1lLCB2YWx1ZX0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudmFsdWUgPSBkYXRhW3Byb3BzLmtleV07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGVycm9ycyAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMuZXJyb3IgPSBlcnJvcnNbcHJvcHMua2V5XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChidWlsZGVybW9kZSAmJiBwcm9wcy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb3BzLmNvbHVtbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuYnVpbGRlcm1vZGUgPSBidWlsZGVybW9kZTtcclxuICAgICAgICAgICAgICAgIHByb3BzLmNyZWF0ZUJ1aWxkZXJEcm9wem9uZSA9IGZ1bmN0aW9uKGNvbHVtbk5hbWUsIHZhbHVlKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRFdLaXRGb3JtQ29udHJvbHMuY3JlYXRlQnVpbGRlckRyb3B6b25lKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5rZXksIHByb3BzLmtleSwgdW5kZWZpbmVkLCBjb2x1bW5OYW1lLCBjb2x1bW5OYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlLnB1c2goe30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKG1vZGVsLmhpZXJhcmNoaWNhbCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5wYXJlbnRJZEZpZWxkICE9PSB1bmRlZmluZWQgJiYgbW9kZWwucGFyZW50SWRGaWVsZCAhPT0gXCJcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmlkRmllbGQgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5pZEZpZWxkICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcHJvcHMudmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRbbW9kZWwuaWRGaWVsZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W21vZGVsLmlkRmllbGRdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRbbW9kZWwucGFyZW50SWRGaWVsZF0gPSBwYXJlbnRbbW9kZWwuaWRGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZS5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzID0gKDxDb2xsZWN0aW9uRWRpdG9yIHsuLi5wcm9wc30gLz4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb250cm9sID09PSBHcmlkVmlldykge1xyXG4gICAgICAgICAgICBwcm9wcy5jb2x1bW5zID0gbW9kZWwuY29sdW1ucztcclxuICAgICAgICAgICAgcHJvcHMubXVsdGlzZWxlY3QgPSBtb2RlbC5tdWx0aXNlbGVjdDtcclxuICAgICAgICAgICAgcHJvcHMucm93S2V5ID0gbW9kZWwucm93S2V5O1xyXG4gICAgICAgICAgICBwcm9wcy5lZGl0Rm9ybSA9IG1vZGVsLmVkaXRGb3JtO1xyXG4gICAgICAgICAgICBwcm9wcy5lZGl0RmxvdyA9IG1vZGVsLmVkaXRGbG93O1xyXG4gICAgICAgICAgICBwcm9wcy5lZGl0VHlwZSA9IG1vZGVsLmVkaXRUeXBlO1xyXG4gICAgICAgICAgICBwcm9wcy5wYWdlclR5cGUgPSBtb2RlbC5wYWdlclR5cGU7XHJcbiAgICAgICAgICAgIHByb3BzLnBhZ2VTaXplID0gbW9kZWwucGFnZVNpemU7XHJcbiAgICAgICAgICAgIHByb3BzLnJvd0hlaWdodCA9IG1vZGVsLnJvd0hlaWdodDtcclxuICAgICAgICAgICAgcHJvcHMubWluSGVpZ2h0ID0gbW9kZWwubWluSGVpZ2h0O1xyXG4gICAgICAgICAgICBwcm9wcy5hdXRvSGVpZ2h0ID0gbW9kZWwuYXV0b0hlaWdodDtcclxuICAgICAgICAgICAgcHJvcHMub2ZmU2V0ID0gbW9kZWwub2ZmU2V0O1xyXG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlU29ydCA9IG1vZGVsLmRpc2FibGVTb3J0O1xyXG4gICAgICAgICAgICBwcm9wcy5yZXNpemVDb2x1bW5zID0gbW9kZWwucmVzaXplQ29sdW1ucztcclxuICAgICAgICAgICAgcHJvcHMuZWRpdEZvcm1TaG93VHlwZSA9IG1vZGVsLmVkaXRGb3JtU2hvd1R5cGU7XHJcbiAgICAgICAgICAgIHByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCA9IGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDtcclxuICAgICAgICAgICAgcHJvcHMuaGFuZGxlRXZlbnQgPSBoYW5kbGVFdmVudDtcclxuICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFNvcnQgPSBtb2RlbC5kZWZhdWx0U29ydDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JzID09PSBcIm9iamVjdFwiICYmIGVycm9yc1ttb2RlbC5rZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmVycm9yID0gZXJyb3JzW21vZGVsLmtleV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IGRhdGFbcHJvcHMua2V5XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChidWlsZGVybW9kZSAmJiBwcm9wcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDMwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtjLmtleV0gPSBjLmtleSArIFwiX1wiICsgaTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZS5wdXNoKG9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4dGVuZGVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIGV4dGVuZGVkRGF0YS5maWx0ZXJzICE9PSB1bmRlZmluZWQgJiYgZXh0ZW5kZWREYXRhLmZpbHRlcnNbcHJvcHMua2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5maWx0ZXIgPSBuZXcgRnVuY3Rpb25hbEZpbHRlcihleHRlbmRlZERhdGEuZmlsdGVyc1twcm9wcy5rZXldLCBwcm9wcy5jb2x1bW5zLm1hcChjID0+IGMua2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzID0gKDxHcmlkVmlldyB7Li4ucHJvcHN9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gTWVudUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHByb3BzW1wiZGF0YS1pdGVtc1wiXSA9IHJlcGxhY2VDb250cm9sVmFsdWUobW9kZWwuaXRlbXMpO1xyXG4gICAgICAgICAgICBwcm9wcy5wb2ludGluZyA9IG1vZGVsLnBvaW50aW5nO1xyXG4gICAgICAgICAgICBwcm9wcy5zZWNvbmRhcnkgPSBtb2RlbC5zZWNvbmRhcnk7XHJcbiAgICAgICAgICAgIHByb3BzLnRhYnVsYXIgPSBtb2RlbC50YWJ1bGFyO1xyXG4gICAgICAgICAgICBwcm9wcy5mbHVpZCA9IG1vZGVsLmZsdWlkO1xyXG4gICAgICAgICAgICBwcm9wcy52ZXJ0aWNhbCA9IG1vZGVsLnZlcnRpY2FsO1xyXG4gICAgICAgICAgICBwcm9wcy5hY3RpdmVpdGVtID0gbW9kZWwuYWN0aXZlaXRlbTtcclxuICAgICAgICAgICAgcHJvcHMubGluayA9IG1vZGVsLmxpbms7XHJcbiAgICAgICAgICAgIHByb3BzLmhhbmRsZUV2ZW50ID0gaGFuZGxlRXZlbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudmFsdWUgPSBkYXRhW3Byb3BzLmtleV07XHJcblxyXG4gICAgICAgICAgICByZXMgPSAoPE1lbnVHcm91cCB7Li4ucHJvcHN9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gQ2hhcnRWaWV3KSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNoYXJ0VHlwZSA9IG1vZGVsLmNoYXJ0VHlwZTtcclxuICAgICAgICAgICAgcHJvcHMucmVzcG9uc2l2ZSA9IG1vZGVsLnJlc3BvbnNpdmU7XHJcbiAgICAgICAgICAgIHByb3BzLmxlZ2VuZFBvc2l0aW9uID0gbW9kZWwubGVnZW5kUG9zaXRpb247XHJcbiAgICAgICAgICAgIHByb3BzLnRpdGxlID0gbW9kZWwudGl0bGU7XHJcbiAgICAgICAgICAgIHByb3BzLnRpdGxlU2l6ZSA9IG1vZGVsLnRpdGxlU2l6ZTtcclxuICAgICAgICAgICAgcHJvcHMuZGF0YXNldEN1c3RvbSA9IG1vZGVsLmRhdGFzZXRDdXN0b207XHJcbiAgICAgICAgICAgIHByb3BzLmRhdGFMYWJlbHMgPSBtb2RlbC5kYXRhTGFiZWxzO1xyXG4gICAgICAgICAgICBwcm9wcy5kYXRhc2V0TGFiZWwgPSBtb2RlbC5kYXRhc2V0TGFiZWw7XHJcbiAgICAgICAgICAgIHByb3BzLmRhdGFzZXRTdGVwcGVkTGluZSA9IG1vZGVsLmRhdGFzZXRTdGVwcGVkTGluZTtcclxuICAgICAgICAgICAgcHJvcHMuZGF0YXNldEJvcmRlckNvbG9yID0gbW9kZWwuZGF0YXNldEJvcmRlckNvbG9yO1xyXG4gICAgICAgICAgICBwcm9wcy5kYXRhc2V0RmlsbCA9IG1vZGVsLmRhdGFzZXRGaWxsO1xyXG4gICAgICAgICAgICBwcm9wcy5kYXRhc2V0Qm9yZGVyV2lkdGggPSBtb2RlbC5kYXRhc2V0Qm9yZGVyV2lkdGg7XHJcbiAgICAgICAgICAgIHByb3BzLmRhdGFzZXRCYWNrZ3JvdW5kQ29sb3IgPSBtb2RlbC5kYXRhc2V0QmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJ1aWxkZXJtb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZGF0YXNldEN1c3RvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlID0gWzEsIDIsIDMsIDQsIDMsIDIsIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXN0RGF0YSA9IHByb3BzLmNoYXJ0VHlwZSAhPT0gXCJzY2F0dGVyXCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbNiwgMjMsIDE1LCAzXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt7eDogNiwgeTogLTEyfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt4OiAxMSwgeTogMX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eDogMjQsIHk6IDV9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3g6IDQwLCB5OiAzMn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudmFsdWUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogW1wiUTFcIiwgXCJRMlwiLCBcIlEzXCIsIFwiUTRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGVzdERhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlID0gZGF0YVtwcm9wcy5rZXldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXMgPSAoPENoYXJ0VmlldyB7Li4ucHJvcHN9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gV29ya2Zsb3dCYXIpIHtcclxuICAgICAgICAgICAgcHJvcHMuYmxvY2tTZXRTdGF0ZSA9IG1vZGVsLmJsb2NrU2V0U3RhdGU7XHJcbiAgICAgICAgICAgIHByb3BzLnNldFN0YXRlQnV0dG9uID0gbW9kZWwuc2V0U3RhdGVCdXR0b247XHJcbiAgICAgICAgICAgIHByb3BzLmhhbmRsZUV2ZW50ID0gaGFuZGxlRXZlbnQ7XHJcbiAgICAgICAgICAgIHByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCA9IGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JzID09PSBcIm9iamVjdFwiICYmIGVycm9yc1ttb2RlbC5rZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmVycm9yID0gZXJyb3JzW21vZGVsLmtleV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChidWlsZGVybW9kZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuY29tbWFuZHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcImFwcHJvdmVcIiwgdGV4dDogXCJBcHByb3ZlXCIsIHR5cGU6IDF9LFxyXG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZTogXCJiYWNrXCIsIHRleHQ6IFwiQmFja1wiLCB0eXBlOiAyfVxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5zdGF0ZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcImRyYWZ0XCIsIHRleHQ6IFwiRHJhZnRcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcInN0YXRlMVwiLCB0ZXh0OiBcIlN0YXRlIDFcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcInN0YXRlMlwiLCB0ZXh0OiBcIlN0YXRlIDJcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcInN0YXRlM1wiLCB0ZXh0OiBcIlN0YXRlIDNcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBcImZpbmlzaFwiLCB0ZXh0OiBcIkZpbmlzaFwifVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzID0gKDxXb3JrZmxvd0JhciB7Li4ucHJvcHN9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJlcyA9ICg8Q29udGFpbmVyIHsuLi5wcm9wc30gY2hpbGRyZW49e2NoaWxkcmVufS8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbCA9PT0gU3RhdGljQ29udGVudCkge1xyXG4gICAgICAgICAgICBwcm9wcy5jb250ZW50ID0gcmVwbGFjZUNvbnRyb2xWYWx1ZShtb2RlbC5jb250ZW50KTtcclxuICAgICAgICAgICAgcHJvcHMuaXNIdG1sID0gbW9kZWwuaXNIdG1sO1xyXG4gICAgICAgICAgICByZXMgPSAoPFN0YXRpY0NvbnRlbnQgey4uLnByb3BzfSAvPik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnRyb2wgPT09IERyb3B6b25lQ29udHJvbCkge1xyXG4gICAgICAgICAgICBwcm9wcy5pY29uRmlsZXR5cGVzID0gbW9kZWwuaWNvbkZpbGV0eXBlcztcclxuICAgICAgICAgICAgcHJvcHMucG9zdFVybCA9IHVwbG9hZFVybDtcclxuICAgICAgICAgICAgcHJvcHMuc2hvd0ZpbGV0eXBlSWNvbiA9IG1vZGVsLnNob3dGaWxldHlwZUljb247XHJcbiAgICAgICAgICAgIHByb3BzLmF1dG9Qcm9jZXNzUXVldWUgPSBtb2RlbC5hdXRvUHJvY2Vzc1F1ZXVlO1xyXG4gICAgICAgICAgICBwcm9wcy5hZGRSZW1vdmVMaW5rcyA9IG1vZGVsLmFkZFJlbW92ZUxpbmtzO1xyXG4gICAgICAgICAgICByZXMgPSAoPERyb3B6b25lQ29udHJvbCB7Li4ucHJvcHN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbXM9e3ttb2RlbCwgZGF0YSwgZXJyb3JzLCBjaGlsZHJlbiwgaGFuZGxlRXZlbnQsIHBhcmVudEl0ZW19fS8+KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb250cm9sIGlzIHVuc3VwcG9ydGVkIVwiLCBjb250cm9sLCBtb2RlbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfSxcclxuICBpc0NvbnRhaW5lcjogZnVuY3Rpb24oa2V5KXtcclxuICAgIHJldHVybiAoa2V5ID09PSAnZm9ybScgfHwga2V5ID09PSAnZm9ybWdyb3VwJyB8fFxyXG4gICAgICBrZXkgPT09ICdncmlkJyB8fCBrZXkgPT09ICdncmlkcm93JyB8fCBrZXkgPT09ICdncmlkY29sdW1uJyB8fFxyXG4gICAgICBrZXkgPT09ICdjYXJkJyB8fCBrZXkgPT09ICdjYXJkY29udGVudCcgfHxcclxuICAgICAga2V5ID09PSAnY29udGFpbmVyJyB8fCBrZXkgPT09ICdkaXYnKTtcclxuICB9LFxyXG4gIGlzRm9ybTogZnVuY3Rpb24obW9kZWwpe1xyXG4gICAgcmV0dXJuIChtb2RlbCAhPT0gbnVsbCAmJiBtb2RlbCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgKG1vZGVsW1wiZGF0YS1idWlsZGVydHlwZVwiXSA9PT0gXCJmb3JtXCIgfHxcclxuICAgICAgICBtb2RlbFtcImRhdGEtYnVpbGRlcnR5cGVcIl0gPT09IFwiZm9ybWdyb3VwXCIpKTtcclxuICB9LFxyXG4gIGNyZWF0ZUJ1aWxkZXJEcm9wem9uZTogZnVuY3Rpb24oa2V5LCBlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnRhZnRlciwgdGV4dCwgcGxhY2Vob2xkZXJLZXkpe1xyXG4gICAgIC8vIGlmKHRleHQgPT09IHVuZGVmaW5lZClcclxuICAgIHRleHQgPSAgXCJEUk9QIFpPTkVcIjtcclxuICAgIHJldHVybiA8ZGl2IG5hbWU9e2tleX0ga2V5PXtrZXl9IGVsZW1lbnRhZnRlcj17ZWxlbWVudGFmdGVyfSBlbGVtZW50dG9pbnNlcnQ9e2VsZW1lbnRUb0luc2VydH0gcGxhY2Vob2xkZXJrZXk9e3BsYWNlaG9sZGVyS2V5fSBjbGFzc05hbWU9XCJkd2tpdC1mb3JtYnVpbGRlci16b25lXCI+e3RleHR9PC9kaXY+XHJcbiAgfSxcclxuXHJcbiAgICBmaWxsRGVmYXVsdFZhbHVlczogZnVuY3Rpb24gKG1vZGVsLCBkZWZhdWx0VmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGNvbnRyb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBkZWZhdWx0VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlbFtrXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgbW9kZWxba10gPSBkZWZhdWx0VmFsdWVzW2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERXS2l0Rm9ybUNvbnRyb2xzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9scy5qc3giLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWZsdXggPSByZXF1aXJlKCdyZWZsdXgnKTtcclxudmFyIEJ1aWxkZXJBY3Rpb25zID0gcmVxdWlyZSgnLi9hY3Rpb25zJyk7XHJcbnZhciBEV0tpdEZvcm1Db250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMnKTtcclxuXHJcbnZhciBfZGF0YTtcclxuXHJcbnZhciBEV0tpdFN0b3JlID0gUmVmbHV4LmNyZWF0ZVN0b3JlKHtcclxuICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubGlzdGVuVG8oQnVpbGRlckFjdGlvbnMuYWRkLCB0aGlzLmFkZCk7XHJcbiAgICB0aGlzLmxpc3RlblRvKEJ1aWxkZXJBY3Rpb25zLm1vdmUsIHRoaXMubW92ZSk7XHJcbiAgICB0aGlzLmxpc3RlblRvKEJ1aWxkZXJBY3Rpb25zLnJlbW92ZSwgdGhpcy5yZW1vdmUpO1xyXG4gICAgdGhpcy5saXN0ZW5UbyhCdWlsZGVyQWN0aW9ucy5zYXZlLCB0aGlzLnNhdmUpO1xyXG4gICAgdGhpcy5saXN0ZW5UbyhCdWlsZGVyQWN0aW9ucy5zYXZlRGF0YSwgdGhpcy5fdXBkYXRlT3JkZXIpO1xyXG5cclxuICAgIF9kYXRhID0gW107XHJcbiAgfSxcclxuXHJcbiAgbW92ZTogZnVuY3Rpb24oa2V5LCBlbCkgeyBcclxuICAgIGlmKGVsID09IHVuZGVmaW5lZClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHZhciBpdGVtID0gdGhpcy5maW5kSXRlbUJ5S2V5KGtleSwgX2RhdGEpO1xyXG4gICAgdmFyIHNvcnRlZEFycmF5ID0gdGhpcy5fZXhjbHVkZUl0ZW1CeUtleShrZXksIF9kYXRhKTtcclxuICAgIFxyXG4gICAgaWYoZWwuYXR0cmlidXRlc1snbmFtZSddICE9IHVuZGVmaW5lZCAmJiBlbC5hdHRyaWJ1dGVzWyduYW1lJ10udmFsdWUgPT0gJ2Ryb3B6b25lX2Zvb3RlcicpXHJcbiAgICB7XHJcbiAgICAgIHNvcnRlZEFycmF5LnB1c2goaXRlbSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKGVsLmF0dHJpYnV0ZXNbJ25hbWUnXSAhPSB1bmRlZmluZWQgJiYgZWwuYXR0cmlidXRlc1snbmFtZSddLnZhbHVlID09ICdkcm9wem9uZV9oZWFkZXInKVxyXG4gICAge1xyXG4gICAgICBzb3J0ZWRBcnJheS51bnNoaWZ0KGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihlbC5hdHRyaWJ1dGVzWydlbGVtZW50dG9pbnNlcnQnXSAhPSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhcmVudENvbnRyb2w7XHJcbiAgICAgICAgdmFyIGluc2VydEluZGV4ID0gMDtcclxuICAgICAgICB2YXIgcGFyZW50S2V5ID0gZWwuYXR0cmlidXRlc1snZWxlbWVudHRvaW5zZXJ0J107XHJcblxyXG4gICAgICAgIGlmKHBhcmVudEtleSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcGFyZW50Q29udHJvbCA9IHRoaXMuZmluZEl0ZW1CeUtleShwYXJlbnRLZXkudmFsdWUsIHNvcnRlZEFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHBhcmVudENvbnRyb2wgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcktleSA9IGVsLmF0dHJpYnV0ZXNbJ3BsYWNlaG9sZGVya2V5J107XHJcbiAgICAgICAgICBsZXQgY29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgIGlmKHBsYWNlaG9sZGVyS2V5ID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBpZihwYXJlbnRDb250cm9sLmNoaWxkcmVuID09IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgICAgcGFyZW50Q29udHJvbC5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBjb250YWluZXIgPSBwYXJlbnRDb250cm9sLmNoaWxkcmVuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaWYocGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnMgPT09IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgICAgcGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnMgPSB7fTtcclxuICAgICAgICAgICAgaWYocGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnNbcGxhY2Vob2xkZXJLZXkudmFsdWVdID09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgcGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnNbcGxhY2Vob2xkZXJLZXkudmFsdWVdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGFpbmVyID0gcGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnNbcGxhY2Vob2xkZXJLZXkudmFsdWVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZihlbC5hdHRyaWJ1dGVzWyduYW1lJ10gIT0gdW5kZWZpbmVkICYmIGVsLmF0dHJpYnV0ZXNbJ25hbWUnXS52YWx1ZS5pbmNsdWRlcygnZHJvcHpvbmVfZm9vdGVyJykpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZihlbC5hdHRyaWJ1dGVzWyduYW1lJ10gIT0gdW5kZWZpbmVkICYmIGVsLmF0dHJpYnV0ZXNbJ25hbWUnXS52YWx1ZS5pbmNsdWRlcygnZHJvcHpvbmVfaGVhZGVyJykpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci51bnNoaWZ0KGl0ZW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYWZ0ZXJLZXkgPSBlbC5hdHRyaWJ1dGVzWydlbGVtZW50YWZ0ZXInXTtcclxuICAgICAgICAgICAgdmFyIGFmdGVyQ29udHJvbDtcclxuICAgICAgICAgICAgaWYoYWZ0ZXJLZXkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgYWZ0ZXJDb250cm9sID0gdGhpcy5maW5kSXRlbUJ5S2V5KGFmdGVyS2V5LnZhbHVlLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zcGxpY2UoY29udGFpbmVyLmluZGV4T2YoYWZ0ZXJDb250cm9sKSwgMCwgaXRlbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IGVsZW1lbnQgaXMgbm90IGZvdW5kXCIsIHBhcmVudEtleSwgaXRlbSwgZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYoZWwuYXR0cmlidXRlc1snZWxlbWVudGFmdGVyJ10gIT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICB2YXIgY29udHJvbDtcclxuICAgICAgdmFyIGFmdGVyS2V5ID0gZWwuYXR0cmlidXRlc1snZWxlbWVudGFmdGVyJ107XHJcbiAgICAgIGlmKGFmdGVyS2V5ICE9IHVuZGVmaW5lZClcclxuICAgICAge1xyXG4gICAgICAgIGNvbnRyb2wgPSB0aGlzLmZpbmRJdGVtQnlLZXkoYWZ0ZXJLZXkudmFsdWUsIHNvcnRlZEFycmF5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoY29udHJvbCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHNvcnRlZEFycmF5LnNwbGljZShzb3J0ZWRBcnJheS5pbmRleE9mKGNvbnRyb2wpLCAwLCBpdGVtKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IGVsZW1lbnQgaXMgbm90IGZvdW5kXCIsIGFmdGVyS2V5LCBpdGVtLCBlbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5zZXREYXRhKHNvcnRlZEFycmF5KTtcclxuICB9LFxyXG4gIF9leGNsdWRlSXRlbUJ5S2V5OiBmdW5jdGlvbihrZXksIGRhdGEpe1xyXG4gICAgdmFyIHNvcnRlZEFycmF5ID0gW107XHJcbiAgICBmb3IodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKXtcclxuICAgICAgaWYoZGF0YVtpXS5rZXkgPT0ga2V5KVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgc29ydGVkQXJyYXkucHVzaChkYXRhW2ldKTtcclxuXHJcbiAgICAgIGlmKGRhdGFbaV0uY2hpbGRyZW4pe1xyXG4gICAgICAgIHNvcnRlZEFycmF5W3NvcnRlZEFycmF5Lmxlbmd0aCAtIDFdLmNoaWxkcmVuID0gdGhpcy5fZXhjbHVkZUl0ZW1CeUtleShrZXksIGRhdGFbaV0uY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZihkYXRhW2ldLnBsYWNlaG9sZGVycyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGZvcihsZXQgcGggaW4gZGF0YVtpXS5wbGFjZWhvbGRlcnMpe1xyXG4gICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShkYXRhW2ldLnBsYWNlaG9sZGVyc1twaF0pKXtcclxuICAgICAgICAgICAgc29ydGVkQXJyYXlbc29ydGVkQXJyYXkubGVuZ3RoIC0gMV0ucGxhY2Vob2xkZXJzW3BoXSA9IHRoaXMuX2V4Y2x1ZGVJdGVtQnlLZXkoa2V5LCBkYXRhW2ldLnBsYWNlaG9sZGVyc1twaF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNvcnRlZEFycmF5O1xyXG4gIH0sXHJcbiAgYWRkOiBmdW5jdGlvbihpdGVtLCBlbCkge1xyXG4gICAgdmFyIHJlcyA9IERXS2l0Rm9ybUNvbnRyb2xzLmZpbGxEZWZhdWx0VmFsdWVzKHsgXHJcbiAgICAgIGtleTogdGhpcy5nZXREZWZhdWx0S2V5KGl0ZW0ua2V5KSwgXHJcbiAgICAgIFwiZGF0YS1idWlsZGVydHlwZVwiOiBpdGVtLmJ1aWxkZXJUeXBlICE9PSB1bmRlZmluZWQgPyBpdGVtLmJ1aWxkZXJUeXBlOiBpdGVtLmtleVxyXG4gICAgfSwgaXRlbS5kZWZhdWx0VmFsdWVzKTtcclxuICBcclxuICAgIGlmKGVsID09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBpZihfZGF0YS5sZW5ndGggPiAwICYmIF9kYXRhW19kYXRhLmxlbmd0aCAtIDFdW1wiZGF0YS1idWlsZGVydHlwZVwiXSA9PSAnZm9ybScpe1xyXG4gICAgICAgICAgdmFyIHAgPSBfZGF0YVtfZGF0YS5sZW5ndGggLSAxXTsgXHJcbiAgICAgICAgICBpZihwLmNoaWxkcmVuID09IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgIHAuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgIHAuY2hpbGRyZW4ucHVzaChyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgX2RhdGEucHVzaChyZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYoZWwuYXR0cmlidXRlc1snbmFtZSddICE9IHVuZGVmaW5lZCAmJiBlbC5hdHRyaWJ1dGVzWyduYW1lJ10udmFsdWUgPT0gJ2Ryb3B6b25lX2Zvb3RlcicpXHJcbiAgICB7XHJcbiAgICAgIF9kYXRhLnB1c2gocmVzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoZWwuYXR0cmlidXRlc1snbmFtZSddICE9IHVuZGVmaW5lZCAmJiBlbC5hdHRyaWJ1dGVzWyduYW1lJ10udmFsdWUgPT0gJ2Ryb3B6b25lX2hlYWRlcicpXHJcbiAgICB7XHJcbiAgICAgIF9kYXRhLnVuc2hpZnQocmVzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoZWwuYXR0cmlidXRlc1snZWxlbWVudHRvaW5zZXJ0J10gIT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXJlbnRDb250cm9sO1xyXG4gICAgICAgIHZhciBpbnNlcnRJbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHBhcmVudEtleSA9IGVsLmF0dHJpYnV0ZXNbJ2VsZW1lbnR0b2luc2VydCddO1xyXG5cclxuICAgICAgICBpZihwYXJlbnRLZXkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBhcmVudENvbnRyb2wgPSB0aGlzLmZpbmRJdGVtQnlLZXkocGFyZW50S2V5LnZhbHVlLCBfZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihwYXJlbnRDb250cm9sICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJLZXkgPSBlbC5hdHRyaWJ1dGVzWydwbGFjZWhvbGRlcmtleSddO1xyXG4gICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICBpZihwbGFjZWhvbGRlcktleSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaWYocGFyZW50Q29udHJvbC5jaGlsZHJlbiA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgcGFyZW50Q29udHJvbC5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBjb250YWluZXIgPSBwYXJlbnRDb250cm9sLmNoaWxkcmVuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaWYocGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnMgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgcGFyZW50Q29udHJvbC5wbGFjZWhvbGRlcnMgPSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHBhcmVudENvbnRyb2wucGxhY2Vob2xkZXJzW3BsYWNlaG9sZGVyS2V5LnZhbHVlXSA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgIHBhcmVudENvbnRyb2wucGxhY2Vob2xkZXJzW3BsYWNlaG9sZGVyS2V5LnZhbHVlXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBhcmVudENvbnRyb2wucGxhY2Vob2xkZXJzW3BsYWNlaG9sZGVyS2V5LnZhbHVlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICBcclxuICAgICAgICAgIGlmKGVsLmF0dHJpYnV0ZXNbJ25hbWUnXSAhPSB1bmRlZmluZWQgJiYgZWwuYXR0cmlidXRlc1snbmFtZSddLnZhbHVlLmluY2x1ZGVzKCdkcm9wem9uZV9mb290ZXInKSlcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnB1c2gocmVzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYoZWwuYXR0cmlidXRlc1snbmFtZSddICE9IHVuZGVmaW5lZCAmJiBlbC5hdHRyaWJ1dGVzWyduYW1lJ10udmFsdWUuaW5jbHVkZXMoJ2Ryb3B6b25lX2hlYWRlcicpKVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBjb250YWluZXIudW5zaGlmdChyZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYWZ0ZXJLZXkgPSBlbC5hdHRyaWJ1dGVzWydlbGVtZW50YWZ0ZXInXTtcclxuICAgICAgICAgICAgdmFyIGFmdGVyQ29udHJvbDtcclxuICAgICAgICAgICAgaWYoYWZ0ZXJLZXkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgYWZ0ZXJDb250cm9sID0gdGhpcy5maW5kSXRlbUJ5S2V5KGFmdGVyS2V5LnZhbHVlLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zcGxpY2UoY29udGFpbmVyLmluZGV4T2YoYWZ0ZXJDb250cm9sKSwgMCwgcmVzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUjogZWxlbWVudCBpcyBub3QgZm91bmRcIiwgcGFyZW50S2V5LCBpdGVtLCBlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZihlbC5hdHRyaWJ1dGVzWydlbGVtZW50YWZ0ZXInXSAhPSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgIHZhciBjb250cm9sO1xyXG4gICAgICB2YXIgYWZ0ZXJLZXkgPSBlbC5hdHRyaWJ1dGVzWydlbGVtZW50YWZ0ZXInXTtcclxuICAgICAgaWYoYWZ0ZXJLZXkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICB7XHJcbiAgICAgICAgY29udHJvbCA9IHRoaXMuZmluZEl0ZW1CeUtleShhZnRlcktleS52YWx1ZSwgX2RhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihjb250cm9sICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgX2RhdGEuc3BsaWNlKF9kYXRhLmluZGV4T2YoY29udHJvbCksIDAsIHJlcyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SOiBlbGVtZW50IGlzIG5vdCBmb3VuZFwiLCBhZnRlcktleSwgYnVpbGRlcnR5cGUsIHRpdGxlLCBlbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgIHRoaXMudHJpZ2dlcihfZGF0YSk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICB0aGlzLnJlbW92ZUl0ZW1CeUtleShpdGVtLmtleSwgX2RhdGEpO1xyXG4gICAgdGhpcy50cmlnZ2VyKF9kYXRhKTtcclxuICB9LFxyXG5cclxuICBjb3B5OiBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICB2YXIgbmV3SXRlbSA9IHRoaXMuY29weU9iaihpdGVtKTtcclxuICAgIHRoaXMuaW5zZXJ0QWZ0ZXJLZXkobmV3SXRlbSwgaXRlbS5rZXksIF9kYXRhKTtcclxuICAgIHRoaXMubWFrZVVuaXF1ZUtleXMobmV3SXRlbSk7XHJcbiAgICB0aGlzLnRyaWdnZXIoX2RhdGEpO1xyXG4gIH0sXHJcblxyXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9kYXRhO1xyXG4gIH0sXHJcblxyXG4gIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIF9kYXRhID0gZGF0YTtcclxuICAgIHRoaXMudHJpZ2dlcihfZGF0YSk7XHJcbiAgfSxcclxuICBcclxuICBfdXBkYXRlT3JkZXI6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XHJcbiAgICBfZGF0YSA9IGVsZW1lbnRzO1xyXG4gICAgdGhpcy50cmlnZ2VyKF9kYXRhKTtcclxuICB9LFxyXG4gIFxyXG4gIGdldERlZmF1bHRLZXk6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IDE7XHJcbiAgICAgIHZhciB0bXAgPSBuYW1lICsgJ18nICsgaW5kZXg7XHJcblxyXG4gICAgICBsZXQgYWxsS2V5cyA9IHRoaXMuZ2V0QWxsS2V5cyhfZGF0YSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gYWxsS2V5c1tpXTtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IG5hbWUgKyAnXycgKyBpbmRleDtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gPT0gdG1wKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgfSxcclxuICAgIGdldEFsbEtleXM6IGZ1bmN0aW9uKGl0ZW1zKVxyXG4gICAge1xyXG4gICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgIGlmKGl0ZW1zICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgIHJlcy5wdXNoKGl0ZW0ua2V5KTtcclxuICAgICAgICAgIGlmKGl0ZW0uY2hpbGRyZW4gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdmFyIGNoaWxka2V5cyA9IHRoaXMuZ2V0QWxsS2V5cyhpdGVtLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjaGlsZGtleXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZihpdGVtLnBsYWNlaG9sZGVycyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBmb3IobGV0IHBoIGluIGl0ZW0ucGxhY2Vob2xkZXJzKXtcclxuICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGl0ZW0ucGxhY2Vob2xkZXJzW3BoXSkpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHBoa2V5cyA9IHRoaXMuZ2V0QWxsS2V5cyhpdGVtLnBsYWNlaG9sZGVyc1twaF0pO1xyXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChwaGtleXMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sXHJcbiAgICBnZXRCeUtleTogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgcmV0dXJuIHRoaXMuZmluZEl0ZW1CeUtleShrZXksIF9kYXRhKTtcclxuICAgIH0sXHJcbiAgICBmaW5kSXRlbUJ5S2V5OiBmdW5jdGlvbihrZXksIGl0ZW1zKXtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgIGlmKGl0ZW0ua2V5ID09IGtleSlcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICBlbHNlIGlmKGl0ZW0uY2hpbGRyZW4gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZmluZEl0ZW1CeUtleShrZXksIGl0ZW0uY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICBpZihyZXMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmKGl0ZW0ucGxhY2Vob2xkZXJzICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGZvcihsZXQgcGggaW4gaXRlbS5wbGFjZWhvbGRlcnMpe1xyXG4gICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoaXRlbS5wbGFjZWhvbGRlcnNbcGhdKSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5maW5kSXRlbUJ5S2V5KGtleSwgaXRlbS5wbGFjZWhvbGRlcnNbcGhdKTtcclxuICAgICAgICAgICAgICAgIGlmKHJlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0sXHJcbiAgICBpbnNlcnRBZnRlcktleTogZnVuY3Rpb24oaW5zZXJ0SXRlbSwga2V5LCBpdGVtcyl7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICBpZihpdGVtLmtleSA9PSBrZXkpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpKzEsIDAsIGluc2VydEl0ZW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYoaXRlbS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaWYodGhpcy5pbnNlcnRBZnRlcktleShpbnNlcnRJdGVtLCBrZXksIGl0ZW0uY2hpbGRyZW4pKXtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmKGl0ZW0ucGxhY2Vob2xkZXJzICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBmb3IobGV0IHBoIGluIGl0ZW0ucGxhY2Vob2xkZXJzKXtcclxuICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGl0ZW0ucGxhY2Vob2xkZXJzW3BoXSkpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pbnNlcnRBZnRlcktleShpbnNlcnRJdGVtLCBrZXksIGl0ZW0ucGxhY2Vob2xkZXJzW3BoXSkpe1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZUl0ZW1CeUtleTogZnVuY3Rpb24oa2V5LCBpdGVtKXtcclxuICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEJ5S2V5KGtleSk7XHJcbiAgICAgIGZvcih2YXIgaSBpbiBpdGVtKXtcclxuICAgICAgICAgIGRhdGFbaV0gPSBpdGVtW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZihrZXkgIT0gaXRlbS5rZXkpe1xyXG4gICAgICAgIHRoaXMucmVwbGFjZURlcGVuc0tleXMoa2V5LCBpdGVtLmtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihfZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcGxhY2VEZXBlbnNLZXlzOiBmdW5jdGlvbihvbGRLZXksIG5ld0tleSwgaXRlbXMpe1xyXG4gICAgICBpZihpdGVtcyA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgaXRlbXMgPSBfZGF0YTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGl0ZW1bXCJldmVudHMtb25jbGljay10YXJnZXRzXCJdKSl7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gaXRlbVtcImV2ZW50cy1vbmNsaWNrLXRhcmdldHNcIl07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGFyZ2V0cy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgaWYodGFyZ2V0c1tqXSA9PSBvbGRLZXkpXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRzW2pdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICB9ICBcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZihpdGVtLmNoaWxkcmVuICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZURlcGVuc0tleXMob2xkS2V5LCBuZXdLZXksIGl0ZW0uY2hpbGRyZW4pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmKGl0ZW0ucGxhY2Vob2xkZXJzICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBmb3IobGV0IHBoIGluIGl0ZW0ucGxhY2Vob2xkZXJzKXtcclxuICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGl0ZW0ucGxhY2Vob2xkZXJzW3BoXSkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRGVwZW5zS2V5cyhvbGRLZXksIG5ld0tleSwgaXRlbS5wbGFjZWhvbGRlcnNbcGhdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZUl0ZW1CeUtleTogZnVuY3Rpb24oa2V5LCBpdGVtcyl7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xyXG4gICAgICAgIGlmKGl0ZW0ua2V5ID09IGtleSl7XHJcbiAgICAgICAgICBpdGVtcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoaXRlbS5jaGlsZHJlbiAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVJdGVtQnlLZXkoa2V5LCBpdGVtLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGl0ZW0ucGxhY2Vob2xkZXJzICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgZm9yKGxldCBwaCBpbiBpdGVtLnBsYWNlaG9sZGVycyl7XHJcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoaXRlbS5wbGFjZWhvbGRlcnNbcGhdKSl7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtQnlLZXkoa2V5LCBpdGVtLnBsYWNlaG9sZGVyc1twaF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29weU9iaihvYmopIHtcclxuICAgICAgaWYgKG51bGwgPT0gb2JqIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIG9iaikgcmV0dXJuIG9iajtcclxuICAgICAgdmFyIGNvcHkgPSBvYmouY29uc3RydWN0b3IoKTtcclxuICAgICAgXHJcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gb2JqKSB7XHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGF0dHIpKSBjb3B5W2F0dHJdID0gdGhpcy5jb3B5T2JqKG9ialthdHRyXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9LFxyXG4gICAgbWFrZVVuaXF1ZUtleXMob2JqKXtcclxuICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgdmFyIGJ1aWxkZXJ0eXBlID0gb2JqW1wiZGF0YS1idWlsZGVydHlwZVwiXTtcclxuICAgICAgaWYoYnVpbGRlcnR5cGUgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBvYmoua2V5ID0gdGhpcy5nZXREZWZhdWx0S2V5KGJ1aWxkZXJ0eXBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoQXJyYXkuaXNBcnJheShvYmouY2hpbGRyZW4pKXtcclxuICAgICAgICBvYmouY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjKXtcclxuICAgICAgICAgIG1lLm1ha2VVbmlxdWVLZXlzKGMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihvYmoucGxhY2Vob2xkZXJzICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGZvcihsZXQgcGggaW4gb2JqLnBsYWNlaG9sZGVycyl7XHJcbiAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG9iai5wbGFjZWhvbGRlcnNbcGhdKSl7XHJcbiAgICAgICAgICAgIG9iai5wbGFjZWhvbGRlcnNbcGhdLmZvckVhY2goZnVuY3Rpb24oYyl7XHJcbiAgICAgICAgICAgICAgbWUubWFrZVVuaXF1ZUtleXMoYyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRFdLaXRTdG9yZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RvcmUuanN4IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX19rZWVwID0gZXhwb3J0cy5qb2luQ29uY2F0ID0gZXhwb3J0cy5qb2luU3RyaWN0ID0gZXhwb3J0cy5qb2luTGVhZGluZyA9IGV4cG9ydHMuYWxsID0gZXhwb3J0cy5qb2luVHJhaWxpbmcgPSBleHBvcnRzLnVzZSA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLnNldEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuY3JlYXRlQWN0aW9ucyA9IGV4cG9ydHMuY3JlYXRlU3RvcmUgPSBleHBvcnRzLmNyZWF0ZUFjdGlvbiA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLlN0b3JlTWV0aG9kcyA9IGV4cG9ydHMuUHVibGlzaGVyTWV0aG9kcyA9IGV4cG9ydHMuTGlzdGVuZXJNZXRob2RzID0gZXhwb3J0cy5BY3Rpb25NZXRob2RzID0gZXhwb3J0cy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX0FjdGlvbk1ldGhvZHMgPSByZXF1aXJlKFwiLi9BY3Rpb25NZXRob2RzXCIpO1xuXG52YXIgQWN0aW9uTWV0aG9kcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9BY3Rpb25NZXRob2RzKTtcblxudmFyIF9MaXN0ZW5lck1ldGhvZHMgPSByZXF1aXJlKFwiLi9MaXN0ZW5lck1ldGhvZHNcIik7XG5cbnZhciBMaXN0ZW5lck1ldGhvZHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfTGlzdGVuZXJNZXRob2RzKTtcblxudmFyIF9QdWJsaXNoZXJNZXRob2RzID0gcmVxdWlyZShcIi4vUHVibGlzaGVyTWV0aG9kc1wiKTtcblxudmFyIFB1Ymxpc2hlck1ldGhvZHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfUHVibGlzaGVyTWV0aG9kcyk7XG5cbnZhciBfU3RvcmVNZXRob2RzID0gcmVxdWlyZShcIi4vU3RvcmVNZXRob2RzXCIpO1xuXG52YXIgU3RvcmVNZXRob2RzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1N0b3JlTWV0aG9kcyk7XG5cbnZhciBfam9pbnMgPSByZXF1aXJlKFwiLi9qb2luc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgXyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbnZhciBfY3JlYXRlQWN0aW9uID0gcmVxdWlyZShcIi4vY3JlYXRlQWN0aW9uXCIpO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZShcIi4vY3JlYXRlU3RvcmVcIik7XG5cbnZhciBfS2VlcCA9IHJlcXVpcmUoXCIuL0tlZXBcIik7XG5cbnZhciBfX2tlZXAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfS2VlcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbnZhciB2ZXJzaW9uID0ge1xuICAgIFwicmVmbHV4LWNvcmVcIjogXCIxLjAuMFwiXG59O1xuXG52YXIgam9pblRyYWlsaW5nID0gKDAsIF9qb2lucy5zdGF0aWNKb2luQ3JlYXRvcikoXCJsYXN0XCIpO1xudmFyIGFsbCA9IGpvaW5UcmFpbGluZzsgLy8gUmVmbHV4LmFsbCBhbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxudmFyIGpvaW5MZWFkaW5nID0gKDAsIF9qb2lucy5zdGF0aWNKb2luQ3JlYXRvcikoXCJmaXJzdFwiKTtcbnZhciBqb2luU3RyaWN0ID0gKDAsIF9qb2lucy5zdGF0aWNKb2luQ3JlYXRvcikoXCJzdHJpY3RcIik7XG52YXIgam9pbkNvbmNhdCA9ICgwLCBfam9pbnMuc3RhdGljSm9pbkNyZWF0b3IpKFwiYWxsXCIpO1xuXG52YXIgdXRpbHMgPSBfO1xuXG5cbi8qKlxyXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZXQgb2YgYWN0aW9uc1xyXG4gKlxyXG4gKiBAcGFyYW0gZGVmaW5pdGlvbnMgdGhlIGRlZmluaXRpb25zIGZvciB0aGUgYWN0aW9ucyB0byBiZSBjcmVhdGVkXHJcbiAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFjdGlvbnMgb2YgY29ycmVzcG9uZGluZyBhY3Rpb24gbmFtZXNcclxuICovXG52YXIgY3JlYXRlQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVkdWNlciA9IGZ1bmN0aW9uIHJlZHVjZXIoZGVmaW5pdGlvbnMsIGFjdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmaW5pdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkZWZpbml0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgICAgICAgIGFjdGlvbnNbYWN0aW9uTmFtZV0gPSAoMCwgX2NyZWF0ZUFjdGlvbi5jcmVhdGVBY3Rpb24pKHZhbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlZmluaXRpb25zKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0ge307XG4gICAgICAgIGlmIChkZWZpbml0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBkZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZXIodmFsLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zW3ZhbF0gPSAoMCwgX2NyZWF0ZUFjdGlvbi5jcmVhdGVBY3Rpb24pKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWR1Y2VyKGRlZmluaXRpb25zLCBhY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9O1xufSgpO1xuXG4vKipcclxuICogU2V0cyB0aGUgZXZlbnRtaXR0ZXIgdGhhdCBSZWZsdXggdXNlc1xyXG4gKi9cbmZ1bmN0aW9uIHNldEV2ZW50RW1pdHRlcihjdHgpIHtcbiAgICBfLkV2ZW50RW1pdHRlciA9IGN0eDtcbn1cblxuLyoqXHJcbiAqIFNldHMgdGhlIG1ldGhvZCB1c2VkIGZvciBkZWZlcnJpbmcgYWN0aW9ucyBhbmQgc3RvcmVzXHJcbiAqL1xuZnVuY3Rpb24gbmV4dFRpY2sobmV4dFRpY2spIHtcbiAgICBfLm5leHRUaWNrID0gbmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIHVzZShwbHVnaW5DYikge1xuICAgIHBsdWdpbkNiKHRoaXMpO1xufVxuXG4vKipcclxuICogUHJvdmlkZXMgdGhlIHNldCBvZiBjcmVhdGVkIGFjdGlvbnMgYW5kIHN0b3JlcyBmb3IgaW50cm9zcGVjdGlvblxyXG4gKi9cbi8qZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUqL1xuXG5cbi8vIGV4cG9ydCBpbiBmb3JtYXQgdGhhdCBzdXBwb3J0cyBzeW50YXg6IHZhciBSZWZsdXggPSByZXF1aXJlKCdyZWZsdXgtY29yZScpO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuQWN0aW9uTWV0aG9kcyA9IEFjdGlvbk1ldGhvZHM7XG5leHBvcnRzLkxpc3RlbmVyTWV0aG9kcyA9IExpc3RlbmVyTWV0aG9kcztcbmV4cG9ydHMuUHVibGlzaGVyTWV0aG9kcyA9IFB1Ymxpc2hlck1ldGhvZHM7XG5leHBvcnRzLlN0b3JlTWV0aG9kcyA9IFN0b3JlTWV0aG9kcztcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbmV4cG9ydHMuY3JlYXRlQWN0aW9uID0gX2NyZWF0ZUFjdGlvbi5jcmVhdGVBY3Rpb247XG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlLmNyZWF0ZVN0b3JlO1xuZXhwb3J0cy5jcmVhdGVBY3Rpb25zID0gY3JlYXRlQWN0aW9ucztcbmV4cG9ydHMuc2V0RXZlbnRFbWl0dGVyID0gc2V0RXZlbnRFbWl0dGVyO1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuZXhwb3J0cy51c2UgPSB1c2U7XG5leHBvcnRzLmpvaW5UcmFpbGluZyA9IGpvaW5UcmFpbGluZztcbmV4cG9ydHMuYWxsID0gYWxsO1xuZXhwb3J0cy5qb2luTGVhZGluZyA9IGpvaW5MZWFkaW5nO1xuZXhwb3J0cy5qb2luU3RyaWN0ID0gam9pblN0cmljdDtcbmV4cG9ydHMuam9pbkNvbmNhdCA9IGpvaW5Db25jYXQ7XG5leHBvcnRzLl9fa2VlcCA9IF9fa2VlcDtcbi8qZXNsaW50LWVuYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSovXG5cbi8vIGV4cG9ydCBpbiBmb3JtYXQgdGhhdCBzdXBwb3J0cyBzeW50YXg6IGltcG9ydCBSZWZsdXggZnJvbSAncmVmbHV4LWNvcmUnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfVxufSk7XG5cbi8qKlxyXG4gKiBXYXJuIGlmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIG5vdCBhdmFpbGFibGVcclxuICovXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIG5vdCBhdmFpbGFibGUuIFwiICsgXCJFUzUgc2hpbSByZXF1aXJlZC4gXCIgKyBcImh0dHBzOi8vZ2l0aHViLmNvbS9zcG9pa2UvcmVmbHV4anMjZXM1XCIpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgYmVmb3JlIEtlZXAuanMgc3RhcnRzIHN0b3JpbmcsIGRvbmUgdmlhIHVzZUtlZXBcbnZhciB1c2UgPSBmYWxzZTtcblxudmFyIGNyZWF0ZWRTdG9yZXMgPSBbXTtcblxudmFyIGNyZWF0ZWRBY3Rpb25zID0gW107XG5cbmZ1bmN0aW9uIHVzZUtlZXAoKSB7XG5cdHZhciBib29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG5cdHVzZSA9IGJvb2w7XG59XG5cbmZ1bmN0aW9uIGFkZFN0b3JlKHN0cikge1xuXHRpZiAodXNlKSB7XG5cdFx0Y3JlYXRlZFN0b3Jlcy5wdXNoKHN0cik7XG5cdH1cbn1cblxuZnVuY3Rpb24gYWRkQWN0aW9uKGFjdCkge1xuXHRpZiAodXNlKSB7XG5cdFx0Y3JlYXRlZEFjdGlvbnMucHVzaChhY3QpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuXHR3aGlsZSAoY3JlYXRlZFN0b3Jlcy5sZW5ndGgpIHtcblx0XHRjcmVhdGVkU3RvcmVzLnBvcCgpO1xuXHR9XG5cdHdoaWxlIChjcmVhdGVkQWN0aW9ucy5sZW5ndGgpIHtcblx0XHRjcmVhdGVkQWN0aW9ucy5wb3AoKTtcblx0fVxufVxuXG5leHBvcnRzLnVzZUtlZXAgPSB1c2VLZWVwO1xuZXhwb3J0cy5hZGRTdG9yZSA9IGFkZFN0b3JlO1xuZXhwb3J0cy5hZGRBY3Rpb24gPSBhZGRBY3Rpb247XG5leHBvcnRzLmNyZWF0ZWRTdG9yZXMgPSBjcmVhdGVkU3RvcmVzO1xuZXhwb3J0cy5jcmVhdGVkQWN0aW9ucyA9IGNyZWF0ZWRBY3Rpb25zO1xuZXhwb3J0cy5yZXNldCA9IHJlc2V0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9LZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZlcldpdGggPSBleHBvcnRzLnRyaWdnZXJBc3luYyA9IGV4cG9ydHMudHJpZ2dlciA9IGV4cG9ydHMubGlzdGVuID0gZXhwb3J0cy5zaG91bGRFbWl0ID0gZXhwb3J0cy5wcmVFbWl0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXHJcbiAqIEEgbW9kdWxlIG9mIG1ldGhvZHMgZm9yIG9iamVjdCB0aGF0IHlvdSB3YW50IHRvIGJlIGFibGUgdG8gbGlzdGVuIHRvLlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBjb25zdW1lZCBieSBgY3JlYXRlU3RvcmVgIGFuZCBgY3JlYXRlQWN0aW9uYFxyXG4gKi9cblxuLyoqXHJcbiAqIEhvb2sgdXNlZCBieSB0aGUgcHVibGlzaGVyIHRoYXQgaXMgaW52b2tlZCBiZWZvcmUgZW1pdHRpbmdcclxuICogYW5kIGJlZm9yZSBgc2hvdWxkRW1pdGAuIFRoZSBhcmd1bWVudHMgYXJlIHRoZSBvbmVzIHRoYXQgdGhlIGFjdGlvblxyXG4gKiBpcyBpbnZva2VkIHdpdGguIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhblxyXG4gKiB1bmRlZmluZWQsIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gYXMgYXJndW1lbnRzIGZvciBzaG91bGRFbWl0IGFuZFxyXG4gKiBlbWlzc2lvbi5cclxuICovXG52YXIgcHJlRW1pdCA9IGV4cG9ydHMucHJlRW1pdCA9IGZ1bmN0aW9uIHByZUVtaXQoKSB7fTtcblxuLyoqXHJcbiAqIEhvb2sgdXNlZCBieSB0aGUgcHVibGlzaGVyIGFmdGVyIGBwcmVFbWl0YCB0byBkZXRlcm1pbmUgaWYgdGhlXHJcbiAqIGV2ZW50IHNob3VsZCBiZSBlbWl0dGVkIHdpdGggZ2l2ZW4gYXJndW1lbnRzLiBUaGlzIG1heSBiZSBvdmVycmlkZGVuXHJcbiAqIGluIHlvdXIgYXBwbGljYXRpb24sIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJldHVybnMgdHJ1ZS5cclxuICpcclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgZXZlbnQgc2hvdWxkIGJlIGVtaXR0ZWRcclxuICovXG52YXIgc2hvdWxkRW1pdCA9IGV4cG9ydHMuc2hvdWxkRW1pdCA9IGZ1bmN0aW9uIHNob3VsZEVtaXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcclxuICogU3Vic2NyaWJlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGFjdGlvbiB0cmlnZ2VyZWRcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJlZ2lzdGVyIGFzIGV2ZW50IGhhbmRsZXJcclxuICogQHBhcmFtIHtNaXhlZH0gW29wdGlvbmFsXSBiaW5kQ29udGV4dCBUaGUgY29udGV4dCB0byBiaW5kIHRoZSBjYWxsYmFjayB3aXRoXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdGhhdCB1bnN1YnNjcmliZXMgdGhlIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlclxyXG4gKi9cbnZhciBsaXN0ZW4gPSBleHBvcnRzLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihjYWxsYmFjaywgYmluZENvbnRleHQpIHtcbiAgICBiaW5kQ29udGV4dCA9IGJpbmRDb250ZXh0IHx8IHRoaXM7XG4gICAgdmFyIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkoYmluZENvbnRleHQsIGFyZ3MpO1xuICAgIH0sXG4gICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdHRlci5hZGRMaXN0ZW5lcih0aGlzLmV2ZW50TGFiZWwsIGV2ZW50SGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIG1lLmVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobWUuZXZlbnRMYWJlbCwgZXZlbnRIYW5kbGVyKTtcbiAgICB9O1xufTtcblxuLyoqXHJcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCB1c2luZyBgdGhpcy5lbWl0dGVyYCAoaWYgYHNob3VsZEVtaXRgIGFncmVlcylcclxuICovXG52YXIgdHJpZ2dlciA9IGV4cG9ydHMudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIHByZSA9IHRoaXMucHJlRW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBhcmdzID0gcHJlID09PSB1bmRlZmluZWQgPyBhcmdzIDogXy5pc0FyZ3VtZW50cyhwcmUpID8gcHJlIDogW10uY29uY2F0KHByZSk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRW1pdC5hcHBseSh0aGlzLCBhcmdzKSkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdCh0aGlzLmV2ZW50TGFiZWwsIGFyZ3MpO1xuICAgIH1cbn07XG5cbi8qKlxyXG4gKiBUcmllcyB0byBwdWJsaXNoIHRoZSBldmVudCBvbiB0aGUgbmV4dCB0aWNrXHJcbiAqL1xudmFyIHRyaWdnZXJBc3luYyA9IGV4cG9ydHMudHJpZ2dlckFzeW5jID0gZnVuY3Rpb24gdHJpZ2dlckFzeW5jKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBtZSA9IHRoaXM7XG4gICAgXy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLnRyaWdnZXIuYXBwbHkobWUsIGFyZ3MpO1xuICAgIH0pO1xufTtcblxuLyoqXHJcbiAqIFdyYXBzIHRoZSB0cmlnZ2VyIG1lY2hhbmlzbSB3aXRoIGEgZGVmZXJyYWwgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBkZWZlcnJhbCBmdW5jdGlvbixcclxuICogICAgICAgIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSByZXNvbHZpbmcgZnVuY3Rpb24gYW5kIHRoZVxyXG4gKiAgICAgICAgcmVzdCBhcmUgdGhlIGFyZ3VtZW50cyBwcm92aWRlZCBmcm9tIHRoZSBwcmV2aW91c1xyXG4gKiAgICAgICAgdHJpZ2dlciBpbnZvY2F0aW9uXHJcbiAqL1xudmFyIGRlZmVyV2l0aCA9IGV4cG9ydHMuZGVmZXJXaXRoID0gZnVuY3Rpb24gZGVmZXJXaXRoKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZFRyaWdnZXIgPSB0aGlzLnRyaWdnZXIsXG4gICAgICAgIGN0eCA9IHRoaXMsXG4gICAgICAgIHJlc29sdmVyID0gZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgIG9sZFRyaWdnZXIuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjay5hcHBseShjdHgsIFtyZXNvbHZlcl0uY29uY2F0KFtdLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvUHVibGlzaGVyTWV0aG9kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF8gPSByZXF1aXJlKCdyZWZsdXgtY29yZS9saWIvdXRpbHMnKSxcclxuICAgIExpc3RlbmVyTWV0aG9kcyA9IHJlcXVpcmUoJ3JlZmx1eC1jb3JlL2xpYi9MaXN0ZW5lck1ldGhvZHMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIG1vZHVsZSBtZWFudCB0byBiZSBjb25zdW1lZCBhcyBhIG1peGluIGJ5IGEgUmVhY3QgY29tcG9uZW50LiBTdXBwbGllcyB0aGUgbWV0aG9kcyBmcm9tXHJcbiAqIGBMaXN0ZW5lck1ldGhvZHNgIG1peGluIGFuZCB0YWtlcyBjYXJlIG9mIHRlYXJkb3duIG9mIHN1YnNjcmlwdGlvbnMuXHJcbiAqIE5vdGUgdGhhdCBpZiB5b3UncmUgdXNpbmcgdGhlIGBjb25uZWN0YCBtaXhpbiB5b3UgZG9uJ3QgbmVlZCB0aGlzIG1peGluLCBhcyBjb25uZWN0IHdpbGxcclxuICogaW1wb3J0IGV2ZXJ5dGhpbmcgdGhpcyBtaXhpbiBjb250YWlucyFcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gXy5leHRlbmQoe1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW5zIHVwIGFsbCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBMaXN0ZW5lck1ldGhvZHMuc3RvcExpc3RlbmluZ1RvQWxsXHJcblxyXG59LCBMaXN0ZW5lck1ldGhvZHMpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL0xpc3RlbmVyTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IEpTT041IGZyb20gJ2pzb241J1xyXG5pbXBvcnQgeyBJbnB1dCwgQ2hlY2tib3gsIERyb3Bkb3duLCBGb3JtLCBJY29uIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnXHJcbmltcG9ydCBVcGxvYWQgZnJvbSAnLi91cGxvYWQnO1xyXG5pbXBvcnQgRGF0ZVBpY2tlciBmcm9tICcuL2RhdGVwaWNrZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGVjdGlvbkVkaXRvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgYXBwbHlDb2xsYXBzZUFsbChkYXRhKXtcclxuICAgICAgICBmb3IodmFyIHAgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUuZXhwYW5kZWRbcF0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmV4cGFuZGVkW3BdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMucHJvcHMuY29sdW1ucztcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMudmFsdWU7XHJcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5wcm9wcy5lcnJvcjtcclxuICAgICAgICBcclxuICAgICAgICBpZihCb29sZWFuKHRoaXMucHJvcHMuY29sbGFwc2VBbGwpICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpe1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29sbGFwc2VBbGwoZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjb2x1bW5zID09IHVuZGVmaW5lZCB8fCBjb2x1bW5zLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIDxkaXY+RmlsbCBjb2x1bW5zIHByb3BlcnR5ITwvZGl2PjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuZGF0YSA9IHRoaXMuZ2V0Q29weVJvd3NGcm9tUHJvcHMoKTtcclxuICAgICAgICByZXR1cm4gKDxkaXYgc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5wcm9wcy5sYWJlbH08L2xhYmVsPlxyXG4gICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwiZHdraXQtY29sbGVjdGlvbmVkaXRvclwiPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckhlYWRlclJvdyhjb2x1bW5zKX1cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJSb3dzKGNvbHVtbnMsIHRoaXMuc3RhdGUuZGF0YSwgZXJyb3IpfVxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJIZWFkZXJSb3coY29sdW1ucyl7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xyXG4gICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICB2YXIgdGl0bGU7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aDtcclxuICAgICAgICAgICAgdmFyIGRhdGFMaXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGMgPT09ICdvYmplY3QnKXtcclxuICAgICAgICAgICAgICAgIGtleSA9IGMua2V5O1xyXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBjLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGMuZGF0YUxpc3QpKVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0T3B0aW9ucyA9IGMuZGF0YUxpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGtleSA9IGM7XHJcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHRpdGxlICE9IHVuZGVmaW5lZCAmJiB0aXRsZS5sZW5ndGggPj0gMil7XHJcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGl0bGUuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdENvbnRyb2w7XHJcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZihkYXRhTGlzdE9wdGlvbnMgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGRhdGFMaXN0SWQgPSBrZXkgKyBcIl9kYXRhbGlzdFwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9wdFZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvKXtcclxuICAgICAgICAgICAgICAgICAgICBvcHRWYWx1ZS5wdXNoKDxvcHRpb24ga2V5PXtvfSB2YWx1ZT17b30gLz4pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdENvbnRyb2wgPSA8ZGF0YWxpc3Qga2V5PXtkYXRhTGlzdElkfSBpZD17ZGF0YUxpc3RJZH0+e29wdFZhbHVlfTwvZGF0YWxpc3Q+O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXMucHVzaCg8dGQga2V5PXtpbmRleH0gc3R5bGU9e3t3aWR0aH19Pnt0aXRsZX17ZGF0YUxpc3RDb250cm9sfTwvdGQ+KTtcclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYoIUJvb2xlYW4odGhpcy5wcm9wcy5yZWFkT25seSkgJiYgdGhpcy5wcm9wcy5kaXNhYmxlQWRkICE9PSB0cnVlKXtcclxuICAgICAgICAgICAgbGV0IGFkZGNvbnRlbnQgPSBcIkFkZFwiO1xyXG4gICAgICAgICAgICBpZih3aW5kb3cuRFdLaXRBZG1pbkxhbmcgIT0gdW5kZWZpbmVkICYmIHdpbmRvdy5EV0tpdEFkbWluTGFuZy5jb2xsZWN0aW9uZWRpdG9yICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBhZGRjb250ZW50ID0gd2luZG93LkRXS2l0QWRtaW5MYW5nLmNvbGxlY3Rpb25lZGl0b3IuYWRkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKDx0ZCBrZXk9XCJidG50ZFwiIGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItYnV0dG9uY29sXCI+PGEga2V5PVwiYnRuYWRkXCIgY2xhc3NOYW1lPVwiZHdraXQtYnRuXCIgb25DbGljaz17dGhpcy5idG5BZGQuYmluZCh0aGlzKX0+e2FkZGNvbnRlbnR9PC9hPjwvdGQ+KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiA8dHIga2V5PVwiaGVhZGVydHJcIiBjbGFzc05hbWU9XCJkd2tpdC1jb2xsZWN0aW9uZWRpdG9yLWhlYWRlclwiPntyZXN9PC90cj47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RHJhZ0NvbHVtbihyb3dzLCBpKXtcclxuICAgICAgICBsZXQgZHJhZ2dhYmxlID0gIUJvb2xlYW4odGhpcy5wcm9wcy5yZWFkT25seSkgJiYgQm9vbGVhbih0aGlzLnByb3BzLmRyYWdnYWJsZSk7XHJcbiAgICAgICAgaWYoZHJhZ2dhYmxlKXtcclxuICAgICAgICAgICAgcmV0dXJuIDxkaXZcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZT17ZHJhZ2dhYmxlfVxyXG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e3RoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzLCBpLCByb3dzKX1cclxuICAgICAgICAgICAgICAgIG9uRHJhZ0VuZD17dGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzLCBpLCByb3dzKX1cclxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXI9e3RoaXMub25EcmFnT3Zlci5iaW5kKHRoaXMpfVxyXG4gICAgICAgICAgICAgICAgb25Ecm9wPXt0aGlzLm9uRHJvcC5iaW5kKHRoaXMsIGksIHJvd3MpfSBcclxuICAgICAgICAgICAgICAgIGtleT1cImNlbGxkcmFnXCIgY2xhc3NOYW1lPVwiZHdraXQtY29sbGVjdGlvbmVkaXRvci1hY3Rpb25cIj5cclxuICAgICAgICAgICAgICAgIDxJY29uIG9uQ2xpY2s9e3RoaXMub25FeHBhbmQuYmluZCh0aGlzLCBpLCBmYWxzZSl9ICBuYW1lPSdlbGxpcHNpcyB2ZXJ0aWNhbCcgLz5cclxuICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclJvd3MoY29sdW1ucywgZGF0YSwgZXJyb3JzLCBwYXJlbnRJZFZhbHVlLCBsZXZlbCwgcHJlZml4KXtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIGxldCByZXMgPSBbXTtcclxuICAgICAgICBsZXQgcm93cyA9IGRhdGE7ICAgICAgICBcclxuICAgICAgICBpZihsZXZlbCA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGxldmVsID0gMDtcclxuXHJcbiAgICAgICAgaWYocHJlZml4ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XHJcbiAgICAgICBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJvcHMuY2hpbGRyZW5GaWVsZCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucHJvcHMuaGllcmFyY2hpY2FsKXtcclxuICAgICAgICAgICAgICAgIGlmKHJvd3NbaV1bdGhpcy5wcm9wcy5wYXJlbnRJZEZpZWxkXSAhPSBwYXJlbnRJZFZhbHVlKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGRyYWdjb2wgPSB0aGlzLmdldERyYWdDb2x1bW4ocm93cywgaSk7XHJcbiAgICAgICAgICAgIGxldCBleHBhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYodGhpcy5wcm9wcy5oaWVyYXJjaGljYWwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGljb247XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UHJlZml4ID0gcHJlZml4ICsgU3RyaW5nKGkgKyBcIl9cIik7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnByb3BzLnBhcmVudElkRmllbGQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzLnBhcmVudElkRmllbGQgIT09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRJZCA9IHJvd3NbaV1bdGhpcy5wcm9wcy5pZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihwYXJlbnRJZCAhPSB1bmRlZmluZWQgJiYgcGFyZW50SWQgIT0gXCJcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5yZW5kZXJSb3dzKGNvbHVtbnMsIGRhdGEsIGVycm9ycywgcGFyZW50SWQsIGxldmVsKzEsIHBhcmVudFByZWZpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkcmVuLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzZXhwYW5kZWQgPSB0aGlzLnN0YXRlLmV4cGFuZGVkW3ByZWZpeCArIGldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNleHBhbmRlZCA9PSB1bmRlZmluZWQgfHwgaXNleHBhbmRlZCA9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gPGltZyBvbkNsaWNrPXt0aGlzLm9uRXhwYW5kLmJpbmQodGhpcywgcHJlZml4ICsgaSwgZmFsc2UpfSBjbGFzc05hbWU9XCJkd2tpdC1jb2xsZWN0aW9uZWRpdG9yLWltZ2J1dHRvblwiIHNyYz1cIi9pbWFnZXMvY29sbGFwc2Uuc3ZnXCIvPjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IDxpbWcgb25DbGljaz17dGhpcy5vbkV4cGFuZC5iaW5kKHRoaXMsIHByZWZpeCArIGksIHRydWUpfSBjbGFzc05hbWU9XCJkd2tpdC1jb2xsZWN0aW9uZWRpdG9yLWltZ2J1dHRvblwiIHNyYz1cIi9pbWFnZXMvZXhwYW5kLnN2Z1wiLz47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkocm93c1tpXVt0aGlzLnByb3BzLmNoaWxkcmVuRmllbGRdKSAmJiByb3dzW2ldW3RoaXMucHJvcHMuY2hpbGRyZW5GaWVsZF0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5yZW5kZXJSb3dzKGNvbHVtbnMsIHJvd3NbaV1bdGhpcy5wcm9wcy5jaGlsZHJlbkZpZWxkXSwgZXJyb3JzLCB1bmRlZmluZWQsIGxldmVsKzEsIHBhcmVudFByZWZpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGRyZW4ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc2V4cGFuZGVkID0gdGhpcy5zdGF0ZS5leHBhbmRlZFtwcmVmaXggKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNleHBhbmRlZCA9PSB1bmRlZmluZWQgfHwgaXNleHBhbmRlZCA9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSA8aW1nIG9uQ2xpY2s9e3RoaXMub25FeHBhbmQuYmluZCh0aGlzLCBwcmVmaXggKyBpLCBmYWxzZSl9IGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItaW1nYnV0dG9uXCIgc3JjPVwiL2ltYWdlcy9jb2xsYXBzZS5zdmdcIi8+O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gPGltZyBvbkNsaWNrPXt0aGlzLm9uRXhwYW5kLmJpbmQodGhpcywgcHJlZml4ICsgaSwgdHJ1ZSl9IGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItaW1nYnV0dG9uXCIgc3JjPVwiL2ltYWdlcy9leHBhbmQuc3ZnXCIvPjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBpY29uID0gPGltZyBzdHlsZT17e29wYWNpdHk6MH19IGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItaW1nYnV0dG9uXCIgc3JjPVwiL2ltYWdlcy9jb2xsYXBzZS5zdmdcIi8+O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBleHBhbmQgPSA8ZGl2IGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItYWN0aW9uXCI+e2ljb259PC9kaXY+O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcm93ID0gW107XHJcbiAgICAgICAgICAgIGxldCBlcnJvck9uUm93ID0gQXJyYXkuaXNBcnJheShlcnJvcnMpID8gZXJyb3JzW2ldIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29sTmFtZTtcclxuICAgICAgICAgICAgICAgIGxldCBjb250cm9sID0gdGhpcy5wcm9wcy5yZWFkT25seSA/IFwiXCIgOiBcImlucHV0XCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YUxpc3RJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbHVtbnNbal0gPT09ICdvYmplY3QnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb2xOYW1lID0gY29sdW1uc1tqXS5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbHVtbnNbal0uY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGNvbHVtbnNbal0uZGF0YUxpc3QpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxpc3RJZCA9IGNvbE5hbWUgKyBcIl9kYXRhbGlzdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShjb2x1bW5zW2pdLm9wdGlvbnMpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvbHVtbnNbal0ub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbE5hbWUgPSBjb2x1bW5zW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBlcnJvckZsYWcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZihlcnJvck9uUm93ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbGFnID0gQm9vbGVhbihlcnJvck9uUm93W2NvbE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmKGNvbnRyb2wgPT0gXCJjaGVja2JveFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gPEZvcm0uQ2hlY2tib3hcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpICsgXCJfXCIgKyBqfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17Y29sTmFtZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e0Jvb2xlYW4ocm93c1tpXVtjb2xOYW1lXSl9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seT17Qm9vbGVhbih0aGlzLnByb3BzLnJlYWRPbmx5KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I9e2Vycm9yRmxhZ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgcm93c1tpXSl9PjwvRm9ybS5DaGVja2JveD47XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjb250cm9sID09IFwic3BhblwiKXtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gPHNwYW5cclxuICAgICAgICAgICAgICAgICAgICBrZXk9e2kgKyBcIl9cIiArIGp9IFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2NvbE5hbWV9ID57cm93c1tpXVtjb2xOYW1lXX08L3NwYW4+O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjb250cm9sID09IFwibnVtYmVyXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvd3NbaV1bY29sTmFtZV0gPT0gbnVsbCA/IFwiXCIgOiByb3dzW2ldW2NvbE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSA8Rm9ybS5JbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2kgKyBcIl9cIiArIGp9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtjb2xOYW1lfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yPXtlcnJvckZsYWd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtCb29sZWFuKHRoaXMucHJvcHMucmVhZE9ubHkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCByb3dzW2ldKX0+PC9Gb3JtLklucHV0PjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY29udHJvbCA9PSBcImRhdGVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcm93c1tpXVtjb2xOYW1lXSA9PSBudWxsID8gXCJcIiA6IHJvd3NbaV1bY29sTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IDxEYXRlUGlja2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aSArIFwiX1wiICsgan0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2NvbE5hbWV9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZGF0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yPXtlcnJvckZsYWd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9ybT17dHJ1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk9e0Jvb2xlYW4odGhpcy5wcm9wcy5yZWFkT25seSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMsIHJvd3NbaV0pfT48L0RhdGVQaWNrZXI+O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjb250cm9sID09IFwiZGF0ZXRpbWVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcm93c1tpXVtjb2xOYW1lXSA9PSBudWxsID8gXCJcIiA6IHJvd3NbaV1bY29sTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IDxEYXRlUGlja2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aSArIFwiX1wiICsgan0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2NvbE5hbWV9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZGF0ZXRpbWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcj17ZXJyb3JGbGFnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Zvcm09e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtCb29sZWFuKHRoaXMucHJvcHMucmVhZE9ubHkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCByb3dzW2ldKX0+PC9EYXRlUGlja2VyPjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY29udHJvbCA9PSBcImRyb3Bkb3duXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvd3NbaV1bY29sTmFtZV0gPT0gbnVsbCA/IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoQm9vbGVhbihjb2x1bW5zW2pdLm11bHRpcGxlKSA/IFtdIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByb3dzW2ldW2NvbE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSA8Rm9ybS5Ecm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2kgKyBcIl9cIiArIGp9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtjb2xOYW1lfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU9e0Jvb2xlYW4oY29sdW1uc1tqXS5tdWx0aXBsZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yPXtlcnJvckZsYWd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtCb29sZWFuKHRoaXMucHJvcHMucmVhZE9ubHkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCByb3dzW2ldKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uIGZsdWlkIHNlYXJjaD48L0Zvcm0uRHJvcGRvd24+O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjb250cm9sID09IFwiZmlsZVwiIHx8IGNvbnRyb2wgPT0gXCJmaWxlMlwiKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByb3dzW2ldW2NvbE5hbWVdID09IG51bGwgPyBcIlwiIDogcm93c1tpXVtjb2xOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gPFVwbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2kgKyBcIl9cIiArIGp9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtjb2xOYW1lfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I9e2Vycm9yRmxhZ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seT17Qm9vbGVhbih0aGlzLnByb3BzLnJlYWRPbmx5KX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgcm93c1tpXSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsPXt0aGlzLnByb3BzLmRvd25sb2FkVXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRVcmw9e3RoaXMucHJvcHMudXBsb2FkVXJsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Zvcm09e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVDbGVhckJ1dHRvbj17Y29udHJvbCA9PSBcImZpbGUyXCJ9ID48L1VwbG9hZD47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNvbnRyb2wgPT0gXCJjdXN0b21cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcm93c1tpXVtjb2xOYW1lXSA9PSBudWxsID8gXCJcIiA6IHJvd3NbaV1bY29sTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wcm9wcy5wbGFjZWhvbGRlcnMgIT0gdW5kZWZpbmVkICYmIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMucHJvcHMucGxhY2Vob2xkZXJzW2NvbE5hbWVdKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnBsYWNlaG9sZGVyc1tjb2xOYW1lXS5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5wcm9wcy5wbGFjZWhvbGRlcnNbY29sTmFtZV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1vZGVsICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5rZXkgPSBjb2xOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJvdyA9IHJvd3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5wcm9wcy5jcmVhdGVDb250cm9sKHRoaXMsIG1vZGVsW1wiZGF0YS1idWlsZGVydHlwZVwiXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLCBkYXRhOiByb3csIGVycm9yczogZXJyb3JPblJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJdGVtOiB0aGlzLnByb3BzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlcm1vZGU6IHRoaXMucHJvcHMuYnVpbGRlcm1vZGUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihhcmdzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJncy5ldmVudE5hbWUgPT0gXCJvbkNoYW5nZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhbmRsZUNoYW5nZShyb3csIGFyZ3Muc3ludGhldGljRXZlbnQsIHtuYW1lOiBhcmdzLm5hbWUsIHZhbHVlOiBhcmdzLnZhbHVlLCBjaGVja2VkOiBhcmdzLmNoZWNrZWR9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5oYW5kbGVDaGFuZ2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDogdGhpcy5wcm9wcy5nZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMucHJvcHMucmVhZE9ubHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkVXJsIDogdGhpcy5wcm9wcy51cGxvYWRVcmwsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsIDogdGhpcy5wcm9wcy5kb3dubG9hZFVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sc1RvUmVwbGFjZTogW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5wcm9wcy5idWlsZGVybW9kZSAmJiB0aGlzLnByb3BzLmNyZWF0ZUJ1aWxkZXJEcm9wem9uZSAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5wcm9wcy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUoY29sTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNleyBcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByb3dzW2ldW2NvbE5hbWVdID09IG51bGwgPyBcIlwiIDogcm93c1tpXVtjb2xOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gPEZvcm0uSW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpICsgXCJfXCIgKyBqfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17Y29sTmFtZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q9e2RhdGFMaXN0SWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yPXtlcnJvckZsYWd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtCb29sZWFuKHRoaXMucHJvcHMucmVhZE9ubHkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCByb3dzW2ldKX0+PC9Gb3JtLklucHV0PjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihqPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGV2ZWwgIT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gU3RyaW5nKGxldmVsICogMTUgKyA1KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKDx0ZCBrZXk9e2kgKyBcIl9cIiArIGogKyBcInRkXCJ9IHN0eWxlPXt7cGFkZGluZ0xlZnR9fT57ZXhwYW5kfXtkcmFnY29sfXtlbGVtZW50fTwvdGQ+KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCg8dGQga2V5PXtpICsgXCJfXCIgKyBqICsgXCJ0ZFwifT57ZWxlbWVudH08L3RkPik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFCb29sZWFuKHRoaXMucHJvcHMucmVhZE9ubHkpKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMucHJvcHMuaGllcmFyY2hpY2FsKXtcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCg8dGQga2V5PVwiY2VsbGRlbGV0ZVwiIGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItY2VsbGJ0blwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiBrZXk9XCJhZGRjaGlsZFwiIG9uQ2xpY2s9e3RoaXMuYnRuQWRkQ2hpbGQuYmluZCh0aGlzLCBpLCByb3dzKX0gbGluayBuYW1lPSdhZGQnIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiBrZXk9XCJkZWxldGVcIiBvbkNsaWNrPXt0aGlzLmJ0bkRlbGV0ZS5iaW5kKHRoaXMsIGksIHJvd3MpfSBsaW5rIG5hbWU9J2RlbGV0ZScgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90ZD4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCg8dGQga2V5PVwiY2VsbGRlbGV0ZVwiIGNsYXNzTmFtZT1cImR3a2l0LWNvbGxlY3Rpb25lZGl0b3ItY2VsbGJ0blwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiBrZXk9XCJkZWxldGVcIiBvbkNsaWNrPXt0aGlzLmJ0bkRlbGV0ZS5iaW5kKHRoaXMsIGksIHVuZGVmaW5lZCl9IGxpbmsgbmFtZT0nZGVsZXRlJyAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PjwvdGQ+KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmVzLnB1c2goPHRyIGtleT17cHJlZml4ICsgaX0gY2xhc3NOYW1lPVwiZHdraXQtY29sbGVjdGlvbmVkaXRvci1yb3dcIiBkYXRhLXJvd2luZGV4PXtpfT57cm93fTwvdHI+KTtcclxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGJ0bkRlbGV0ZShpbmRleCwgcm93cyl7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5vbkNoYW5nZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYocm93cyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByb3dzID0gdGhpcy5zdGF0ZS5kYXRhO1xyXG4gICAgICAgXHJcbiAgICAgICAgdmFyIG9iaiA9IHJvd3NbaW5kZXhdO1xyXG4gICAgICAgIHJvd3Muc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZW5kQ2hhbmdlc1RvUGFyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgYnRuQWRkQ2hpbGQoaW5kZXgsIHJvd3Mpe1xyXG4gICAgICAgIGlmKHJvd3MgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcm93cyA9IHRoaXMuc3RhdGUuZGF0YSA9PSB1bmRlZmluZWQgPyBbXSA6IHRoaXMuc3RhdGUuZGF0YWU7XHJcblxyXG4gICAgICAgIHZhciBvYmpQYXJlbnQgPSByb3dzW2luZGV4XTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5wcm9wcy5kZWZhdWx0cm93ID09IHVuZGVmaW5lZCA/IHt9IDogey4uLnRoaXMucHJvcHMuZGVmYXVsdHJvd307XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5wYXJlbnRJZEZpZWxkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5wYXJlbnRJZEZpZWxkICE9PSBcIlwiKXtcclxuICAgICAgICAgICAgb2JqW3RoaXMucHJvcHMucGFyZW50SWRGaWVsZF0gPSBvYmpQYXJlbnRbdGhpcy5wcm9wcy5pZEZpZWxkXTtcclxuICAgICAgICAgICAgcm93cy5wdXNoKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJvd3NbaW5kZXhdW3RoaXMucHJvcHMuY2hpbGRyZW5GaWVsZF0pKVxyXG4gICAgICAgICAgICAgICAgcm93c1tpbmRleF1bdGhpcy5wcm9wcy5jaGlsZHJlbkZpZWxkXSA9IFtdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcm93c1tpbmRleF1bdGhpcy5wcm9wcy5jaGlsZHJlbkZpZWxkXS5wdXNoKG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLmhhbmRsZUV2ZW50ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuaGFuZGxlRXZlbnQoe2tleTogdGhpcy5wcm9wcy5uYW1lLCBldmVudE5hbWU6IFwib25BZGRDaGlsZFwiLCBwYXJhbWV0ZXJzOiB7IHJvd0lkeDogcm93cy5sZW5ndGggLSAxLCByb3c6IG9iaiB9fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VuZENoYW5nZXNUb1BhcmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGJ0bkFkZCgpe1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLnByb3BzLmRlZmF1bHRyb3cgPT0gdW5kZWZpbmVkID8ge30gOiB0aGlzLnByb3BzLmRlZmF1bHRyb3c7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLnB1c2gob2JqKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5oYW5kbGVFdmVudCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLmhhbmRsZUV2ZW50KHtrZXk6IHRoaXMucHJvcHMubmFtZSwgZXZlbnROYW1lOiBcIm9uQWRkXCIsIHBhcmFtZXRlcnM6IHsgcm93SWR4OiB0aGlzLnN0YXRlLmRhdGEubGVuZ3RoIC0gMSwgcm93OiBvYmogfX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZW5kQ2hhbmdlc1RvUGFyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25FeHBhbmQoaSwgdmFsdWUpe1xyXG4gICAgICB0aGlzLnN0YXRlLmV4cGFuZGVkW2ldID0gdmFsdWU7XHJcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWdPdmVyKGUpe1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgb25EcmFnU3RhcnQoaW5kZXgsIHJvd3MsIGUpe1xyXG4gICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YSgnaW5kZXgnLCBpbmRleCk7IFxyXG4gICAgICAgdGhpcy5zdGF0ZS5kcmFnRWxlbWVudEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICB0aGlzLnN0YXRlLmRyYWdSb3dzID0gcm93cztcclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWdFbmQoaW5kZXgsIGUpe1xyXG4gICAgICAgIHRoaXMuc3RhdGUuZHJhZ0VsZW1lbnRJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0YXRlLmRyYWdSb3dzID0gdW5kZWZpbmVkO1xyXG4gICAgIH1cclxuXHJcbiAgICBvbkRyb3AoaW5kZXgsIHJvd3MsIGUpe1xyXG4gICAgICAgIHZhciByb3dJbmRleEEgPSB0aGlzLnN0YXRlLmRyYWdFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdmFyIHJvd3NBID0gdGhpcy5zdGF0ZS5kcmFnUm93cztcclxuICAgICAgICB2YXIgcm93SW5kZXhCID0gaW5kZXg7XHJcbiAgICAgICAgdmFyIHJvd3NCID0gcm93cztcclxuICAgICAgICBpZihyb3dJbmRleEEgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaWYocm93SW5kZXhCICE9IHJvd0luZGV4QSl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnByb3BzLnBhcmVudElkRmllbGQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzLnBhcmVudElkRmllbGQgIT09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd3NBW3Jvd0luZGV4QV1bdGhpcy5wcm9wcy5wYXJlbnRJZEZpZWxkXSA9IHJvd3NCW3Jvd0luZGV4Ql1bdGhpcy5wcm9wcy5wYXJlbnRJZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd3NCLnNwbGljZShyb3dJbmRleEIsIDAsIHJvd3NBLnNwbGljZShyb3dJbmRleEEsIDEpWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENoYW5nZXNUb1BhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUNoYW5nZShpdGVtLCBlLCB7bmFtZSwgdmFsdWUsIGNoZWNrZWR9KXtcclxuICAgICAgICBpZih0aGlzLnByb3BzLm9uQ2hhbmdlID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgXHJcbiAgICAgICAgaWYodmFsdWUgPT0gdW5kZWZpbmVkICYmIGNoZWNrZWQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaXRlbVtuYW1lXSA9IGNoZWNrZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaXRlbVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNlbmRDaGFuZ2VzVG9QYXJlbnQoKTtcclxuXHJcbiAgICAgICAgaWYoZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb3B5Um93c0Zyb21Qcm9wcygpe1xyXG4gICAgICAgIHZhciByb3dzID0gdGhpcy5wcm9wcy52YWx1ZSA9PSB1bmRlZmluZWQgPyBbXSA6IHRoaXMucHJvcHMudmFsdWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zdHJpbmdtb2RlID0gZmFsc2U7XHJcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkocm93cykpe1xyXG4gICAgICAgICAgICByb3dzID0gSlNPTjUucGFyc2Uocm93cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RyaW5nbW9kZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcm93cztcclxuICAgIH1cclxuXHJcbiAgICBzZW5kQ2hhbmdlc1RvUGFyZW50KCl7XHJcbiAgICAgICAgbGV0IHJvd3MgPSB0aGlzLnN0YXRlLmRhdGE7XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuc3RhdGUuc3RyaW5nbW9kZSA/IEpTT041LnN0cmluZ2lmeShyb3dzKSA6IHJvd3M7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShudWxsLCB7bmFtZTogdGhpcy5wcm9wcy5uYW1lLCB2YWx1ZTogcmVzfSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udHJvbC9jb2xsZWN0aW9uZWRpdG9yLmpzeCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibW9tZW50XCJcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWZsdXggPSByZXF1aXJlKCdyZWZsdXgtY29yZScpO1xyXG5cclxuUmVmbHV4LnNlcnZlck1vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JztcclxuXHJcblJlZmx1eC5jb25uZWN0ID0gcmVxdWlyZSgnLi9jb25uZWN0Jyk7XHJcblxyXG5SZWZsdXguY29ubmVjdEZpbHRlciA9IHJlcXVpcmUoJy4vY29ubmVjdEZpbHRlcicpO1xyXG5cclxuUmVmbHV4Lkxpc3RlbmVyTWl4aW4gPSByZXF1aXJlKCcuL0xpc3RlbmVyTWl4aW4nKTtcclxuXHJcblJlZmx1eC5saXN0ZW5UbyA9IHJlcXVpcmUoJy4vbGlzdGVuVG8nKTtcclxuXHJcblJlZmx1eC5saXN0ZW5Ub01hbnkgPSByZXF1aXJlKCcuL2xpc3RlblRvTWFueScpO1xyXG5cclxucmVxdWlyZSgnLi9hZGRFUzYnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVmbHV4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvQWN0aW9uTWV0aG9kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RhdGljSm9pbkNyZWF0b3IgPSBzdGF0aWNKb2luQ3JlYXRvcjtcbmV4cG9ydHMuaW5zdGFuY2VKb2luQ3JlYXRvciA9IGluc3RhbmNlSm9pbkNyZWF0b3I7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKFwiLi9jcmVhdGVTdG9yZVwiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgXyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxyXG4gKiBJbnRlcm5hbCBtb2R1bGUgdXNlZCB0byBjcmVhdGUgc3RhdGljIGFuZCBpbnN0YW5jZSBqb2luIG1ldGhvZHNcclxuICovXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICBzdHJhdGVneU1ldGhvZE5hbWVzID0ge1xuICAgIHN0cmljdDogXCJqb2luU3RyaWN0XCIsXG4gICAgZmlyc3Q6IFwiam9pbkxlYWRpbmdcIixcbiAgICBsYXN0OiBcImpvaW5UcmFpbGluZ1wiLFxuICAgIGFsbDogXCJqb2luQ29uY2F0XCJcbn07XG5cbi8qKlxyXG4gKiBVc2VkIGluIGBpbmRleC5qc2AgdG8gY3JlYXRlIHRoZSBzdGF0aWMgam9pbiBtZXRob2RzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJhdGVneSBXaGljaCBzdHJhdGVneSB0byB1c2Ugd2hlbiB0cmFja2luZyBsaXN0ZW5hYmxlIHRyaWdnZXIgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHN0b3JlIHdpdGggYSBqb2luIGxpc3RlbiBvbiB0aGUgZ2l2ZW4gbGlzdGVuYWJsZXMgdXNpbmcgdGhlIGdpdmVuIHN0cmF0ZWd5XHJcbiAqL1xuZnVuY3Rpb24gc3RhdGljSm9pbkNyZWF0b3Ioc3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgLyogbGlzdGVuYWJsZXMuLi4gKi97XG4gICAgICAgIHZhciBsaXN0ZW5hYmxlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuICgwLCBfY3JlYXRlU3RvcmUuY3JlYXRlU3RvcmUpKHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzdHJhdGVneU1ldGhvZE5hbWVzW3N0cmF0ZWd5XV0uYXBwbHkodGhpcywgbGlzdGVuYWJsZXMuY29uY2F0KFwidHJpZ2dlckFzeW5jXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXHJcbiAqIFVzZWQgaW4gYExpc3RlbmVyTWV0aG9kcy5qc2AgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBqb2luIG1ldGhvZHNcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmF0ZWd5IFdoaWNoIHN0cmF0ZWd5IHRvIHVzZSB3aGVuIHRyYWNraW5nIGxpc3RlbmFibGUgdHJpZ2dlciBhcmd1bWVudHNcclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBbiBpbnN0YW5jZSBtZXRob2Qgd2hpY2ggc2V0cyB1cCBhIGpvaW4gbGlzdGVuIG9uIHRoZSBnaXZlbiBsaXN0ZW5hYmxlcyB1c2luZyB0aGUgZ2l2ZW4gc3RyYXRlZ3lcclxuICovXG5mdW5jdGlvbiBpbnN0YW5jZUpvaW5DcmVhdG9yKHN0cmF0ZWd5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIC8qIGxpc3RlbmFibGVzLi4uLCBjYWxsYmFjayove1xuICAgICAgICBfLnRocm93SWYoYXJndW1lbnRzLmxlbmd0aCA8IDIsIFwiQ2Fubm90IGNyZWF0ZSBhIGpvaW4gd2l0aCBsZXNzIHRoYW4gMiBsaXN0ZW5hYmxlcyFcIik7XG4gICAgICAgIHZhciBsaXN0ZW5hYmxlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbGlzdGVuYWJsZXMucG9wKCksXG4gICAgICAgICAgICBudW1iZXJPZkxpc3RlbmFibGVzID0gbGlzdGVuYWJsZXMubGVuZ3RoLFxuICAgICAgICAgICAgam9pbiA9IHtcbiAgICAgICAgICAgIG51bWJlck9mTGlzdGVuYWJsZXM6IG51bWJlck9mTGlzdGVuYWJsZXMsXG4gICAgICAgICAgICBjYWxsYmFjazogdGhpc1tjYWxsYmFja10gfHwgY2FsbGJhY2ssXG4gICAgICAgICAgICBsaXN0ZW5lcjogdGhpcyxcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgICAgICB9LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGNhbmNlbHMgPSBbXSxcbiAgICAgICAgICAgIHN1Ym9iajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mTGlzdGVuYWJsZXM7IGkrKykge1xuICAgICAgICAgICAgXy50aHJvd0lmKHRoaXMudmFsaWRhdGVMaXN0ZW5pbmcobGlzdGVuYWJsZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZMaXN0ZW5hYmxlczsgaSsrKSB7XG4gICAgICAgICAgICBjYW5jZWxzLnB1c2gobGlzdGVuYWJsZXNbaV0ubGlzdGVuKG5ld0xpc3RlbmVyKGksIGpvaW4pLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoam9pbik7XG4gICAgICAgIHN1Ym9iaiA9IHsgbGlzdGVuYWJsZTogbGlzdGVuYWJsZXMgfTtcbiAgICAgICAgc3Vib2JqLnN0b3AgPSBtYWtlU3RvcHBlcihzdWJvYmosIGNhbmNlbHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAodGhpcy5zdWJzY3JpcHRpb25zIHx8IFtdKS5jb25jYXQoc3Vib2JqKTtcbiAgICAgICAgcmV0dXJuIHN1Ym9iajtcbiAgICB9O1xufVxuXG4vLyAtLS0tIGludGVybmFsIGpvaW4gZnVuY3Rpb25zIC0tLS1cblxuZnVuY3Rpb24gbWFrZVN0b3BwZXIoc3Vib2JqLCBjYW5jZWxzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBzdWJzID0gY29udGV4dC5zdWJzY3JpcHRpb25zLFxuICAgICAgICAgICAgaW5kZXggPSBzdWJzID8gc3Vicy5pbmRleE9mKHN1Ym9iaikgOiAtMTtcbiAgICAgICAgXy50aHJvd0lmKGluZGV4ID09PSAtMSwgXCJUcmllZCB0byByZW1vdmUgam9pbiBhbHJlYWR5IGdvbmUgZnJvbSBzdWJzY3JpcHRpb25zIGxpc3QhXCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FuY2Vscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FuY2Vsc1tpXSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiByZXNldChqb2luKSB7XG4gICAgam9pbi5saXN0ZW5hYmxlc0VtaXR0ZWQgPSBuZXcgQXJyYXkoam9pbi5udW1iZXJPZkxpc3RlbmFibGVzKTtcbiAgICBqb2luLmFyZ3MgPSBuZXcgQXJyYXkoam9pbi5udW1iZXJPZkxpc3RlbmFibGVzKTtcbn1cblxuZnVuY3Rpb24gbmV3TGlzdGVuZXIoaSwgam9pbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGpvaW4ubGlzdGVuYWJsZXNFbWl0dGVkW2ldKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGpvaW4uc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmljdCBqb2luIGZhaWxlZCBiZWNhdXNlIGxpc3RlbmVyIHRyaWdnZXJlZCB0d2ljZS5cIik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxhc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgam9pbi5hcmdzW2ldID0gY2FsbGFyZ3M7YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgICAgICAgICAgICAgICBqb2luLmFyZ3NbaV0ucHVzaChjYWxsYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqb2luLmxpc3RlbmFibGVzRW1pdHRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICBqb2luLmFyZ3NbaV0gPSBqb2luLnN0cmF0ZWd5ID09PSBcImFsbFwiID8gW2NhbGxhcmdzXSA6IGNhbGxhcmdzO1xuICAgICAgICB9XG4gICAgICAgIGVtaXRJZkFsbExpc3RlbmFibGVzRW1pdHRlZChqb2luKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBlbWl0SWZBbGxMaXN0ZW5hYmxlc0VtaXR0ZWQoam9pbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgam9pbi5udW1iZXJPZkxpc3RlbmFibGVzOyBpKyspIHtcbiAgICAgICAgaWYgKCFqb2luLmxpc3RlbmFibGVzRW1pdHRlZFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGpvaW4uY2FsbGJhY2suYXBwbHkoam9pbi5saXN0ZW5lciwgam9pbi5hcmdzKTtcbiAgICByZXNldChqb2luKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvam9pbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX0tlZXAgPSByZXF1aXJlKFwiLi9LZWVwXCIpO1xuXG52YXIgS2VlcCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9LZWVwKTtcblxudmFyIF9taXhlciA9IHJlcXVpcmUoXCIuL21peGVyXCIpO1xuXG52YXIgX2JpbmRNZXRob2RzID0gcmVxdWlyZShcIi4vYmluZE1ldGhvZHNcIik7XG5cbnZhciBfU3RvcmVNZXRob2RzID0gcmVxdWlyZShcIi4vU3RvcmVNZXRob2RzXCIpO1xuXG52YXIgU3RvcmVNZXRob2RzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1N0b3JlTWV0aG9kcyk7XG5cbnZhciBfUHVibGlzaGVyTWV0aG9kcyA9IHJlcXVpcmUoXCIuL1B1Ymxpc2hlck1ldGhvZHNcIik7XG5cbnZhciBQdWJsaXNoZXJNZXRob2RzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1B1Ymxpc2hlck1ldGhvZHMpO1xuXG52YXIgX0xpc3RlbmVyTWV0aG9kcyA9IHJlcXVpcmUoXCIuL0xpc3RlbmVyTWV0aG9kc1wiKTtcblxudmFyIExpc3RlbmVyTWV0aG9kcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9MaXN0ZW5lck1ldGhvZHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgYWxsb3dlZCA9IHsgcHJlRW1pdDogMSwgc2hvdWxkRW1pdDogMSB9O1xuXG4vKipcclxuICogQ3JlYXRlcyBhbiBldmVudCBlbWl0dGluZyBEYXRhIFN0b3JlLiBJdCBpcyBtaXhlZCBpbiB3aXRoIGZ1bmN0aW9uc1xyXG4gKiBmcm9tIHRoZSBgTGlzdGVuZXJNZXRob2RzYCBhbmQgYFB1Ymxpc2hlck1ldGhvZHNgIG1peGlucy4gYHByZUVtaXRgXHJcbiAqIGFuZCBgc2hvdWxkRW1pdGAgbWF5IGJlIG92ZXJyaWRkZW4gaW4gdGhlIGRlZmluaXRpb24gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBUaGUgZGF0YSBzdG9yZSBvYmplY3QgZGVmaW5pdGlvblxyXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgZGF0YSBzdG9yZSBpbnN0YW5jZVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGRlZmluaXRpb24pIHtcblxuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uIHx8IHt9O1xuXG4gICAgZm9yICh2YXIgYSBpbiBTdG9yZU1ldGhvZHMpIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkW2FdICYmIChQdWJsaXNoZXJNZXRob2RzW2FdIHx8IExpc3RlbmVyTWV0aG9kc1thXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBvdmVycmlkZSBBUEkgbWV0aG9kIFwiICsgYSArIFwiIGluIFJlZmx1eC5TdG9yZU1ldGhvZHMuIFVzZSBhbm90aGVyIG1ldGhvZCBuYW1lIG9yIG92ZXJyaWRlIGl0IG9uIFJlZmx1eC5QdWJsaXNoZXJNZXRob2RzIC8gUmVmbHV4Lkxpc3RlbmVyTWV0aG9kcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGQgaW4gZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoIWFsbG93ZWRbZF0gJiYgKFB1Ymxpc2hlck1ldGhvZHNbZF0gfHwgTGlzdGVuZXJNZXRob2RzW2RdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG92ZXJyaWRlIEFQSSBtZXRob2QgXCIgKyBkICsgXCIgaW4gc3RvcmUgY3JlYXRpb24uIFVzZSBhbm90aGVyIG1ldGhvZCBuYW1lIG9yIG92ZXJyaWRlIGl0IG9uIFJlZmx1eC5QdWJsaXNoZXJNZXRob2RzIC8gUmVmbHV4Lkxpc3RlbmVyTWV0aG9kcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZmluaXRpb24gPSAoMCwgX21peGVyLm1peCkoZGVmaW5pdGlvbik7XG5cbiAgICBmdW5jdGlvbiBTdG9yZSgpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgYXJyO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IF8uRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZXZlbnRMYWJlbCA9IFwiY2hhbmdlXCI7XG4gICAgICAgICgwLCBfYmluZE1ldGhvZHMuYmluZE1ldGhvZHMpKHRoaXMsIGRlZmluaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5pbml0ICYmIF8uaXNGdW5jdGlvbih0aGlzLmluaXQpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saXN0ZW5hYmxlcykge1xuICAgICAgICAgICAgYXJyID0gW10uY29uY2F0KHRoaXMubGlzdGVuYWJsZXMpO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvTWFueShhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgXy5leHRlbmQoU3RvcmUucHJvdG90eXBlLCBMaXN0ZW5lck1ldGhvZHMsIFB1Ymxpc2hlck1ldGhvZHMsIFN0b3JlTWV0aG9kcywgZGVmaW5pdGlvbik7XG5cbiAgICB2YXIgc3RvcmUgPSBuZXcgU3RvcmUoKTtcbiAgICBLZWVwLmFkZFN0b3JlKHN0b3JlKTtcblxuICAgIHJldHVybiBzdG9yZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvY3JlYXRlU3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZmx1eC1jb3JlL2xpYi9TdG9yZU1ldGhvZHMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7TWVudSwgRm9ybSwgR3JpZCwgQ2FyZCwgSW5wdXQsIERyb3Bkb3duLCBDaGVja2JveCwgVGV4dEFyZWEsIEJ1dHRvbiwgSWNvbiwgTWVzc2FnZSwgSW1hZ2UsIExhYmVsLCBIZWFkZXIsIEl0ZW0sIFNlZ21lbnQsIE1vZGFsfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuaW1wb3J0IENvbGxlY3Rpb25FZGl0b3IgZnJvbSAnLi9jb250cm9sL2NvbGxlY3Rpb25lZGl0b3InXHJcbmltcG9ydCBKU09ONSBmcm9tICdqc29uNSdcclxuaW1wb3J0IEV2ZW50c0VkaXRvciBmcm9tICcuL2NvbnRyb2wvZXZlbnRzZWRpdG9yJ1xyXG5pbXBvcnQgUmFkaW9Hcm91cCBmcm9tICcuL2NvbnRyb2wvcmFkaW9ncm91cCdcclxuXHJcblxyXG4vLy0tLS0tLUVkaXQgRm9ybS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY2xhc3MgQmFzZUVkaXRDb250cm9sIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBhY3RpdmVJdGVtOiAnZ2VuZXJhbCdcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tZW51SXRlbXMgPSBbXHJcbiAgICAgICAge2tleTonZ2VuZXJhbCcsIG5hbWU6J2dlbmVyYWwnLCBjb250ZW50OiB0aGlzLmdldExvY2FsVmFsdWUoJ2dlbmVyYWx0YWInLCAnR2VuZXJhbCcpLCAgYWN0aXZlOiB0cnVlLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUl0ZW1DbGljay5iaW5kKHRoaXMpfSxcclxuICAgICAgICB7a2V5OidzdHlsZScsIG5hbWU6J3N0eWxlJywgY29udGVudDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzdHlsZXRhYicsICdTdHlsZScpLCBhY3RpdmU6IGZhbHNlLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUl0ZW1DbGljay5iaW5kKHRoaXMpfSxcclxuICAgICAgICB7a2V5OidldmVudHMnLCBuYW1lOidldmVudHMnLCBjb250ZW50OiB0aGlzLmdldExvY2FsVmFsdWUoJ2V2ZW50c3RhYicsICdFdmVudHMnKSwgIGFjdGl2ZTogZmFsc2UsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlSXRlbUNsaWNrLmJpbmQodGhpcyl9LFxyXG4gICAgICAgIHtrZXk6J290aGVyJywgbmFtZTonb3RoZXInLCBjb250ZW50OiB0aGlzLmdldExvY2FsVmFsdWUoJ290aGVydGFiJywgJ090aGVyJyksIGFjdGl2ZTogZmFsc2UsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlSXRlbUNsaWNrLmJpbmQodGhpcyl9XHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgZ2V0TG9jYWxWYWx1ZShrZXksIGRlZmF1bHR2YWx1ZSwgZm9ybW5hbWUpe1xyXG4gICAgdmFyIGxvY2FsID0gdGhpcy5wcm9wcy5sb2NhbGl6YXRpb247XHJcbiAgICB2YXIgYmxvY2sgPSBmb3JtbmFtZSAhPSB1bmRlZmluZWQgPyBmb3JtbmFtZSA6IFwiYmFzZVwiO1xyXG5cclxuICAgIGlmKGxvY2FsID09IHVuZGVmaW5lZCB8fCBsb2NhbFtibG9ja10gPT0gdW5kZWZpbmVkIHx8ICBsb2NhbFtibG9ja11ba2V5XSA9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBkZWZhdWx0dmFsdWU7XHJcbiAgICByZXR1cm4gbG9jYWxbYmxvY2tdW2tleV07XHJcbiAgfVxyXG5cclxuICBoYW5kbGVJdGVtQ2xpY2soZSwgeyBuYW1lIH0pe1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZUl0ZW06IG5hbWUgfSk7IFxyXG4gIH1cclxuXHJcbiAgZ2V0RGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5zdGF0ZS5hY3RpdmVJdGVtO1xyXG4gICAgXHJcbiAgICB0aGlzLm1lbnVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIGl0ZW0uYWN0aXZlID0gaXRlbS5uYW1lID09PSBhY3RpdmVJdGVtO1xyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gKDxNb2RhbC5EZXNjcmlwdGlvbj5cclxuICAgICAgICAgICAgICA8TWVudSBrZXk9XCJkZXNjcmlwdGlvbk1lbnVcIiBwb2ludGluZyBzZWNvbmRhcnkgaXRlbXM9e3RoaXMubWVudUl0ZW1zfS8+XHJcbiAgICAgICAgICAgICAge3RoaXMuZ2V0RGV0YWlsRGVzY3JpcHRpb24oYWN0aXZlSXRlbSl9XHJcbiAgICAgICAgICAgIDwvTW9kYWwuRGVzY3JpcHRpb24+KTtcclxuICB9XHJcblxyXG4gIGdldERldGFpbERlc2NyaXB0aW9uKGFjdGl2ZUl0ZW0pe1xyXG4gICAgdmFyIHNlZ21lbnQ7XHJcblxyXG4gICAgaWYoYWN0aXZlSXRlbSA9PT0gJ2dlbmVyYWwnKVxyXG4gICAgICBzZWdtZW50ID0gdGhpcy5nZXRHZW5lcmFsRGVzY3JpcHRpb24oKTtcclxuICAgIGVsc2UgaWYoYWN0aXZlSXRlbSA9PT0gJ3N0eWxlJylcclxuICAgICAgIHNlZ21lbnQgPSB0aGlzLmdldFN0eWxlRGVzY3JpcHRpb24oKTtcclxuICAgIGVsc2UgaWYoYWN0aXZlSXRlbSA9PT0gJ2V2ZW50cycpXHJcbiAgICAgICBzZWdtZW50ID0gdGhpcy5nZXRFdmVudHNEZXNjcmlwdGlvbigpO1xyXG4gICAgZWxzZSBpZihhY3RpdmVJdGVtID09PSAnb3RoZXInKVxyXG4gICAgICAgc2VnbWVudCA9IHRoaXMuZ2V0T3RoZXJEZXNjcmlwdGlvbigpO1xyXG5cclxuICAgIHJldHVybiBzZWdtZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHJldHVybiAoPEZvcm0ga2V5PVwiZ2VuZXJhbERlc2NyaXB0aW9uRm9ybVwiPlxyXG4gICAgICAgIDxGb3JtLklucHV0IGtleT1cIm5hbWVcIiBsYWJlbD1cIk5hbWVcIiBuYW1lPVwia2V5XCIgdmFsdWU9e2RhdGEua2V5fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldFN0eWxlRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBzdHlsZXNvdXJjZV9wcyA9IFwiLyoqKiBFeGFtcGxlIENvZGUgKioqL1xcbmNvbG9yOnJlZDtcXG5wYWRkaW5nVG9wOjVweDtcIjtcclxuICAgIHJldHVybiAoPEZvcm0ga2V5PVwic3R5bGVEZXNjcmlwdGlvbkZvcm1cIj5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiID5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJzdHlsZS13aWR0aFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3dpZHRoZmllbGQnLCAnV2lkdGgnKX0gcGxhY2Vob2xkZXI9XCIxMDBweFwiIHZhbHVlPXtkYXRhW1wic3R5bGUtd2lkdGhcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwic3R5bGUtaGVpZ2h0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaGVpZ2h0ZmllbGQnLCAnSGVpZ2h0Jyl9IHBsYWNlaG9sZGVyPVwiMTAwcHhcIiB2YWx1ZT17ZGF0YVtcInN0eWxlLWhlaWdodFwiXX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJzdHlsZS1tYXJnaW5Ub3BcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtYXJnaW50b3BmaWVsZCcsICdNYXJnaW4gVG9wJyl9IHBsYWNlaG9sZGVyPVwiMHB4XCIgdmFsdWU9e2RhdGFbXCJzdHlsZS1tYXJnaW5Ub3BcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwic3R5bGUtbWFyZ2luQm90dG9tXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbWFyZ2luYm90dG9tZmllbGQnLCAnTWFyZ2luIEJvdHRvbScpfSBwbGFjZWhvbGRlcj1cIjBweFwiIHZhbHVlPXtkYXRhW1wic3R5bGUtbWFyZ2luQm90dG9tXCJdfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInN0eWxlLW1hcmdpbkxlZnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtYXJnaW5sZWZ0ZmllbGQnLCAnTWFyZ2luIExlZnQnKX0gcGxhY2Vob2xkZXI9XCIwcHhcIiB2YWx1ZT17ZGF0YVtcInN0eWxlLW1hcmdpbkxlZnRcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwic3R5bGUtbWFyZ2luUmlnaHRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtYXJnaW5yaWdodGZpZWxkJywgJ01hcmdpbiBSaWdodCcpfSBwbGFjZWhvbGRlcj1cIjBweFwiIHZhbHVlPXtkYXRhW1wic3R5bGUtbWFyZ2luUmlnaHRcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJzdHlsZS1jdXN0b21jc3NcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjdXN0b21jc3NjbGFzc2ZpZWxkJywgJ0N1c3RvbSBDU1MgY2xhc3MnKX0gcGxhY2Vob2xkZXI9XCJkd2tpdC1hcHBsaWNhdGlvbi1jc3MgKHdpdGhvdXQgJy4nKVwiIHZhbHVlPXtkYXRhW1wic3R5bGUtY3VzdG9tY3NzXCJdfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDxGb3JtLlRleHRBcmVhIG5hbWU9XCJzdHlsZS1zb3VyY2VcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzdHlsZWZpZWxkJywgJ1N0eWxlJyl9IHBsYWNlaG9sZGVyPXtzdHlsZXNvdXJjZV9wc30gdmFsdWU9e2RhdGFbXCJzdHlsZS1zb3VyY2VcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInN0eWxlLWhpZGRlblwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2hpZGRlbmZpZWxkJywgJ0hpZGRlbicpfSBjaGVja2VkPXtkYXRhW1wic3R5bGUtaGlkZGVuXCJdfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgZ2V0RXZlbnRzRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgXHJcbiAgICBpZihkYXRhLmV2ZW50cyA9PSB1bmRlZmluZWQpXHJcbiAgICAgIGRhdGEuZXZlbnRzID0ge307XHJcbiAgICBcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7IFxyXG4gICAgXHJcbiAgICB2YXIgYWN0aW9ucyA9IHRoaXMucHJvcHMuYWN0aW9ucztcclxuICAgIHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50c0xpc3QoKTtcclxuICAgIHZhciBjb250ZW50O1xyXG4gICAgaWYoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSB8fCBldmVudHMubGVuZ3RoID09IDApe1xyXG4gICAgICBjb250ZW50ID0gPE1lc3NhZ2UgaWNvbj5cclxuICAgICAgICAgIDxJbWFnZSBzcmM9Jy9pbWFnZXMvZHdraXRidWlsZGVyLWluZm8ucG5nJyBoZWlnaHQ9XCIzMnB4XCIvPlxyXG4gICAgICAgICAgPE1lc3NhZ2UuQ29udGVudD5cclxuICAgICAgICAgIHt0aGlzLmdldExvY2FsVmFsdWUoJ2NvbnRyb2xoYXNub2V2ZW50c21zZycsICdUaGlzIGNvbnRyb2wgaGFzIG5vIGV2ZW50cy4nKX1cclxuICAgICAgICAgIDwvTWVzc2FnZS5Db250ZW50PlxyXG4gICAgICAgIDwvTWVzc2FnZT47XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICB2YXIgY29udHJvbHNPbkZvcm0gPSB0aGlzLnByb3BzLnBhcmVudC5nZXRDb250cm9sc0xpc3QoKTtcclxuICAgICAgdmFyIGxpc3RDb250cm9scyA9IFtdO1xyXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IGNvbnRyb2xzT25Gb3JtLmxlbmd0aDsgaSsrICl7XHJcbiAgICAgICAgaWYoZGF0YS5rZXkgPT0gY29udHJvbHNPbkZvcm1baV0pIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGlzdENvbnRyb2xzLnB1c2goe3RleHQ6IGNvbnRyb2xzT25Gb3JtW2ldLCB2YWx1ZTogY29udHJvbHNPbkZvcm1baV19KTtcclxuICAgICAgfVxyXG4gICAgICBjb250ZW50ID0gPEV2ZW50c0VkaXRvclxyXG4gICAgICAgIGtleT1cImV2ZW50c1wiIG5hbWU9XCJldmVudHNcIlxyXG4gICAgICAgIGRhdGE9e2RhdGEuZXZlbnRzfVxyXG4gICAgICAgIGV2ZW50cz17ZXZlbnRzfVxyXG4gICAgICAgIGFjdGlvbnM9e2FjdGlvbnN9XHJcbiAgICAgICAgdGFyZ2V0cz17bGlzdENvbnRyb2xzfVxyXG4gICAgICAgIG9uQWRkaXRpb25BY3Rpb25zPXt0aGlzLmhhbmRsZUFkZGl0aW9uQWN0aW9ucy5iaW5kKHRoaXMpfVxyXG4gICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+O1xyXG4gICAgfVxyXG4gICAgICBsZXQgdGltZW90ID0gbnVsbDtcclxuICAgICAgaWYgKGV2ZW50cy5pbmNsdWRlcyhcIm9uQ2hhbmdlXCIpKSB7XHJcbiAgICAgICAgICB0aW1lb3QgPSA8Rm9ybS5JbnB1dCBuYW1lPVwib25DaGFuZ2VUaW1lb3V0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e3dpZHRoOjEwMH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e1wiMFwifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e1wibnVtYmVyXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZShcIm9uY2hhbmdldGltZW91dFwiLFwib25DaGFuZ2UgdGltZW91dFwiKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZGF0YS5vbkNoYW5nZVRpbWVvdXR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9Lz47XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuICg8Rm9ybSBrZXk9XCJldmVudHNEZXNjcmlwdGlvbkZvcm1cIj5cclxuICAgICAgICA8TWVzc2FnZSBpY29uPlxyXG4gICAgICAgICAgPEltYWdlIHNyYz0nL2ltYWdlcy9kd2tpdGJ1aWxkZXItaW5mby5wbmcnIGhlaWdodD1cIjMycHhcIi8+XHJcbiAgICAgICAgICA8TWVzc2FnZS5Db250ZW50PlxyXG4gICAgICAgICAgICB7dGhpcy5nZXRMb2NhbFZhbHVlKCdldmVudHNpbmZvbXNnJywgJ1RoZXNlIGZsYWdzIGVuYWJsZSBwcm9jZXNzaW5nIGZyb20gdGhpcyBlbGVtZW50LicpfVxyXG4gICAgICAgICAgPC9NZXNzYWdlLkNvbnRlbnQ+XHJcbiAgICAgICAgPC9NZXNzYWdlPlxyXG4gICAgICAgIHt0aW1lb3R9XHJcbiAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0T3RoZXJEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGN1c3RvbXZhbGlkYXRpb25fcHMgPSBcIi8qKiogRXhhbXBsZSBDb2RlICoqKi9cXG52YWx1ZSA+IDEwID8gdHJ1ZSA6ICdNdXN0IGJlIG1vcmUgMTAnXCI7XHJcbiAgICB2YXIgdmlzaWJsZWNvbml0aW9uX3BzID0gXCIvKioqIEV4YW1wbGUgQ29kZSAqKiovXFxuZGF0YS50eXBlID09IDEgPyB0cnVlIDogZmFsc2VcIjtcclxuICAgIHZhciByZWFkT25seWNvbml0aW9uX3BzID0gXCIvKioqIEV4YW1wbGUgQ29kZSAqKiovXFxuZGF0YS50eXBlID09IDEgPyB0cnVlIDogZmFsc2VcIjtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtIGtleT1cIm90aGVyRGVzY3JpcHRpb25Gb3JtXCI+XHJcbiAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cIm90aGVyLXJlcXVpcmVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVxdWlyZWRmaWVsZCcsICdSZXF1aXJlZCcpfSBjaGVja2VkPXtkYXRhW1wib3RoZXItcmVxdWlyZWRcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImRlZmF1bHRWYWx1ZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2RlZmF1bHR2YWx1ZWZpZWxkJywgJ0RlZmF1bHQgdmFsdWUnKX0gdmFsdWU9e2RhdGFbXCJkZWZhdWx0VmFsdWVcIl19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPEZvcm0uVGV4dEFyZWEgbmFtZT1cIm90aGVyLWN1c3RvbVZhbGlkYXRpb25cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjdXN0b212YWxpZGF0aW9uZmllbGQnLCAnQ3VzdG9tIFZhbGlkYXRpb24nKX0gcGxhY2Vob2xkZXI9e2N1c3RvbXZhbGlkYXRpb25fcHN9IHZhbHVlPXtkYXRhW1wib3RoZXItY3VzdG9tVmFsaWRhdGlvblwiXX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8Rm9ybS5UZXh0QXJlYSBuYW1lPVwib3RoZXItdmlzaWJsZUNvbml0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndmlzaWJsZWNvbmRpdGlvbmZpZWxkJywgJ1Zpc2libGUgY29uZGl0aW9uJyl9IHBsYWNlaG9sZGVyPXt2aXNpYmxlY29uaXRpb25fcHN9IHZhbHVlPXtkYXRhW1wib3RoZXItdmlzaWJsZUNvbml0aW9uXCJdfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDxGb3JtLlRleHRBcmVhIG5hbWU9XCJvdGhlci1yZWFkT25seUNvbml0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVhZG9ubHljb25kaXRpb25maWVsZCcsICdSZWFkT25seSBjb25kaXRpb24nKX0gcGxhY2Vob2xkZXI9e3JlYWRPbmx5Y29uaXRpb25fcHN9IHZhbHVlPXtkYXRhW1wib3RoZXItcmVhZE9ubHlDb25pdGlvblwiXX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8TW9kYWwgZGltbWVyPSdpbnZlcnRlZCcgb3Blbj17dGhpcy5wcm9wcy5vcGVufSBvbkNsb3NlPXt0aGlzLnByb3BzLm9uQ2xvc2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCl9PlxyXG4gICAgICAgICAgPE1vZGFsLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgIDxNb2RhbC5EZXNjcmlwdGlvbj5cclxuICAgICAgICAgICAgICB7dGhpcy5nZXREZXNjcmlwdGlvbigpfVxyXG4gICAgICAgICAgICA8L01vZGFsLkRlc2NyaXB0aW9uPlxyXG4gICAgICAgICAgPC9Nb2RhbC5Db250ZW50PlxyXG4gICAgICAgICAgPE1vZGFsLkFjdGlvbnM+XHJcbiAgICAgICAgICAgIDxCdXR0b24gY2xhc3NOYW1lPVwiYnV0dG9udHlwZTFcIiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uU2F2ZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KX0+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2F2ZWJ1dHRvbicsICdTYXZlJyl9PC9CdXR0b24+XHJcbiAgICAgICAgICAgIDxCdXR0b24gY2xhc3NOYW1lPVwiYnV0dG9udHlwZTJcIiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xvc2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCl9Pnt0aGlzLmdldExvY2FsVmFsdWUoJ2NhbmNlbGJ1dHRvbicsICdDYW5jZWwnKX08L0J1dHRvbj5cclxuICAgICAgICAgIDwvTW9kYWwuQWN0aW9ucz5cclxuICAgICAgICA8L01vZGFsPlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNoZWNrQWN0aW9uc0xpc3QodmFsdWUpe1xyXG4gICAgdmFyIGlzRXhpc3RzID0gZmFsc2U7XHJcbiAgICBcclxuICAgIGZvcihsZXQgaT0wO2k8IHRoaXMucHJvcHMuYWN0aW9ucy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgIGlmKHRoaXMucHJvcHMuYWN0aW9uc1tpXSA9PSB2YWx1ZSl7XHJcbiAgICAgICAgaXNFeGlzdHMgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIWlzRXhpc3RzKXtcclxuICAgICAgdGhpcy5wcm9wcy5hY3Rpb25zLnB1c2goeyB0ZXh0OiB2YWx1ZSwgdmFsdWV9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhhbmRsZUFkZGl0aW9uQWN0aW9ucyhlLCB7IHZhbHVlIH0pe1xyXG4gICAgdGhpcy5jaGVja0FjdGlvbnNMaXN0KHZhbHVlKTtcclxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEhlYWRlckVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuICAgIHZhciBzaXplZGF0YSA9IFtcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWRlZmF1bHQnLCAnRGVmYXVsdCcpLCB2YWx1ZTogJyd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbWluaScsICdNaW5pJyksIHZhbHVlOiAnbWluaSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXpldGlueScsICdUaW55JyksIHZhbHVlOiAndGlueSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplc21hbGwnLCAnU21hbGwnKSwgdmFsdWU6ICdzbWFsbCd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbWVkaXVtJywgJ01lZGl1bScpLCB2YWx1ZTogJ21lZGl1bSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbGFyZ2UnLCAnTGFyZ2UnKSwgdmFsdWU6ICdsYXJnZSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplaHVnZScsICdIdWdlJyksIHZhbHVlOiAnaHVnZSd9XTtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcImhlYWRlcmZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLkRyb3Bkb3duIG5hbWU9XCJzaXplXCIgc2VsZWN0aW9uIGZsdWlkIG9wdGlvbnM9e3NpemVkYXRhfSBwbGFjZWhvbGRlcj1cIkRlZmF1bHRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplZmllbGQnLCAnU2l6ZScsIFwiaGVhZGVyXCIpfSB2YWx1ZT17ZGF0YS5zaXplfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uVGV4dEFyZWEgbmFtZT1cImNvbnRlbnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb250ZW50ZmllbGQnLCAnQ29udGVudCcsIFwiaGVhZGVyZm9ybVwiKX0gdmFsdWU9e2RhdGEuY29udGVudH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ3RleHRhbGlnbmZpZWxkJywgJ1RleHQgQWxpZ24nLCBcImhlYWRlcmZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidGV4dEFsaWduXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndGV4dGFsaWdubGVmdCcsICdMZWZ0JywgXCJoZWFkZXJmb3JtXCIpfSB2YWx1ZT0nbGVmdCcgY2hlY2tlZD17ZGF0YS50ZXh0QWxpZ24gPT09ICdsZWZ0J30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidGV4dEFsaWduXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndGV4dGFsaWduY2VudGVyJywgJ0NlbnRlcicsIFwiaGVhZGVyZm9ybVwiKX0gdmFsdWU9J2NlbnRlcicgY2hlY2tlZD17ZGF0YS50ZXh0QWxpZ24gPT09ICdjZW50ZXInfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ0ZXh0QWxpZ25cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0ZXh0YWxpZ25yaWdodCcsICdSaWdodCcsIFwiaGVhZGVyZm9ybVwiKX0gdmFsdWU9J3JpZ2h0JyBjaGVja2VkPXtkYXRhLnRleHRBbGlnbiA9PT0gJ3JpZ2h0J30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJzdWJoZWFkZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzdWJoZWFkZXJmaWVsZCcsICdTdWJoZWFkZXInLCBcImhlYWRlcmZvcm1cIil9IHZhbHVlPXtkYXRhLnN1YmhlYWRlcn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBCdXR0b25FZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcbiAgICBcclxuICAgIHZhciBzaXplZGF0YSA9IFtcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWRlZmF1bHQnLCAnRGVmYXVsdCcpLCB2YWx1ZTogJyd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbWluaScsICdNaW5pJyksIHZhbHVlOiAnbWluaSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXpldGlueScsICdUaW55JyksIHZhbHVlOiAndGlueSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplc21hbGwnLCAnU21hbGwnKSwgdmFsdWU6ICdzbWFsbCd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbWVkaXVtJywgJ01lZGl1bScpLCB2YWx1ZTogJ21lZGl1bSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplYmlnJywgJ0JpZycpLCB2YWx1ZTogJ2JpZyd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbGFyZ2UnLCAnTGFyZ2UnKSwgdmFsdWU6ICdsYXJnZSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplaHVnZScsICdIdWdlJyksIHZhbHVlOiAnaHVnZSd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplbWFzc2l2ZScsICdNYXNzaXZlJyksIHZhbHVlOiAnbWFzc2l2ZSd9XHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiYnV0dG9uZm9ybVwiKX0gdmFsdWU9e2RhdGEua2V5fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndHlwZWZpZWxkJywgJ1R5cGUnLCBcImJ1dHRvbmZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cImJ1dHRvblR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlbm9uZWZpZWxkJywgJ05vbmUnLCBcImJ1dHRvbmZvcm1cIil9IHZhbHVlPScnIGNoZWNrZWQ9e2RhdGEuYnV0dG9uVHlwZSA9PT0gJycgfHwgZGF0YS5idXR0b25UeXBlID09PSB1bmRlZmluZWR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cImJ1dHRvblR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlc3VibWl0ZmllbGQnLCAnU3VibWl0JywgXCJidXR0b25mb3JtXCIpfSB2YWx1ZT0nc3VibWl0JyBjaGVja2VkPXtkYXRhLmJ1dHRvblR5cGUgPT09ICdzdWJtaXQnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJjb250ZW50XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnY29udGVudGZpZWxkJywgJ0NvbnRlbnQnLCBcImJ1dHRvbmZvcm1cIil9IHZhbHVlPXtkYXRhLmNvbnRlbnR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBuYW1lPVwic2l6ZVwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXtzaXplZGF0YX0gcGxhY2Vob2xkZXI9XCJEZWZhdWx0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWZpZWxkJywgJ1NpemUnLCBcImJ1dHRvbmZvcm1cIil9IHZhbHVlPXtkYXRhLnNpemV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiYnV0dG9uZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiYmFzaWNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdiYXNpY2ZpZWxkJywgJ0Jhc2ljJywgXCJidXR0b25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmJhc2ljfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJjaXJjdWxhclwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NpcmN1bGFyZmllbGQnLCAnQ2lyY3VsYXInLCBcImJ1dHRvbmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuY2lyY3VsYXIgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJjb21wYWN0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnY29tcGFjdGZpZWxkJywgJ0NvbXBhY3QnLCBcImJ1dHRvbmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuY29tcGFjdH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXNhYmxlZGZpZWxkJywgJ0Rpc2FibGVkJywgXCJidXR0b25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmRpc2FibGVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZmx1aWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdmbHVpZGZpZWxkJywgJ0ZsdWlkJywgXCJidXR0b25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmZsdWlkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiaW52ZXJ0ZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdpbnZlcnRlZGZpZWxkJywgJ0ludmVydGVkJywgXCJidXR0b25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmludmVydGVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibG9hZGluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xvYWRpbmdmaWVsZCcsICdMb2FkaW5nJywgXCJidXR0b25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmxvYWRpbmcgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJwcmltYXJ5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncHJpbWFyeWZpZWxkJywgJ1ByaW1hcnknLCBcImJ1dHRvbmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEucHJpbWFyeSB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInNlY29uZGFyeVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NlY29uZGFyeWZpZWxkJywgJ1NlY29uZGFyeScsIFwiYnV0dG9uZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zZWNvbmRhcnkgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJ0b2dnbGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0b2dnbGVmaWVsZCcsICdUb2dnbGUnLCBcImJ1dHRvbmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEudG9nZ2xlIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdmbG9hdGVkZmllbGQnLCAnRmxvYXRlZCcsIFwiYnV0dG9uZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwiZmxvYXRlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0ZWRkZWZhdWx0ZmllbGQnLCAnRGVmYXVsdCcsIFwiYnV0dG9uZm9ybVwiKX0gdmFsdWU9JycgY2hlY2tlZD17ZGF0YS5mbG9hdGVkID09PSB1bmRlZmluZWQgfHwgZGF0YS5mbG9hdGVkID09PSAnJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwiZmxvYXRlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0ZWRsZWZ0ZmllbGQnLCAnTGVmdCcsIFwiYnV0dG9uZm9ybVwiKX0gdmFsdWU9J2xlZnQnIGNoZWNrZWQ9e2RhdGEuZmxvYXRlZCA9PT0gJ2xlZnQnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJmbG9hdGVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmxvYXRlZHJpZ2h0ZmllbGQnLCAnUmlnaHQnLCBcImJ1dHRvbmZvcm1cIil9IHZhbHVlPSdyaWdodCcgY2hlY2tlZD17ZGF0YS5mbG9hdGVkID09PSAncmlnaHQnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRzTGlzdCgpe1xyXG4gICAgcmV0dXJuIFtcIm9uQ2xpY2tcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBMYWJlbEVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuXHJcbiAgICB2YXIgc2l6ZWRhdGEgPSBbXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVkZWZhdWx0JywgJ0RlZmF1bHQnKSwgdmFsdWU6ICcnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1pbmknLCAnTWluaScpLCB2YWx1ZTogJ21pbmknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXRpbnknLCAnVGlueScpLCB2YWx1ZTogJ3RpbnknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXNtYWxsJywgJ1NtYWxsJyksIHZhbHVlOiAnc21hbGwnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1lZGl1bScsICdNZWRpdW0nKSwgdmFsdWU6ICdtZWRpdW0nfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWxhcmdlJywgJ0xhcmdlJyksIHZhbHVlOiAnbGFyZ2UnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWh1Z2UnLCAnSHVnZScpLCB2YWx1ZTogJ2h1Z2UnfVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgYXR0YWNoZWRkYXRhID0gW1xyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdhdHRhY2hlZG5vbmUnLCAnTm9uZScpLCB2YWx1ZTogJyd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdhdHRhY2hlZHRvcCcsICdUb3AnKSwgdmFsdWU6ICd0b3AnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnYXR0YWNoZWRib3R0b20nLCAnQm90dG9tJyksIHZhbHVlOiAnYm90dG9tJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2F0dGFjaGVkdG9wcmlnaHQnLCAnVG9wIHJpZ2h0JyksIHZhbHVlOiAndG9wIHJpZ2h0J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2F0dGFjaGVkdG9wbGVmdCcsICdUb3AgbGVmdCcpLCB2YWx1ZTogJ3RvcCBsZWZ0J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2F0dGFjaGVkYm90dG9tbGVmdCcsICdCb3R0b20gbGVmdCcpLCB2YWx1ZTogJ2JvdHRvbSBsZWZ0J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2F0dGFjaGVkYm90dG9tcmlnaHQnLCAnQm90dG9tIHJpZ2h0JyksIHZhbHVlOiAnYm90dG9tIHJpZ2h0J31cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJsYWJlbGZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLkRyb3Bkb3duIG5hbWU9XCJhdHRhY2hlZFwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXthdHRhY2hlZGRhdGF9IHBsYWNlaG9sZGVyPXthdHRhY2hlZGRhdGFbMF0udGV4dH0gbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYXR0YWNoZWRmaWVsZCcsICdBdHRhY2hlZCcsIFwibGFiZWxmb3JtXCIpfSB2YWx1ZT17ZGF0YS5hdHRhY2hlZH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImNvbnRlbnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb250ZW50ZmllbGQnLCAnQ29udGVudCcsIFwibGFiZWxmb3JtXCIpfSB2YWx1ZT17ZGF0YS5jb250ZW50fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBuYW1lPVwic2l6ZVwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXtzaXplZGF0YX0gcGxhY2Vob2xkZXI9XCJEZWZhdWx0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWZpZWxkJywgJ1NpemUnLCBcImxhYmVsZm9ybVwiKX0gdmFsdWU9e2RhdGEuc2l6ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnb3B0aW9uc2ZpZWxkJywgJ09wdGlvbnMnLCBcImxhYmVsZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiYmFzaWNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdiYXNpY2ZpZWxkJywgJ0Jhc2ljJywgXCJsYWJlbGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuYmFzaWN9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImNpcmN1bGFyXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnY2lyY3VsYXJmaWVsZCcsICdDaXJjdWxhcicsIFwibGFiZWxmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmNpcmN1bGFyfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJjb3JuZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb3JuZXJmaWVsZCcsICdDb3JuZXInLCBcImxhYmVsZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5jb3JuZXJ9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZsb2F0aW5nXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmxvYXRpbmdmaWVsZCcsICdGbG9hdGluZycsIFwibGFiZWxmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmZsb2F0aW5nfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJob3Jpem9udGFsXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaG9yaXpvbnRhbGZpZWxkJywgJ0hvcml6b250YWwnLCBcImxhYmVsZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5ob3Jpem9udGFsfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJwb2ludGluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3BvaW50aW5nZmllbGQnLCAnUG9pbnRpbmcnLCBcImxhYmVsZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5wb2ludGluZ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFN0YXRpY0NvbnRlbnRFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcInN0YXRpY2NvbnRlbnRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwic3R5bGUtZm9udC1zaXplXCIgcGxhY2Vob2xkZXI9XCIyMHB4XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZm9udHNpemVmaWVsZCcsICdGb250IHNpemUnLCBcInN0YXRpY2NvbnRlbnRmb3JtXCIpfSB2YWx1ZT17ZGF0YVtcInN0eWxlLWZvbnQtc2l6ZVwiXX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImlzSHRtbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2FsbG93aHRtbGZpZWxkJywgJ0FsbG93IEhUTUwnLCBcInN0YXRpY2NvbnRlbnRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmlzSHRtbH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8VGV4dEFyZWEgcm93cz17Nn0gYXV0b0hlaWdodD17dHJ1ZX0gbmFtZT1cImNvbnRlbnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb250ZW50ZmllbGQnLCAnQ29udGVudCcsIFwic3RhdGljY29udGVudGZvcm1cIil9IHZhbHVlPXtkYXRhLmNvbnRlbnR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgTWVzc2FnZUVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuXHJcbiAgICB2YXIgc2l6ZWRhdGEgPSBbXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVkZWZhdWx0JywgJ0RlZmF1bHQnKSwgdmFsdWU6ICcnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1pbmknLCAnTWluaScpLCB2YWx1ZTogJ21pbmknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXRpbnknLCAnVGlueScpLCB2YWx1ZTogJ3RpbnknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXNtYWxsJywgJ1NtYWxsJyksIHZhbHVlOiAnc21hbGwnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1lZGl1bScsICdNZWRpdW0nKSwgdmFsdWU6ICdtZWRpdW0nfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWxhcmdlJywgJ0xhcmdlJyksIHZhbHVlOiAnbGFyZ2UnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWh1Z2UnLCAnSHVnZScpLCB2YWx1ZTogJ2h1Z2UnfVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwibWVzc2FnZWZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImhlYWRlclwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2hlYWRlcmZpZWxkJywgJ0hlYWRlcicsIFwibWVzc2FnZWZvcm1cIil9IHZhbHVlPXtkYXRhLmhlYWRlcn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnb3B0aW9uc2ZpZWxkJywgJ09wdGlvbnMnLCBcIm1lc3NhZ2Vmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJjb21wYWN0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnY29tcGFjdGZpZWxkJywgJ0NvbXBhY3QnLCBcIm1lc3NhZ2Vmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmNvbXBhY3R9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImVycm9yXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZXJyb3JmaWVsZCcsICdFcnJvcicsIFwibWVzc2FnZWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZXJyb3J9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZsb2F0aW5nXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmxvYXRpbmdmaWVsZCcsICdGbG9hdGluZycsIFwibWVzc2FnZWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZmxvYXRpbmd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImluZm9cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdpbmZvZmllbGQnLCAnSW5mbycsIFwibWVzc2FnZWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuaW5mb30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibmVnYXRpdmVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduZWdhdGl2ZWZpZWxkJywgJ05lZ2F0aXZlJywgXCJtZXNzYWdlZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5uZWdhdGl2ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwicG9zaXRpdmVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdwb3NpdGl2ZWZpZWxkJywgJ1Bvc2l0aXZlJywgXCJtZXNzYWdlZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5wb3NpdGl2ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwic3VjY2Vzc1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3N1Y2Nlc3NmaWVsZCcsICdTdWNjZXNzJywgXCJtZXNzYWdlZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zdWNjZXNzfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJ3YXJuaW5nXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnd2FybmluZ2ZpZWxkJywgJ1dhcm5pbmcnLCBcIm1lc3NhZ2Vmb3JtXCIpfSBjaGVja2VkPXtkYXRhLndhcm5pbmd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uVGV4dEFyZWEgbmFtZT1cImNvbnRlbnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb250ZW50ZmllbGQnLCAnQ29udGVudCcsIFwibWVzc2FnZWZvcm1cIil9IHZhbHVlPXtkYXRhLmNvbnRlbnR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBuYW1lPVwic2l6ZVwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXtzaXplZGF0YX0gcGxhY2Vob2xkZXI9e3NpemVkYXRhWzBdLnRleHR9IGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVmaWVsZCcsICdTaXplJywgXCJtZXNzYWdlZm9ybVwiKX0gdmFsdWU9e2RhdGEuc2l6ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgSW5wdXRFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgdmFyIHNpemVkYXRhID0gW1xyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplZGVmYXVsdCcsICdEZWZhdWx0JyksIHZhbHVlOiAnJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVtaW5pJywgJ01pbmknKSwgdmFsdWU6ICdtaW5pJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemV0aW55JywgJ1RpbnknKSwgdmFsdWU6ICd0aW55J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVzbWFsbCcsICdTbWFsbCcpLCB2YWx1ZTogJ3NtYWxsJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVtZWRpdW0nLCAnTWVkaXVtJyksIHZhbHVlOiAnbWVkaXVtJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVsYXJnZScsICdMYXJnZScpLCB2YWx1ZTogJ2xhcmdlJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVodWdlJywgJ0h1Z2UnKSwgdmFsdWU6ICdodWdlJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVtYXNzaXZlJywgJ01hc3NpdmUnKSwgdmFsdWU6ICdtYXNzaXZlJ31cclxuICAgIF07XHJcblxyXG4gICAgdmFyIGxhYmVsUG9zaXRpb25zID0gW1xyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdsYWJlbGRlZmF1bHQnLCAnRGVmYXVsdCcpLCB2YWx1ZTogJyd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdsYWJlbGxlZnQnLCAnTGVmdCcpLCB2YWx1ZTogJ2xlZnQnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnbGFiZWxyaWdodCcsICdSaWdodCcpLCB2YWx1ZTogJ3JpZ2h0J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsbGVmdGNvcm5lcicsICdMZWZ0IGNvcm5lcicpLCB2YWx1ZTogJ2xlZnQgY29ybmVyJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVscmlnaHRjb3JuZXInLCAnUmlnaHQgY29ybmVyJyksIHZhbHVlOiAncmlnaHQgY29ybmVyJ31cclxuICAgIF07XHJcbiAgICBcclxuICAgIGxldCBkaXNhYmxlRGF0ZUZvcm1hdCA9IGRhdGEudHlwZSAhPT0gXCJkYXRlXCIgJiYgZGF0YS50eXBlICE9PSBcImRhdGV0aW1lXCIgJiYgZGF0YS50eXBlICE9PSBcInRpbWVcIjtcclxuICAgIFxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJpbnB1dGZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJsYWJlbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZmllbGQnLCAnTGFiZWwnLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9e2RhdGEubGFiZWx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlZmllbGQnLCAnVHlwZScsIFwiaW5wdXRmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cInR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBldGV4dCcsICdUZXh0JywgXCJpbnB1dGZvcm1cIil9IHZhbHVlPSd0ZXh0JyBjaGVja2VkPXtkYXRhLnR5cGUgPT0gdW5kZWZpbmVkIHx8IGRhdGEudHlwZSA9PSAndGV4dCcgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ0eXBlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndHlwZW51bWJlcicsICdOdW1iZXInLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9J251bWJlcicgY2hlY2tlZD17ZGF0YS50eXBlID09PSAnbnVtYmVyJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidHlwZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3R5cGVwYXNzd29kJywgJ1Bhc3N3b3JkJywgXCJpbnB1dGZvcm1cIil9IHZhbHVlPSdwYXNzd29yZCcgY2hlY2tlZD17ZGF0YS50eXBlID09PSAncGFzc3dvcmQnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ0eXBlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndHlwZWZpbGUnLCAnRmlsZScsIFwiaW5wdXRmb3JtXCIpfSB2YWx1ZT0nZmlsZScgY2hlY2tlZD17ZGF0YS50eXBlID09PSAnZmlsZSd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidHlwZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3R5cGVkYXRlJywgJ0RhdGUnLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9J2RhdGUnIGNoZWNrZWQ9e2RhdGEudHlwZSA9PT0gJ2RhdGUnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ0eXBlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndHlwZXRpbWUnLCAnVGltZScsIFwiaW5wdXRmb3JtXCIpfSB2YWx1ZT0ndGltZScgY2hlY2tlZD17ZGF0YS50eXBlID09PSAndGltZSd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cInR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlZGF0ZXRpbWUnLCAnRGF0ZSAmIFRpbWUnLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9J2RhdGV0aW1lJyBjaGVja2VkPXtkYXRhLnR5cGUgPT09ICdkYXRldGltZSd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBuYW1lPVwibGFiZWxQb3NpdGlvblwiIHNlbGVjdGlvbiBmbHVpZCBwbGFjZWhvbGRlcj17bGFiZWxQb3NpdGlvbnNbMF0udGV4dH0gb3B0aW9ucz17bGFiZWxQb3NpdGlvbnN9IGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVscG9zaXRpb25maWVsZCcsICdMYWJlbCBwb3NpdGlvbicsIFwiaW5wdXRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5sYWJlbFBvc2l0aW9ufSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwicGxhY2Vob2xkZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdwbGFjZWhvbGRlcmZpZWxkJywgJ1BsYWNlaG9sZGVyJywgXCJpbnB1dGZvcm1cIil9IHZhbHVlPXtkYXRhLnBsYWNlaG9sZGVyfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiaW5wdXRmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImxvYWRpbmdcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdsb2FkaW5nZmllbGQnLCAnTG9hZGluZycsIFwiaW5wdXRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmxvYWRpbmd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImludmVydGVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaW52ZXJ0ZWRmaWVsZCcsICdJbnZlcnRlZCcsIFwiaW5wdXRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmludmVydGVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZXJyb3JcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdlcnJvcmZpZWxkJywgJ0Vycm9yJywgXCJpbnB1dGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZXJyb3IgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImRpc2FibGVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGlzYWJsZWRmaWVsZCcsICdEaXNhYmxlZCcsIFwiaW5wdXRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmRpc2FibGVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwidHJhbnNwYXJlbnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0cmFuc3BhcmVudGZpZWxkJywgJ1RyYW5zcGFyZW50JywgXCJpbnB1dGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEudHJhbnNwYXJlbnQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJmbHVpZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2ZsdWlkZmllbGQnLCAnRmx1aWQnLCBcImlucHV0Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5mbHVpZCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwicmVhZE9ubHlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyZWFkb25seWZpZWxkJywgJ1JlYWQgb25seScsIFwiaW5wdXRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnJlYWRPbmx5IH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLkRyb3Bkb3duIG5hbWU9XCJzaXplXCIgc2VsZWN0aW9uIGZsdWlkIG9wdGlvbnM9e3NpemVkYXRhfSBwbGFjZWhvbGRlcj17c2l6ZWRhdGFbMF0udGV4dH0gbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWZpZWxkJywgJ1NpemUnLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9e2RhdGEuc2l6ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgey8qPEZvcm0uSW5wdXQgbmFtZT1cImRhdGVGb3JtYXRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkYXRlZm9ybWF0ZmllbGQnLCAnRGF0ZSBGb3JtYXQnLCBcImlucHV0Zm9ybVwiKX0gdmFsdWU9e2RhdGEuZGF0ZUZvcm1hdH0gZGlzYWJsZWQ9e2Rpc2FibGVEYXRlRm9ybWF0fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPiovfVxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkNsaWNrXCIsIFwib25DaGFuZ2VcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBUZXh0QXJlYUVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJ0ZXh0YXJlYWZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJsYWJlbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZmllbGQnLCAnTGFiZWwnLCBcInRleHRhcmVhZm9ybVwiKX0gdmFsdWU9e2RhdGEubGFiZWx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwicm93c1wiIHBsYWNlaG9sZGVyPVwiM1wiIHR5cGU9XCJudW1iZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyb3dzZmllbGQnLCAnUm93cycsIFwidGV4dGFyZWFmb3JtXCIpfSB2YWx1ZT17ZGF0YS5yb3dzfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwicGxhY2Vob2xkZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdwbGFjZWhvbGRlcmZpZWxkJywgJ1BsYWNlaG9sZGVyJywgXCJ0ZXh0YXJlYWZvcm1cIil9IHZhbHVlPXtkYXRhLnBsYWNlaG9sZGVyfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncGxhY2Vob2xkZXJmaWVsZCcsICdPcHRpb25zJywgXCJ0ZXh0YXJlYWZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiYXV0b0hlaWdodFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2F1dG9oZWlnaHRmaWVsZCcsICdBdXRvIGhlaWdodCcsIFwidGV4dGFyZWFmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmF1dG9IZWlnaHR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInJlYWRPbmx5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVhZG9ubHlmaWVsZCcsICdSZWFkIG9ubHknLCBcInRleHRhcmVhZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5yZWFkT25seSB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkNsaWNrXCIsIFwib25DaGFuZ2VcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBTZWFyY2hFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwic2VhcmNoZm9ybVwiKX0gdmFsdWU9e2RhdGEua2V5fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJ1cmxcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd1cmxmaWVsZCcsICdVcmwnLCBcInNlYXJjaGZvcm1cIil9IHZhbHVlPXtkYXRhLnVybH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiY2F0ZWdvcnlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjYXRlZ29yeWZpZWxkJywgJ0VuYWJsZSBDYXRlZ29yaWVzJywgXCJzZWFyY2hmb3JtXCIpfSBjaGVja2VkPXtCb29sZWFuKGRhdGEuY2F0ZWdvcnkpfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvblNlbGVjdFwiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENoZWNrYm94RWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJjaGVja2JveGZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJsYWJlbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZmllbGQnLCAnTGFiZWwnLCBcImNoZWNrYm94Zm9ybVwiKX0gdmFsdWU9e2RhdGEubGFiZWx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cIjJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ29wdGlvbnNmaWVsZCcsICdPcHRpb25zJywgXCJjaGVja2JveGZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZpdHRlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2ZpdHRlZGZpZWxkJywgJ0ZpdHRlZCcsIFwiY2hlY2tib3hmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmZpdHRlZH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiaW5kZXRlcm1pbmF0ZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2luZGV0ZXJtaW5hdGVmaWVsZCcsICdJbmRldGVybWluYXRlJywgXCJjaGVja2JveGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuaW5kZXRlcm1pbmF0ZSB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInJlYWRPbmx5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVhZG9ubHlmaWVsZCcsICdSZWFkT25seScsIFwiY2hlY2tib3hmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnJlYWRPbmx5IH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXNhYmxlZGZpZWxkJywgJ0Rpc2FibGVkJywgXCJjaGVja2JveGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZGlzYWJsZWQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJzbGlkZXJcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzbGlkZXJmaWVsZCcsICdTbGlkZXInLCBcImNoZWNrYm94Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zbGlkZXIgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJ0b2dnbGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0b2dnbGVmaWVsZCcsICdUb2dnbGUnLCBcImNoZWNrYm94Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS50b2dnbGUgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRzTGlzdCgpe1xyXG4gICAgcmV0dXJuIFtcIm9uQ2xpY2tcIiwgXCJvbkNoYW5nZVwiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIERyb3Bkb3duRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gICAgXHJcbiAgICB2YXIgbGFiZWxQb3NpdGlvbnMgPSBbXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZGVmYXVsdCcsICdEZWZhdWx0JyksIHZhbHVlOiAnJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsbGVmdCcsICdMZWZ0JyksIHZhbHVlOiAnbGVmdCd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdsYWJlbHJpZ2h0JywgJ1JpZ2h0JyksIHZhbHVlOiAncmlnaHQnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnbGFiZWxsZWZ0Y29ybmVyJywgJ0xlZnQgY29ybmVyJyksIHZhbHVlOiAnbGVmdCBjb3JuZXInfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnbGFiZWxyaWdodGNvcm5lcicsICdSaWdodCBjb3JuZXInKSwgdmFsdWU6ICdyaWdodCBjb3JuZXInfVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgdmFyIGRhdGFDb2x1bW5zID0gW1xyXG4gICAgICB7a2V5OiAndmFsdWUnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGF2YWx1ZWNvbHVtbicsICdWYWx1ZScsIFwiZHJvcGRvd25mb3JtXCIpfSxcclxuICAgICAge2tleTogJ3RleHQnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGF0ZXh0Y29sdW1uJywgJ1RleHQnLCBcImRyb3Bkb3duZm9ybVwiKX1cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJkcm9wZG93bmZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJsYWJlbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZmllbGQnLCAnTGFiZWwnLCBcImRyb3Bkb3duZm9ybVwiKX0gdmFsdWU9e2RhdGEubGFiZWx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Q29sbGVjdGlvbkVkaXRvciBrZXk9XCJkYXRhLWVsZW1lbnRzXCIgXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZT17dHJ1ZX1cclxuICAgICAgICAgICAgY29sdW1ucz17ZGF0YUNvbHVtbnN9IFxyXG4gICAgICAgICAgICBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkYXRhZmllbGQnLCAnRGF0YScsIFwiZHJvcGRvd25mb3JtXCIpfVxyXG4gICAgICAgICAgICBuYW1lPVwiZGF0YS1lbGVtZW50c1wiIFxyXG4gICAgICAgICAgICB2YWx1ZT17ZGF0YVtcImRhdGEtZWxlbWVudHNcIl19XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJwbGFjZWhvbGRlclwiIGxhYmVsPVwiUGxhY2Vob2xkZXJcIiB2YWx1ZT17ZGF0YS5wbGFjZWhvbGRlcn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiZHJvcGRvd25mb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibG9hZGluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xvYWRpbmdmaWVsZCcsICdMb2FkaW5nJywgXCJkcm9wZG93bmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEubG9hZGluZ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJlcnJvclwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Vycm9yZmllbGQnLCAnRXJyb3InLCBcImRyb3Bkb3duZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5lcnJvciB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXNhYmxlZGZpZWxkJywgJ0Rpc2FibGVkJywgXCJkcm9wZG93bmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZGlzYWJsZWQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZsdWlkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmx1aWRmaWVsZCcsICdGbHVpZCcsIFwiZHJvcGRvd25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLmZsdWlkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibXVsdGlwbGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtdWx0aXBsZWZpZWxkJywgJ011bHRpcGxlJywgXCJkcm9wZG93bmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEubXVsdGlwbGUgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInNlYXJjaFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NlYXJjaGZpZWxkJywgJ1NlYXJjaCcsIFwiZHJvcGRvd25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLnNlYXJjaCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwic2VsZWN0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2VsZWN0aW9uZmllbGQnLCAnU2VsZWN0aW9uJywgXCJkcm9wZG93bmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuc2VsZWN0aW9uIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwicmVhZE9ubHlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyZWFkb25seWZpZWxkJywgJ1JlYWQgb25seScsIFwiZHJvcGRvd25mb3JtXCIpfSBjaGVja2VkPXtkYXRhLnJlYWRPbmx5IH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJhbGxvd0FkZEl0ZW1zXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYWxsb3dBZGRJdGVtc2ZpZWxkJywgJ0FsbG93IGFkZCBpdGVtcycsIFwiZHJvcGRvd25mb3JtXCIpfSBkaXNhYmxlZD17IShkYXRhLnNlYXJjaCAmJiBkYXRhLm11bHRpcGxlKX0gY2hlY2tlZD17ZGF0YS5hbGxvd0FkZEl0ZW1zIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkNsaWNrXCIsIFwib25DaGFuZ2VcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBEaWN0aW9uYXJ5RWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gICAgXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcImRpY3Rpb25hcnlmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwibGFiZWxcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdsYWJlbGZpZWxkJywgJ0xhYmVsJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gdmFsdWU9e2RhdGEubGFiZWx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiZGF0YU1vZGVsXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGF0YW1vZGVsZmllbGQnLCAnRGF0YSBtb2RlbCcsIFwiZGljdGlvbmFyeWZvcm1cIil9IHZhbHVlPXtkYXRhLmRhdGFNb2RlbH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJwbGFjZWhvbGRlclwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3BsYWNlaG9sZGVyZmllbGQnLCAnUGxhY2Vob2xkZXInLCBcImRpY3Rpb25hcnlmb3JtXCIpfSB2YWx1ZT17ZGF0YS5wbGFjZWhvbGRlcn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+ICBcclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiY29sdW1uc1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NvbHVtbnNmaWVsZCcsICdDb2x1bW5zIChOYW1lIEFTQywgRW1haWwpJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gdmFsdWU9e2RhdGEuY29sdW1uc30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInBhZ2VTaXplXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncGFnZXNpemVmaWVsZCcsICdQYWdlIFNpemUnLCBcImRpY3Rpb25hcnlmb3JtXCIpfSBkaXNhYmxlZD17IUJvb2xlYW4oZGF0YS5wYWdpbmcpfSB2YWx1ZT17ZGF0YS5wYWdlU2l6ZX0gcGxhY2Vob2xkZXI9XCIxMDBcIiBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiZGljdGlvbmFyeWZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInBhZ2luZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3BhZ2luZ2ZpZWxkJywgJ1NlcnZlciBwYWdpbmF0aW9uJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5wYWdpbmd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInNlYXJjaFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NlYXJjaGZpZWxkJywgJ1NlYXJjaCcsIFwiZGljdGlvbmFyeWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuc2VhcmNoIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibXVsdGlwbGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtdWx0aXBsZWZpZWxkJywgJ011bHRpcGxlJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5tdWx0aXBsZSB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInJlYWRPbmx5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVhZG9ubHlmaWVsZCcsICdSZWFkIG9ubHknLCBcImRpY3Rpb25hcnlmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnJlYWRPbmx5IH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXNhYmxlZGZpZWxkJywgJ0Rpc2FibGVkJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5kaXNhYmxlZCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImNsZWFyYWJsZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NsZWFyYWJsZWZpZWxkJywgJ0NsZWFyYWJsZScsIFwiZGljdGlvbmFyeWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuY2xlYXJhYmxlIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwic2VsZWN0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2VsZWN0aW9uZmllbGQnLCAnU2VsZWN0aW9uJywgXCJkaWN0aW9uYXJ5Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zZWxlY3Rpb24gfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZsdWlkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmx1aWRmaWVsZCcsICdGbHVpZCcsIFwiZGljdGlvbmFyeWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZmx1aWQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImVycm9yXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZXJyb3JmaWVsZCcsICdFcnJvcicsIFwiZGljdGlvbmFyeWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZXJyb3IgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImxvYWRpbmdcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdsb2FkaW5nZmllbGQnLCAnTG9hZGluZycsIFwiZGljdGlvbmFyeWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEubG9hZGluZ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkNoYW5nZVwiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFJhZGlvR3JvdXBFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgdmFyIGRhdGFDb2x1bW5zID0gW1xyXG4gICAgICB7a2V5OiAndmFsdWUnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGF2YWx1ZWNvbHVtbicsICdWYWx1ZScsIFwicmFkaW9ncm91cGZvcm1cIil9LFxyXG4gICAgICB7a2V5OiAndGV4dCcsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnZGF0YXRleHRjb2x1bW4nLCAnVGV4dCcsIFwicmFkaW9ncm91cGZvcm1cIil9XHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwicmFkaW9ncm91cGZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJsYWJlbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xhYmVsZmllbGQnLCAnTGFiZWwnLCBcInJhZGlvZ3JvdXBmb3JtXCIpfSB2YWx1ZT17ZGF0YS5sYWJlbH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxDb2xsZWN0aW9uRWRpdG9yIGtleT1cImRhdGEtZWxlbWVudHNcIiBcclxuICAgICAgICAgICAgICBkcmFnZ2FibGU9e3RydWV9XHJcbiAgICAgICAgICAgICAgY29sdW1ucz17ZGF0YUNvbHVtbnN9IFxyXG4gICAgICAgICAgICAgIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGFmaWVsZCcsICdEYXRhJywgXCJyYWRpb2dyb3VwZm9ybVwiKX1cclxuICAgICAgICAgICAgICBuYW1lPVwiZGF0YS1lbGVtZW50c1wiIFxyXG4gICAgICAgICAgICAgIHZhbHVlPXtkYXRhW1wiZGF0YS1lbGVtZW50c1wiXX1cclxuICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdncm91cGRpcmVjdGZpZWxkJywgJ0dyb3VwIGRpcmVjdCcsIFwicmFkaW9ncm91cGZvcm1cIil9PC9sYWJlbD5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwiZGlyZWN0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGlyZWN0aW9uZ29yaXpvbnRhbGZpZWxkJywgJ0dvcml6b250YWwnLCBcInJhZGlvZ3JvdXBmb3JtXCIpfSB2YWx1ZT0nZycgY2hlY2tlZD17ZGF0YS5kaXJlY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBkYXRhLmRpcmVjdGlvbiA9PT0gJ2cnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJkaXJlY3Rpb25cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXJlY3Rpb252ZXJ0aWNhbGZpZWxkJywgJ1ZlcnRpY2FsJywgXCJyYWRpb2dyb3VwZm9ybVwiKX0gdmFsdWU9J3YnIGNoZWNrZWQ9e2RhdGEuZGlyZWN0aW9uID09PSAndid9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwicmVhZE9ubHlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyZWFkb25seWZpZWxkJywgJ1JlYWQgb25seScsIFwicmFkaW9ncm91cGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEucmVhZE9ubHkgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG5cclxuICBnZXRFdmVudHNMaXN0KCl7XHJcbiAgICByZXR1cm4gW1wib25DbGlja1wiLCBcIm9uQ2hhbmdlXCJdO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgRm9ybUVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG5cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgdmFyIHNpemVkYXRhID0gW1xyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdzaXplZGVmYXVsdCcsICdEZWZhdWx0JyksIHZhbHVlOiAnJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVtaW5pJywgJ01pbmknKSwgdmFsdWU6ICdtaW5pJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemV0aW55JywgJ1RpbnknKSwgdmFsdWU6ICd0aW55J30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVzbWFsbCcsICdTbWFsbCcpLCB2YWx1ZTogJ3NtYWxsJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVtZWRpdW0nLCAnTWVkaXVtJyksIHZhbHVlOiAnbWVkaXVtJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVsYXJnZScsICdMYXJnZScpLCB2YWx1ZTogJ2xhcmdlJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVodWdlJywgJ0h1Z2UnKSwgdmFsdWU6ICdodWdlJ31cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBuYW1lPVwic2l6ZVwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXtzaXplZGF0YX0gcGxhY2Vob2xkZXI9e3NpemVkYXRhWzBdLnRleHR9IGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVmaWVsZCcsICdTaXplJywgXCJmb3JtXCIpfSB2YWx1ZT17ZGF0YS5zaXplfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCIyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibG9hZGluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xvYWRpbmdmaWVsZCcsICdMb2FkaW5nJywgXCJmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmxvYWRpbmd9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImVycm9yXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZXJyb3JmaWVsZCcsICdFcnJvcicsIFwiZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5lcnJvciB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImludmVydGVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaW52ZXJ0ZWRmaWVsZCcsICdJbnZlcnRlZCcsIFwiZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5pbnZlcnRlZCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInJlcGx5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncmVwbHlmaWVsZCcsICdSZXBseScsIFwiZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5yZXBseSB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInN1Y2Nlc3NcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzdWNjZXNzZmllbGQnLCAnU3VjY2VzcycsIFwiZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zdWNjZXNzIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwid2FybmluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3dhcm5pbmdmaWVsZCcsICdXYXJuaW5nJywgXCJmb3JtXCIpfSBjaGVja2VkPXtkYXRhLndhcm5pbmcgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRzTGlzdCgpe1xyXG4gICAgcmV0dXJuIFtcIm9uU3VibWl0XCJdO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgRm9ybUdyb3VwRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG5cclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiZm9ybWdyb3VwZm9ybVwiKX0gdmFsdWU9e2RhdGEua2V5fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnd2lkdGhzZmllbGQnLCAnV2lkdGhzJywgXCJmb3JtZ3JvdXBmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ3aWR0aHNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd3aWR0aHNkZWZhdWx0ZmllbGQnLCAnRGVmYXVsdCcsIFwiZm9ybWdyb3VwZm9ybVwiKX0gY2hlY2tlZD17IGRhdGEud2lkdGhzID09PSB1bmRlZmluZWQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ3aWR0aHNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd3aWR0aHNlcXVhbGZpZWxkJywgJ0VxdWFsJywgXCJmb3JtZ3JvdXBmb3JtXCIpfSB2YWx1ZT0nZXF1YWwnIGNoZWNrZWQ9e2RhdGEud2lkdGhzID09PSAnZXF1YWwnfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ3aWR0aHNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd3aWR0aHNjdXN0b21maWVsZCcsICdDdXN0b20gKDEgLSAxNiknLCBcImZvcm1ncm91cGZvcm1cIil9IHZhbHVlPSdjdXN0b20nIGNoZWNrZWQ9e2RhdGEud2lkdGhzID09PSAnY3VzdG9tJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cIjJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ3R5cGVmaWVsZCcsICdUeXBlJywgXCJmb3JtZ3JvdXBmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIGlubGluZT5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwib3JpZW50YXRpb25cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdvcmllbnRhdGlvbmNvbHVtbnNmaWVsZCcsICdDb2x1bW5zJywgXCJmb3JtZ3JvdXBmb3JtXCIpfSB2YWx1ZT1cImlubGluZVwiIGNoZWNrZWQ9e2RhdGEub3JpZW50YXRpb24gPT09IHVuZGVmaW5lZCB8fCBkYXRhLm9yaWVudGF0aW9uID09PSAnaW5saW5lJyB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cIm9yaWVudGF0aW9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnb3JpZW50YXRpb25yb3dzZmllbGQnLCAnUm93cycsIFwiZm9ybWdyb3VwZm9ybVwiKX0gdmFsdWU9XCJncm91cGVkXCIgY2hlY2tlZD17ZGF0YS5vcmllbnRhdGlvbiA9PT0gXCJncm91cGVkXCIgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJ3aWR0aHNDdXN0b21cIiBkaXNhYmxlZD17ZGF0YS53aWR0aHMgIT09ICdjdXN0b20nfSBwbGFjZWhvbGRlcj1cIjJcIiB2YWx1ZT17ZGF0YS53aWR0aHNDdXN0b219IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9Lz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQ29udGFpbmVyRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG5cclxuICAgIHZhciBmbG9hdGRhdGEgPSBbXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0bm9uZWZpZWxkJywgJ05vbmUnLCBcImNvbnRhaW5lcmZvcm1cIiksIHZhbHVlOiAnJ30sXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0bGVmdGZpZWxkJywgJ0xlZnQnLCBcImNvbnRhaW5lcmZvcm1cIiksIHZhbHVlOiAnbGVmdCd9LFxyXG4gICAgICB7dGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdmbG9hdHJpZ2h0ZmllbGQnLCAnUmlnaHQnLCBcImNvbnRhaW5lcmZvcm1cIiksIHZhbHVlOiAncmlnaHQnfVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcImNvbnRhaW5lcmZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLkRyb3Bkb3duIG5hbWU9XCJzdHlsZS1mbG9hdFwiIHNlbGVjdGlvbiBmbHVpZCBvcHRpb25zPXtmbG9hdGRhdGF9IHBsYWNlaG9sZGVyPXtmbG9hdGRhdGFbMF0udGV4dH0gbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmxvYXRmaWVsZCcsICdGbG9hdCcsIFwiY29udGFpbmVyZm9ybVwiKX0gdmFsdWU9e2RhdGFbXCJzdHlsZS1mbG9hdFwiXX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgSW1hZ2VFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcbiAgICBcclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiaW1hZ2Vmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJzcmNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzcmNmaWVsZCcsICdTcmMnLCBcImltYWdlZm9ybVwiKX0gdmFsdWU9e2RhdGEuc3JjfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiaHJlZlwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2hyZWZmaWVsZCcsICdIcmVmJywgXCJpbWFnZWZvcm1cIil9IHZhbHVlPXtkYXRhLmhyZWZ9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwiaW1hZ2Vmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiYXZhdGFyXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYXZhdGFyZmllbGQnLCAnQXZhdGFyJywgXCJpbWFnZWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuYXZhdGFyfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImJvcmRlcmVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYm9yZGVyZWRmaWVsZCcsICdCb3JkZXJlZCcsIFwiaW1hZ2Vmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmJvcmRlcmVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJjZW50ZXJlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NlbnRlcmVkZmllbGQnLCAnQ2VudGVyZWQnLCBcImltYWdlZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5jZW50ZXJlZCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImRpc2FibGVkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGlzYWJsZWRmaWVsZCcsICdEaXNhYmxlZCcsIFwiaW1hZ2Vmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmRpc2FibGVkIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJpbmxpbmVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdpbmxpbmVmaWVsZCcsICdJbmxpbmUnLCBcImltYWdlZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5pbmxpbmUgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInNwYWNlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3NwYWNlZGZpZWxkJywgJ1NwYWNlZCcsIFwiaW1hZ2Vmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnNwYWNlZCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdmbG9hdGVkZmllbGQnLCAnRmxvYXRlZCcsIFwiaW1hZ2Vmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwiZmxvYXRlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0ZWRsZWZ0ZmllbGQnLCAnTGVmdCcsIFwiaW1hZ2Vmb3JtXCIpfSB2YWx1ZT0nbGVmdCcgY2hlY2tlZD17IGRhdGEuZmxvYXRlZCA9PT0gJ2xlZnQnIHx8IGRhdGEuZmxvYXRlZCA9PT0gJycgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cImZsb2F0ZWRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdmbG9hdGVkcmlnaHRmaWVsZCcsICdSaWdodCcsIFwiaW1hZ2Vmb3JtXCIpfSB2YWx1ZT0ncmlnaHQnIGNoZWNrZWQ9e2RhdGEuZmxvYXRlZCA9PT0gJ3JpZ2h0J30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ3ZlcnRpY2FsYWxpZ25maWVsZCcsICdWZXJ0aWNhbCBhbGlnbicsIFwiaW1hZ2Vmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidmVydGljYWxBbGlnblwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3ZlcnRpY2FsYWxpZ250b3BmaWVsZCcsICdUb3AnLCBcImltYWdlZm9ybVwiKX0gdmFsdWU9XCJ0b3BcIiBjaGVja2VkPXsgZGF0YS52ZXJ0aWNhbEFsaWduID09PSAndG9wJyB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwidmVydGljYWxBbGlnblwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3ZlcnRpY2FsYWxpZ25taWRkbGVmaWVsZCcsICdNaWRkbGUnLCBcImltYWdlZm9ybVwiKX0gdmFsdWU9J21pZGRsZScgY2hlY2tlZD17ZGF0YS52ZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJ2ZXJ0aWNhbEFsaWduXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgndmVydGljYWxhbGlnbmJvdHRvbWZpZWxkJywgJ0JvdHRvbScsIFwiaW1hZ2Vmb3JtXCIpfSB2YWx1ZT0nYm90dG9tJyBjaGVja2VkPXtkYXRhLnZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgU3RhdGlzdGljRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gICAgXHJcbiAgICB2YXIgc2l6ZWRhdGEgPSBbXHJcbiAgICAgIHt0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3NpemVkZWZhdWx0JywgJ0RlZmF1bHQnKSwgdmFsdWU6ICcnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1pbmknLCAnTWluaScpLCB2YWx1ZTogJ21pbmknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXRpbnknLCAnVGlueScpLCB2YWx1ZTogJ3RpbnknfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZXNtYWxsJywgJ1NtYWxsJyksIHZhbHVlOiAnc21hbGwnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZW1lZGl1bScsICdNZWRpdW0nKSwgdmFsdWU6ICdtZWRpdW0nfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWxhcmdlJywgJ0xhcmdlJyksIHZhbHVlOiAnbGFyZ2UnfSxcclxuICAgICAge3RleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWh1Z2UnLCAnSHVnZScpLCB2YWx1ZTogJ2h1Z2UnfVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgdmFyIGRhdGFjb2x1bW5zID0gW1xyXG4gICAgICB7a2V5OiAnbGFiZWwnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGFrZXljb2x1bW4nLCAnTGFiZWwnLCBcInN0YXRpc3RpY2Zvcm1cIil9LFxyXG4gICAgICB7a2V5OiAndmFsdWUnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGF2YWx1ZWNvbHVtbicsICdWYWx1ZScsIFwic3RhdGlzdGljZm9ybVwiKX1cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJzdGF0aXN0aWNmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD57dGhpcy5nZXRMb2NhbFZhbHVlKCdvcHRpb25zZmllbGQnLCAnT3B0aW9ucycsIFwic3RhdGlzdGljZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZmxvYXRlZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Zsb2F0ZWRmaWVsZCcsICdGbG9hdGVkJywgXCJzdGF0aXN0aWNmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmZsb2F0ZWR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImhvcml6b250YWxcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdob3Jpem9udGFsZmllbGQnLCAnSG9yaXpvbnRhbCcsIFwic3RhdGlzdGljZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5ob3Jpem9udGFsfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxDb2xsZWN0aW9uRWRpdG9yIGtleT1cImRhdGEtZWxlbWVudHNcIiBcclxuICAgICAgICAgICAgICBjb2x1bW5zPXtkYXRhY29sdW1uc30gXHJcbiAgICAgICAgICAgICAgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGF0YWZpZWxkJywgJ0RhdGEnLCBcInN0YXRpc3RpY2Zvcm1cIil9XHJcbiAgICAgICAgICAgICAgbmFtZT1cImRhdGEtZWxlbWVudHNcIiBcclxuICAgICAgICAgICAgICB2YWx1ZT17ZGF0YVtcImRhdGEtZWxlbWVudHNcIl19XHJcbiAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxGb3JtLkRyb3Bkb3duIG5hbWU9XCJzaXplXCIgc2VsZWN0aW9uIGZsdWlkIG9wdGlvbnM9e3NpemVkYXRhfSBwbGFjZWhvbGRlcj17c2l6ZWRhdGFbMF0udGV4dH0gbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2l6ZWZpZWxkJywgJ1NpemUnLCBcInN0YXRpc3RpY2Zvcm1cIil9IHZhbHVlPXtkYXRhLnNpemV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEdyaWRFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgdmFyIHBhZ2VydHlwZSA9IFtcclxuICAgICAge3ZhbHVlOiBcIlwiLCB0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ3BhZ2VydHlwZW5vbmVmaWVsZCcsICdOb25lJywgXCJncmlkZm9ybVwiKX0sXHJcbiAgICAgIHt2YWx1ZTogXCJzZXJ2ZXJcIiwgdGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdwYWdlcnR5cGVzZXJ2ZXJmaWVsZCcsICdTZXJ2ZXInLCBcImdyaWRmb3JtXCIpfSxcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGVkaXRmb3JtdHlwZSA9IFtcclxuICAgICAge3ZhbHVlOiBcIlwiLCB0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2VkaXRmb3JtdHlwZWRlZmF1bHRmaWVsZCcsICdEZWZhdWx0JywgXCJncmlkZm9ybVwiKX0sXHJcbiAgICAgIC8ve3ZhbHVlOiBcIm1vZGFsXCIsIHRleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnZWRpdGZvcm10eXBlbW9kYWxmaWVsZCcsICdNb2RhbCcsIFwiZ3JpZGZvcm1cIil9LFxyXG4gICAgXTtcclxuXHJcbiAgICBsZXQgY29sdW1ucyA9IFtcclxuICAgICAge2tleTogJ2tleScsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgna2V5Y29sdW1uJywgJ0tleScsIFwiZ3JpZGZvcm1cIil9LFxyXG4gICAgICB7a2V5OiAnbmFtZScsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWNvbHVtbicsICdOYW1lJywgXCJncmlkZm9ybVwiKX0sXHJcbiAgICAgIHtrZXk6ICd0eXBlJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlY29sdW1uJywgJ1R5cGUnLCBcImdyaWRmb3JtXCIpLCBkYXRhTGlzdDpbXCJcIiwgXCJudW1iZXJcIiwgXCJjaGVja2JveFwiLCBcImRhdGVcIiwgXCJkYXRldGltZVwiLCBcInRpbWVcIiwgXCJjdXN0b21cIl19LFxyXG4gICAgICB7a2V5OiAnd2lkdGgnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ3dpZHRoY29sdW1uJywgJ1dpZHRoJywgXCJncmlkZm9ybVwiKSwgY29udHJvbDogJ251bWJlcid9LFxyXG4gICAgICB7a2V5OiAncmVzaXphYmxlJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdyZXNpemFibGVjb2x1bW4nLCAnUmVzaXphYmxlJywgXCJncmlkZm9ybVwiKSwgY29udHJvbDogXCJjaGVja2JveFwifV1cclxuXHJcbiAgICB2YXIgZWRpdFR5cGVJdGVtcyA9IFtcclxuICAgICAge2tleTogXCJmb3JtXCIsIHRleHQ6IFwiRm9ybVwiLCB2YWx1ZTogdW5kZWZpbmVkfSxcclxuICAgICAge2tleTogXCJmbG93XCIsIHRleHQ6IFwiRmxvd1wiLCB2YWx1ZTogXCJmbG93XCJ9XHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiZ3JpZGZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ29wdGlvbnNmaWVsZCcsICdPcHRpb25zJywgXCJncmlkZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwibXVsdGlzZWxlY3RcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtdWx0aXNlbGVjdGZpZWxkJywgJ011bHRpc2VsZWN0JywgXCJncmlkZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5tdWx0aXNlbGVjdH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZVNvcnRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkaXNhYmxlc29ydGZpZWxkJywgJ0Rpc2FibGUgc29ydGluZycsIFwiZ3JpZGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZGlzYWJsZVNvcnR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgICAgIDxSYWRpb0dyb3VwIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiZWRpdFR5cGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdlZGl0dHlwZWZpZWxkJywgJ0VkaXQgdHlwZScsIFwiZ3JpZGZvcm1cIil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zPXtlZGl0VHlwZUl0ZW1zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZGF0YS5lZGl0VHlwZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9ID5cclxuICAgICAgICAgICAgICA8L1JhZGlvR3JvdXA+XHJcbiAgICAgICAgICAgICAge2RhdGEuZWRpdFR5cGUgIT0gXCJmbG93XCIgJiYgPEZvcm0uSW5wdXQgbmFtZT1cImVkaXRGb3JtXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZWRpdGZvcm1maWVsZCcsICdFZGl0IGZvcm0nLCBcImdyaWRmb3JtXCIpfSBkaXNhYmxlZD17ZGF0YS5pbmxpbmUgPT0gdHJ1ZX0gdmFsdWU9e2RhdGEuZWRpdEZvcm19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+fVxyXG4gICAgICAgICAgICAgIHtkYXRhLmVkaXRUeXBlID09IFwiZmxvd1wiICYmIDxGb3JtLklucHV0IG5hbWU9XCJlZGl0Rmxvd1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2VkaXRmbG93ZmllbGQnLCAnRWRpdCBmbG93JywgXCJncmlkZm9ybVwiKX0gZGlzYWJsZWQ9e2RhdGEuaW5saW5lID09IHRydWV9IHZhbHVlPXtkYXRhLmVkaXRGbG93fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPn1cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwicm93S2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncm93a2V5ZmllbGQnLCAnUm93IGtleScsIFwiZ3JpZGZvcm1cIil9IHZhbHVlPXtkYXRhLnJvd0tleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInBhZ2VTaXplXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncGFnZXNpemVmaWVsZCcsICdQYWdlIHNpemUnLCBcImdyaWRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5wYWdlU2l6ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImRlZmF1bHRTb3J0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGVmYXVsdHNvcnRmaWVsZCcsICdEZWZhdWx0IHNvcnQnLCBcImdyaWRmb3JtXCIpfSBwbGFjZWhvbGRlcj1cIk5hbWUgQVNDXCIgdmFsdWU9e2RhdGEuZGVmYXVsdFNvcnR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPEZvcm0uRHJvcGRvd24gbmFtZT1cImVkaXRGb3JtU2hvd1R5cGVcIiBzZWxlY3Rpb24gZmx1aWQgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZWRpdGZvcm1zaG93dHlwZWZpZWxkJywgJ0VkaXQgZm9ybSBzaG93IHR5cGUnLCBcImdyaWRmb3JtXCIpfSBwbGFjZWhvbGRlcj17ZWRpdGZvcm10eXBlWzBdLnRleHR9IG9wdGlvbnM9e2VkaXRmb3JtdHlwZX0gdmFsdWU9e2RhdGEuZWRpdEZvcm1TaG93VHlwZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uRHJvcGRvd24gbmFtZT1cInBhZ2VyVHlwZVwiIHNlbGVjdGlvbiBmbHVpZCBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdwYWdlcnR5cGVmaWVsZCcsICdQYWdpbmF0aW9uIHR5cGUnLCBcImdyaWRmb3JtXCIpfSBwbGFjZWhvbGRlcj1cIk5vbmVcIiBvcHRpb25zPXtwYWdlcnR5cGV9IHZhbHVlPXtkYXRhLnBhZ2VyVHlwZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInJvd0hlaWdodFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3Jvd2hlaWdodGZpZWxkJywgJ1JvdyBoZWlnaHQnLCBcImdyaWRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5yb3dIZWlnaHR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJtaW5IZWlnaHRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdtaW5oZWlnaHRmaWVsZCcsICdNaW4gaGVpZ2h0JywgXCJncmlkZm9ybVwiKX0gdmFsdWU9e2RhdGEubWluSGVpZ2h0fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJhdXRvSGVpZ2h0XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYXV0b2hlaWdodGZpZWxkJywgJ0F1dG8gSGVpZ2h0JywgXCJncmlkZm9ybVwiKX0gY2hlY2tlZD17Qm9vbGVhbihkYXRhLmF1dG9IZWlnaHQpfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJvZmZTZXRcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdvZmZzZXRmaWVsZCcsICdPZmZTZXQnLCBcImdyaWRmb3JtXCIpfSBkaXNhYmxlZD17IUJvb2xlYW4oZGF0YS5hdXRvSGVpZ2h0KX0gdmFsdWU9e2RhdGEub2ZmU2V0fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8Q29sbGVjdGlvbkVkaXRvciBrZXk9XCJjb2x1bW5zXCIgXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU9e3RydWV9XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfSBcclxuICAgICAgICAgICAgICAgIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NvbHVtbnNmaWVsZCcsICdDb2x1bW5zJywgXCJncmlkZm9ybVwiKX1cclxuICAgICAgICAgICAgICAgIG5hbWU9XCJjb2x1bW5zXCIgXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17ZGF0YVtcImNvbHVtbnNcIl19XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuICBcclxuICBnZXRFdmVudHNMaXN0KCl7XHJcbiAgICByZXR1cm4gW1wib25Sb3dDbGlja1wiLCBcIm9uUm93RGJsQ2xpY2tcIiwgXCJvblNlbGVjdGlvbkNoYW5nZWRcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBDb2xsZWN0aW9uRWRpdG9yRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuXHJcbiAgICB2YXIgY29sdW1ucyA9IFtcclxuICAgICAge2tleTogJ2tleScsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgna2V5Y29sdW1uJywgJ0tleScsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIil9LCBcclxuICAgICAge2tleTogJ25hbWUnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVjb2x1bW4nLCAnTmFtZScsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIil9LCBcclxuICAgICAge2tleTogJ2NvbnRyb2wnLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2NvbnRyb2xjb2x1bW4nLCAnQ29udHJvbCcsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIiksIGRhdGFMaXN0OltcImlucHV0XCIsIFwiY2hlY2tib3hcIiwgXCJzcGFuXCIsIFwibnVtYmVyXCIsIFwiZmlsZVwiLCBcImRhdGVcIiwgXCJkYXRldGltZVwiLCBcImN1c3RvbVwiXX0sXHJcbiAgICAgIHtrZXk6ICd3aWR0aCcsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnd2lkdGhjb2x1bW4nLCAnV2lkdGgnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiaWRGaWVsZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2lkZmllbGQnLCAnSWQgZmllbGQnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfSBkaXNhYmxlZD17ZGF0YS5oaWVyYXJjaGljYWwgIT0gdHJ1ZX0gdmFsdWU9e2RhdGEuaWRGaWVsZH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ29wdGlvbnNmaWVsZCcsICdPcHRpb25zJywgXCJjb2xsZWN0aW9uZWRpdG9yZm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cD5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwicmVhZE9ubHlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyZWFkb25seWZpZWxkJywgJ1JlYWRPbmx5JywgXCJjb2xsZWN0aW9uZWRpdG9yZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5yZWFkT25seX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZHJhZ2dhYmxlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZHJhZ2dhYmxlZmllbGQnLCAnRHJhZ2dhYmxlJywgXCJjb2xsZWN0aW9uZWRpdG9yZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5kcmFnZ2FibGV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImhpZXJhcmNoaWNhbFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2hpZXJhcmNoaWNhbGZpZWxkJywgJ0hpZXJhcmNoaWNhbCcsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuaGllcmFyY2hpY2FsfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiZGlzYWJsZUFkZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Rpc2FibGVBZGQnLCAnRGlzYWJsZSBBZGQnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmRpc2FibGVBZGR9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImNvbGxhcHNlQWxsXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnY29sbGFwc2VhbGxmaWVsZCcsICdDb2xsYXBzZSBhbGwnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfSBkaXNhYmxlZD17ZGF0YS5oaWVyYXJjaGljYWwgIT0gdHJ1ZX0gY2hlY2tlZD17ZGF0YS5jb2xsYXBzZUFsbH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJwYXJlbnRJZEZpZWxkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgncGFyZW50aWRmaWVsZCcsICdQYXJlbnRJZCBmaWVsZCcsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIil9IGRpc2FibGVkPXtkYXRhLmhpZXJhcmNoaWNhbCAhPSB0cnVlfSB2YWx1ZT17ZGF0YS5wYXJlbnRJZEZpZWxkfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiY2hpbGRyZW5GaWVsZFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NoaWxkcmVuRmllbGQnLCAnQ2hpbGRyZW4gZmllbGQnLCBcImNvbGxlY3Rpb25lZGl0b3Jmb3JtXCIpfSBkaXNhYmxlZD17ZGF0YS5oaWVyYXJjaGljYWwgIT0gdHJ1ZSB8fCAoZGF0YS5wYXJlbnRJZEZpZWxkICE9PSB1bmRlZmluZWQgJiYgZGF0YS5wYXJlbnRJZEZpZWxkICE9PSBcIlwiKX0gdmFsdWU9e2RhdGEuY2hpbGRyZW5GaWVsZH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Q29sbGVjdGlvbkVkaXRvciBrZXk9XCJjb2x1bW5zXCIgXHJcbiAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cclxuICAgICAgICAgICAgICBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdjb2x1bW5zZmllbGQnLCAnQ29sdW1ucycsIFwiY29sbGVjdGlvbmVkaXRvcmZvcm1cIil9XHJcbiAgICAgICAgICAgICAgbmFtZT1cImNvbHVtbnNcIiBcclxuICAgICAgICAgICAgICB2YWx1ZT17ZGF0YVtcImNvbHVtbnNcIl19XHJcbiAgICAgICAgICAgICAgaGVpZ2h0PVwiMjAwcHhcIlxyXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDwvRm9ybT4pO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRzTGlzdCgpe1xyXG4gICAgcmV0dXJuIFtcIm9uQ2hhbmdlXCIsIFwib25BZGRcIiwgXCJvbkRlbGV0ZVwiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEN1c3RvbUVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuICAgIHJldHVybiAoPEZvcm0+XHJcbiAgICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiY3VzdG9tZm9ybVwiKX0gdmFsdWU9e2RhdGEua2V5fSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0eXBlZmllbGQnLCAnVHlwZSBjb250cm9sJywgXCJjdXN0b21mb3JtXCIpfSB2YWx1ZT17ZGF0YS50eXBlfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uVGV4dEFyZWEga2V5PVwicHJvcHNcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdwcm9wc2ZpZWxkJywgJ1Byb3BzJywgXCJjdXN0b21mb3JtXCIpfSBuYW1lPVwicHJvcHNcIiBcclxuICAgICAgICAgICAgICB2YWx1ZT17ZGF0YVtcInByb3BzXCJdfSBcclxuICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxyXG4gICAgICAgICAgICAgIHJvd3M9ezV9IC8+XHJcbiAgICAgICAgICA8Rm9ybS5UZXh0QXJlYSBrZXk9XCJjaGlsZHJlblwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2NoaWxkcmVuZmllbGQnLCAnQ2hpbGRyZW4nLCBcImN1c3RvbWZvcm1cIil9IG5hbWU9XCJjaGlsZHJlblwiIFxyXG4gICAgICAgICAgICAgIHZhbHVlPXtkYXRhW1wiY2hpbGRyZW5cIl19IFxyXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgcm93cz17NX0gLz5cclxuICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8L0Zvcm0+KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEN1c3RvbUJsb2NrRWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG4gIFxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJjdXN0b21ibG9ja2Zvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ3NvdXJjZXR5cGVmaWVsZCcsICdTb3VyY2UgdHlwZScsIFwiY3VzdG9tYmxvY2tmb3JtXCIpfTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICAgIDxGb3JtLlJhZGlvIG5hbWU9XCJzb3VyY2VUeXBlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc291cmNldHlwZWZvcm1maWVsZCcsICdGb3JtIG5hbWUnLCBcImN1c3RvbWJsb2NrZm9ybVwiKX0gdmFsdWU9XCJmb3JtXCIgY2hlY2tlZD17ZGF0YS5zb3VyY2VUeXBlID09PSB1bmRlZmluZWQgfHwgZGF0YS5zb3VyY2VUeXBlID09ICdmb3JtJyB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgPEZvcm0uUmFkaW8gbmFtZT1cInNvdXJjZVR5cGVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzb3VyY2V0eXBlanNvbmZpZWxkJywgJ0pTT04gc291cmNlJywgXCJjdXN0b21ibG9ja2Zvcm1cIil9IHZhbHVlPVwic291cmNlXCIgY2hlY2tlZD17ZGF0YS5zb3VyY2VUeXBlID09PSAnc291cmNlJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgICA8Rm9ybS5SYWRpbyBuYW1lPVwic291cmNlVHlwZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3BsYWNlaG9sZGVyZmllbGQnLCAnUGxhY2Vob2xkZXInLCBcImN1c3RvbWJsb2NrZm9ybVwiKX0gdmFsdWU9XCJwbGFjZWhvbGRlclwiIGNoZWNrZWQ9e2RhdGEuc291cmNlVHlwZSA9PT0gJ3BsYWNlaG9sZGVyJ30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJmb3JtbmFtZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2Zvcm1uYW1lZmllbGQnLCAnRm9ybSBuYW1lJywgXCJjdXN0b21ibG9ja2Zvcm1cIil9IHZhbHVlPXtkYXRhLmZvcm1uYW1lfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSBcclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2RhdGEuc291cmNlVHlwZSAhPSB1bmRlZmluZWQgJiYgZGF0YS5zb3VyY2VUeXBlICE9ICdmb3JtJ30gLz5cclxuICAgICAgICA8Rm9ybS5UZXh0QXJlYSBrZXk9XCJzb3VyY2VcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzb3VyY2VmaWVsZCcsICdKU09OIHNvdXJjZScsIFwiY3VzdG9tYmxvY2tmb3JtXCIpfSBuYW1lPVwic291cmNlXCIgXHJcbiAgICAgICAgICAgIHZhbHVlPXtkYXRhW1wic291cmNlXCJdfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSByb3dzPXsxMH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2RhdGEuc291cmNlVHlwZSAhPSAnc291cmNlJ30gIC8+XHJcbiAgICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBNZW51RWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTsgIFxyXG5cclxuICAgIHZhciBjb2x1bW5zID0gW1xyXG4gICAgICB7a2V5OiAndGFyZ2V0JywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc3RhcmdldGNvbHVtbicsICdUYXJnZXQnLCBcIm1lbnVmb3JtXCIpLCB3aWR0aDogMTUwfSxcclxuICAgICAge2tleTogJ3RpdGxlJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc3RpdGxlY29sdW1uJywgJ1RpdGxlJywgXCJtZW51Zm9ybVwiKX0sXHJcbiAgICAgIHtrZXk6ICd2aXNpYmxlQ29uZGl0aW9uJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCd2aXNpYmxlQ29uZGl0aW9uY29sdW1uJywgJ1Zpc2libGUgQ29uZGl0aW9uJywgXCJtZW51Zm9ybVwiKX1cclxuICAgIF07XHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwibWVudWZvcm1cIil9IHZhbHVlPXtkYXRhLmtleX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiYWN0aXZlSXRlbVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2FjdGl2ZWl0ZW1maWVsZCcsICdBY3RpdmUgSXRlbScsIFwibWVudWZvcm1cIil9IHZhbHVlPXtkYXRhLmFjdGl2ZUl0ZW19IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgPGxhYmVsPnt0aGlzLmdldExvY2FsVmFsdWUoJ29wdGlvbnNmaWVsZCcsICdPcHRpb25zJywgXCJtZW51Zm9ybVwiKX08L2xhYmVsPlxyXG4gICAgICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJwb2ludGluZ1wiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3BvaW50aW5nZmllbGQnLCAnUG9pbnRpbmcnLCBcIm1lbnVmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnBvaW50aW5nfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwic2Vjb25kYXJ5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2Vjb25kYXJ5ZmllbGQnLCAnU2Vjb25kYXJ5JywgXCJtZW51Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5zZWNvbmRhcnkgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwidGFidWxhclwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3RhYnVsYXJmaWVsZCcsICdUYWJ1bGFyJywgXCJtZW51Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS50YWJ1bGFyIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImZsdWlkXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZmx1aWRmaWVsZCcsICdGbHVpZCcsIFwibWVudWZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZmx1aWQgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwidmVydGljYWxcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd2ZXJ0aWNhbGZpZWxkJywgJ1ZlcnRpY2FsJywgXCJtZW51Zm9ybVwiKX0gY2hlY2tlZD17ZGF0YS52ZXJ0aWNhbCB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJsaW5rXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbGlua2ZpZWxkJywgJ0xpbmsnLCBcIm1lbnVmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmxpbmsgfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPENvbGxlY3Rpb25FZGl0b3Iga2V5PVwiaXRlbXNcIiBcclxuICAgICAgICAgICAgICBkcmFnZ2FibGU9e3RydWV9XHJcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsPXt0cnVlfVxyXG4gICAgICAgICAgICAgIGNoaWxkcmVuRmllbGQ9XCJjaGlsZHJlblwiXHJcbiAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc30gXHJcbiAgICAgICAgICAgICAgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaXRlbXNmaWVsZCcsICdJdGVtcycsIFwibWVudWZvcm1cIil9XHJcbiAgICAgICAgICAgICAgbmFtZT1cIml0ZW1zXCIgXHJcbiAgICAgICAgICAgICAgdmFsdWU9e2RhdGFbXCJpdGVtc1wiXX1cclxuICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkl0ZW1DbGlja1wiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEJyZWFkY3J1bWJFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgdmFyIGNvbHVtbnMgPSBbXHJcbiAgICAgIHtrZXk6ICd0ZXh0JywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc3RleHRjb2x1bW4nLCAnVGV4dCcsIFwiYnJlYWRjcnVtYmZvcm1cIil9LFxyXG4gICAgICB7a2V5OiAndXJsJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc3VybGNvbHVtbicsICdVcmwnLCBcImJyZWFkY3J1bWJmb3JtXCIpfSxcclxuICAgICAge2tleTogJ2FjdGl2ZScsIGNvbnRyb2w6J2NoZWNrYm94JywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc2FjdGl2ZWNvbHVtbicsICdBY3RpdmUnLCBcImJyZWFkY3J1bWJmb3JtXCIpfSxcclxuICAgICAge2tleTogJ2RpdmlkZXInLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2l0ZW1zaWNvbmNvbHVtbicsICdEaXZpZGVyIEljb24nLCBcImJyZWFkY3J1bWJmb3JtXCIpLCBkYXRhTGlzdDpbXCJyaWdodCBhbmdsZVwiLCBcInJpZ2h0IGNoZXZyb25cIl19XHJcbiAgICBdO1xyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgPEZvcm0uR3JvdXAgd2lkdGhzPVwiZXF1YWxcIj5cclxuICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwia2V5XCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnbmFtZWZpZWxkJywgJ05hbWUnLCBcImJyZWFkY3J1bWJmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgPENvbGxlY3Rpb25FZGl0b3Iga2V5PVwiaXRlbXNcIiBcclxuICAgICAgICAgICAgICBkcmFnZ2FibGU9e3RydWV9XHJcbiAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc30gXHJcbiAgICAgICAgICAgICAgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaXRlbXNmaWVsZCcsICdJdGVtcycsIFwiYnJlYWRjcnVtYmZvcm1cIil9XHJcbiAgICAgICAgICAgICAgbmFtZT1cIml0ZW1zXCIgXHJcbiAgICAgICAgICAgICAgdmFsdWU9e2RhdGFbXCJpdGVtc1wiXX1cclxuICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJvbkl0ZW1DbGlja1wiXTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIERyb3Bkb3duVHJpZ2dlckVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gdGhpcy5wcm9wcy5wYXJlbnQuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcy5wcm9wcy5wYXJlbnQpO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7ICBcclxuXHJcbiAgICB2YXIgY29sdW1ucyA9IFtcclxuICAgICAge2tleTogJ3RhcmdldCcsIG5hbWU6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnaXRlbXN0YXJnZXRjb2x1bW4nLCAnVGFyZ2V0JywgXCJkcm9wZG93bnRyaWdnZXJmb3JtXCIpfSxcclxuICAgICAge2tleTogJ3RpdGxlJywgbmFtZTogdGhpcy5nZXRMb2NhbFZhbHVlKCdpdGVtc3RpdGxlY29sdW1uJywgJ1RpdGxlJywgXCJkcm9wZG93bnRyaWdnZXJmb3JtXCIpfSxcclxuICAgICAge2tleTogJ3Zpc2libGVDb25kaXRpb24nLCBuYW1lOiB0aGlzLmdldExvY2FsVmFsdWUoJ2l0ZW1zdmlzaWJsZWNvbmRpdGlvbmNvbHVtbicsICdWaXNpYmxlIENvbmRpdGlvbicsIFwiZHJvcGRvd250cmlnZ2VyZm9ybVwiKX1cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJkcm9wZG93bnRyaWdnZXJmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJkZWZhdWx0VmFsdWVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkZWZhdWx0dmFsdWVmaWVsZCcsICdEZWZhdWx0IFZhbHVlJywgXCJkcm9wZG93bnRyaWdnZXJmb3JtXCIpfSB2YWx1ZT17ZGF0YS5kZWZhdWx0VmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIjogZGF0YS5kZWZhdWx0VmFsdWV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJpbWFnZVVybFwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2ltYWdldXJsZmllbGQnLCAnSW1hZ2VVcmwnLCBcImRyb3Bkb3dudHJpZ2dlcmZvcm1cIil9IHZhbHVlPXtkYXRhLmltYWdlVXJsID09IHVuZGVmaW5lZCA/IFwiXCI6IGRhdGEuaW1hZ2VVcmx9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDxDb2xsZWN0aW9uRWRpdG9yIGtleT1cIml0ZW1zXCIgXHJcbiAgICAgICAgICAgICAgZHJhZ2dhYmxlPXt0cnVlfVxyXG4gICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9IFxyXG4gICAgICAgICAgICAgIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2l0ZW1zZmllbGQnLCAnSXRlbXMnLCBcImRyb3Bkb3dudHJpZ2dlcmZvcm1cIil9IFxyXG4gICAgICAgICAgICAgIG5hbWU9XCJpdGVtc1wiIFxyXG4gICAgICAgICAgICAgIHZhbHVlPXtkYXRhW1wiaXRlbXNcIl19XHJcbiAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG5cclxuICBnZXRFdmVudHNMaXN0KCl7XHJcbiAgICByZXR1cm4gW1wib25JdGVtQ2xpY2tcIl07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBEcm9wem9uZUVkaXRDb250cm9sIGV4dGVuZHMgQmFzZUVkaXRDb250cm9se1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgfVxyXG4gIGdldEdlbmVyYWxEZXNjcmlwdGlvbigpe1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhOyAgXHJcblxyXG4gICAgcmV0dXJuICg8Rm9ybT5cclxuICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImtleVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ25hbWVmaWVsZCcsICdOYW1lJywgXCJ1cGxvYWRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJpY29uRmlsZXR5cGVzXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnaWNvbkZpbGV0eXBlcycsICdJY29uIGZpbGUgdHlwZXMnLCBcInVwbG9hZGZvcm1cIil9IHBsYWNlaG9sZGVyPVwiKi5wbmcsICouanBnLCAqLmdpZlwiIHZhbHVlPXtkYXRhLmljb25GaWxldHlwZXMgPT0gdW5kZWZpbmVkID8gXCJcIiA6IGRhdGEuaWNvbkZpbGV0eXBlc30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInNob3dGaWxldHlwZUljb25cIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdzaG93RmlsZXR5cGVJY29uJywgJ1Nob3cgZmlsZSB0eXBlIGljb24nLCBcInVwbG9hZGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuc2hvd0ZpbGV0eXBlSWNvbiB9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cImF1dG9Qcm9jZXNzUXVldWVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdhdXRvUHJvY2Vzc1F1ZXVlJywgJ0F1dG8gcHJvY2VzcyBxdWV1ZScsIFwidXBsb2FkZm9ybVwiKX0gY2hlY2tlZD17ZGF0YS5hdXRvUHJvY2Vzc1F1ZXVlIH0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICA8Rm9ybS5DaGVja2JveCBuYW1lPVwiYWRkUmVtb3ZlTGlua3NcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdhZGRSZW1vdmVMaW5rcycsICdBZGQgcmVtb3ZlIGxpbmtzJywgXCJ1cGxvYWRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLmFkZFJlbW92ZUxpbmtzfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICA8L0Zvcm0uR3JvdXA+XHJcbiAgICA8L0Zvcm0+KTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50c0xpc3QoKXtcclxuICAgIHJldHVybiBbXCJzdWNjZXNzXCJdO1xyXG4gIH1cclxufVxyXG5cclxuLy8tLS0tLS0tLS0tXHJcbi8vQ2hhcnRcclxuLy8tLS0tLS0tLS0tXHJcbmNsYXNzIENoYXJ0RWRpdENvbnRyb2wgZXh0ZW5kcyBCYXNlRWRpdENvbnRyb2x7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICB9XHJcbiAgZ2V0R2VuZXJhbERlc2NyaXB0aW9uKCl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcclxuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSB0aGlzLnByb3BzLnBhcmVudC5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLnByb3BzLnBhcmVudCk7XHJcblxyXG4gICAgdmFyIGxlZ2VuZFBvc2l0aW9uT3B0aW9ucyA9IFtcclxuICAgICAge3ZhbHVlOiBcIlwiLCB0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xlZ2VuZHBvc2l0aW9uZGVmYXVsdGZpZWxkJywgJ0RlZmF1bHQnLCBcImNoYXJ0Zm9ybVwiKX0sXHJcbiAgICAgIHt2YWx1ZTogXCJ0b3BcIiwgdGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdsZWdlbmRwb3NpdGlvbnRvcGZpZWxkJywgJ1RvcCcsIFwiY2hhcnRmb3JtXCIpfSxcclxuICAgICAge3ZhbHVlOiBcImxlZnRcIiwgdGV4dDogdGhpcy5nZXRMb2NhbFZhbHVlKCdsZWdlbmRwb3NpdGlvbmxlZnRmaWVsZCcsICdMZWZ0JywgXCJjaGFydGZvcm1cIil9LFxyXG4gICAgICB7dmFsdWU6IFwiYm90dG9tXCIsIHRleHQ6IHRoaXMuZ2V0TG9jYWxWYWx1ZSgnbGVnZW5kcG9zaXRpb25ib3R0b21maWVsZCcsICdCb3R0b20nLCBcImNoYXJ0Zm9ybVwiKX0sXHJcbiAgICAgIHt2YWx1ZTogXCJyaWdodFwiLCB0ZXh0OiB0aGlzLmdldExvY2FsVmFsdWUoJ2xlZ2VuZHBvc2l0aW9ucmlnaHRmaWVsZCcsICdSaWdodCcsIFwiY2hhcnRmb3JtXCIpfVxyXG4gICAgXTtcclxuICAgXHJcbiAgICB2YXIgZGlzYWJsZUN1c3RvbSA9IGRhdGEuZGF0YXNldEN1c3RvbSA9PSBcIlwiIHx8IGRhdGEuZGF0YXNldEN1c3RvbSA9PSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwiY2hhcnRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJ0aXRsZVwiIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ3RpdGxlZmllbGQnLCAnVGl0bGUnLCBcImNoYXJ0Zm9ybVwiKX0gdmFsdWU9e2RhdGEudGl0bGV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJ0aXRsZVNpemVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCd0aXRsZXNpemVmaWVsZCcsICdUaXRsZSBzaXplJywgXCJjaGFydGZvcm1cIil9IHZhbHVlPXtkYXRhLnRpdGxlU2l6ZX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uRHJvcGRvd24gbmFtZT1cImxlZ2VuZFBvc2l0aW9uXCIgc2VsZWN0aW9uIGZsdWlkIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2xlZ2VuZHBvc2l0aW9uZmllbGQnLCAnTGVnZW5kIHBvc2l0aW9uJywgXCJjaGFydGZvcm1cIil9IHBsYWNlaG9sZGVyPXtsZWdlbmRQb3NpdGlvbk9wdGlvbnNbMF0udGV4dH0gb3B0aW9ucz17bGVnZW5kUG9zaXRpb25PcHRpb25zfSB2YWx1ZT17ZGF0YS5sZWdlbmRQb3NpdGlvbn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDwvZGl2PiBcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPEZvcm0uQ2hlY2tib3ggbmFtZT1cInJlc3BvbnNpdmVcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdyZXNwb25zaXZlZmllbGQnLCAnUmVzcG9uc2l2ZScsIFwiY2hhcnRmb3JtXCIpfSBjaGVja2VkPXtkYXRhLnJlc3BvbnNpdmV9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJkYXRhc2V0Q3VzdG9tXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGF0YXNldGN1c3RvbWZpZWxkJywgJ0RhdGFzZXQgY3VzdG9tJywgXCJjaGFydGZvcm1cIil9IGNoZWNrZWQ9e2RhdGEuZGF0YXNldEN1c3RvbX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cImRhdGFMYWJlbHNcIiBzdHlsZT17e3BhZGRpbmdUb3A6IFwiNXB4XCJ9fSBkaXNhYmxlZD17ZGlzYWJsZUN1c3RvbX0gcGxhY2Vob2xkZXI9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnZGF0YWxhYmVsc3BsYWNlaG9sZGVyJywgJ1ExLCBRMiwgUTMsIFE0JywgXCJjaGFydGZvcm1cIil9IFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGFsYWJlbHNmaWVsZCcsICdEYXRhIGxhYmVscycsIFwiY2hhcnRmb3JtXCIpfSB2YWx1ZT17ZGF0YS5kYXRhTGFiZWxzfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiZGF0YXNldExhYmVsXCIgZGlzYWJsZWQ9e2Rpc2FibGVDdXN0b219IGxhYmVsPXt0aGlzLmdldExvY2FsVmFsdWUoJ2RhdGFzZXRsYWJlbGZpZWxkJywgJ0RhdGFzZXQgTGFiZWwnLCBcImNoYXJ0Zm9ybVwiKX0gdmFsdWU9e2RhdGEuZGF0YXNldExhYmVsfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgICAgICA8Rm9ybS5JbnB1dCBuYW1lPVwiZGF0YXNldEJhY2tncm91bmRDb2xvclwiIGRpc2FibGVkPXtkaXNhYmxlQ3VzdG9tfSBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCdkYXRhc2V0YmFja2dyb3VuZGNvbG9yZmllbGQnLCAnRGF0YXNldCBCYWNrZ3JvdW5kQ29sb3InLCBcImNoYXJ0Zm9ybVwiKX0gdmFsdWU9e2RhdGEuZGF0YXNldEJhY2tncm91bmRDb2xvcn0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG59XHJcblxyXG4vLy0tLS0tLS0tLS1cclxuLy9Xb3JrZmxvd1xyXG4vLy0tLS0tLS0tLS1cclxuY2xhc3MgV29ya2Zsb3dCYXJFZGl0Q29udHJvbCBleHRlbmRzIEJhc2VFZGl0Q29udHJvbHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gIH1cclxuICBnZXRHZW5lcmFsRGVzY3JpcHRpb24oKXtcclxuICAgIHZhciBkYXRhID0gdGhpcy5wcm9wcy5kYXRhO1xyXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IHRoaXMucHJvcHMucGFyZW50LmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMucHJvcHMucGFyZW50KTtcclxuXHJcbiAgICByZXR1cm4gKDxGb3JtPlxyXG4gICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJrZXlcIiBsYWJlbD17dGhpcy5nZXRMb2NhbFZhbHVlKCduYW1lZmllbGQnLCAnTmFtZScsIFwid29ya2Zsb3dmb3JtXCIpfSB2YWx1ZT17ZGF0YS5rZXl9IG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IC8+XHJcbiAgICAgICAgPEZvcm0uSW5wdXQgbmFtZT1cInNldFN0YXRlQnV0dG9uXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnc2V0c3RhdGVidXR0b25maWVsZCcsICdTZXQgc3RhdGUgYnV0dG9uJywgXCJ3b3JrZmxvd2Zvcm1cIil9IHZhbHVlPXtkYXRhLnNldFN0YXRlQnV0dG9ufSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxyXG4gICAgICAgIDxGb3JtLkNoZWNrYm94IG5hbWU9XCJibG9ja1NldFN0YXRlXCIgbGFiZWw9e3RoaXMuZ2V0TG9jYWxWYWx1ZSgnYmxvY2tzZXRzdGF0ZWZpZWxkJywgJ0Jsb2NrIFNldFN0YXRlJywgXCJ3b3JrZmxvd2Zvcm1cIil9IGNoZWNrZWQ9e0Jvb2xlYW4oZGF0YS5ibG9ja1NldFN0YXRlKX0gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX0gLz5cclxuICAgICAgPC9Gb3JtPik7XHJcbiAgfVxyXG5cclxuICBnZXRFdmVudHNMaXN0KCl7XHJcbiAgICByZXR1cm4gW1wib25Db21tYW5kQ2xpY2tcIiwgXCJvblNldFN0YXRlQ2xpY2tcIiwgXCJvblJlY2VpdmVkQ29tbWFuZHNcIl07XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBCYXNlRWRpdENvbnRyb2wsXHJcbiAgSGVhZGVyRWRpdENvbnRyb2wsXHJcbiAgQnV0dG9uRWRpdENvbnRyb2wsXHJcbiAgTGFiZWxFZGl0Q29udHJvbCxcclxuICBNZXNzYWdlRWRpdENvbnRyb2wsXHJcbiAgSW5wdXRFZGl0Q29udHJvbCxcclxuICBUZXh0QXJlYUVkaXRDb250cm9sLFxyXG4gIERyb3Bkb3duRWRpdENvbnRyb2wsXHJcbiAgRGljdGlvbmFyeUVkaXRDb250cm9sLFxyXG4gIFJhZGlvR3JvdXBFZGl0Q29udHJvbCxcclxuICBDaGVja2JveEVkaXRDb250cm9sLFxyXG4gIEZvcm1FZGl0Q29udHJvbCxcclxuICBGb3JtR3JvdXBFZGl0Q29udHJvbCxcclxuICBJbWFnZUVkaXRDb250cm9sLCBcclxuICBTdGF0aXN0aWNFZGl0Q29udHJvbCxcclxuICBHcmlkRWRpdENvbnRyb2wsXHJcbiAgQ3VzdG9tRWRpdENvbnRyb2wsXHJcbiAgTWVudUVkaXRDb250cm9sLFxyXG4gIENoYXJ0RWRpdENvbnRyb2wsXHJcbiAgV29ya2Zsb3dCYXJFZGl0Q29udHJvbCxcclxuICBDb250YWluZXJFZGl0Q29udHJvbCxcclxuICBTdGF0aWNDb250ZW50RWRpdENvbnRyb2wsXHJcbiAgQ29sbGVjdGlvbkVkaXRvckVkaXRDb250cm9sLFxyXG4gIEN1c3RvbUJsb2NrRWRpdENvbnRyb2wsXHJcbiAgRHJvcGRvd25UcmlnZ2VyRWRpdENvbnRyb2wsXHJcbiAgRHJvcHpvbmVFZGl0Q29udHJvbCxcclxuICBCcmVhZGNydW1iRWRpdENvbnRyb2wsXHJcbiAgU2VhcmNoRWRpdENvbnRyb2xcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lZGl0Zm9ybS1jb250cm9scy5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7fVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICBsZXQgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcclxuICAgIGxldCBjb250cm9scyA9IFtdO1xyXG4gICAgbGV0IGlzRm9ybSA9IHRoaXMucHJvcHMuaXNGb3JtO1xyXG4gICAgbGV0IHRva2VuID0gdGhpcy5wcm9wcy52YWx1ZTtcclxuICAgXHJcbiAgICBpZih0b2tlbiAhPSB1bmRlZmluZWQgJiYgdG9rZW4gIT0gbnVsbCAmJiB0b2tlbiAhPSBcIlwiKXtcclxuICAgICAgbGV0IGRvd25sb2FkdGV4dCA9IFwiRG93bmxvYWRcIjtcclxuICAgICAgbGV0IGNsZWFydGV4dCA9IFwiQ2xlYXJcIjtcclxuICAgICAgaWYod2luZG93LkRXS2l0QWRtaW5MYW5nICE9IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRBZG1pbkxhbmcuYnV0dG9uICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgZG93bmxvYWR0ZXh0ID0gd2luZG93LkRXS2l0QWRtaW5MYW5nLmJ1dHRvbi5kb3dubG9hZDtcclxuICAgICAgICBjbGVhcnRleHQgPSB3aW5kb3cuRFdLaXRBZG1pbkxhbmcuYnV0dG9uLmNsZWFyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgaXNIaWRlQ2xlYXIgPSB0aGlzLnByb3BzLmRpc2FibGVkIHx8IHRoaXMucHJvcHMucmVhZE9ubHkgfHwgdGhpcy5wcm9wcy5oaWRlQ2xlYXJCdXR0b247XHJcbiAgICAgIGNvbnRyb2xzLnB1c2goPGEga2V5PVwiZG93bmxvYWRcIiBjbGFzc05hbWU9XCJ1aSBidXR0b25cIiB0YXJnZXQ9XCJibGFua1wiIGhyZWY9e3RoaXMucHJvcHMuZG93bmxvYWRVcmwgKyB0b2tlbn0+e2Rvd25sb2FkdGV4dH08L2E+KTtcclxuICAgICBcclxuICAgICAgaWYoIWlzSGlkZUNsZWFyKXtcclxuICAgICAgICBjb250cm9scy5wdXNoKDxzcGFuIGtleT1cInNwYXJhdG9yXCI+Jm5ic3A7Jm5ic3A7PC9zcGFuPik7XHJcbiAgICAgICAgY29udHJvbHMucHVzaCg8YnV0dG9uIGtleT1cImNsZWFyXCIgY2xhc3NOYW1lPVwidWkgYnV0dG9uXCIgb25DbGljaz17dGhpcy5vbkNsZWFyLmJpbmQodGhpcyl9PntjbGVhcnRleHR9PC9idXR0b24+KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgaWYodGhpcy5wcm9wcy5kaXNhYmxlZCB8fCB0aGlzLnByb3BzLnJlYWRPbmx5KVxyXG4gICAgICAgIGNvbnRyb2xzLnB1c2goPHNwYW4+PC9zcGFuPik7XHJcbiAgICAgIGVsc2UgIFxyXG4gICAgICAgIGNvbnRyb2xzLnB1c2goPGlucHV0IGtleT1cInVwbG9hZGNvbnRyb2xcIiB0eXBlPVwiZmlsZVwiIG5hbWU9e3RoaXMucHJvcHMubmFtZX0gb25DaGFuZ2U9e3RoaXMub25DaGFuZ2UuYmluZCh0aGlzKX0vPik7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcclxuICAgIGlmKGlzRm9ybSl7XHJcbiAgICAgIHJlcyA9IDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cclxuICAgICAgICB7dGhpcy5wcm9wcy5sYWJlbCAhPSB1bmRlZmluZWQgJiYgPGxhYmVsPnt0aGlzLnByb3BzLmxhYmVsfTwvbGFiZWw+fVxyXG4gICAgICAgIDxkaXYgZGF0YS1idWlsZGVydHlwZT17dHlwZX0+XHJcbiAgICAgICAgICB7Y29udHJvbHN9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PjtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJlcyA9IDxkaXYgZGF0YS1idWlsZGVydHlwZT17dHlwZX0+XHJcbiAgICAgICAge3RoaXMucHJvcHMubGFiZWwgIT0gdW5kZWZpbmVkICYmIDxkaXYgY2xhc3NOYW1lPVwidWkgbGFiZWwgbGFiZWxcIj57dGhpcy5wcm9wcy5sYWJlbH08L2Rpdj59XHJcbiAgICAgICAge2NvbnRyb2xzfVxyXG4gICAgICA8L2Rpdj47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIG9uQ2hhbmdlKGUpe1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIHZhciBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgZm9ybWRhdGEuYXBwZW5kKG1lLnByb3BzLm5hbWUsIGUudGFyZ2V0LmZpbGVzWzBdKTtcclxuXHJcbiAgICAkLmFqYXgoe1xyXG4gICAgICB1cmw6IG1lLnByb3BzLnVwbG9hZFVybCxcclxuICAgICAgdHlwZTogJ1BPU1QnLFxyXG4gICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcclxuICAgICAgZGF0YVR5cGUgOiAnanNvbicsXHJcbiAgICAgIGRhdGE6IGZvcm1kYXRhLFxyXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihqc29uRGF0YSl7XHJcbiAgICAgICAgaWYoanNvbkRhdGEuc3VjY2VzcyA9PSB0cnVlKXtcclxuICAgICAgICAgIGlmKG1lLnByb3BzLm9uQ2hhbmdlICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1lLnByb3BzLm9uQ2hhbmdlKGUsIHtuYW1lOiBtZS5wcm9wcy5uYW1lLCB2YWx1ZToganNvbkRhdGEubWVzc2FnZX0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBvbkNsZWFyKCl7XHJcbiAgICBpZih0aGlzLnByb3BzLm9uQ2hhbmdlICE9IHVuZGVmaW5lZClcclxuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh1bmRlZmluZWQsIHtuYW1lOiB0aGlzLnByb3BzLm5hbWUsIHZhbHVlOiBudWxsfSk7XHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbnRyb2wvdXBsb2FkLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IFJlYWN0RGF0ZVBpY2tlciBmcm9tICdyZWFjdC1kYXRlcGlja2VyJztcclxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVBpY2tlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSB7fTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpe1xyXG4gICAgbGV0IHR5cGUgPSB0aGlzLnByb3BzLnR5cGU7XHJcbiAgICBsZXQgaXNGb3JtID0gdGhpcy5wcm9wcy5pc0Zvcm07XHJcbiAgICBsZXQgZGF0ZSA9IHRoaXMucHJvcHMudmFsdWUgPyBtb21lbnQodGhpcy5wcm9wcy52YWx1ZSkgOiB1bmRlZmluZWQ7XHJcbiAgXHJcbiAgICBsZXQgY29udHJvbFByb3BzID0ge307XHJcbiAgICBjb250cm9sUHJvcHMucmVhZE9ubHkgPSB0aGlzLnByb3BzLnJlYWRPbmx5O1xyXG4gICAgXHJcbiAgICBpZih0eXBlID09PSBcImRhdGVcIil7XHJcbiAgICAgIGlmKHdpbmRvdy5EV0tpdExhbmcgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRMYW5nLmNvbW1vbiAhPSB1bmRlZmluZWQgJiYgd2luZG93LkRXS2l0TGFuZy5jb21tb24uZGF0ZUZvcm1hdCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGNvbnRyb2xQcm9wcy5kYXRlRm9ybWF0ID0gd2luZG93LkRXS2l0TGFuZy5jb21tb24uZGF0ZUZvcm1hdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIGNvbnRyb2xQcm9wcy5kYXRlRm9ybWF0ID0gXCJERC5NTS5ZWVlZXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gXCJ0aW1lXCIpe1xyXG4gICAgICBjb250cm9sUHJvcHMuc2hvd1RpbWVTZWxlY3QgPSB0cnVlO1xyXG4gICAgICBjb250cm9sUHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5ID0gdHJ1ZTtcclxuICAgICAgY29udHJvbFByb3BzLnRpbWVJbnRlcnZhbHM9IDEwO1xyXG4gICAgICBpZih3aW5kb3cuRFdLaXRMYW5nICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkRXS2l0TGFuZy5jb21tb24gIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRMYW5nLmNvbW1vbi50aW1lRm9ybWF0ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgY29udHJvbFByb3BzLmRhdGVGb3JtYXQgPSB3aW5kb3cuRFdLaXRMYW5nLmNvbW1vbi50aW1lRm9ybWF0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgY29udHJvbFByb3BzLmRhdGVGb3JtYXQgPSBcIkhIOm1tXCI7XHJcbiAgICAgICAgY29udHJvbFByb3BzLnRpbWVGb3JtYXQ9XCJISDptbVwiXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gXCJkYXRldGltZVwiKXtcclxuICAgICAgY29udHJvbFByb3BzLnNob3dUaW1lU2VsZWN0ID0gdHJ1ZTtcclxuICAgICAgaWYod2luZG93LkRXS2l0TGFuZyAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5EV0tpdExhbmcuY29tbW9uICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkRXS2l0TGFuZy5jb21tb24uZGF0ZUZvcm1hdCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGNvbnRyb2xQcm9wcy50aW1lRm9ybWF0ID0gd2luZG93LkRXS2l0TGFuZy5jb21tb24udGltZUZvcm1hdDtcclxuICAgICAgICBjb250cm9sUHJvcHMuZGF0ZUZvcm1hdCA9IHdpbmRvdy5EV0tpdExhbmcuY29tbW9uLmRhdGVGb3JtYXQgKyBcIiBcIiArIFxyXG4gICAgICAgICAgKHdpbmRvdy5EV0tpdExhbmcuY29tbW9uLnRpbWVGb3JtYXQgPT0gdW5kZWZpbmVkID8gXCJISDpzc1wiIDogd2luZG93LkRXS2l0TGFuZy5jb21tb24udGltZUZvcm1hdCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICBjb250cm9sUHJvcHMuZGF0ZUZvcm1hdCA9IFwiREQuTU0uWVlZWSBISDptbVwiO1xyXG4gICAgICAgIGNvbnRyb2xQcm9wcy50aW1lRm9ybWF0PVwiSEg6bW1cIlxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5wcm9wcy5kYXRlRm9ybWF0ICE9IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzLmRhdGVGb3JtYXQgIT0gXCJcIilcclxuICAgICAgY29udHJvbFByb3BzLmRhdGVGb3JtYXQ7XHJcblxyXG4gICAgdGhpcy5zdGF0ZS5kYXRlRm9ybWF0ID0gY29udHJvbFByb3BzLmRhdGVGb3JtYXQ7XHJcblxyXG4gICAgbGV0IGNvbnRyb2w7XHJcbiAgICBcclxuICAgIGNvbnRyb2wgPSA8UmVhY3REYXRlUGlja2VyIHsuLi5jb250cm9sUHJvcHN9XHJcbiAgICAgICAgICBwZWVrTmV4dE1vbnRoXHJcbiAgICAgICAgICBzaG93TW9udGhEcm9wZG93blxyXG4gICAgICAgICAgc2hvd1llYXJEcm9wZG93blxyXG4gICAgICAgICAgZHJvcGRvd25Nb2RlPVwic2VsZWN0XCJcclxuICAgICAgICAgIGlzQ2xlYXJhYmxlPXshdGhpcy5wcm9wcy5yZWFkT25seX1cclxuICAgICAgICAgIHBsYWNlaG9sZGVyVGV4dD17dGhpcy5wbGFjZWhvbGRlcn1cclxuICAgICAgICAgIHNlbGVjdGVkPXtkYXRlfVxyXG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2UuYmluZCh0aGlzKX1cclxuICAgICAgICAgIG9uQ2hhbmdlUmF3PXsoZXZlbnQpID0+XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlUmF3KGV2ZW50LnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgLz47XHJcblxyXG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcclxuICAgIGlmKGlzRm9ybSl7XHJcbiAgICAgIGxldCBkaXZDbGFzcyA9IFwiZmllbGRcIjtcclxuICAgICAgaWYodGhpcy5wcm9wcy5lcnJvcilcclxuICAgICAgICBkaXZDbGFzcyArPSBcIiBlcnJvclwiO1xyXG4gICAgICByZXMgPSA8ZGl2IGNsYXNzTmFtZT17ZGl2Q2xhc3N9PlxyXG4gICAgICAgIHt0aGlzLnByb3BzLmxhYmVsICE9IHVuZGVmaW5lZCAmJiA8bGFiZWw+e3RoaXMucHJvcHMubGFiZWx9PC9sYWJlbD59XHJcbiAgICAgICAgPGRpdiBkYXRhLWJ1aWxkZXJ0eXBlPXt0eXBlfSBjbGFzc05hbWU9XCJ1aSBmbHVpZCBpbnB1dFwiPlxyXG4gICAgICAgICAge2NvbnRyb2x9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PjtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIGxldCBkaXZDbGFzcyA9IFwidWkgZmx1aWQgbGFiZWxlZCBpbnB1dFwiO1xyXG4gICAgICBpZih0aGlzLnByb3BzLmVycm9yKVxyXG4gICAgICAgIGRpdkNsYXNzICs9IFwiIGVycm9yXCI7XHJcbiAgICAgIHJlcyA9IDxkaXYgZGF0YS1idWlsZGVydHlwZT17dHlwZX0gY2xhc3NOYW1lPXtkaXZDbGFzc30+XHJcbiAgICAgICAge3RoaXMucHJvcHMubGFiZWwgIT0gdW5kZWZpbmVkICYmIDxkaXYgY2xhc3NOYW1lPVwidWkgbGFiZWwgbGFiZWxcIj57dGhpcy5wcm9wcy5sYWJlbH08L2Rpdj59XHJcbiAgICAgICAge2NvbnRyb2x9XHJcbiAgICAgIDwvZGl2PjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlQ2hhbmdlUmF3KHZhbHVlKSB7XHJcbiAgICBsZXQgZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgIGxldCB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xyXG4gICAgZGF0ZSA9IG1vbWVudCh2YWx1ZSwgdGhpcy5zdGF0ZS5kYXRlRm9ybWF0KTtcclxuICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XHJcbiAgfVxyXG5cclxuICBvbkNoYW5nZShkYXRlKXsgXHJcbiAgICBpZih0aGlzLnByb3BzLnJlYWRPbmx5KVxyXG4gICAgICByZXR1cm47XHJcbiAgICBcclxuICAgIGlmKHRoaXMucHJvcHMub25DaGFuZ2UgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgbGV0IHZhbHVlID0gbnVsbDtcclxuICAgICAgaWYoZGF0ZSAhPSBudWxsICYmIGRhdGUgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBsZXQgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcclxuICAgICAgICBsZXQgZm9ybWF0ID0gXCJcIjtcclxuICAgICAgICBpZih0eXBlID09PSBcImRhdGVcIil7XHJcbiAgICAgICAgICB2YWx1ZSA9IGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IGRhdGUudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG51bGwsIHtuYW1lOiB0aGlzLnByb3BzLm5hbWUsIHZhbHVlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL2RhdGVwaWNrZXIuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBGb3JtLCBSYWRpbyB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9Hcm91cCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHt9XHJcbiAgfVxyXG5cclxuICBvbkNoYW5nZShlLCB7bmFtZSwgdmFsdWV9KXtcclxuICAgICAgaWYodGhpcy5wcm9wcy5vbkNoYW5nZSAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZSwge25hbWU6IHRoaXMucHJvcHMubmFtZSwgdmFsdWV9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlNldCBvbkNoYW5nZSBwcm9wZXJ0eSBmb3IgUmFkaW9Hcm91cCFcIik7XHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICB2YXIgZmllbGRzID0gdGhpcy5wcm9wcy5pdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxGb3JtLkZpZWxkIGtleT17aXRlbS5rZXkgKyBcIl9mb3JtZmllbGRcIn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPEZvcm0uUmFkaW9cclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpdGVtLmtleX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2l0ZW0udGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bWUucHJvcHMubmFtZSArICdfcmFkaW9Hcm91cCd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtpdGVtLnZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seT17bWUucHJvcHMucmVhZE9ubHl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e21lLnByb3BzLnZhbHVlID09PSBpdGVtLnZhbHVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17bWUub25DaGFuZ2UuYmluZCh0aGlzKX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtLkZpZWxkPlxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgaWYodGhpcy5wcm9wcy5kaXJlY3Rpb24gPT0gJ3YnKXtcclxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ1aSBmb3JtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWw+e3RoaXMucHJvcHMubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxGb3JtIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9IHN0eWxlPXt0aGlzLnByb3BzLnN0eWxlfSA+XHJcbiAgICAgICAgICAgICAgICAgICAge2ZpZWxkc31cclxuICAgICAgICAgICAgICAgIDwvRm9ybT5cclxuICAgICAgPC9kaXY+O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJ1aSBmb3JtXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+e3RoaXMucHJvcHMubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfSBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZX0gPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uR3JvdXAga2V5PVwiZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICB7ZmllbGRzfVxyXG4gICAgICAgICAgICAgICAgPC9Gb3JtLkdyb3VwPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+KTtcclxuICAgIFxyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL3JhZGlvZ3JvdXAuanN4IiwiY2xhc3MgRmlsdGVyVGVybXMge1xyXG4gICAgc3RhdGljIGdldCBHcmVhdGVyICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFwiPlwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIElzR3JlYXRlciAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBGaWx0ZXJUZXJtcy5HcmVhdGVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBMZXNzICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFwiPlwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIElzTGVzcyAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBGaWx0ZXJUZXJtcy5MZXNzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFcXVhbCAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBcIj1cIjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBJc0VxdWFsICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IEZpbHRlclRlcm1zLkVxdWFsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBHcmVhdGVyT3JFcXVhbCAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBcIj49XCI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgSXNHcmVhdGVyT3JFcXVhbCAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBGaWx0ZXJUZXJtcy5HcmVhdGVyT3JFcXVhbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTGVzc09yRXF1YWwgKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gXCI8PVwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIElzTGVzc09yRXF1YWwgKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gRmlsdGVyVGVybXMuTGVzc09yRXF1YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5vdEVxdWFsICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFwiIT1cIjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBJc05vdEVxdWFsICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IEZpbHRlclRlcm1zLk5vdEVxdWFsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBMaWtlICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFwibGlrZVwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIElzTGlrZSAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IEZpbHRlclRlcm1zLkxpa2UgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCIqbGlrZSpcIjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgU3RhcnRzV2l0aCAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBcImxpa2UqXCI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgSXNTdGFydHNXaXRoICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gRmlsdGVyVGVybXMuU3RhcnRzV2l0aDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRW5kc1dpdGggKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gXCIqbGlrZVwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIElzRW5kc1dpdGggKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBGaWx0ZXJUZXJtcy5FbmRzV2l0aDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBFdmFsdWF0ZSAodmFsdWUsIGV4cGVjdGVkLCB0ZXJtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChGaWx0ZXJUZXJtcy5Jc0dyZWF0ZXIodGVybSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyVGVybXMuY29tcGFyZVdpdGhUeXBlQ2hlY2sodmFsdWUsZXhwZWN0ZWQsKHYsZSk9PnY+ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChGaWx0ZXJUZXJtcy5Jc0xlc3ModGVybSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyVGVybXMuY29tcGFyZVdpdGhUeXBlQ2hlY2sodmFsdWUsZXhwZWN0ZWQsKHYsZSk9PnY8ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChGaWx0ZXJUZXJtcy5Jc0VxdWFsKHRlcm0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclRlcm1zLmNvbXBhcmVXaXRoVHlwZUNoZWNrKHZhbHVlLGV4cGVjdGVkLCh2LGUpPT52PT09ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChGaWx0ZXJUZXJtcy5Jc0dyZWF0ZXJPckVxdWFsKHRlcm0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclRlcm1zLmNvbXBhcmVXaXRoVHlwZUNoZWNrKHZhbHVlLGV4cGVjdGVkLCh2LGUpPT52Pj1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEZpbHRlclRlcm1zLklzTGVzc09yRXF1YWwodGVybSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyVGVybXMuY29tcGFyZVdpdGhUeXBlQ2hlY2sodmFsdWUsZXhwZWN0ZWQsKHYsZSk9PnY8PWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoRmlsdGVyVGVybXMuSXNOb3RFcXVhbCh0ZXJtKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJUZXJtcy5jb21wYXJlV2l0aFR5cGVDaGVjayh2YWx1ZSxleHBlY3RlZCwodixlKT0+diE9PWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoRmlsdGVyVGVybXMuSXNMaWtlKHRlcm0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclRlcm1zLmxpa2VDb21wYXJlKHZhbHVlLGV4cGVjdGVkLCh2LGUpPT52LmluZGV4T2YoZSk+PTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoRmlsdGVyVGVybXMuSXNTdGFydHNXaXRoKHRlcm0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclRlcm1zLmxpa2VDb21wYXJlKHZhbHVlLGV4cGVjdGVkLCh2LGUpPT52LnN0YXJ0c1dpdGgoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoRmlsdGVyVGVybXMuSXNFbmRzV2l0aCh0ZXJtKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJUZXJtcy5saWtlQ29tcGFyZSh2YWx1ZSxleHBlY3RlZCwodixlKT0+di5lbmRzV2l0aChlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBcIlVua25vd24gdGVybSBcIiArIHRlcm07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxpa2VDb21wYXJlICh2YWx1ZSxleHBlY3RlZCxjb21wYXJhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBleHBlY3RlZCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV4cGVjdGVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwgfHwgZXhwZWN0ZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSxleHBlY3RlZC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjb21wYXJlV2l0aFR5cGVDaGVjayAodmFsdWUsIGV4cGVjdGVkLCBjb21wYXJhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBleHBlY3RlZCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV4cGVjdGVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwgfHwgZXhwZWN0ZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSB0eXBlb2YgZXhwZWN0ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWx1ZSxleHBlY3RlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZXhwZWN0ZWQgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvciAodmFsdWUscGFyc2VGbG9hdChleHBlY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGV4cGVjdGVkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IgKHZhbHVlLGV4cGVjdGVkLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWx1ZSxleHBlY3RlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBGdW5jdGlvbmFsRmlsdGVyXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9iamVjdEZpbHRlcixjb2x1bW5zKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2lubmVyRmlsdGVyID0ge307XHJcbiAgICAgICAgaWYgKG9iamVjdEZpbHRlciA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KG9iamVjdEZpbHRlcikpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoY29sdW1ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KGNvbHVtbnMpKVxyXG4gICAgICAgICAgICB0aHJvdyBcImNvbHVtbnMgbXVzdCBiZSBhcnJheVwiO1xyXG5cclxuICAgICAgICBvYmplY3RGaWx0ZXIuZm9yRWFjaCgoZWwpPT57XHJcbiAgICAgICAgICAgIGlmIChlbCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlUb0NvbHVtbnM7XHJcbiAgICAgICAgICAgIGlmIChlbC5jb2x1bW4gPT09IFwiKlwiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhcHBseVRvQ29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhcHBseVRvQ29sdW1ucyA9IGVsLmNvbHVtbi5zcGxpdChcIixcIikubWFwKG49Pm4udHJpbSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5BZGRGaWx0ZXIoe25hbWVzOmFwcGx5VG9Db2x1bW5zLGV4cGVjdGVkOmVsLnZhbHVlLHRlcm06ZWwudGVybX0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBBZGRGaWx0ZXIgKHtuYW1lcyxleHBlY3RlZCx0ZXJtLGlkfSkge1xyXG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPCAxKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBmaWx0ZXJJZCA9IG5hbWVzLmxlbmd0aCA9PT0gMSA/IG5hbWVzWzBdIDogbmFtZXMuc29ydCgpLmpvaW4oXCJfXCIpO1xyXG4gICAgICAgIGxldCBmaWx0ZXI7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbm5lckZpbHRlci5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJJZCkpIHtcclxuICAgICAgICAgICAgZmlsdGVyID0gdGhpcy5faW5uZXJGaWx0ZXJbZmlsdGVySWRdID0ge307XHJcbiAgICAgICAgICAgIGZpbHRlci5mdW5jcyA9IFtdO1xyXG4gICAgICAgICAgICBmaWx0ZXIuaXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgZmlsdGVyLnRlc3QgPSAocikgPT4gdGhpcy5faW5uZXJGaWx0ZXJbZmlsdGVySWRdLmZ1bmNzLmV2ZXJ5KChmKSA9PiBmKHIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbHRlciA9IHRoaXMuX2lubmVyRmlsdGVyW2ZpbHRlcklkXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBsZXQgY29tcEZ1bmM7XHJcbiAgICAgICAgbGV0IHNpbmdsZUNvbXBGdW5jID0gKHIsIG5hbWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBPYmplY3Qua2V5cyhyKS5maW5kKGsgPT4gay50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBGaWx0ZXJUZXJtcy5FdmFsdWF0ZShyW3Byb3BOYW1lXSwgZXhwZWN0ZWQsIHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbXBGdW5jID0gKHIpID0+IHNpbmdsZUNvbXBGdW5jKHIsbmFtZXNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcEZ1bmMgPSAocikgPT4gbmFtZXMuc29tZSgobmFtZSkgPT4gc2luZ2xlQ29tcEZ1bmMocixuYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbHRlci5mdW5jcy5wdXNoKGNvbXBGdW5jKTtcclxuICAgICAgICBmaWx0ZXIuaXRlbXMucHVzaCh7ZXhwZWN0ZWQsIHRlcm0sIGlkfSk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVtb3ZlRmlsdGVyICh7bmFtZSwgaWR9KVxyXG4gICAge1xyXG4gICAgICAgIGxldCBmaWx0ZXJJZDtcclxuICAgICAgICBsZXQgbmFtZXM7XHJcbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBuYW1lLmxlbmd0aCA9PT0gMSA/IG5hbWVbMF0gOiBuYW1lLnNvcnQoKS5qb2luKFwiX1wiKTtcclxuICAgICAgICAgICAgICAgIG5hbWVzID0gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIG5hbWVzID0gW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkICYmIGlkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW5uZXJGaWx0ZXJbZmlsdGVySWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSB1bmRlZmluZWQgJiYgaWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lubmVyRmlsdGVyID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmVjcmVhdGVQcm9wZXJ0eSA9IChmaWx0ZXJJZCxuYW1lcyxpZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbm5lckZpbHRlci5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJJZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW1zID0gdGhpcy5faW5uZXJGaWx0ZXJbZmlsdGVySWRdLml0ZW1zLmZpbHRlcigoZWwpID0+IGVsLmlkICE9PSBpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbXMubGVuZ3RoIDwgdGhpcy5faW5uZXJGaWx0ZXJbZmlsdGVySWRdLml0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbm5lckZpbHRlcltmaWx0ZXJJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbXMuZm9yRWFjaCgobmkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRGaWx0ZXIoe25hbWVzLCBleHBlY3RlZDogbmkuZXhwZWN0ZWQsIHRlcm06IG5pLnRlcm0sIGlkOiBuaS5pZH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkICYmIGlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlY3JlYXRlUHJvcGVydHkoZmlsdGVySWQsbmFtZXMsaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRmlsdGVySWRzID0gT2JqZWN0LmtleXModGhpcy5faW5uZXJGaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgYWxsRmlsdGVySWRzLmZvckVhY2goKGZpbHRlcklkKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3JlYXRlUHJvcGVydHkoZmlsdGVySWQsZmlsdGVySWQuc3BsaXQoXCJfXCIpLGlkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgSXNSb3dNYXRjaGVkIChyb3cpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgYWxsTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9pbm5lckZpbHRlcik7XHJcbiAgICAgICAgaWYgKGFsbE5hbWVzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxOYW1lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5uZXJGaWx0ZXJbYWxsTmFtZXNbaV1dLnRlc3Qocm93KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEdldEZpbHRlckFzT2JqZWN0cyAoKXtcclxuICAgICAgICBpZiAodGhpcy5faW5uZXJGaWx0ZXIgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBjb25zdCBhbGxOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuX2lubmVyRmlsdGVyKTtcclxuICAgICAgICBhbGxOYW1lcy5mb3JFYWNoKChwbik9PntcclxuICAgICAgICAgICAgdGhpcy5faW5uZXJGaWx0ZXJbcG5dLml0ZW1zLmZvckVhY2goKGkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtjb2x1bW46cG4ucmVwbGFjZSgvXy9nLFwiLFwiKSx2YWx1ZTppLmV4cGVjdGVkLHRlcm06aS50ZXJtfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgRmlsdGVyVGVybXMsIEZ1bmN0aW9uYWxGaWx0ZXIgfVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mdW5jdGlvbmFsZmlsdGVyLmpzIiwiaW1wb3J0IERXS2l0Rm9ybUJ1aWRlciBmcm9tIFwiLi9zcmMvYnVpbGRlclwiO1xyXG5pbXBvcnQgRFdLaXRGb3JtIGZyb20gXCIuL3NyYy9mb3JtXCI7XHJcblxyXG5leHBvcnQge0RXS2l0Rm9ybUJ1aWRlcn1cclxuZXhwb3J0IHtEV0tpdEZvcm19XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vaW5kZXguanMiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XHJcbmltcG9ydCBUb29sYmFyIGZyb20gJy4vdG9vbGJhcidcclxuaW1wb3J0IFByZXZpZXcgZnJvbSAnLi9wcmV2aWV3J1xyXG5pbXBvcnQgU3RvcmUgZnJvbSAnLi9zdG9yZSdcclxuaW1wb3J0IEVkaXRGb3JtIGZyb20gJy4vZWRpdGZvcm0nO1xyXG5pbXBvcnQgRFdLaXRTdG9yZSBmcm9tICcuL3N0b3JlJztcclxuaW1wb3J0IEpTT041IGZyb20gJ2pzb241J1xyXG5pbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcuanN4J1xyXG5cclxuaW1wb3J0IHsgVGFiLCBNZW51LCBDaGVja2JveCwgQnV0dG9uIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEV0tpdEZvcm1CdWlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgZGVmYXVsdEZvcm06IHByb3BzLmRlZmF1bHRGb3JtLFxyXG4gICAgICBhcGl1cmw6IHByb3BzLmFwaXVybCxcclxuICAgICAgaW1hZ2Vmb2xkZXI6IHByb3BzLmltYWdlZm9sZGVyLFxyXG4gICAgICBhY3Rpb25zOiBwcm9wcy5hY3Rpb25zLFxyXG4gICAgICBkcm9wem9uZWFjdGl2ZTogdHJ1ZVxyXG4gICAgfSBcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgaWYodGhpcy5zdGF0ZS5kZWZhdWx0Rm9ybSAhPSB1bmRlZmluZWQpXHJcbiAgICAgIHRoaXMubG9hZCh0aGlzLnN0YXRlLmRlZmF1bHRGb3JtKTtcclxuICB9XHJcblxyXG4gIGV4aXN0cyhjb2RlKXtcclxuICAgIHJldHVybiBTdG9yZS5leGlzdHMoY29kZSk7XHJcbiAgfVxyXG5cclxuICBzZXRCdWlsZGVyTW9kZShlbmFibGVkKXtcclxuICAgIGlmKGVuYWJsZWQpe1xyXG4gICAgICAkKCcuZHdraXQtZm9ybWJ1aWxkZXItem9uZScpLnNob3coKTtcclxuICAgICAgJCgnLmR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXInKS5zaG93KCk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAkKCcuZHdraXQtZm9ybWJ1aWxkZXItem9uZScpLmhpZGUoKTtcclxuICAgICAgJCgnLmR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXInKS5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgIGRyb3B6b25lYWN0aXZlOiBlbmFibGVkXHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICBjcmVhdGUoKXtcclxuICAgIFN0b3JlLnNldERhdGEoW10pO1xyXG4gICAgdGhpcy5zZXRCdWlsZGVyTW9kZSh0cnVlKTtcclxuICB9XHJcblxyXG4gIGxvYWREYXRhKGRhdGEpe1xyXG4gICAgU3RvcmUuc2V0RGF0YShkYXRhKTtcclxuICAgIHRoaXMuc2V0QnVpbGRlck1vZGUodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBnZXREYXRhKCl7XHJcbiAgICByZXR1cm4gRFdLaXRTdG9yZS5nZXREYXRhKCk7XHJcbiAgfVxyXG5cclxuICBsb2FkKGNvZGUpe1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmdldEZvcm1GdW5jKGNvZGUpO1xyXG4gICAgU3RvcmUuc2V0RGF0YShkYXRhKTtcclxuICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICBjb2RlOiBjb2RlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNldEJ1aWxkZXJNb2RlKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgZG93bmxvYWQoKXtcclxuICAgIHZhciBkYXRhID0gRFdLaXRTdG9yZS5nZXREYXRhKCk7XHJcbiAgICB2YXIganNvbkNvbnRlbnQgPSAnZGF0YTp0ZXh0L2pzb247Y2hhcnNldD11dGYtOCwnO1xyXG4gICAganNvbkNvbnRlbnQgKz0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XHJcbiAgICB2YXIgZW5jb2RlZFVyaSA9IGpzb25Db250ZW50O1xyXG4gICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBlbmNvZGVkVXJpKTtcclxuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgXCJmb3JtLmpzb25cIik7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG4gICAgbGluay5jbGljaygpO1xyXG4gIH1cclxuXHJcbiAgdXBsb2FkKGZvcm0sIHN1Y2Nlc3NGdW5jKXtcclxuICAgIHZhciBmaWxlID0gZm9ybS5maWxlc1swXTtcclxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgcmVhZGVyLm9ubG9hZCA9IChmdW5jdGlvbih0aGVGaWxlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgRFdLaXRTdG9yZS5zZXREYXRhKGRhdGEpO1xyXG4gICAgICB9O1xyXG4gICAgfSkoZmlsZSk7XHJcblxyXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVTaG93RHJvcHpvbmVzQ2xpY2soZSwge25hbWUsIGNoZWNrZWR9KXtcclxuICAgIHRoaXMuc2V0QnVpbGRlck1vZGUoY2hlY2tlZCk7XHJcbiAgfVxyXG5cclxuICBvbkNob29zZUZpbGVVcGxvYWQoZSl7XHJcbiAgICAkKCcjYnVpbGRlclVwbG9hZEZpbGUnKS5jbGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25DaGFuZ2VGaWxlVXBsb2FkKGUpe1xyXG4gICAgJCgnI2J1aWxkZXJVcGxvYWRTdWJtaXQnKS5jbGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25VcGxvYWQoZSl7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0aGlzLnVwbG9hZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ1aWxkZXJVcGxvYWRGaWxlXCIpKTtcclxuICB9XHJcblxyXG4gIG9uRG93bmxvYWQoZSl7XHJcbiAgICB0aGlzLmRvd25sb2FkKCk7XHJcbiAgfVxyXG5cclxuICBzaG93c2FtcGxlMSgpe1xyXG4gICAgdGhpcy5sb2FkKFwiaW52b2ljZWZvcm1cIik7XHJcbiAgfVxyXG5cclxuICBzaG93c2FtcGxlMigpe1xyXG4gICAgdGhpcy5sb2FkKFwicHJvamVjdGZvcm1cIik7XHJcbiAgfVxyXG5cclxuICBnZXRIZWFkZXIoKXtcclxuICAgIHZhciBsb2NhbCA9IHRoaXMuZ2V0Q3VycmVudExvY2FsaXphdGlvbigpO1xyXG5cclxuICAgIHZhciBzcGFuU2VsZWN0b3JTdHlsZSA9IHRoaXMuc3RhdGUuZHJvcHpvbmVhY3RpdmUgPyBcIlwiIDogXCJkd2tpdC1mb3JtYnVpbGRlci1zZWxlY3Rvci1wcmV2aWV3XCI7XHJcbiAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItaGVhZGVyXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItaGVhZGVyLWxlZnRcIj5cclxuICAgICAgICA8aW1nIGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLWhlYWRlci1sb2dvXCIgc3JjPVwiL2ltYWdlcy9sb2dvLnN2Z1wiLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItaGVhZGVyLWNlbnRlclwiPlxyXG4gICAgICAgIDxCdXR0b24gbmFtZT1cImJ0bkVtcHR5XCIgY2xhc3NOYW1lPVwiYnV0dG9udHlwZTJcIiBvbkNsaWNrPXt0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpfT57bG9jYWwuY2xlYXJidXR0b259PC9CdXR0b24+XHJcbiAgICAgICAgPEJ1dHRvbiBuYW1lPVwiYnRuU2FtcGxlMVwiIGNsYXNzTmFtZT1cImJ1dHRvbnR5cGUxXCIgb25DbGljaz17dGhpcy5zaG93c2FtcGxlMS5iaW5kKHRoaXMpfT5TYW1wbGUgMTwvQnV0dG9uPlxyXG4gICAgICAgIDxCdXR0b24gbmFtZT1cImJ0blNhbXBsZTFcIiBjbGFzc05hbWU9XCJidXR0b250eXBlMVwiIG9uQ2xpY2s9e3RoaXMuc2hvd3NhbXBsZTIuYmluZCh0aGlzKX0+U2FtcGxlIDI8L0J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItaGVhZGVyLXJpZ2h0XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkd2tpdC1mb3JtYnVpbGRlci1zZWxlY3RvclwiPlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzcGFuU2VsZWN0b3JTdHlsZX0+UHJldmlldzwvc3Bhbj5cclxuICAgICAgICAgIDxDaGVja2JveCB0b2dnbGUgbmFtZT1cImNiU2hvd0Ryb3B6b25lc1wiIGxhYmVsPVwiQnVpbGRlclwiIGNoZWNrZWQ9e3RoaXMuc3RhdGUuZHJvcHpvbmVhY3RpdmV9IG9uQ2hhbmdlPXt0aGlzLmhhbmRsZVNob3dEcm9wem9uZXNDbGljay5iaW5kKHRoaXMpfS8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPEJ1dHRvbiBuYW1lPVwiYnRuVXBsb2FkXCIgY2xhc3NOYW1lPVwiYnV0dG9udHlwZTJcIiBvbkNsaWNrPXt0aGlzLm9uQ2hvb3NlRmlsZVVwbG9hZC5iaW5kKHRoaXMpfSA+e2xvY2FsLnVwbG9hZGJ1dHRvbn08L0J1dHRvbj5cclxuICAgICAgICA8QnV0dG9uIG5hbWU9XCJidG5Eb3dubG9hZFwiIGNsYXNzTmFtZT1cImJ1dHRvbnR5cGUyXCIgb25DbGljaz17dGhpcy5vbkRvd25sb2FkLmJpbmQodGhpcyl9Pntsb2NhbC5kb3dubG9hZGJ1dHRvbn08L0J1dHRvbj5cclxuICAgICAgICA8Zm9ybSBhY3Rpb249XCIvXCIgbWV0aG9kPVwicG9zdFwiIGlkPVwiYnVpbGRlclVwbG9hZEZvcm1cIiBzdHlsZT17e2Rpc3BsYXk6IFwibm9uZVwifX0gb25TdWJtaXQ9e3RoaXMub25VcGxvYWQuYmluZCh0aGlzKX0+XHJcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBpZD1cImJ1aWxkZXJVcGxvYWRGaWxlXCIgb25DaGFuZ2U9eyB0aGlzLm9uQ2hhbmdlRmlsZVVwbG9hZC5iaW5kKHRoaXMpIH0gLz5cclxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgaWQ9XCJidWlsZGVyVXBsb2FkU3VibWl0XCIgLz5cclxuICAgICAgICA8L2Zvcm0+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+KTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHZhciBsb2NhbGl6YXRpb24gPSB0aGlzLmdldEN1cnJlbnRMb2NhbGl6YXRpb24oKTtcclxuXHJcbiAgICB2YXIgY2xhc3NOYW1lID0gXCJkd2tpdC1mb3JtYnVpbGRlclwiO1xyXG4gICAgaWYodGhpcy5zdGF0ZS5kcm9wem9uZWFjdGl2ZSl7XHJcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkd2tpdC1mb3JtYnVpbGRlci1kcm9wem9uZWFjdGl2ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBidWlsZGVyID0gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItY29udGVudFwiPlxyXG4gICAgICAgIDxQcmV2aWV3IFxyXG4gICAgICAgICAgZ2V0Rm9ybUZ1bmM9e3RoaXMucHJvcHMuZ2V0Rm9ybUZ1bmN9IFxyXG4gICAgICAgICAgZ2V0Rm9ybUZpc3Q9e3RoaXMucHJvcHMuZ2V0Rm9ybUZpc3R9XHJcbiAgICAgICAgICBnZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2w9e3RoaXMucHJvcHMuZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sfVxyXG4gICAgICAgICAgbG9jYWxpemF0aW9uPXtsb2NhbGl6YXRpb24ucHJldmlld31cclxuICAgICAgICAgIGRvd25sb2FkVXJsPXt0aGlzLnByb3BzLmRvd25sb2FkVXJsfVxyXG4gICAgICAgICAgdXBsb2FkVXJsPXt0aGlzLnByb3BzLnVwbG9hZFVybH0gLz5cclxuICAgICAgICA8RWRpdEZvcm0gYWN0aW9ucz17dGhpcy5zdGF0ZS5hY3Rpb25zfSBsb2NhbGl6YXRpb249e2xvY2FsaXphdGlvbi5lZGl0Zm9ybXN9IC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8VG9vbGJhciBsb2NhbGl6YXRpb249e2xvY2FsaXphdGlvbi50b29sYmFyfSB0ZW1wbGF0ZXM9e3RoaXMucHJvcHMudGVtcGxhdGVzfSAvPlxyXG4gICAgPC9kaXY+O1xyXG5cclxuICAgIGlmKHRoaXMucHJvcHMuc2hvd0hlYWRlcil7XHJcbiAgICAgIHJldHVybiAoPGRpdj57dGhpcy5nZXRIZWFkZXIoKX17YnVpbGRlcn08L2Rpdj4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBidWlsZGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudExvY2FsaXphdGlvbigpe1xyXG4gICAgaWYodGhpcy5wcm9wcy5sb2NhbGl6YXRpb24gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMubG9jYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBMYW5nO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9idWlsZGVyLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBCdWlsZGVyQWN0aW9ucyBmcm9tICcuL2FjdGlvbnMnXHJcbmltcG9ydCBEV0tpdEZvcm1Db250cm9scyBmcm9tICcuL2NvbnRyb2xzJ1xyXG5pbXBvcnQge0N1c3RvbUJsb2NrRWRpdENvbnRyb2x9IGZyb20gJy4vZWRpdGZvcm0tY29udHJvbHMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sYmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICBsZXQgaXRlbXMgPSBbLi4uRFdLaXRGb3JtQ29udHJvbHMuSXRlbXNdO1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLnRlbXBsYXRlcykgJiYgdGhpcy5wcm9wcy50ZW1wbGF0ZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgIGl0ZW1zLnB1c2goeyBrZXk6IFwic2VwVGVtcGxhdGVzXCIsIHRpdGxlOiAnVGVtcGxhdGVzJywgaXNzZXBhcmF0ZTogdHJ1ZSwgZGVmYXVsdG9wZW46IGZhbHNlfSk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnByb3BzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHRlbXBsYXRlKXtcclxuICAgICAgICBpdGVtcy5wdXNoKHsgXHJcbiAgICAgICAgICBrZXk6IHRlbXBsYXRlLCBcclxuICAgICAgICAgIGJ1aWxkZXJUeXBlOiBcImN1c3RvbWJsb2NrXCIsXHJcbiAgICAgICAgICB0aXRsZTogdGVtcGxhdGUsIFxyXG4gICAgICAgICAgY29udHJvbDogdW5kZWZpbmVkLCBcclxuICAgICAgICAgIGVkaXRDb250cm9sOiBDdXN0b21CbG9ja0VkaXRDb250cm9sLFxyXG4gICAgICAgICAgZGVmYXVsdFZhbHVlczoge2Zvcm1uYW1lOiB0ZW1wbGF0ZSwgc291cmNlVHlwZTogXCJmb3JtXCJ9IH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1ha2VMb2NhbGl6YXRpb24oaXRlbXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBpdGVtczogaXRlbXNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBtYWtlTG9jYWxpemF0aW9uKGl0ZW1zKXtcclxuICAgIGlmKHRoaXMucHJvcHMubG9jYWxpemF0aW9uID09IHVuZGVmaW5lZClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHZhciBsb2NhbCA9IHRoaXMucHJvcHMubG9jYWxpemF0aW9uO1xyXG4gICAgZm9yKHZhciBpPTA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgIGlmKGxvY2FsW2l0ZW1zW2ldLmtleV0gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBpdGVtc1tpXS50aXRsZSA9IGxvY2FsW2l0ZW1zW2ldLmtleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRHJhZ1N0YXJ0KGl0ZW0sIGUpIHtcclxuICAgIHZhciBzZWxlY3RvciA9ICcuZHdraXQtZm9ybWJ1aWxkZXItem9uZSc7XHJcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgJycpOyBcclxuXHJcbiAgICBpZihpdGVtLmZvckNvbnRhaW5lclR5cGUgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgbGV0IGNUeXBlcyA9IGl0ZW0uZm9yQ29udGFpbmVyVHlwZS5zcGxpdCgnLCcpO1xyXG4gICAgICBsZXQgc3ViU2VsZWN0b3IgPSBcIlwiO1xyXG4gICAgICBjVHlwZXMuZm9yRWFjaChmdW5jdGlvbihjKXtcclxuICAgICAgICBpZihzdWJTZWxlY3Rvci5sZW5ndGggPiAwKSBcclxuICAgICAgICAgIHN1YlNlbGVjdG9yICs9IFwiLFwiO1xyXG4gICAgICAgIHN1YlNlbGVjdG9yICs9IFwiW2RhdGEtYnVpbGRlcnR5cGU9J1wiICsgYyArIFwiJ10gPiBcIiArIHNlbGVjdG9yO1xyXG4gICAgICB9KTtcclxuICAgICAgc2VsZWN0b3IgPSBzdWJTZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAkKHNlbGVjdG9yKVxyXG4gICAgICAgIC5hZGRDbGFzcygnZHdraXQtZm9ybWJ1aWxkZXItem9uZS1hY3RpdmUnKVxyXG4gICAgICAgIC5vbignZHJhZ2VudGVyJywgdGhpcy5vblRhcmdldERyYWdFbnRlci5iaW5kKHRoaXMsIGl0ZW0sICdkd2tpdC1mb3JtYnVpbGRlci16b25lLXNlbGVjdCcpKVxyXG4gICAgICAgIC5vbignZHJhZ2xlYXZlJywgdGhpcy5vblRhcmdldERyYWdMZWF2ZS5iaW5kKHRoaXMsIGl0ZW0sICdkd2tpdC1mb3JtYnVpbGRlci16b25lLXNlbGVjdCcpKVxyXG4gICAgICAgIC5vbignZHJhZ292ZXInLCBmdW5jdGlvbihlKSB7ZS5wcmV2ZW50RGVmYXVsdCgpO30pXHJcbiAgICAgICAgLm9uKCdkcm9wJywgdGhpcy5vbkRyb3AuYmluZCh0aGlzLCBpdGVtKSk7XHJcbiAgfVxyXG5cclxuICBvblRhcmdldERyYWdFbnRlcihpdGVtLCBjc3MsIGUpIHtcclxuICAgICQoZS50YXJnZXQpLmFkZENsYXNzKGNzcyk7XHJcbiAgfVxyXG5cclxuICBvblRhcmdldERyYWdMZWF2ZShpdGVtLCBjc3MsIGUpIHtcclxuICAgICQoZS50YXJnZXQpLnJlbW92ZUNsYXNzKGNzcyk7XHJcbiAgfVxyXG5cclxuICBvbkRyYWdFbmQoaXRlbSkge1xyXG4gICAgdGhpcy5zdG9wID0gZmFsc2U7XHJcbiAgICB2YXIgem9uZXMgPSAkKCcuZHdraXQtZm9ybWJ1aWxkZXItem9uZScpO1xyXG5cclxuICAgIHpvbmVzLnJlbW92ZUNsYXNzKCdkd2tpdC1mb3JtYnVpbGRlci16b25lLWFjdGl2ZScpO1xyXG4gICAgem9uZXMucmVtb3ZlQ2xhc3MoJ2R3a2l0LWZvcm1idWlsZGVyLXpvbmUtc2VsZWN0JylcclxuICAgIHpvbmVzLm9mZigpO1xyXG4gIH1cclxuXHJcbiAgb25Ecm9wKGl0ZW0sIGUpe1xyXG4gICAgdmFyIGVsID0gJChlLnRhcmdldCk7XHJcbiAgICBpZihlbC5sZW5ndGggPiAwKXtcclxuICAgICAgQnVpbGRlckFjdGlvbnMuYWRkKGl0ZW0sIGVsWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9uRHJhZ0VuZChpdGVtKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIG9uRG91YmxlQ2xpY2soaXRlbSl7XHJcbiAgICBCdWlsZGVyQWN0aW9ucy5hZGQoaXRlbSk7XHJcbiAgfVxyXG5cclxuICBvbkV4cGFuZChpdGVtLCB2YWx1ZSl7XHJcbiAgICBpdGVtLmlzZXhwYW5kZWQgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0Q29va2llKFwidG9vbGJhcl9cIiArIGl0ZW0ua2V5LCB2YWx1ZSk7XHJcbiAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgdmFyIGV4cGFuZGVkYm9jayA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJkd2tpdC1mb3JtYnVpbGRlci10b29sYm94XCI+XHJcbiAgICAgICAgPHVsPlxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLml0ZW1zLm1hcChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IGl0ZW0udGl0bGU7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYobWUucHJvcHMubG9jYWxpemF0aW9uICE9IHVuZGVmaW5lZCAmJiBtZS5wcm9wcy5sb2NhbGl6YXRpb25baXRlbS5rZXldICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICAgIHRpdGxlID0gbWUucHJvcHMubG9jYWxpemF0aW9uW2l0ZW0ua2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihpdGVtLmlzc2VwYXJhdGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBpY29uO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgb25jbGljaztcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uaXNleHBhbmRlZCA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29raWV2YWx1ZSA9IG1lLmdldENvb2tpZShcInRvb2xiYXJfXCIgKyBpdGVtLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pc2V4cGFuZGVkID0gY29va2lldmFsdWUgIT0gdW5kZWZpbmVkID8gKGNvb2tpZXZhbHVlID09IFwidHJ1ZVwiKSA6IGl0ZW0uZGVmYXVsdG9wZW47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uaXNleHBhbmRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRib2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrID0gbWUub25FeHBhbmQuYmluZChtZSwgaXRlbSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGljb24gPSA8c3Bhbj4mbmRhc2g7PC9zcGFuPjsvLzxpbWcgIGtleT1cImJ0bmV4cGFuZFwiIGNsYXNzTmFtZT1cImNvbGxhcHNlXCIgc3JjPVwiL2ltYWdlcy9jb2xsYXBzZS5zdmdcIi8+O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRib2NrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgb25jbGljayA9IG1lLm9uRXhwYW5kLmJpbmQobWUsIGl0ZW0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGljb24gPSA8c3Bhbj4rPC9zcGFuPjsvLzxpbWcga2V5PVwiYnRuZXhwYW5kXCIgY2xhc3NOYW1lPVwiZXhwYW5kXCIgc3JjPVwiL2ltYWdlcy9leHBhbmQuc3ZnXCIvPjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIDxsaSBkcmFnZ2FibGU9XCJmYWxzZVwiIG9uQ2xpY2s9e29uY2xpY2t9IGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLXRvb2xib3gtc3ViaGVhZGVyXCIga2V5PXtpdGVtLmtleX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICB7aWNvbn08L2xpPjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoZXhwYW5kZWRib2NrKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHcgPSBpdGVtLmltYWdld2lkdGggIT0gdW5kZWZpbmVkID8gaXRlbS5pbWFnZXdpZHRoIDogMzI7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBoID0gaXRlbS5pbWFnZWhlaWdodCAhPSB1bmRlZmluZWQgPyBpdGVtLmltYWdlaGVpZ2h0IDogMzI7XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKDxsaSBkcmFnZ2FibGU9XCJ0cnVlXCIgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItdG9vbGJveC1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgICAgIGtleT17aXRlbS5rZXl9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17dGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMsIGl0ZW0pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25EcmFnRW5kPXt0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMsIGl0ZW0pfSBcclxuICAgICAgICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s9e3RoaXMub25Eb3VibGVDbGljay5iaW5kKHRoaXMsIGl0ZW0pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25EcmFnPXt0aGlzLm9uRHJhZy5iaW5kKHRoaXMpfT5cclxuICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItdG9vbGJveC1jb250cm9sLWljb25cIiBzcmM9XCIvaW1hZ2VzL2R3a2l0YnVpbGRlci10b29sYmFyLW1vdmUucG5nXCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkd2tpdC1mb3JtYnVpbGRlci10b29sYm94LWNvbnRyb2wtdGV4dFwiPnt0aXRsZX08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPC9saT4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgb25EcmFnKGUpe1xyXG4gICAgdmFyIHN0ZXAgPSAxMDtcclxuICAgIGlmIChlLmNsaWVudFkgPCAxNTApIHtcclxuICAgICAgdGhpcy5zY3JvbGwoLXN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlLmNsaWVudFkgPiAoJCh3aW5kb3cpLmhlaWdodCgpIC0gMTUwKSkge1xyXG4gICAgICB0aGlzLnNjcm9sbChzdGVwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNjcm9sbChzdGVwKSB7XHJcbiAgICB2YXIgc2Nyb2xsWSA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcclxuICAgICQod2luZG93KS5zY3JvbGxUb3Aoc2Nyb2xsWSArIHN0ZXApO1xyXG4gICAgaWYgKCFzdG9wKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHNjcm9sbChzdGVwKSB9LCAyMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRDb29raWUobmFtZSkge1xyXG4gICAgdmFyIG1hdGNoZXMgPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cChcclxuICAgICAgXCIoPzpefDsgKVwiICsgbmFtZS5yZXBsYWNlKC8oW1xcLiQ/Knx7fVxcKFxcKVxcW1xcXVxcXFxcXC9cXCteXSkvZywgJ1xcXFwkMScpICsgXCI9KFteO10qKVwiXHJcbiAgICApKTtcclxuICAgIHJldHVybiBtYXRjaGVzID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoZXNbMV0pIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcclxuICAgIHZhciBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xyXG4gIFxyXG4gICAgaWYgKHR5cGVvZiBleHBpcmVzID09IFwibnVtYmVyXCIgJiYgZXhwaXJlcykge1xyXG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGQuc2V0VGltZShkLmdldFRpbWUoKSArIGV4cGlyZXMgKiAxMDAwKTtcclxuICAgICAgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcyA9IGQ7XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwaXJlcyAmJiBleHBpcmVzLnRvVVRDU3RyaW5nKSB7XHJcbiAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IGV4cGlyZXMudG9VVENTdHJpbmcoKTtcclxuICAgIH1cclxuICBcclxuICAgIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICBcclxuICAgIHZhciB1cGRhdGVkQ29va2llID0gbmFtZSArIFwiPVwiICsgdmFsdWU7XHJcbiAgXHJcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgIHVwZGF0ZWRDb29raWUgKz0gXCI7IFwiICsgcHJvcE5hbWU7XHJcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBvcHRpb25zW3Byb3BOYW1lXTtcclxuICAgICAgaWYgKHByb3BWYWx1ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIHVwZGF0ZWRDb29raWUgKz0gXCI9XCIgKyBwcm9wVmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIGRvY3VtZW50LmNvb2tpZSA9IHVwZGF0ZWRDb29raWU7XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90b29sYmFyLmpzeCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vXG4vLyBXZSBzdG9yZSBvdXIgRUUgb2JqZWN0cyBpbiBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBgfmAgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Qgb3ZlcnJpZGRlbiBvclxuLy8gdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy8gV2UgYWxzbyBhc3N1bWUgdGhhdCBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIGV2ZW50IG5hbWVcbi8vIGlzIGFuIEVTNiBTeW1ib2wuXG4vL1xudmFyIHByZWZpeCA9IHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSAnZnVuY3Rpb24nID8gJ34nIDogZmFsc2U7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgRXZlbnRFbWl0dGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgdG8gYmUgY2FsbGVkLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBDb250ZXh0IGZvciBmdW5jdGlvbiBleGVjdXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBPbmx5IGVtaXQgb25jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsgLyogTm90aGluZyB0byBzZXQgKi8gfVxuXG4vKipcbiAqIEhvbGQgdGhlIGFzc2lnbmVkIEV2ZW50RW1pdHRlcnMgYnkgbmFtZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1xuICAgICwgbmFtZXMgPSBbXVxuICAgICwgbmFtZTtcblxuICBpZiAoIWV2ZW50cykgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiBldmVudHMpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBhc3NpZ25lZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxuICogQHBhcmFtIHtCb29sZWFufSBleGlzdHMgV2Ugb25seSBuZWVkIHRvIGtub3cgaWYgdGhlcmUgYXJlIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQsIGV4aXN0cykge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgYXZhaWxhYmxlID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChleGlzdHMpIHJldHVybiAhIWF2YWlsYWJsZTtcbiAgaWYgKCFhdmFpbGFibGUpIHJldHVybiBbXTtcbiAgaWYgKGF2YWlsYWJsZS5mbikgcmV0dXJuIFthdmFpbGFibGUuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXZhaWxhYmxlLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGF2YWlsYWJsZVtpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogRW1pdCBhbiBldmVudCB0byBhbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIHdlJ3ZlIGVtaXR0ZWQgYW4gZXZlbnQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IEV2ZW50TGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudExpc3RlbmVyIHRoYXQncyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMsIHRydWUpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3ZSB3YW50IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciB0aGF0IHdlIG5lZWQgdG8gZmluZC5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgT25seSByZW1vdmUgbGlzdGVuZXJzIG1hdGNoaW5nIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmNlIGxpc3RlbmVycy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGV2ZW50cyA9IFtdO1xuXG4gIGlmIChmbikge1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgIGlmIChcbiAgICAgICAgICAgbGlzdGVuZXJzLmZuICE9PSBmblxuICAgICAgICB8fCAob25jZSAmJiAhbGlzdGVuZXJzLm9uY2UpXG4gICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVycy5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm5cbiAgICAgICAgICB8fCAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICAgICkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gIC8vXG4gIGlmIChldmVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBvciBvbmx5IHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3YW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcblxuICBpZiAoZXZlbnQpIGRlbGV0ZSB0aGlzLl9ldmVudHNbcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudF07XG4gIGVsc2UgdGhpcy5fZXZlbnRzID0gcHJlZml4ID8ge30gOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgYXBwbHkgYW55bW9yZS5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWl4ID0gbWl4O1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gbWl4KGRlZikge1xuICAgIHZhciBjb21wb3NlZCA9IHtcbiAgICAgICAgaW5pdDogW10sXG4gICAgICAgIHByZUVtaXQ6IFtdLFxuICAgICAgICBzaG91bGRFbWl0OiBbXVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlZCA9IGZ1bmN0aW9uIG1peERlZihtaXhpbikge1xuICAgICAgICB2YXIgbWl4ZWQgPSB7fTtcbiAgICAgICAgaWYgKG1peGluLm1peGlucykge1xuICAgICAgICAgICAgbWl4aW4ubWl4aW5zLmZvckVhY2goZnVuY3Rpb24gKHN1Yk1peGluKSB7XG4gICAgICAgICAgICAgICAgXy5leHRlbmQobWl4ZWQsIG1peERlZihzdWJNaXhpbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXy5leHRlbmQobWl4ZWQsIG1peGluKTtcbiAgICAgICAgT2JqZWN0LmtleXMoY29tcG9zZWQpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvc2FibGUpIHtcbiAgICAgICAgICAgIGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VkW2NvbXBvc2FibGVdLnB1c2gobWl4aW5bY29tcG9zYWJsZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1peGVkO1xuICAgIH0oZGVmKTtcblxuICAgIGlmIChjb21wb3NlZC5pbml0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdXBkYXRlZC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBjb21wb3NlZC5pbml0LmZvckVhY2goZnVuY3Rpb24gKGluaXQpIHtcbiAgICAgICAgICAgICAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb21wb3NlZC5wcmVFbWl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdXBkYXRlZC5wcmVFbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VkLnByZUVtaXQucmVkdWNlKGZ1bmN0aW9uIChhcmdzLCBwcmVFbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gcHJlRW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IGFyZ3MgOiBbbmV3VmFsdWVdO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29tcG9zZWQuc2hvdWxkRW1pdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHVwZGF0ZWQuc2hvdWxkRW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuICFjb21wb3NlZC5zaG91bGRFbWl0LnNvbWUoZnVuY3Rpb24gKHNob3VsZEVtaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXNob3VsZEVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoY29tcG9zZWQpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvc2FibGUpIHtcbiAgICAgICAgaWYgKGNvbXBvc2VkW2NvbXBvc2FibGVdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXBkYXRlZFtjb21wb3NhYmxlXSA9IGNvbXBvc2VkW2NvbXBvc2FibGVdWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvbWl4ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJpbmRNZXRob2RzID0gYmluZE1ldGhvZHM7XG5mdW5jdGlvbiBiaW5kTWV0aG9kcyhzdG9yZSwgZGVmaW5pdGlvbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmluaXRpb24sIG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5RGVzY3JpcHRvci52YWx1ZSB8fCB0eXBlb2YgcHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlICE9PSBcImZ1bmN0aW9uXCIgfHwgIWRlZmluaXRpb24uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmVbbmFtZV0gPSBkZWZpbml0aW9uW25hbWVdLmJpbmQoc3RvcmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gZGVmaW5pdGlvbltuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJmdW5jdGlvblwiIHx8ICFkZWZpbml0aW9uLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0b3JlW25hbWVdID0gcHJvcGVydHkuYmluZChzdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcmU7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVmbHV4LWNvcmUvbGliL2JpbmRNZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVBY3Rpb24gPSBjcmVhdGVBY3Rpb247XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX0FjdGlvbk1ldGhvZHMgPSByZXF1aXJlKFwiLi9BY3Rpb25NZXRob2RzXCIpO1xuXG52YXIgQWN0aW9uTWV0aG9kcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9BY3Rpb25NZXRob2RzKTtcblxudmFyIF9QdWJsaXNoZXJNZXRob2RzID0gcmVxdWlyZShcIi4vUHVibGlzaGVyTWV0aG9kc1wiKTtcblxudmFyIFB1Ymxpc2hlck1ldGhvZHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfUHVibGlzaGVyTWV0aG9kcyk7XG5cbnZhciBfS2VlcCA9IHJlcXVpcmUoXCIuL0tlZXBcIik7XG5cbnZhciBLZWVwID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0tlZXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgYWxsb3dlZCA9IHsgcHJlRW1pdDogMSwgc2hvdWxkRW1pdDogMSB9O1xuXG4vKipcclxuICogQ3JlYXRlcyBhbiBhY3Rpb24gZnVuY3RvciBvYmplY3QuIEl0IGlzIG1peGVkIGluIHdpdGggZnVuY3Rpb25zXHJcbiAqIGZyb20gdGhlIGBQdWJsaXNoZXJNZXRob2RzYCBtaXhpbi4gYHByZUVtaXRgIGFuZCBgc2hvdWxkRW1pdGAgbWF5XHJcbiAqIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGRlZmluaXRpb24gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBUaGUgYWN0aW9uIG9iamVjdCBkZWZpbml0aW9uXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGRlZmluaXRpb24pIHtcblxuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uIHx8IHt9O1xuICAgIGlmICghXy5pc09iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICBkZWZpbml0aW9uID0geyBhY3Rpb25OYW1lOiBkZWZpbml0aW9uIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYSBpbiBBY3Rpb25NZXRob2RzKSB7XG4gICAgICAgIGlmICghYWxsb3dlZFthXSAmJiBQdWJsaXNoZXJNZXRob2RzW2FdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgb3ZlcnJpZGUgQVBJIG1ldGhvZCBcIiArIGEgKyBcIiBpbiBSZWZsdXguQWN0aW9uTWV0aG9kcy4gVXNlIGFub3RoZXIgbWV0aG9kIG5hbWUgb3Igb3ZlcnJpZGUgaXQgb24gUmVmbHV4LlB1Ymxpc2hlck1ldGhvZHMgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBkIGluIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkW2RdICYmIFB1Ymxpc2hlck1ldGhvZHNbZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBvdmVycmlkZSBBUEkgbWV0aG9kIFwiICsgZCArIFwiIGluIGFjdGlvbiBjcmVhdGlvbi4gVXNlIGFub3RoZXIgbWV0aG9kIG5hbWUgb3Igb3ZlcnJpZGUgaXQgb24gUmVmbHV4LlB1Ymxpc2hlck1ldGhvZHMgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZpbml0aW9uLmNoaWxkcmVuID0gZGVmaW5pdGlvbi5jaGlsZHJlbiB8fCBbXTtcbiAgICBpZiAoZGVmaW5pdGlvbi5hc3luY1Jlc3VsdCkge1xuICAgICAgICBkZWZpbml0aW9uLmNoaWxkcmVuID0gZGVmaW5pdGlvbi5jaGlsZHJlbi5jb25jYXQoW1wiY29tcGxldGVkXCIsIFwiZmFpbGVkXCJdKTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGNoaWxkQWN0aW9ucyA9IHt9O1xuICAgIGZvciAoOyBpIDwgZGVmaW5pdGlvbi5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hEZWYgPSBkZWZpbml0aW9uLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgY2hOYW1lID0gdHlwZW9mIGNoRGVmID09PSBcInN0cmluZ1wiID8gY2hEZWYgOiBjaERlZi5hY3Rpb25OYW1lO1xuICAgICAgICBjaGlsZEFjdGlvbnNbY2hOYW1lXSA9IGNyZWF0ZUFjdGlvbihjaERlZik7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSBfLmV4dGVuZCh7XG4gICAgICAgIGV2ZW50TGFiZWw6IFwiYWN0aW9uXCIsXG4gICAgICAgIGVtaXR0ZXI6IG5ldyBfLkV2ZW50RW1pdHRlcigpLFxuICAgICAgICBfaXNBY3Rpb246IHRydWVcbiAgICB9LCBQdWJsaXNoZXJNZXRob2RzLCBBY3Rpb25NZXRob2RzLCBkZWZpbml0aW9uKTtcblxuICAgIHZhciBmdW5jdG9yID0gZnVuY3Rpb24gZnVuY3RvcigpIHtcbiAgICAgICAgdmFyIGhhc0NoaWxkQWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6MCAqL1xuICAgICAgICBmb3IgKHZhciBpZ25vcmUgaW4gZnVuY3Rvci5jaGlsZEFjdGlvbnMpIHtcbiAgICAgICAgICAgIGhhc0NoaWxkQWN0aW9ucyA9IHRydWU7YnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzeW5jID0gIWZ1bmN0b3Iuc3luYyAmJiB0eXBlb2YgZnVuY3Rvci5zeW5jICE9PSBcInVuZGVmaW5lZFwiIHx8IGhhc0NoaWxkQWN0aW9ucztcbiAgICAgICAgdmFyIHRyaWdnZXJUeXBlID0gYXN5bmMgPyBcInRyaWdnZXJBc3luY1wiIDogXCJ0cmlnZ2VyXCI7XG4gICAgICAgIHJldHVybiBmdW5jdG9yW3RyaWdnZXJUeXBlXS5hcHBseShmdW5jdG9yLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBfLmV4dGVuZChmdW5jdG9yLCBjaGlsZEFjdGlvbnMsIGNvbnRleHQpO1xuXG4gICAgS2VlcC5hZGRBY3Rpb24oZnVuY3Rvcik7XG5cbiAgICByZXR1cm4gZnVuY3Rvcjtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgtY29yZS9saWIvY3JlYXRlQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdGVuZXJNZXRob2RzID0gcmVxdWlyZSgncmVmbHV4LWNvcmUvbGliL0xpc3RlbmVyTWV0aG9kcycpLFxyXG4gICAgTGlzdGVuZXJNaXhpbiA9IHJlcXVpcmUoJy4vTGlzdGVuZXJNaXhpbicpLFxyXG4gICAgXyA9IHJlcXVpcmUoJ3JlZmx1eC1jb3JlL2xpYi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0ZW5hYmxlLCBrZXkpIHtcclxuXHJcbiAgICBfLnRocm93SWYodHlwZW9mKGtleSkgPT09ICd1bmRlZmluZWQnLCAnUmVmbHV4LmNvbm5lY3QoKSByZXF1aXJlcyBhIGtleS4nKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKGxpc3RlbmFibGUuZ2V0SW5pdGlhbFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gXy5vYmplY3QoW2tleV0sW2xpc3RlbmFibGUuZ2V0SW5pdGlhbFN0YXRlKCldKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIF8uZXh0ZW5kKG1lLCBMaXN0ZW5lck1ldGhvZHMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhsaXN0ZW5hYmxlLCBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZShfLm9iamVjdChba2V5XSxbdl0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudDogTGlzdGVuZXJNaXhpbi5jb21wb25lbnRXaWxsVW5tb3VudFxyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVmbHV4L3NyYy9jb25uZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdGVuZXJNZXRob2RzID0gcmVxdWlyZSgncmVmbHV4LWNvcmUvbGliL0xpc3RlbmVyTWV0aG9kcycpLFxyXG4gICAgTGlzdGVuZXJNaXhpbiA9IHJlcXVpcmUoJy4vTGlzdGVuZXJNaXhpbicpLFxyXG4gICAgXyA9IHJlcXVpcmUoJ3JlZmx1eC1jb3JlL2xpYi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0ZW5hYmxlLCBrZXksIGZpbHRlckZ1bmMpIHtcclxuXHJcbiAgICBfLnRocm93SWYoXy5pc0Z1bmN0aW9uKGtleSksICdSZWZsdXguY29ubmVjdEZpbHRlcigpIHJlcXVpcmVzIGEga2V5LicpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obGlzdGVuYWJsZS5nZXRJbml0aWFsU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbHRlciBpbml0aWFsIHBheWxvYWQgZnJvbSBzdG9yZS5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZpbHRlckZ1bmMuY2FsbCh0aGlzLCBsaXN0ZW5hYmxlLmdldEluaXRpYWxTdGF0ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZihyZXN1bHQpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ub2JqZWN0KFtrZXldLCBbcmVzdWx0XSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIF8uZXh0ZW5kKHRoaXMsIExpc3RlbmVyTWV0aG9kcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGxpc3RlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmlsdGVyRnVuYy5jYWxsKG1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZShfLm9iamVjdChba2V5XSwgW3Jlc3VsdF0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudDogTGlzdGVuZXJNaXhpbi5jb21wb25lbnRXaWxsVW5tb3VudFxyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVmbHV4L3NyYy9jb25uZWN0RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdGVuZXJNZXRob2RzID0gcmVxdWlyZSgncmVmbHV4LWNvcmUvbGliL0xpc3RlbmVyTWV0aG9kcycpO1xyXG5cclxuLyoqXHJcbiAqIEEgbWl4aW4gZmFjdG9yeSBmb3IgYSBSZWFjdCBjb21wb25lbnQuIE1lYW50IGFzIGEgbW9yZSBjb252ZW5pZW50IHdheSBvZiB1c2luZyB0aGUgYExpc3RlbmVyTWl4aW5gLFxyXG4gKiB3aXRob3V0IGhhdmluZyB0byBtYW51YWxseSBzZXQgbGlzdGVuZXJzIGluIHRoZSBgY29tcG9uZW50RGlkTW91bnRgIG1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIHtBY3Rpb258U3RvcmV9IGxpc3RlbmFibGUgQW4gQWN0aW9uIG9yIFN0b3JlIHRoYXQgc2hvdWxkIGJlXHJcbiAqICBsaXN0ZW5lZCB0by5cclxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byByZWdpc3RlciBhcyBldmVudCBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBkZWZhdWx0Q2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJlZ2lzdGVyIGFzIGRlZmF1bHQgaGFuZGxlclxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgdG8gYmUgdXNlZCBhcyBhIG1peGluLCB3aGljaCBzZXRzIHVwIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGxpc3RlbmFibGUuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3RlbmFibGUsY2FsbGJhY2ssaW5pdGlhbCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB1cCB0aGUgbWl4aW4gYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuIEltcG9ydCBtZXRob2RzIGZyb20gYExpc3RlbmVyTWV0aG9kc2BcclxuICAgICAgICAgKiBhbmQgdGhlbiBtYWtlIHRoZSBjYWxsIHRvIGBsaXN0ZW5Ub2Agd2l0aCB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIG0gaW4gTGlzdGVuZXJNZXRob2RzKXtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzW21dICE9PSBMaXN0ZW5lck1ldGhvZHNbbV0pe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW21dKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJDYW4ndCBoYXZlIG90aGVyIHByb3BlcnR5ICdcIittK1wiJyB3aGVuIHVzaW5nIFJlZmx1eC5saXN0ZW5UbyFcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttXSA9IExpc3RlbmVyTWV0aG9kc1ttXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGxpc3RlbmFibGUsY2FsbGJhY2ssaW5pdGlhbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhbnMgdXAgYWxsIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudDogTGlzdGVuZXJNZXRob2RzLnN0b3BMaXN0ZW5pbmdUb0FsbFxyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVmbHV4L3NyYy9saXN0ZW5Uby5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RlbmVyTWV0aG9kcyA9IHJlcXVpcmUoJ3JlZmx1eC1jb3JlL2xpYi9MaXN0ZW5lck1ldGhvZHMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIG1peGluIGZhY3RvcnkgZm9yIGEgUmVhY3QgY29tcG9uZW50LiBNZWFudCBhcyBhIG1vcmUgY29udmVuaWVudCB3YXkgb2YgdXNpbmcgdGhlIGBsaXN0ZW5lck1peGluYCxcclxuICogd2l0aG91dCBoYXZpbmcgdG8gbWFudWFsbHkgc2V0IGxpc3RlbmVycyBpbiB0aGUgYGNvbXBvbmVudERpZE1vdW50YCBtZXRob2QuIFRoaXMgdmVyc2lvbiBpcyB1c2VkXHJcbiAqIHRvIGF1dG9tYXRpY2FsbHkgc2V0IHVwIGEgYGxpc3RlblRvTWFueWAgY2FsbC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmFibGVzIEFuIG9iamVjdCBvZiBsaXN0ZW5hYmxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgdG8gYmUgdXNlZCBhcyBhIG1peGluLCB3aGljaCBzZXRzIHVwIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBsaXN0ZW5hYmxlcy5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdGVuYWJsZXMpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdXAgdGhlIG1peGluIGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLiBJbXBvcnQgbWV0aG9kcyBmcm9tIGBMaXN0ZW5lck1ldGhvZHNgXHJcbiAgICAgICAgICogYW5kIHRoZW4gbWFrZSB0aGUgY2FsbCB0byBgbGlzdGVuVG9gIHdpdGggdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZmFjdG9yeSBmdW5jdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBtIGluIExpc3RlbmVyTWV0aG9kcyl7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1ttXSAhPT0gTGlzdGVuZXJNZXRob2RzW21dKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1ttXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ2FuJ3QgaGF2ZSBvdGhlciBwcm9wZXJ0eSAnXCIrbStcIicgd2hlbiB1c2luZyBSZWZsdXgubGlzdGVuVG9NYW55IVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzW21dID0gTGlzdGVuZXJNZXRob2RzW21dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG9NYW55KGxpc3RlbmFibGVzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFucyB1cCBhbGwgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBMaXN0ZW5lck1ldGhvZHMuc3RvcExpc3RlbmluZ1RvQWxsXHJcbiAgICB9O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL2xpc3RlblRvTWFueS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8qIGdsb2JhbHMgUmVhY3Q6IGZhbHNlICovXHJcblxyXG52YXIgUmVmbHV4ID0gcmVxdWlyZSgncmVmbHV4LWNvcmUnKTtcclxuUmVmbHV4LmRlZmluZVJlYWN0ID0gcmVxdWlyZSgnLi9kZWZpbmVSZWFjdCcpO1xyXG5cclxuLy8gdXNlZnVsIHV0aWxpdHkgZm9yIEVTNiB3b3JrLCBtaW1pY3MgdGhlIGFiaWxpdHkgdG8gZXh0ZW5kXHJcblJlZmx1eC51dGlscy5pbmhlcml0cyA9IGZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcblx0aWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XHJcblx0fVxyXG5cdHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xyXG5cdFx0Y29uc3RydWN0b3I6IHtcclxuXHRcdFx0dmFsdWU6IHN1YkNsYXNzLFxyXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGlmIChzdXBlckNsYXNzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XHJcblx0XHRcdE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvKiBqc2hpbnQgcHJvdG86IHRydWUgKi9cclxuXHRcdFx0c3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBmaXJzdCB0cnkgdG8gc2VlIGlmIHRoZXJlJ3MgYSBnbG9iYWwgUmVhY3QgdmFyIGFuZCB1c2UgaXRcclxuaWYgKHR5cGVvZiBSZWFjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVhY3QpIHtcclxuXHRSZWZsdXguZGVmaW5lUmVhY3QoUmVhY3QpO1xyXG4vLyBvdGhlcndpc2Ugd2UncmUgZ29ubmEgcmVzb3J0IHRvICd0cnknIHN0dWZmIGluIGNhc2Ugb2Ygb3RoZXIgZW52aXJvbm1lbnRzXHJcbn0gZWxzZSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBSID0gcmVxdWlyZShcInJlYWN0XCIpOyAvLyB3ZSBpZ25vcmUgdGhpcyBpbiBicm93c2VyaWZ5IG1hbnVhbGx5IChzZWUgZ3J1bnQgZmlsZSksIHNvIGl0J3MgbW9yZSBvZiBhIGRvdWJsZWNoZWNrIGZvciBpbiBub2RlXHJcblx0XHRSZWZsdXguZGVmaW5lUmVhY3QoUik7XHJcblx0fSBjYXRjaCAoZSkge31cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsdXgvc3JjL2FkZEVTNi5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFscyBSZWFjdDogZmFsc2UgKi9cclxuXHJcbnZhciBSZWZsdXggPSByZXF1aXJlKCdyZWZsdXgtY29yZScpO1xyXG5cclxuLyoqXHJcbiAqIFJlZmx1eC5kZWZpbmVSZWFjdCBmdW5jdGlvbiB3aGVyZSB5b3UgY2FuIG1hbnVhbGx5IHN1cHBseVxyXG4gKiB0aGUgUmVhY3Qgb2JqZWN0IGluIG9yZGVyIHRvIGNyZWF0ZSBpbiBjYXNlIFJlZmx1eCBuZWVkcyB0byBsb2FkIGJlZm9yZVxyXG4gKiBSZWFjdCBvciB0aGVyZSBpcyBhIG1vZHVsYXIgZW52aXJvbm1lbnQgd2hlcmUgdGhlcmUgd29uJ3QgYmUgYSBnbG9iYWxcclxuICogUmVhY3QgdmFyaWFibGUuXHJcbiAqIEBub3RlIFRoZSB0aGlyZCBwYXJhbSBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seS5cclxuICovXHJcbnZhciBfcmVhY3QsIF9kZWZpbmVkID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0KHJlYWN0LCBub0xvbmdlclVzZWQsIGV4dGVuZClcclxue1xyXG5cdHZhciBwcm90bywgX2V4dGVuZDtcclxuXHRcclxuXHQvLyBpZiBubyBSZWZsdXggb2JqZWN0IGlzIHlldCBhdmFpbGFibGUgdGhlbiByZXR1cm4gYW5kIGp1c3Qgd2FpdCB1bnRpbCBkZWZpbmVSZWFjdCBpcyBjYWxsZWQgbWFudWFsbHkgd2l0aCBpdFxyXG5cdHRyeSB7XHJcblx0XHRfcmVhY3QgID0gcmVhY3QgIHx8IF9yZWFjdCAgfHwgUmVhY3Q7XHJcblx0XHRfZXh0ZW5kID0gZXh0ZW5kIHx8IF9yZWFjdC5Db21wb25lbnQ7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRcclxuXHQvLyBpZiBSZWZsdXggYW5kIFJlYWN0IGFyZW4ndCBwcmVzZW50IHRoZW4gaWdub3JlLCB3YWl0IHVudGlsIHRoZXkgYXJlIHByb3Blcmx5IHByZXNlbnRcclxuXHQvLyBhbHNvIGlnbm9yZSBpZiBpdCdzIGJlZW4gY2FsbGVkIGJlZm9yZSBVTkxFU1MgdGhlcmUncyBtYW51YWwgZXh0ZW5kaW5nIGhhcHBlbmluZ1xyXG5cdGlmICghX3JlYWN0IHx8ICFfZXh0ZW5kIHx8IChfZGVmaW5lZCAmJiAhZXh0ZW5kKSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLSBCRUdJTiBSZWZsdXguQ29tcG9uZW50IC0tLS0tLS0tLS0tLVxyXG5cdC8qKlxyXG5cdCAqIFJlZmx1eC5Db21wb25lbnQ6XHJcblx0ICogQW4gaW1wbGVtZW50YXRpb24gZm9yIGlkaW9tYXRpYyBSZWFjdC5qcyBjbGFzc2VzIHRoYXQgbWl4IHdpdGhcclxuXHQgKiBSZWZsdXggc3RvcmVzLiBUbyB1dGlsaXplIGV4dGVuZCBSZWZsdXguQ29tcG9uZW50IGluc3RlYWQgb2ZcclxuXHQgKiBSZWFjdC5Db21wb25lbnQuIFRoZW4geW91IG1heSBob29rIGFueSBSZWZsdXggc3RvcmUgdGhhdCBoYXMgYVxyXG5cdCAqIGB0aGlzLnN0YXRlYCBwcm9wZXJ0eSBjb250YWluaW5nIGl0cyBzdGF0ZSB2YWx1ZXMgdG8gdGhlIGNvbXBvbmVudFxyXG5cdCAqIHZpYSBgdGhpcy5zdG9yZWAgb3IgYW4gQXJyYXkgb2YgUmVmbHV4IHN0b3JlcyB2aWEgYHRoaXMuc3RvcmVzYCBpblxyXG5cdCAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciAoc2ltaWxhciB0byBob3cgeW91IGFzc2lnbiBpbml0aWFsIHN0YXRlXHJcblx0ICogaW4gdGhlIGNvbnN0cnVjdG9yIGluIEVTNiBzdHlsZSBSZWFjdCkuIFRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGVcclxuXHQgKiBzdG9yZXMgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZmxlY3QgaW4gdGhlIGNvbXBvbmVudCdzIHN0YXRlLCBhbmQgYW55XHJcblx0ICogZnVydGhlciBgdHJpZ2dlcmAgY2FsbHMgZnJvbSB0aGF0IHN0b3JlIHdpbGwgdXBkYXRlIHByb3BlcnRpZXMgcGFzc2VkXHJcblx0ICogaW4gdGhlIHRyaWdnZXIgaW50byB0aGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkuXHJcblx0ICovXHJcblx0dmFyIFJlZmx1eENvbXBvbmVudCA9IGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XHJcblx0XHRfZXh0ZW5kLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gZXF1aXZhbGVudCBvZiBgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRgIG9yIG90aGVyIGNsYXNzIGlmIHByb3ZpZGVkIHZpYSBgZXh0ZW5kYCBwYXJhbVxyXG5cdFJlZmx1eC51dGlscy5pbmhlcml0cyhSZWZsdXhDb21wb25lbnQsIF9leHRlbmQpO1xyXG5cdFxyXG5cdHByb3RvID0gUmVmbHV4Q29tcG9uZW50LnByb3RvdHlwZTtcclxuXHRcclxuXHQvKipcclxuXHQgKiB0aGlzLnN0b3JlS2V5c1xyXG5cdCAqIFdoZW4gdGhpcyBpcyBhIGZhbHNleSB2YWx1ZSAobnVsbCBieSBkZWZhdWx0KSB0aGUgY29tcG9uZW50IG1peGVzIGluXHJcblx0ICogYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3RvcmVzIGF0dGFjaGVkIHRvIGl0IGFuZCB1cGRhdGVzIG9uIGNoYW5nZXNcclxuXHQgKiBmcm9tIGFsbCBvZiB0aGVtLiBXaGVuIHNldCB0byBhbiBhcnJheSBvZiBzdHJpbmcga2V5cyBpdCB3aWxsIG9ubHlcclxuXHQgKiB1dGlsaXplZCBzdGF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aG9zZSBrZXlzIGluIGFueSBzdG9yZSBhdHRhY2hlZC4gVGhpc1xyXG5cdCAqIGxldHMgeW91IGNob29zZSB3aGljaCBwYXJ0cyBvZiBzdG9yZXMgdXBkYXRlIHRoZSBjb21wb25lbnQgb24gYSBjb21wb25lbnQtXHJcblx0ICogYnktY29tcG9uZW50IGJhc2lzLiBJZiB1c2luZyB0aGlzIGl0IGlzIGJlc3Qgc2V0IGluIHRoZSBjb25zdHJ1Y3Rvci5cclxuXHQgKi9cclxuXHRwcm90by5zdG9yZUtleXMgPSBudWxsO1xyXG5cdFxyXG5cdC8vIG9uIHRoZSBtb3VudGluZyBvZiB0aGUgY29tcG9uZW50IHRoYXQgaXMgd2hlcmUgdGhlIHN0b3JlL3N0b3JlcyBhcmUgYXR0YWNoZWQgYW5kIGluaXRpYWxpemVkIGlmIG5lZWRlZFxyXG5cdHByb3RvLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGlmIHRoZXJlIGlzIGEgdGhpcy5zdG9yZSB0aGVuIHNpbXBseSBwdXNoIGl0IG9udG8gdGhlIHRoaXMuc3RvcmVzIGFycmF5IG9yIG1ha2Ugb25lIGlmIG5lZWRlZFxyXG5cdFx0aWYgKHRoaXMuc3RvcmUpIHtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdG9yZXMpKSB7XHJcblx0XHRcdFx0dGhpcy5zdG9yZXMudW5zaGlmdCh0aGlzLnN0b3JlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnN0b3JlcyA9IFt0aGlzLnN0b3JlXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAodGhpcy5zdG9yZXMpIHtcclxuXHRcdFx0dGhpcy5fX3N0b3JldW5zdWJzY3JpYmVzX18gPSB0aGlzLl9fc3RvcmV1bnN1YnNjcmliZXNfXyB8fCBbXTtcclxuXHRcdFx0dmFyIHNTID0gdGhpcy5zZXRTdGF0ZS5iaW5kKHRoaXMpO1xyXG5cdFx0XHQvLyB0aGlzIGhhbmRsZXMgdGhlIHRyaWdnZXJpbmcgb2YgYSBzdG9yZSwgY2hlY2tpbmcgd2hhdCdzIHVwZGF0ZWQgaWYgcHJvdG8uc3RvcmVLZXlzIGlzIHV0aWxpemVkXHJcblx0XHRcdHZhciBvblN0b3JlVHJpZ2dlciA9IGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdFx0dmFyIHVwZGF0ZU9iaiA9IGZpbHRlckJ5U3RvcmVLZXlzKHRoaXMuc3RvcmVLZXlzLCBvYmopO1xyXG5cdFx0XHRcdGlmICh1cGRhdGVPYmopIHtcclxuXHRcdFx0XHRcdHNTKHVwZGF0ZU9iaik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LmJpbmQodGhpcyk7XHJcblx0XHRcdC8vIGZvciBlYWNoIHN0b3JlIGluIHRoaXMuc3RvcmVzLi4uXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuc3RvcmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgc3RyID0gdGhpcy5zdG9yZXNbaV07XHJcblx0XHRcdFx0Ly8gaWYncyBhIGZ1bmN0aW9uIHRoZW4gd2Uga25vdyBpdCdzIGEgY2xhc3MgZ2V0dGluZyBwYXNzZWQsIG5vdCBhbiBpbnN0YW5jZVxyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc3RyID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RvcmVJZCA9IHN0ci5pZDtcclxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIE5PVCBhIC5zaW5nbGV0b24gcHJvcGVydHkgb24gdGhlIHN0b3JlIHRoZW4gdGhpcyBzdG9yZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LCBzbyBkbyBzb1xyXG5cdFx0XHRcdFx0aWYgKCFzdHIuc2luZ2xldG9uKSB7XHJcblx0XHRcdFx0XHRcdHN0ci5zaW5nbGV0b24gPSBuZXcgc3RyKCk7XHJcblx0XHRcdFx0XHRcdGlmIChzdG9yZUlkKSB7XHJcblx0XHRcdFx0XHRcdFx0UmVmbHV4LnN0b3Jlc1tzdG9yZUlkXSA9IHN0ci5zaW5nbGV0b247XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIGJlZm9yZSB3ZSB3ZXJlbid0IHN1cmUgaWYgd2Ugd2VyZSB3b3JraW5nIHdpdGggYW4gaW5zdGFuY2Ugb3IgY2xhc3MsIHNvIG5vdyB3ZSBrbm93IGFuIGluc3RhbmNlIGlzIGNyZWF0ZWQgc2V0IGl0XHJcblx0XHRcdFx0XHQvLyB0byB0aGUgdmFyaWFibGVzIHdlIHdlcmUgdXNpbmcgc28gdGhhdCB3ZSBjYW4ganVzdCBjb250aW51ZSBvbiBrbm93aW5nIGl0J3MgdGhlIGluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgd2l0aFxyXG5cdFx0XHRcdFx0dGhpcy5zdG9yZXNbaV0gPSBzdHIgPSBzdHIuc2luZ2xldG9uO1xyXG5cdFx0XHRcdFx0Ly8gdGhlIGluc3RhbmNlIHNob3VsZCBoYXZlIGFuIC5pZCBwcm9wZXJ0eSBhcyB3ZWxsIGlmIHRoZSBjbGFzcyBkb2VzLCBzbyBzZXQgdGhhdCBoZXJlXHJcblx0XHRcdFx0XHRzdHIuaWQgPSBzdG9yZUlkO1xyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gaWQgYW5kIHRoZXJlIGlzIGEgZ2xvYmFsIHN0YXRlIHByb3BlcnR5IGZvciB0aGlzIHN0b3JlIHRoZW4gbWVyZ2VcclxuXHRcdFx0XHRcdC8vIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhhdCBnbG9iYWwgc3RhdGUgaW50byB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgc3RvcmUgQU5EIHRoZW5cclxuXHRcdFx0XHRcdC8vIHNldCB0aGUgZ2xvYmFsIHN0YXRlIHRvIHRoYXQgbmV3IHN0YXRlIChzaW5jZSBpdCBtYXkgaGF2ZSBwcmV2aW91c2x5IGJlZW4gcGFydGlhbClcclxuXHRcdFx0XHRcdGlmIChzdG9yZUlkICYmIFJlZmx1eC5HbG9iYWxTdGF0ZVtzdG9yZUlkXSkge1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gUmVmbHV4Lkdsb2JhbFN0YXRlW3N0b3JlSWRdKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyLnN0YXRlW2tleV0gPSBSZWZsdXguR2xvYmFsU3RhdGVbc3RvcmVJZF1ba2V5XTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRSZWZsdXguR2xvYmFsU3RhdGVbc3RvcmVJZF0gPSBzdHIuc3RhdGU7XHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgKGlmIGl0IGhhcyBhbiBpZCkgc2V0IHRoZSBnbG9iYWwgc3RhdGUgdG8gdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIHN0b3JlXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0b3JlSWQpIHtcclxuXHRcdFx0XHRcdFx0UmVmbHV4Lkdsb2JhbFN0YXRlW3N0b3JlSWRdID0gc3RyLnN0YXRlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gaWYgbm8gaWQsIHRoZW4gbm8gbWVzc2luZyB3aXRoIGdsb2JhbCBzdGF0ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBsaXN0ZW4vc3Vic2NyaWJlIGZvciB0aGUgXCIudHJpZ2dlcigpXCIgaW4gdGhlIHN0b3JlLCBhbmQgdHJhY2sgdGhlIHVuc3Vic2NyaWJlcyBzbyB0aGF0IHdlIGNhbiB1bnN1YnNjcmliZSBvbiB1bm1vdW50XHJcblx0XHRcdFx0aWYgKCFSZWZsdXguc2VydmVyTW9kZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fX3N0b3JldW5zdWJzY3JpYmVzX18ucHVzaChzdHIubGlzdGVuKG9uU3RvcmVUcmlnZ2VyKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHJ1biBzZXQgc3RhdGUgc28gdGhhdCBpdCBtaXhlcyBpbiB0aGUgcHJvcHMgZnJvbSB0aGUgc3RvcmUgd2l0aCB0aGUgY29tcG9uZW50XHJcblx0XHRcdFx0dmFyIHVwZGF0ZU9iaiA9IGZpbHRlckJ5U3RvcmVLZXlzKHRoaXMuc3RvcmVLZXlzLCBzdHIuc3RhdGUpO1xyXG5cdFx0XHRcdGlmICh1cGRhdGVPYmopIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUodXBkYXRlT2JqKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gbWFwU3RvcmVUb1N0YXRlIG5lZWRzIHRvIGtub3cgaWYgaXMgcmVhZHkgdG8gbWFwIG9yIG11c3Qgd2FpdFxyXG5cdFx0dGhpcy5fX3JlYWR5dG9tYXBfXyA9IHRydWU7XHJcblx0XHQvLyBpZiB0aGVyZSBhcmUgbWFwcGluZ3MgdGhhdCB3ZXJlIGRlbGF5ZWQsIGRvIHRoZW0gbm93XHJcblx0XHR2YXIgZG1hcHMgPSB0aGlzLl9fZGVsYXllZG1hcHNfXztcclxuXHRcdGlmIChkbWFwcykge1xyXG5cdFx0XHRmb3IgKHZhciBqPTAsamo9ZG1hcHMubGVuZ3RoOyBqPGpqOyBqKyspIHtcclxuXHRcdFx0XHRkbWFwc1tqXS5mdW5jKCBkbWFwc1tqXS5zdGF0ZSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLl9fZGVsYXllZG1hcHNfXyA9IG51bGw7XHJcblx0fTtcclxuXHRcclxuXHQvLyBvbiB0aGUgdW5tb3VudCBwaGFzZSBvZiB0aGUgY29tcG9uZW50IHVuc3Vic2NyaWJlIHRoYXQgd2hpY2ggd2Ugc3Vic2NyaWJlZCBlYXJsaWVyIHRvIGtlZXAgb3VyIGdhcmJhZ2UgdHJhaWwgY2xlYW5cclxuXHRwcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9fc3RvcmV1bnN1YnNjcmliZXNfXykge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9fc3RvcmV1bnN1YnNjcmliZXNfXy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fX3N0b3JldW5zdWJzY3JpYmVzX19baV0oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5fX3JlYWR5dG9tYXBfXyA9IGZhbHNlO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogdGhpcy5tYXBTdG9yZVRvU3RhdGVcclxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93IHlvdSB0byBzdXBwbHkgbWFwIHRoZSBzdGF0ZSBvZiBhIHN0b3JlIHRvIHRoZVxyXG5cdCAqIHN0YXRlIG9mIHRoaXMgY29tcG9uZW50IG1hbnVhbGx5IHZpYSB5b3VyIG93biBsb2dpYy4gVGhpcyBtZXRob2RcclxuXHQgKiBpcyBjb21wbGV0ZWx5IHNlcGFyYXRlIGZyb20gdGhpcy5zdG9yZS90aGlzLnN0b3JlcyBhbmQvb3IgdGhpcy5zdG9yZUtleXMuXHJcblx0ICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggYW4gRVM2IHN0b3JlIChjbGFzcyBvciBzaW5nbGV0b24gaW5zdGFuY2UpIGFzIHRoZVxyXG5cdCAqIGZpcnN0IGFyZ3VtZW50IGFuZCB5b3VyIGZpbHRlciBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kLiBZb3VyIGZpbHRlciBmdW5jdGlvblxyXG5cdCAqIHdpbGwgcmVjZWl2ZSBhbiBvYmplY3Qgb2YgdGhlIHBhcnRzIG9mIHRoZSBFUzYgc3RvcmUgYmVpbmcgdXBkYXRlZCBldmVyeVxyXG5cdCAqIHRpbWUgaXRzIHNldFN0YXRlIGlzIGNhbGxlZC4gWW91ciBmaWx0ZXIgZnVuY3Rpb24gdGhlbiByZXR1cm5zIGFuIG9iamVjdFxyXG5cdCAqIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZSAoSUYgaXQgaGFzIGFueSBwcm9wZXJ0aWVzIGF0IGFsbCxcclxuXHQgKiBzaG91bGQgeW91IHJldHVybiBhIGJsYW5rIG9iamVjdCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlcmVuZGVyKS5cclxuXHQgKi9cclxuXHRwcm90by5tYXBTdG9yZVRvU3RhdGUgPSBmdW5jdGlvbihzdG9yZSwgZmlsdGVyRnVuYylcclxuXHR7XHJcblx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIHByb3BlciBzaW5nbGV0b24gaW5zdGFuY2UgdG8gd29yayB3aXRoXHJcblx0XHRpZiAodHlwZW9mIHN0b3JlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGlmIChzdG9yZS5zaW5nbGV0b24pIHtcclxuXHRcdFx0XHRzdG9yZSA9IHN0b3JlLnNpbmdsZXRvbjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdG9yZSA9IFJlZmx1eC5pbml0U3RvcmUoc3RvcmUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIHdlIG5lZWQgYSBjbG9zdXJlIHNvIHRoYXQgdGhlIGNhbGxlZCBmdW5jdGlvbiBjYW4gcmVtZW1iZXIgdGhlIHByb3BlciBmaWx0ZXIgZnVuY3Rpb24gdG8gdXNlLCBzbyBmdW5jdGlvbiBnZXRzIGRlZmluZWQgaGVyZVxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0ZnVuY3Rpb24gb25NYXBTdG9yZVRyaWdnZXIob2JqKSB7XHJcblx0XHRcdC8vIGdldCBhbiBvYmplY3QgXHJcblx0XHRcdHZhciB1cGRhdGUgPSBmaWx0ZXJGdW5jLmNhbGwoc2VsZiwgb2JqKTtcclxuXHRcdFx0Ly8gaWYgbm8gb2JqZWN0IHJldHVybmVkIGZyb20gZmlsdGVyIGZ1bmN0aW9ucyBkbyBub3RoaW5nXHJcblx0XHRcdGlmICghdXBkYXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNoZWNrIGlmIHRoZSB1cGRhdGUgYWN0dWFsbHkgaGFzIGFueSBtYXBwZWQgcHJvcHNcclxuXHRcdFx0Lypqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xyXG5cdFx0XHR2YXIgaGFzUHJvcHMgPSBmYWxzZTtcclxuXHRcdFx0Zm9yICh2YXIgY2hlY2sgaW4gdXBkYXRlKSB7XHJcblx0XHRcdFx0aGFzUHJvcHMgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGlmIHRoZXJlIHdlcmUgcHJvcHMgbWFwcGVkLCB0aGVuIHVwZGF0ZSB2aWEgc2V0U3RhdGVcclxuXHRcdFx0aWYgKGhhc1Byb3BzKSB7XHJcblx0XHRcdFx0c2VsZi5zZXRTdGF0ZSh1cGRhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIGFkZCB0aGUgbGlzdGVuZXIgdG8ga25vdyB3aGVuIHRoZSBzdG9yZSBpcyB0cmlnZ2VyZWRcclxuXHRcdHRoaXMuX19zdG9yZXVuc3Vic2NyaWJlc19fID0gdGhpcy5fX3N0b3JldW5zdWJzY3JpYmVzX18gfHwgW107XHJcblx0XHR0aGlzLl9fc3RvcmV1bnN1YnNjcmliZXNfXy5wdXNoKHN0b3JlLmxpc3Rlbihvbk1hcFN0b3JlVHJpZ2dlcikpO1xyXG5cdFx0XHJcblx0XHQvLyBub3cgYWN0dWFsbHkgcnVuIG9uTWFwU3RvcmVUcmlnZ2VyIHdpdGggdGhlIGZ1bGwgc3RvcmUgc3RhdGUgc28gdGhhdCB3ZSBpbW1lZGlhdGVseSBoYXZlIGFsbCBzdG9yZSBzdGF0ZSBtYXBwZWQgdG8gY29tcG9uZW50IHN0YXRlXHJcblx0XHRpZiAodGhpcy5fX3JlYWR5dG9tYXBfXykge1xyXG5cdFx0XHRvbk1hcFN0b3JlVHJpZ2dlcihzdG9yZS5zdGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9fZGVsYXllZG1hcHNfXyA9IHRoaXMuX19kZWxheWVkbWFwc19fIHx8IFtdO1xyXG5cdFx0XHR0aGlzLl9fZGVsYXllZG1hcHNfXy5wdXNoKHtmdW5jOm9uTWFwU3RvcmVUcmlnZ2VyLCBzdGF0ZTpzdG9yZS5zdGF0ZX0pO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVmbHV4LkNvbXBvbmVudC5leHRlbmQoT3RoZXJDbGFzcylcclxuXHQgKiBUaGlzIGFsbG93cyB5b3UgdG8gZ2V0IGNsYXNzZXMgdGhhdCBleHRlbmQgb2ZmIG9mIGFub3RoZXIgUmVhY3QuQ29tcG9uZW50XHJcblx0ICogaW5oZXJpdGluZyBjbGFzcy4gRm9yIGV4YW1wbGUgaWYgeW91J3JlIHVzaW5nIGEgdGhpcmQgcGFydHkgdGhhdCB1c2VzXHJcblx0ICogY29tcG9uZW50cyB0aGF0IGFsbG93IGBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIExpYkNvbXBvbmVudGAgKHdoZXJlIExpYkNvbXBvbmVudFxyXG5cdCAqIGl0c2VsZiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCkgYW5kIHlvdSB3YW50IHRvIHVzZSB0aGF0IGNvbXBvbmVudCB3aXRoIEVTNiB0aGVuXHJcblx0ICogeW91IGNhbiBtYWtlIGEgY2xhc3MgYHZhciBNeUR1YWxDb21wb25lbnQgPSBSZWZsdXguQ29tcG9uZW50LmV4dGVuZChMaWJDb21wb25lbnQpO2BcclxuXHQgKiB0aGVuIHlvdSBjYW4gdXNlIGBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIE15RHVhbENvbXBvbmVudGAgdG8gZ2V0IHRoZSBiZW5lZml0c1xyXG5cdCAqIG9mIGJvdGggbGlicmFyaWVzLlxyXG5cdCAqL1xyXG5cdFJlZmx1eENvbXBvbmVudC5leHRlbmQgPSBmdW5jdGlvbihjbHNzKSB7XHJcblx0XHRyZXR1cm4gZGVmaW5lUmVhY3QobnVsbCwgbnVsbCwgY2xzcyk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBpZiBpcyBiZWluZyBtYW51YWxseSBjYWxsZWQgd2l0aCBhbiBgZXh0ZW5kYCBhcmd1bWVudCBwcmVzZW50IHRoZW4ganVzdCByZXR1cm4gdGhlIGNyZWF0ZWQgY2xhc3NcclxuXHRpZiAoZXh0ZW5kKSB7XHJcblx0XHRyZXR1cm4gUmVmbHV4Q29tcG9uZW50O1xyXG5cdH1cclxuXHRcclxuXHQvLyBvdGhlcndpc2Ugc2V0IGFzIFJlZmx1eC5Db21wb25lbnQgYW5kIGNvbnRpbnVlIHdpdGggb3RoZXIgbm9ybWFsIGRlZmluaXRpb25zXHJcblx0UmVmbHV4LkNvbXBvbmVudCA9IFJlZmx1eENvbXBvbmVudDtcclxuXHRcclxuXHQvLyBhbHNvIHNldCBSZWZsdXguUHVyZUNvbXBvbmVudCAoaWYgaXQgZXhpc3RzKSB1c2luZyB0aGUgLmV4dGVuZCBmZWF0dXJlXHJcblx0aWYgKF9yZWFjdC5QdXJlQ29tcG9uZW50KSB7XHJcblx0XHRSZWZsdXguUHVyZUNvbXBvbmVudCA9IFJlZmx1eENvbXBvbmVudC5leHRlbmQoX3JlYWN0LlB1cmVDb21wb25lbnQpO1xyXG5cdH1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0tLS0gRU5EIFJlZmx1eC5Db21wb25lbnQgLS0tLS0tLS0tLS0tXHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tIEJFR0lOIFJlZmx1eC5TdG9yZSAtLS0tLS0tLS0tLS1cclxuXHQvKipcclxuXHQgKiBSZWZsdXguU3RvcmU6XHJcblx0ICogQWxzbyBpbXBsZW1lbnRzIG9wdGlvbmFsIFJlZmx1eC5TdG9yZSBjbGFzcyB0aGF0IGlzIGlkaW9tYXRpYyB3aXRoXHJcblx0ICogdGhlIFJlYWN0IEVTNiBzdHlsZS4gWW91IGV4dGVuZCBSZWZsdXguU3RvcmUgYW5kIHRoZW4gdGhlIHJlc3Qgd29ya3NcclxuXHQgKiB0aGUgc2FtZSBhcyBjcmVhdGVTdG9yZSwgZXhjZXB0IHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGluaXQsIGFuZFxyXG5cdCAqIGl0IGhvbGRzIHN0YXRlIGluIGEgc3RhdGUgcHJvcGVydHksIGFuZCBhIC5zZXRTdGF0ZSBtZXRob2QgaXMgYXZhaWxhYmxlXHJcblx0ICogd2hpY2ggYXV0b21hdGljYWxseSB1cGRhdGVzIHN0YXRlIGFuZCBkb2VzIGEgdHJpZ2dlci4gVGhlbiB3aGVuIHVzaW5nXHJcblx0ICogd2l0aCB0aGlzLnN0b3JlIG9yIHRoaXMuc3RvcmVzIGluIGFuIEVTNiBjb21wb25lbnQganVzdCBwbGFzcyB0aGUgY2xhc3MsXHJcblx0ICogaXQgd2lsbCBkZWFsIHdpdGggYSBzaW5nbGV0b24gaW5zdGFudGlhdGlvbiBvZiB0aGUgY2xhc3MgYXV0b21hdGljYWxseS5cclxuXHQgKi9cclxuXHR2YXIgUmVmbHV4U3RvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIGV4dGVuZGluZyBkb2Vzbid0IHJlYWxseSB3b3JrIHdlbGwgaGVyZSwgc28gaW5zdGVhZCB3ZSBjcmVhdGUgYW4gaW50ZXJuYWwgaW5zdGFuY2VcclxuXHRcdC8vIGFuZCBqdXN0IGxvb3AgdGhyb3VnaCBpdHMgcHJvcGVydGllcy9tZXRob2RzIGFuZCBtYWtlIGEgZ2V0dGVyL3NldHRlciBmb3IgZWFjaFxyXG5cdFx0Ly8gdGhhdCB3aWxsIGFjdHVhbGx5IGJlIGdldHRpbmcgYW5kIHNldHRpbmcgb24gdGhhdCBpbnRlcm5hbCBpbnN0YW5jZS5cclxuXHRcdHRoaXMuX19zdG9yZV9fID0gUmVmbHV4LmNyZWF0ZVN0b3JlKCk7XHJcblx0XHR0aGlzLnN0YXRlID0ge307XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fX3N0b3JlX18pIHtcclxuXHRcdFx0Lypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cclxuXHRcdFx0KGZ1bmN0aW9uIChwcm9wKSB7XHJcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIHByb3AsIHtcclxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fX3N0b3JlX19bcHJvcF07IH0sXHJcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICh2KSB7IHNlbGYuX19zdG9yZV9fW3Byb3BdID0gdjsgfVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KShrZXkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0cHJvdG8gPSBSZWZsdXhTdG9yZS5wcm90b3R5cGU7XHJcblx0XHJcblx0Ly8gdGhpcyBkZWZpbmVzIHRoZSBsaXN0ZW5hYmxlcyBwcm9wZXJ0eSwgbW9zdGx5IGludGVuZGVkIHRvIGJlIHNldCBhcyBgdGhpcy5saXN0ZW5hYmxlc2AgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdG9yZVxyXG5cdC8vIGl0IGlzIGVzc2VudGlhbGx5IGEgc2hvcnRjdXQgdG8gdGhlIGBsaXN0ZW5Ub01hbnlgIG1ldGhvZFxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJsaXN0ZW5hYmxlc1wiLCB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX19saXN0ZW5hYmxlc19fO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKHYpIHtcclxuXHRcdFx0dmFyIENvbWJpbmVkID0ge307XHJcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHYpKXtcclxuXHRcdFx0XHR2LmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0XHRcdFx0XHRcdENvbWJpbmVkW2tleV0gPSBvYmpba2V5XTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRDb21iaW5lZCA9IHY7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fX2xpc3RlbmFibGVzX18gPSBDb21iaW5lZDtcclxuXHRcdFx0dGhpcy5saXN0ZW5Ub01hbnkoQ29tYmluZWQpO1xyXG5cdFx0fSxcclxuXHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRjb25maWd1cmFibGU6IHRydWVcclxuXHR9KTtcclxuXHRcclxuXHQvLyBhbGxvd3Mgc2ltcGxlIHVzYWdlIG9mIGB0aGlzLnNldFN0YXRlKG9iailgIHdpdGhpbiB0aGUgc3RvcmUgdG8gYm90aCB1cGRhdGUgdGhlIHN0YXRlIGFuZCB0cmlnZ2VyIHRoZSBzdG9yZSB0byB1cGRhdGVcclxuXHQvLyBjb21wb25lbnRzIHRoYXQgaXQgaXMgYXR0YWNoZWQgdG8gaW4gYSBzaW1wbGUgd2F5IHRoYXQgaXMgaWRpb21hdGljIHdpdGggUmVhY3RcclxuXHRwcm90by5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdC8vIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgb2JqKTsgLy8gbGF0ZXIgdHVybiB0aGlzIHRvIE9iamVjdC5hc3NpZ24gYW5kIHJlbW92ZSBsb29wIG9uY2Ugc3VwcG9ydCBpcyBnb29kIGVub3VnaFxyXG5cdFx0Zm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdFx0XHR0aGlzLnN0YXRlW2tleV0gPSBvYmpba2V5XTtcclxuXHRcdH1cclxuXHRcdC8vIGlmIHRoZXJlJ3MgYW4gaWQgKGkuZS4gaXQncyBiZWluZyB0cmFja2VkIGJ5IHRoZSBnbG9iYWwgc3RhdGUpIHRoZW4gbWFrZSBzdXJlIHRvIHVwZGF0ZSB0aGUgZ2xvYmFsIHN0YXRlXHJcblx0XHRpZiAodGhpcy5pZCkge1xyXG5cdFx0XHRSZWZsdXguR2xvYmFsU3RhdGVbdGhpcy5pZF0gPSB0aGlzLnN0YXRlO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdHJpZ2dlciwgYmVjYXVzZSBhbnkgY29tcG9uZW50IGl0J3MgYXR0YWNoZWQgdG8gaXMgbGlzdGVuaW5nIGFuZCB3aWxsIG1lcmdlIHRoZSBzdG9yZSBzdGF0ZSBpbnRvIGl0cyBvd24gb24gYSBzdG9yZSB0cmlnZ2VyXHJcblx0XHR0aGlzLnRyaWdnZXIob2JqKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIHRoaXMgaXMgYSBzdGF0aWMgcHJvcGVydHkgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBpZGVudGlmeSB0aGF0IHRoaXMgaXMgYSBSZWZsdXguU3RvcmUgY2xhc3NcclxuXHQvLyBoYXMgaXNzdWVzIHNwZWNpZmljYWxseSB3aGVuIHVzaW5nIGJhYmVsIHRvIHRyYW5zcGlsZSB5b3VyIEVTNiBzdG9yZXMgZm9yIElFMTAgYW5kIGJlbG93LCBub3QgZG9jdW1lbnRlZCBhbmQgc2hvdWxkbid0IHVzZSB5ZXRcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbHV4U3RvcmUsIFwiaXNFUzZTdG9yZVwiLCB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIGFsbG93cyBhIHNob3J0Y3V0IGZvciBhY2Nlc3NpbmcgTXlTdG9yZS5zaW5nbGV0b24uc3RhdGUgYXMgTXlTdG9yZS5zdGF0ZSAoc2luY2UgY29tbW9uIHVzYWdlIG1ha2VzIGEgc2luZ2xldG9uKVxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsdXhTdG9yZSwgXCJzdGF0ZVwiLCB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKCF0aGlzLnNpbmdsZXRvbikge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVmbHV4LlN0b3JlLnN0YXRlIGlzIGluYWNjZXNzaWJsZSBiZWZvcmUgdGhlIHN0b3JlIGhhcyBiZWVuIGluaXRpYWxpemVkLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzLnNpbmdsZXRvbi5zdGF0ZTtcclxuXHRcdH0sXHJcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlXHJcblx0fSk7XHJcblx0XHJcblx0LyogTk9URTpcclxuXHRJZiBhIFJlZmx1eC5TdG9yZSBkZWZpbml0aW9uIGlzIGdpdmVuIGEgc3RhdGljIGlkIHByb3BlcnR5IGFuZCB1c2VkXHJcblx0cHJvcGVybHkgd2l0aGluIGEgUmVmbHV4LkNvbXBvbmVudCBvciB3aXRoIFJlZmx1eC5pbml0U3RvcmUgdGhlblxyXG5cdGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFJlZmx1eC5HbG9iYWxTdGF0ZSBvYmplY3Qgd2hpY2ggYXV0b21hdGljYWxseSB0cmFja3MgdGhlXHJcblx0Y3VycmVudCBzdGF0ZSBvZiBhbGwgc3VjaCBkZWZpbmVkIHN0b3JlcyBpbiB0aGUgcHJvZ3JhbS4gKi9cclxuXHRcclxuXHRSZWZsdXguU3RvcmUgPSBSZWZsdXhTdG9yZTtcclxuXHQvLyAtLS0tLS0tLS0tLSBFTkQgUmVmbHV4LlN0b3JlIC0tLS0tLS0tLS0tLS1cclxuXHRcclxuXHQvLyAtLS0tLS0tLS0gQkVHSU4gUmVmbHV4IFN0YXRpYyBQcm9wcy9NZXRob2RzIC0tLS0tLS0tLS0tLVxyXG5cdC8qKlxyXG5cdCAqIFJlZmx1eC5HbG9iYWxTdGF0ZSBpcyB3aGVyZSBkYXRhIGlzIHN0b3JlZCBmb3IgYW55IFJlZmx1eC5TdG9yZSB0aGF0IGhhcyBhIHN0YXRpYyBpZCBwcm9wZXJ0eS4gRWFjaCBzdG9yZSdzXHJcblx0ICogc3RhdGUgd2lsbCBiZSBvbiB0aGUgUmVmbHV4Lkdsb2JhbFN0YXRlIG9iamVjdCB3aXRoIHRoZSBpZCBhcyB0aGUga2V5LiBTbyBhIHN0b3JlIHdpdGggdGhlIGlkIFwiTXlTdG9yZVwiIGFuZFxyXG5cdCAqIGEgc3RhdGUge1wiY29sb3JcIjpcInJlZFwifSB3aWxsIGVuZCB1cCB3aXRoIGEgUmVmbHV4Lkdsb2JhbFN0YXRlIG9mIHtcIk15U3RvcmVcIjp7XCJjb2xvclwiOlwicmVkXCJ9fVxyXG5cdCAqIFJlZmx1eC5HbG9iYWxTdGF0ZSBpcyBhbiBhY2Nlc3NpYmxlIHBhcnQgb2YgdGhlIEFQSS4gSG93ZXZlciwga2VlcCBpbiBtaW5kIHRoYXQgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIHlvdVxyXG5cdCAqIHJlYWQgb2ZmIG9mIGl0IHdpbGwgY29udGludWUgdG8gbXV0YXRlIGFuZCB5b3UgY2FuIG9ubHkgbWFudWFsbHkgbXV0YXRlIFJlZmx1eC5HbG9iYWxTdGF0ZSBCRUZPUkUgYW55IGNvbXBvbmVudFxyXG5cdCAqIG1vdW50aW5nIG9mIGNvbXBvbmVudHMgd2l0aCBFUzYgc3RvcmVzLiBGb3IgbW9yZSBmdW5jdGlvbmFsaXR5IGxvb2sgdG8gUmVmbHV4LnNldEdsb2JhbFN0YXRlIHRvIGNoYW5nZSB0aGUgZ2xvYmFsXHJcblx0ICogc3RhdGUgYXQgYW55IHBvaW50LCBhbmQgUmVmbHV4LmdldEdsb2JhbFN0YXRlIHRvIHJldHVybiBhIGRlZXAgY2xvbmUgb2YgdGhlIFJlZmx1eC5HbG9iYWxTdGF0ZSBvYmplY3Qgd2hpY2ggd2lsbFxyXG5cdCAqIG5vdCBjb250aW51ZSB0byBtdXRhdGUgYXMgUmVmbHV4Lkdsb2JhbFN0YXRlIGNvbnRpbnVlcyB0byBtdXRhdGUuXHJcblx0ICovXHJcblx0UmVmbHV4Lkdsb2JhbFN0YXRlID0gUmVmbHV4Lkdsb2JhbFN0YXRlIHx8IHt9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJlZmx1eC5zdG9yZXNcclxuXHQgKiBBbGwgaW5pdGlhbGl6ZWQgc3RvcmVzIHRoYXQgaGF2ZSBhbiBpZCB3aWxsIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlaXIgc2luZ2xldG9uIHN0b3JlZCBoZXJlIHdpdGggdGhlIGtleSBiZWluZyB0aGUgaWQuXHJcblx0ICovXHJcblx0UmVmbHV4LnN0b3JlcyA9IHt9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJlZmx1eC5nZXRHbG9iYWxTdGF0ZSB0YWtlcyBubyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBSZWZsdXguR2xvYmFsU3RhdGUgXHJcblx0ICogd2hpY2ggd2lsbCBub3QgY29udGludWUgdG8gbXV0YXRlIGFzIFJlZmx1eC5HbG9iYWxTdGF0ZSBkb2VzLiBJdCBjYW4gZXNzZW50aWFsbHkgc3RvcmVcclxuXHQgKiBzbmFwc2hvdHMgb2YgdGhlIGdsb2JhbCBzdGF0ZSBhcyB0aGUgcHJvZ3JhbSBnb2VzIGZvciBzYXZpbmcgb3IgZm9yIGluLWFwcCB0aW1lIHRyYXZlbC5cclxuXHQgKi9cclxuXHRSZWZsdXguZ2V0R2xvYmFsU3RhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBjbG9uZShSZWZsdXguR2xvYmFsU3RhdGUpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVmbHV4LnNldEdsb2JhbFN0YXRlIHRha2VzIG9uZSBhcmd1bWVudCB0aGF0IGlzIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGEgcG9zc2libGVcclxuXHQgKiBnbG9iYWwgc3RhdGUuIEl0IHVwZGF0ZXMgYWxsIHN0b3JlcyBpbiB0aGUgcHJvZ3JhbSB0byByZXByZXNlbnQgZGF0YSBpbiB0aGF0IGdpdmVuIHN0YXRlLlxyXG5cdCAqIFRoaXMgaW5jbHVkZXMgdHJpZ2dlcmluZyB0aG9zZSBzdG9yZXMgc28gdGhhdCB0aGF0IHN0YXRlIGlzIHJlcHJlc2VudGVkIGluIGFueSBSZWZsdXguQ29tcG9uZW50XHJcblx0ICogaW5zdGFuY2VzIHRoZXkgYXJlIGF0dGFjaGVkIHRvLiBQYXJ0aWFsIHN0YXRlcyBtYXkgYmUgZ2l2ZW4gdG8gaXQsIGFuZCBvbmx5IHRoZSByZXByZXNlbnRlZFxyXG5cdCAqIHN0b3Jlcy9zdGF0ZSB2YWx1ZXMgd2lsbCBiZSB1cGRhdGVkLlxyXG5cdCAqL1xyXG5cdFJlZmx1eC5zZXRHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0Zm9yICh2YXIgc3RvcmVJRCBpbiBvYmopIHtcclxuXHRcdFx0aWYgKFJlZmx1eC5zdG9yZXNbc3RvcmVJRF0pIHtcclxuXHRcdFx0XHRSZWZsdXguc3RvcmVzW3N0b3JlSURdLnNldFN0YXRlKG9ialtzdG9yZUlEXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0UmVmbHV4Lkdsb2JhbFN0YXRlW3N0b3JlSURdID0gb2JqW3N0b3JlSURdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZWZsdXguaW5pdFN0b3JlIHRha2VzIG9uZSBhcmd1bWVudCAoYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVmbHV4LlN0b3JlKSBhbmQgcmV0dXJucyBhIHNpbmdsZXRvblxyXG5cdCAqIGludGFuY2Ugb2YgdGhhdCBjbGFzcy4gSXRzIG1haW4gZnVuY3Rpb25hbGl0eSBpcyB0byBiZSBhYmxlIHRvIG1pbWljIHdoYXQgaGFwcGVucyB0byBzdG9yZXMgYXR0YWNoZWQgdG9cclxuXHQgKiB0aGlzLnN0b3JlIG9yIHRoaXMuc3RvcmVzIGR1cmluZyB0aGUgbW91bnRpbmcgcGhhc2Ugb2YgYSBjb21wb25lbnQgd2l0aG91dCBoYXZpbmcgdG8gYWN0dWFsbHkgYXR0YWNoIHRoZVxyXG5cdCAqIHN0b3JlIHRvIGEgY29tcG9uZW50IGluIG9yZGVyIHRvIHdvcmsgcHJvcGVybHkgd2l0aCB0aGUgZ2xvYmFsIHN0YXRlLlxyXG5cdCAqL1xyXG5cdC8vIFJlZmx1eC5pbml0aWFsaXplR2xvYmFsU3RvcmUgaXMga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJ1dCBkZXByZWNhdGVkIHNpbmNlIHRoZSBmdW5jdGlvbiBpc1xyXG5cdC8vIG5vdyBmb3IgbW9yZSBicm9hZCBpbnN0YW50aWF0aW9uIG9mIGdsb2JhbGx5IHN0b3JlZCBBTkQgbm9uLWdsb2JhbGx5IHN0b3JlZCBjbGFzc2VzXHJcblx0UmVmbHV4LmluaXRpYWxpemVHbG9iYWxTdG9yZSA9IFJlZmx1eC5pbml0U3RvcmUgPSBmdW5jdGlvbihzdHIpIHtcclxuXHRcdHZhciBzdG9yZUlkID0gc3RyLmlkO1xyXG5cdFx0Ly8gaWYgdGhleSdyZSBpbml0aWFsaXppbmcgc29tZXRoaW5nIHR3aWNlIHRoZW4gd2UncmUgZG9uZSBhbHJlYWR5LCByZXR1cm4gaXRcclxuXHRcdGlmIChzdHIuc2luZ2xldG9uKSB7XHJcblx0XHRcdHJldHVybiBzdHIuc2luZ2xldG9uO1xyXG5cdFx0fVxyXG5cdFx0Ly8gaWYgbm8gaWQgdGhlbiBpdCdzIGVhc3k6IGp1c3QgbWFrZSBuZXcgaW5zdGFuY2UgYW5kIHNldCB0byBzaW5nbGV0b25cclxuXHRcdGlmICghc3RvcmVJZCkge1xyXG5cdFx0XHRzdHIuc2luZ2xldG9uID0gbmV3IHN0cigpO1xyXG5cdFx0XHRyZXR1cm4gc3RyLnNpbmdsZXRvbjtcclxuXHRcdH1cclxuXHRcdC8vIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGFuZCBhc3NpZ24gaXQgdG8gdGhlIGNsYXNzJ3Mgc2luZ2xldG9uIHN0YXRpYyBwcm9wZXJ0eVxyXG5cdFx0dmFyIGluc3QgPSBzdHIuc2luZ2xldG9uID0gbmV3IHN0cigpO1xyXG5cdFx0Ly8gc3RvcmUgaXQgb24gdGhlIFJlZmx1eC5zdG9yZXMgYXJyYXkgdG8gYmUgYWNjZXNzaWJsZSBsYXRlclxyXG5cdFx0UmVmbHV4LnN0b3Jlc1tzdG9yZUlkXSA9IGluc3Q7XHJcblx0XHQvLyB0aGUgc2luZ2xldG9uIGluc3RhbmNlIGl0c2VsZiBzaG91bGQgYWxzbyBoYXZlIHRoZSBpZCBwcm9wZXJ0eSBvZiB0aGUgY2xhc3NcclxuXHRcdGluc3QuaWQgPSBzdG9yZUlkO1xyXG5cdFx0Ly8gaWYgdGhlIGdsb2JhbCBzdGF0ZSBoYXMgc29tZXRoaW5nIHNldCBmb3IgdGhpcyBpZCwgY29weSBpdCB0byB0aGUgc3RhdGUgYW5kIHRoZW5cclxuXHRcdC8vIG1ha2Ugc3VyZSB0byBzZXQgdGhlIGdsb2JhbCBzdGF0ZSB0byB0aGUgZW5kIHJlc3VsdCwgc2luY2UgaXQgbWF5IGhhdmUgb25seSBiZWVuIHBhcnRpYWxcclxuXHRcdGlmIChSZWZsdXguR2xvYmFsU3RhdGVbc3RvcmVJZF0pIHtcclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIFJlZmx1eC5HbG9iYWxTdGF0ZVtzdG9yZUlkXSkge1xyXG5cdFx0XHRcdGluc3Quc3RhdGVba2V5XSA9IFJlZmx1eC5HbG9iYWxTdGF0ZVtzdG9yZUlkXVtrZXldO1xyXG5cdFx0XHR9XHJcblx0XHRcdFJlZmx1eC5HbG9iYWxTdGF0ZVtzdG9yZUlkXSA9IGluc3Quc3RhdGU7XHJcblx0XHQvLyBvdGhlcndpc2UganVzdCBzZXQgdGhlIGdsb2JhbCBzdGF0ZSB0byB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgY2xhc3NcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdFJlZmx1eC5HbG9iYWxTdGF0ZVtzdG9yZUlkXSA9IGluc3Quc3RhdGU7XHJcblx0XHR9XHJcblx0XHQvLyByZXR1cm5zIHRoZSBzaW5nbGV0b24gaXRzZWxmLCB0aG91Z2ggaXQgd2lsbCBhbHNvIGJlIGFjY2Vzc2libGUgYXMgYXMgYE15Q2xhc3Muc2luZ2xldG9uYFxyXG5cdFx0cmV0dXJuIGluc3Q7XHJcblx0fTtcclxuXHQvLyAtLS0tLS0tLS0gRU5EIFJlZmx1eCBTdGF0aWMgUHJvcHMvTWV0aG9kcyAtLS0tLS0tLS0tLS1cclxuXHRcclxuXHQvLyBzbyBpdCBrbm93cyBub3QgdG8gcmVkZWZpbmUgUmVmbHV4IHN0YXRpYyBzdHVmZiBhbmQgc3RvcmVzIGlmIGNhbGxlZCBhZ2FpblxyXG5cdF9kZWZpbmVkID0gdHJ1ZTtcclxufVxyXG5cclxuLy8gZmlsdGVycyBhIHN0YXRlIG9iamVjdCBieSBzdG9yZUtleXMgYXJyYXkgKGlmIGl0IGV4aXN0cylcclxuLy8gaWYgZmlsdGVyaW5nIGFuZCBvYmogY29udGFpbnMgbm8gcHJvcGVydGllcyB0byB1c2UsIHJldHVybnMgZmFsc2UgdG8gbGV0IHRoZSBjb21wb25lbnQga25vdyBub3QgdG8gdXBkYXRlXHJcbmZ1bmN0aW9uIGZpbHRlckJ5U3RvcmVLZXlzKHN0b3JlS2V5cywgb2JqKVxyXG57XHJcblx0Ly8gaWYgdGhlcmUgYXJlIG5vdCBzdG9yZUtleXMgZGVmaW5lZCB0aGVuIHNpbXBseSByZXR1cm4gdGhlIHdob2xlIG9yaWdpbmFsIG9iamVjdFxyXG5cdGlmICghc3RvcmVLZXlzKSB7XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH1cclxuXHQvLyBvdGhlcndpc2UgZ28gdGhyb3VnaCBhbmQgb25seSB1cGRhdGUgcHJvcGVydGllcyB0aGF0IGFyZSBpbiB0aGUgc3RvcmVLZXlzIGFycmF5LCBhbmQgcmV0dXJuIHN0cmFpZ2h0IGZhbHNlIGlmIHRoZXJlIGFyZSBub25lXHJcblx0dmFyIGRvVXBkYXRlID0gZmFsc2U7XHJcblx0dmFyIHVwZGF0ZU9iaiA9IHt9O1xyXG5cdGZvciAodmFyIGkgPSAwLCBpaSA9IHN0b3JlS2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcblx0XHR2YXIgcHJvcCA9IHN0b3JlS2V5c1tpXTtcclxuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuXHRcdFx0ZG9VcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHR1cGRhdGVPYmpbcHJvcF0gPSBvYmpbcHJvcF07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkb1VwZGF0ZSA/IHVwZGF0ZU9iaiA6IGZhbHNlO1xyXG59XHJcblxyXG4vLyB0aGlzIGlzIHV0aWxpemVkIGJ5IHNvbWUgb2YgdGhlIGdsb2JhbCBzdGF0ZSBmdW5jdGlvbmFsaXR5IGluIG9yZGVyIHRvIGdldCBhIGNsb25lIHRoYXQgd2lsbFxyXG4vLyBub3QgY29udGludWUgdG8gYmUgbW9kaWZpZWQgYXMgdGhlIEdsb2JhbFN0YXRlIG11dGF0ZXNcclxuZnVuY3Rpb24gY2xvbmUoZnJtLCB0bykge1xyXG5cdGlmIChmcm0gPT09IG51bGwgfHwgdHlwZW9mIGZybSAhPT0gXCJvYmplY3RcIikge1xyXG5cdFx0cmV0dXJuIGZybTtcclxuXHR9XHJcblx0aWYgKGZybS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIGZybS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcclxuXHRcdHJldHVybiBmcm07XHJcblx0fVxyXG5cdGlmIChmcm0uY29uc3RydWN0b3IgPT09IERhdGUgfHwgZnJtLmNvbnN0cnVjdG9yID09PSBSZWdFeHAgfHwgZnJtLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbiB8fFxyXG5cdFx0ZnJtLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgZnJtLmNvbnN0cnVjdG9yID09PSBOdW1iZXIgfHwgZnJtLmNvbnN0cnVjdG9yID09PSBCb29sZWFuKSB7XHJcblx0XHRyZXR1cm4gbmV3IGZybS5jb25zdHJ1Y3Rvcihmcm0pO1xyXG5cdH1cclxuXHR0byA9IHRvIHx8IG5ldyBmcm0uY29uc3RydWN0b3IoKTtcclxuXHRmb3IgKHZhciBuYW1lIGluIGZybSkge1xyXG5cdFx0dG9bbmFtZV0gPSB0eXBlb2YgdG9bbmFtZV0gPT09IFwidW5kZWZpbmVkXCIgPyBjbG9uZShmcm1bbmFtZV0sIG51bGwpIDogdG9bbmFtZV07XHJcblx0fVxyXG5cdHJldHVybiB0bztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVSZWFjdDtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZmx1eC9zcmMvZGVmaW5lUmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgb25DbGlja091dHNpZGUgZnJvbSAncmVhY3Qtb25jbGlja291dHNpZGUnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgTWFuYWdlciwgUG9wcGVyLCBUYXJnZXQgfSBmcm9tICdyZWFjdC1wb3BwZXInO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVllYXJzKHllYXIsIG5vT2ZZZWFyLCBtaW5EYXRlLCBtYXhEYXRlKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMiAqIG5vT2ZZZWFyICsgMTsgaSsrKSB7XG4gICAgdmFyIG5ld1llYXIgPSB5ZWFyICsgbm9PZlllYXIgLSBpO1xuICAgIHZhciBpc0luUmFuZ2UgPSB0cnVlO1xuXG4gICAgaWYgKG1pbkRhdGUpIHtcbiAgICAgIGlzSW5SYW5nZSA9IG1pbkRhdGUueWVhcigpIDw9IG5ld1llYXI7XG4gICAgfVxuXG4gICAgaWYgKG1heERhdGUgJiYgaXNJblJhbmdlKSB7XG4gICAgICBpc0luUmFuZ2UgPSBtYXhEYXRlLnllYXIoKSA+PSBuZXdZZWFyO1xuICAgIH1cblxuICAgIGlmIChpc0luUmFuZ2UpIHtcbiAgICAgIGxpc3QucHVzaChuZXdZZWFyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxudmFyIFllYXJEcm9wZG93bk9wdGlvbnMgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhZZWFyRHJvcGRvd25PcHRpb25zLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBZZWFyRHJvcGRvd25PcHRpb25zKHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhckRyb3Bkb3duT3B0aW9ucyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMucmVuZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxlY3RlZFllYXIgPSBfdGhpcy5wcm9wcy55ZWFyO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5zdGF0ZS55ZWFyc0xpc3QubWFwKGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBzZWxlY3RlZFllYXIgPT09IHllYXIgPyBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uIHJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uLS1zZWxlY3RlZF95ZWFyXCIgOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uXCIsXG4gICAgICAgICAgICBrZXk6IHllYXIsXG4gICAgICAgICAgICByZWY6IHllYXIsXG4gICAgICAgICAgICBvbkNsaWNrOiBfdGhpcy5vbkNoYW5nZS5iaW5kKF90aGlzLCB5ZWFyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0ZWRZZWFyID09PSB5ZWFyID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb24tLXNlbGVjdGVkXCIgfSxcbiAgICAgICAgICAgIFwiXFx1MjcxM1wiXG4gICAgICAgICAgKSA6IFwiXCIsXG4gICAgICAgICAgeWVhclxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBtaW5ZZWFyID0gX3RoaXMucHJvcHMubWluRGF0ZSA/IF90aGlzLnByb3BzLm1pbkRhdGUueWVhcigpIDogbnVsbDtcbiAgICAgIHZhciBtYXhZZWFyID0gX3RoaXMucHJvcHMubWF4RGF0ZSA/IF90aGlzLnByb3BzLm1heERhdGUueWVhcigpIDogbnVsbDtcblxuICAgICAgaWYgKCFtYXhZZWFyIHx8ICFfdGhpcy5zdGF0ZS55ZWFyc0xpc3QuZmluZChmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICByZXR1cm4geWVhciA9PT0gbWF4WWVhcjtcbiAgICAgIH0pKSB7XG4gICAgICAgIG9wdGlvbnMudW5zaGlmdChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uXCIsXG4gICAgICAgICAgICByZWY6IFwidXBjb21pbmdcIixcbiAgICAgICAgICAgIGtleTogXCJ1cGNvbWluZ1wiLFxuICAgICAgICAgICAgb25DbGljazogX3RoaXMuaW5jcmVtZW50WWVhcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24gcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMgcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMtdXBjb21pbmdcIiB9KVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtaW5ZZWFyIHx8ICFfdGhpcy5zdGF0ZS55ZWFyc0xpc3QuZmluZChmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICByZXR1cm4geWVhciA9PT0gbWluWWVhcjtcbiAgICAgIH0pKSB7XG4gICAgICAgIG9wdGlvbnMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItb3B0aW9uXCIsXG4gICAgICAgICAgICByZWY6IFwicHJldmlvdXNcIixcbiAgICAgICAgICAgIGtleTogXCJwcmV2aW91c1wiLFxuICAgICAgICAgICAgb25DbGljazogX3RoaXMuZGVjcmVtZW50WWVhcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24gcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMgcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMtcHJldmlvdXNcIiB9KVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKHllYXIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zaGlmdFllYXJzID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgdmFyIHllYXJzID0gX3RoaXMuc3RhdGUueWVhcnNMaXN0Lm1hcChmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICByZXR1cm4geWVhciArIGFtb3VudDtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHllYXJzTGlzdDogeWVhcnNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5pbmNyZW1lbnRZZWFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zaGlmdFllYXJzKDEpO1xuICAgIH07XG5cbiAgICBfdGhpcy5kZWNyZW1lbnRZZWFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zaGlmdFllYXJzKC0xKTtcbiAgICB9O1xuXG4gICAgdmFyIHllYXJEcm9wZG93bkl0ZW1OdW1iZXIgPSBwcm9wcy55ZWFyRHJvcGRvd25JdGVtTnVtYmVyLFxuICAgICAgICBzY3JvbGxhYmxlWWVhckRyb3Bkb3duID0gcHJvcHMuc2Nyb2xsYWJsZVllYXJEcm9wZG93bjtcblxuICAgIHZhciBub09mWWVhciA9IHllYXJEcm9wZG93bkl0ZW1OdW1iZXIgfHwgKHNjcm9sbGFibGVZZWFyRHJvcGRvd24gPyAxMCA6IDUpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB5ZWFyc0xpc3Q6IGdlbmVyYXRlWWVhcnMoX3RoaXMucHJvcHMueWVhciwgbm9PZlllYXIsIF90aGlzLnByb3BzLm1pbkRhdGUsIF90aGlzLnByb3BzLm1heERhdGUpXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBZZWFyRHJvcGRvd25PcHRpb25zLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGRyb3Bkb3duQ2xhc3MgPSBjbGFzc25hbWVzKHtcbiAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93blwiOiB0cnVlLFxuICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLWRyb3Bkb3duLS1zY3JvbGxhYmxlXCI6IHRoaXMucHJvcHMuc2Nyb2xsYWJsZVllYXJEcm9wZG93blxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBjbGFzc05hbWU6IGRyb3Bkb3duQ2xhc3MgfSxcbiAgICAgIHRoaXMucmVuZGVyT3B0aW9ucygpXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gWWVhckRyb3Bkb3duT3B0aW9ucztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuWWVhckRyb3Bkb3duT3B0aW9ucy5wcm9wVHlwZXMgPSB7XG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgc2Nyb2xsYWJsZVllYXJEcm9wZG93bjogUHJvcFR5cGVzLmJvb2wsXG4gIHllYXI6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgeWVhckRyb3Bkb3duSXRlbU51bWJlcjogUHJvcFR5cGVzLm51bWJlclxufTtcblxudmFyIGRheU9mV2Vla0NvZGVzID0ge1xuICAxOiBcIm1vblwiLFxuICAyOiBcInR1ZVwiLFxuICAzOiBcIndlZFwiLFxuICA0OiBcInRodVwiLFxuICA1OiBcImZyaVwiLFxuICA2OiBcInNhdFwiLFxuICA3OiBcInN1blwiXG59O1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgYXJlIG5vdCBleHBvcnRlZCBzb1xuLy8gdGhhdCB3ZSBhdm9pZCBtYWdpYyBzdHJpbmdzIGxpa2UgJ2RheXMnXG5mdW5jdGlvbiBzZXQkMShkYXRlLCB1bml0LCB0bykge1xuICByZXR1cm4gZGF0ZS5zZXQodW5pdCwgdG8pO1xufVxuXG5mdW5jdGlvbiBhZGQoZGF0ZSwgYW1vdW50LCB1bml0KSB7XG4gIHJldHVybiBkYXRlLmFkZChhbW91bnQsIHVuaXQpO1xufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdChkYXRlLCBhbW91bnQsIHVuaXQpIHtcbiAgcmV0dXJuIGRhdGUuc3VidHJhY3QoYW1vdW50LCB1bml0KTtcbn1cblxuZnVuY3Rpb24gZ2V0JDEoZGF0ZSwgdW5pdCkge1xuICByZXR1cm4gZGF0ZS5nZXQodW5pdCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0T2YoZGF0ZSwgdW5pdCkge1xuICByZXR1cm4gZGF0ZS5zdGFydE9mKHVuaXQpO1xufVxuXG4vLyAqKiBEYXRlIENvbnN0cnVjdG9ycyAqKlxuXG5mdW5jdGlvbiBuZXdEYXRlKHBvaW50KSB7XG4gIHJldHVybiBtb21lbnQocG9pbnQpO1xufVxuXG5mdW5jdGlvbiBuZXdEYXRlV2l0aE9mZnNldCh1dGNPZmZzZXQpIHtcbiAgcmV0dXJuIG1vbWVudCgpLnV0YygpLnV0Y09mZnNldCh1dGNPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBub3cobWF5YmVGaXhlZFV0Y09mZnNldCkge1xuICBpZiAobWF5YmVGaXhlZFV0Y09mZnNldCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ld0RhdGUoKTtcbiAgfVxuICByZXR1cm4gbmV3RGF0ZVdpdGhPZmZzZXQobWF5YmVGaXhlZFV0Y09mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRGF0ZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLmNsb25lKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWx1ZSwgX3JlZikge1xuICB2YXIgZGF0ZUZvcm1hdCA9IF9yZWYuZGF0ZUZvcm1hdCxcbiAgICAgIGxvY2FsZSA9IF9yZWYubG9jYWxlO1xuXG4gIHZhciBtID0gbW9tZW50KHZhbHVlLCBkYXRlRm9ybWF0LCBsb2NhbGUgfHwgbW9tZW50LmxvY2FsZSgpLCB0cnVlKTtcbiAgcmV0dXJuIG0uaXNWYWxpZCgpID8gbSA6IG51bGw7XG59XG5cbi8vICoqIERhdGUgXCJSZWZsZWN0aW9uXCIgKipcblxuZnVuY3Rpb24gaXNNb21lbnQoZGF0ZSkge1xuICByZXR1cm4gbW9tZW50LmlzTW9tZW50KGRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZGF0ZSkge1xuICByZXR1cm4gbW9tZW50LmlzRGF0ZShkYXRlKTtcbn1cblxuLy8gKiogRGF0ZSBGb3JtYXR0aW5nICoqXG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0KSB7XG4gIHJldHVybiBkYXRlLmZvcm1hdChmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBzYWZlRGF0ZUZvcm1hdChkYXRlLCBfcmVmMikge1xuICB2YXIgZGF0ZUZvcm1hdCA9IF9yZWYyLmRhdGVGb3JtYXQsXG4gICAgICBsb2NhbGUgPSBfcmVmMi5sb2NhbGU7XG5cbiAgcmV0dXJuIGRhdGUgJiYgZGF0ZS5jbG9uZSgpLmxvY2FsZShsb2NhbGUgfHwgbW9tZW50LmxvY2FsZSgpKS5mb3JtYXQoQXJyYXkuaXNBcnJheShkYXRlRm9ybWF0KSA/IGRhdGVGb3JtYXRbMF0gOiBkYXRlRm9ybWF0KSB8fCBcIlwiO1xufVxuXG4vLyAqKiBEYXRlIFNldHRlcnMgKipcblxuZnVuY3Rpb24gc2V0VGltZShkYXRlLCBfcmVmMykge1xuICB2YXIgaG91ciA9IF9yZWYzLmhvdXIsXG4gICAgICBtaW51dGUgPSBfcmVmMy5taW51dGUsXG4gICAgICBzZWNvbmQgPSBfcmVmMy5zZWNvbmQ7XG5cbiAgZGF0ZS5zZXQoeyBob3VyOiBob3VyLCBtaW51dGU6IG1pbnV0ZSwgc2Vjb25kOiBzZWNvbmQgfSk7XG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBzZXRNb250aChkYXRlLCBtb250aCkge1xuICByZXR1cm4gc2V0JDEoZGF0ZSwgXCJtb250aFwiLCBtb250aCk7XG59XG5cbmZ1bmN0aW9uIHNldFllYXIoZGF0ZSwgeWVhcikge1xuICByZXR1cm4gc2V0JDEoZGF0ZSwgXCJ5ZWFyXCIsIHllYXIpO1xufVxuXG5cblxuLy8gKiogRGF0ZSBHZXR0ZXJzICoqXG5cbmZ1bmN0aW9uIGdldFNlY29uZChkYXRlKSB7XG4gIHJldHVybiBnZXQkMShkYXRlLCBcInNlY29uZFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWludXRlKGRhdGUpIHtcbiAgcmV0dXJuIGdldCQxKGRhdGUsIFwibWludXRlXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3VyKGRhdGUpIHtcbiAgcmV0dXJuIGdldCQxKGRhdGUsIFwiaG91clwiKTtcbn1cblxuLy8gUmV0dXJucyBkYXkgb2Ygd2Vla1xuZnVuY3Rpb24gZ2V0RGF5KGRhdGUpIHtcbiAgcmV0dXJuIGdldCQxKGRhdGUsIFwiZGF5XCIpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgcmV0dXJuIGdldCQxKGRhdGUsIFwid2Vla1wiKTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9udGgoZGF0ZSkge1xuICByZXR1cm4gZ2V0JDEoZGF0ZSwgXCJtb250aFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0WWVhcihkYXRlKSB7XG4gIHJldHVybiBnZXQkMShkYXRlLCBcInllYXJcIik7XG59XG5cbi8vIFJldHVybnMgZGF5IG9mIG1vbnRoXG5mdW5jdGlvbiBnZXREYXRlKGRhdGUpIHtcbiAgcmV0dXJuIGdldCQxKGRhdGUsIFwiZGF0ZVwiKTtcbn1cblxuXG5cbmZ1bmN0aW9uIGdldERheU9mV2Vla0NvZGUoZGF5KSB7XG4gIHJldHVybiBkYXlPZldlZWtDb2Rlc1tkYXkuaXNvV2Vla2RheSgpXTtcbn1cblxuLy8gKioqIFN0YXJ0IG9mICoqKlxuXG5mdW5jdGlvbiBnZXRTdGFydE9mRGF5KGRhdGUpIHtcbiAgcmV0dXJuIGdldFN0YXJ0T2YoZGF0ZSwgXCJkYXlcIik7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0T2ZXZWVrKGRhdGUpIHtcbiAgcmV0dXJuIGdldFN0YXJ0T2YoZGF0ZSwgXCJ3ZWVrXCIpO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRPZk1vbnRoKGRhdGUpIHtcbiAgcmV0dXJuIGdldFN0YXJ0T2YoZGF0ZSwgXCJtb250aFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRPZkRhdGUoZGF0ZSkge1xuICByZXR1cm4gZ2V0U3RhcnRPZihkYXRlLCBcImRhdGVcIik7XG59XG5cbi8vICoqKiBFbmQgb2YgKioqXG5cblxuXG5cblxuLy8gKiogRGF0ZSBNYXRoICoqXG5cbi8vICoqKiBBZGRpdGlvbiAqKipcblxuZnVuY3Rpb24gYWRkTWludXRlcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZChkYXRlLCBhbW91bnQsIFwibWludXRlc1wiKTtcbn1cblxuZnVuY3Rpb24gYWRkSG91cnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiBhZGQoZGF0ZSwgYW1vdW50LCBcImhvdXJzXCIpO1xufVxuXG5mdW5jdGlvbiBhZGREYXlzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gYWRkKGRhdGUsIGFtb3VudCwgXCJkYXlzXCIpO1xufVxuXG5mdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZChkYXRlLCBhbW91bnQsIFwid2Vla3NcIik7XG59XG5cbmZ1bmN0aW9uIGFkZE1vbnRocyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZChkYXRlLCBhbW91bnQsIFwibW9udGhzXCIpO1xufVxuXG5mdW5jdGlvbiBhZGRZZWFycyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZChkYXRlLCBhbW91bnQsIFwieWVhcnNcIik7XG59XG5cbi8vICoqKiBTdWJ0cmFjdGlvbiAqKipcbmZ1bmN0aW9uIHN1YnRyYWN0RGF5cyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIHN1YnRyYWN0KGRhdGUsIGFtb3VudCwgXCJkYXlzXCIpO1xufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdFdlZWtzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gc3VidHJhY3QoZGF0ZSwgYW1vdW50LCBcIndlZWtzXCIpO1xufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdE1vbnRocyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIHN1YnRyYWN0KGRhdGUsIGFtb3VudCwgXCJtb250aHNcIik7XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0WWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiBzdWJ0cmFjdChkYXRlLCBhbW91bnQsIFwieWVhcnNcIik7XG59XG5cbi8vICoqIERhdGUgQ29tcGFyaXNvbiAqKlxuXG5mdW5jdGlvbiBpc0JlZm9yZShkYXRlMSwgZGF0ZTIpIHtcbiAgcmV0dXJuIGRhdGUxLmlzQmVmb3JlKGRhdGUyKTtcbn1cblxuZnVuY3Rpb24gaXNBZnRlcihkYXRlMSwgZGF0ZTIpIHtcbiAgcmV0dXJuIGRhdGUxLmlzQWZ0ZXIoZGF0ZTIpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoZGF0ZTEsIGRhdGUyKSB7XG4gIHJldHVybiBkYXRlMS5pc1NhbWUoZGF0ZTIpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVZZWFyKGRhdGUxLCBkYXRlMikge1xuICBpZiAoZGF0ZTEgJiYgZGF0ZTIpIHtcbiAgICByZXR1cm4gZGF0ZTEuaXNTYW1lKGRhdGUyLCBcInllYXJcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lTW9udGgoZGF0ZTEsIGRhdGUyKSB7XG4gIGlmIChkYXRlMSAmJiBkYXRlMikge1xuICAgIHJldHVybiBkYXRlMS5pc1NhbWUoZGF0ZTIsIFwibW9udGhcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lRGF5KG1vbWVudDEsIG1vbWVudDIpIHtcbiAgaWYgKG1vbWVudDEgJiYgbW9tZW50Mikge1xuICAgIHJldHVybiBtb21lbnQxLmlzU2FtZShtb21lbnQyLCBcImRheVwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gIW1vbWVudDEgJiYgIW1vbWVudDI7XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICB2YXIgYmVmb3JlID0gc3RhcnREYXRlLmNsb25lKCkuc3RhcnRPZihcImRheVwiKS5zdWJ0cmFjdCgxLCBcInNlY29uZHNcIik7XG4gIHZhciBhZnRlciA9IGVuZERhdGUuY2xvbmUoKS5zdGFydE9mKFwiZGF5XCIpLmFkZCgxLCBcInNlY29uZHNcIik7XG4gIHJldHVybiBkYXkuY2xvbmUoKS5zdGFydE9mKFwiZGF5XCIpLmlzQmV0d2VlbihiZWZvcmUsIGFmdGVyKTtcbn1cblxuLy8gKioqIERpZmZpbmcgKioqXG5cblxuXG4vLyAqKiBEYXRlIExvY2FsaXphdGlvbiAqKlxuXG5mdW5jdGlvbiBsb2NhbGl6ZURhdGUoZGF0ZSwgbG9jYWxlKSB7XG4gIHJldHVybiBkYXRlLmNsb25lKCkubG9jYWxlKGxvY2FsZSB8fCBtb21lbnQubG9jYWxlKCkpO1xufVxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBnZXRMb2NhbGVEYXRhKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUubG9jYWxlRGF0YSgpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhbGVEYXRhRm9yTG9jYWxlKGxvY2FsZSkge1xuICByZXR1cm4gbW9tZW50LmxvY2FsZURhdGEobG9jYWxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkV2Vla2RheUluTG9jYWxlKGxvY2FsZSwgZGF0ZSwgZm9ybWF0RnVuYykge1xuICByZXR1cm4gZm9ybWF0RnVuYyhsb2NhbGUud2Vla2RheXMoZGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrZGF5TWluSW5Mb2NhbGUobG9jYWxlLCBkYXRlKSB7XG4gIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW4oZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtkYXlTaG9ydEluTG9jYWxlKGxvY2FsZSwgZGF0ZSkge1xuICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnQoZGF0ZSk7XG59XG5cbi8vIFRPRE8gd2hhdCBpcyB0aGlzIGZvcm1hdCBleGFjdGx5P1xuZnVuY3Rpb24gZ2V0TW9udGhJbkxvY2FsZShsb2NhbGUsIGRhdGUsIGZvcm1hdCkge1xuICByZXR1cm4gbG9jYWxlLm1vbnRocyhkYXRlLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBnZXRNb250aFNob3J0SW5Mb2NhbGUobG9jYWxlLCBkYXRlKSB7XG4gIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnQoZGF0ZSk7XG59XG5cbi8vICoqIFV0aWxzIGZvciBzb21lIGNvbXBvbmVudHMgKipcblxuZnVuY3Rpb24gaXNEYXlEaXNhYmxlZChkYXkpIHtcbiAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIG1pbkRhdGUgPSBfcmVmNC5taW5EYXRlLFxuICAgICAgbWF4RGF0ZSA9IF9yZWY0Lm1heERhdGUsXG4gICAgICBleGNsdWRlRGF0ZXMgPSBfcmVmNC5leGNsdWRlRGF0ZXMsXG4gICAgICBpbmNsdWRlRGF0ZXMgPSBfcmVmNC5pbmNsdWRlRGF0ZXMsXG4gICAgICBmaWx0ZXJEYXRlID0gX3JlZjQuZmlsdGVyRGF0ZTtcblxuICByZXR1cm4gbWluRGF0ZSAmJiBkYXkuaXNCZWZvcmUobWluRGF0ZSwgXCJkYXlcIikgfHwgbWF4RGF0ZSAmJiBkYXkuaXNBZnRlcihtYXhEYXRlLCBcImRheVwiKSB8fCBleGNsdWRlRGF0ZXMgJiYgZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVEYXRlKSB7XG4gICAgcmV0dXJuIGlzU2FtZURheShkYXksIGV4Y2x1ZGVEYXRlKTtcbiAgfSkgfHwgaW5jbHVkZURhdGVzICYmICFpbmNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgaW5jbHVkZURhdGUpO1xuICB9KSB8fCBmaWx0ZXJEYXRlICYmICFmaWx0ZXJEYXRlKGRheS5jbG9uZSgpKSB8fCBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUaW1lRGlzYWJsZWQodGltZSwgZGlzYWJsZWRUaW1lcykge1xuICB2YXIgbCA9IGRpc2FibGVkVGltZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChkaXNhYmxlZFRpbWVzW2ldLmdldChcImhvdXJzXCIpID09PSB0aW1lLmdldChcImhvdXJzXCIpICYmIGRpc2FibGVkVGltZXNbaV0uZ2V0KFwibWludXRlc1wiKSA9PT0gdGltZS5nZXQoXCJtaW51dGVzXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGltZUluRGlzYWJsZWRSYW5nZSh0aW1lLCBfcmVmNSkge1xuICB2YXIgbWluVGltZSA9IF9yZWY1Lm1pblRpbWUsXG4gICAgICBtYXhUaW1lID0gX3JlZjUubWF4VGltZTtcblxuICBpZiAoIW1pblRpbWUgfHwgIW1heFRpbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIG1pblRpbWUgYW5kIG1heFRpbWUgcHJvcHMgcmVxdWlyZWRcIik7XG4gIH1cblxuICB2YXIgYmFzZSA9IG1vbWVudCgpLmhvdXJzKDApLm1pbnV0ZXMoMCkuc2Vjb25kcygwKTtcbiAgdmFyIGJhc2VUaW1lID0gYmFzZS5jbG9uZSgpLmhvdXJzKHRpbWUuZ2V0KFwiaG91cnNcIikpLm1pbnV0ZXModGltZS5nZXQoXCJtaW51dGVzXCIpKTtcbiAgdmFyIG1pbiA9IGJhc2UuY2xvbmUoKS5ob3VycyhtaW5UaW1lLmdldChcImhvdXJzXCIpKS5taW51dGVzKG1pblRpbWUuZ2V0KFwibWludXRlc1wiKSk7XG4gIHZhciBtYXggPSBiYXNlLmNsb25lKCkuaG91cnMobWF4VGltZS5nZXQoXCJob3Vyc1wiKSkubWludXRlcyhtYXhUaW1lLmdldChcIm1pbnV0ZXNcIikpO1xuXG4gIHJldHVybiAhKGJhc2VUaW1lLmlzU2FtZU9yQWZ0ZXIobWluKSAmJiBiYXNlVGltZS5pc1NhbWVPckJlZm9yZShtYXgpKTtcbn1cblxuZnVuY3Rpb24gYWxsRGF5c0Rpc2FibGVkQmVmb3JlKGRheSwgdW5pdCkge1xuICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgbWluRGF0ZSA9IF9yZWY2Lm1pbkRhdGUsXG4gICAgICBpbmNsdWRlRGF0ZXMgPSBfcmVmNi5pbmNsdWRlRGF0ZXM7XG5cbiAgdmFyIGRhdGVCZWZvcmUgPSBkYXkuY2xvbmUoKS5zdWJ0cmFjdCgxLCB1bml0KTtcbiAgcmV0dXJuIG1pbkRhdGUgJiYgZGF0ZUJlZm9yZS5pc0JlZm9yZShtaW5EYXRlLCB1bml0KSB8fCBpbmNsdWRlRGF0ZXMgJiYgaW5jbHVkZURhdGVzLmV2ZXJ5KGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkge1xuICAgIHJldHVybiBkYXRlQmVmb3JlLmlzQmVmb3JlKGluY2x1ZGVEYXRlLCB1bml0KTtcbiAgfSkgfHwgZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFsbERheXNEaXNhYmxlZEFmdGVyKGRheSwgdW5pdCkge1xuICB2YXIgX3JlZjcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgbWF4RGF0ZSA9IF9yZWY3Lm1heERhdGUsXG4gICAgICBpbmNsdWRlRGF0ZXMgPSBfcmVmNy5pbmNsdWRlRGF0ZXM7XG5cbiAgdmFyIGRhdGVBZnRlciA9IGRheS5jbG9uZSgpLmFkZCgxLCB1bml0KTtcbiAgcmV0dXJuIG1heERhdGUgJiYgZGF0ZUFmdGVyLmlzQWZ0ZXIobWF4RGF0ZSwgdW5pdCkgfHwgaW5jbHVkZURhdGVzICYmIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICByZXR1cm4gZGF0ZUFmdGVyLmlzQWZ0ZXIoaW5jbHVkZURhdGUsIHVuaXQpO1xuICB9KSB8fCBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlTWluRGF0ZShfcmVmOCkge1xuICB2YXIgbWluRGF0ZSA9IF9yZWY4Lm1pbkRhdGUsXG4gICAgICBpbmNsdWRlRGF0ZXMgPSBfcmVmOC5pbmNsdWRlRGF0ZXM7XG5cbiAgaWYgKGluY2x1ZGVEYXRlcyAmJiBtaW5EYXRlKSB7XG4gICAgcmV0dXJuIG1vbWVudC5taW4oaW5jbHVkZURhdGVzLmZpbHRlcihmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICAgIHJldHVybiBtaW5EYXRlLmlzU2FtZU9yQmVmb3JlKGluY2x1ZGVEYXRlLCBcImRheVwiKTtcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZURhdGVzKSB7XG4gICAgcmV0dXJuIG1vbWVudC5taW4oaW5jbHVkZURhdGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWluRGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVNYXhEYXRlKF9yZWY5KSB7XG4gIHZhciBtYXhEYXRlID0gX3JlZjkubWF4RGF0ZSxcbiAgICAgIGluY2x1ZGVEYXRlcyA9IF9yZWY5LmluY2x1ZGVEYXRlcztcblxuICBpZiAoaW5jbHVkZURhdGVzICYmIG1heERhdGUpIHtcbiAgICByZXR1cm4gbW9tZW50Lm1heChpbmNsdWRlRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkge1xuICAgICAgcmV0dXJuIG1heERhdGUuaXNTYW1lT3JBZnRlcihpbmNsdWRlRGF0ZSwgXCJkYXlcIik7XG4gICAgfSkpO1xuICB9IGVsc2UgaWYgKGluY2x1ZGVEYXRlcykge1xuICAgIHJldHVybiBtb21lbnQubWF4KGluY2x1ZGVEYXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1heERhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SGlnaHRMaWdodERheXNNYXAoKSB7XG4gIHZhciBoaWdobGlnaHREYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBkZWZhdWx0Q2xhc3NOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taGlnaGxpZ2h0ZWRcIjtcblxuICB2YXIgZGF0ZUNsYXNzZXMgPSBuZXcgTWFwKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoaWdobGlnaHREYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBvYmogPSBoaWdobGlnaHREYXRlc1tpXTtcbiAgICBpZiAoaXNNb21lbnQob2JqKSkge1xuICAgICAgdmFyIGtleSA9IG9iai5mb3JtYXQoXCJNTS5ERC5ZWVlZXCIpO1xuICAgICAgdmFyIGNsYXNzTmFtZXNBcnIgPSBkYXRlQ2xhc3Nlcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgIGlmICghY2xhc3NOYW1lc0Fyci5pbmNsdWRlcyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICBjbGFzc05hbWVzQXJyLnB1c2goZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgICAgIGRhdGVDbGFzc2VzLnNldChrZXksIGNsYXNzTmFtZXNBcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IGtleXNbMF07XG4gICAgICB2YXIgYXJyT2ZNb21lbnRzID0gb2JqW2tleXNbMF1dO1xuICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgYXJyT2ZNb21lbnRzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBrID0gMCwgX2xlbiA9IGFyck9mTW9tZW50cy5sZW5ndGg7IGsgPCBfbGVuOyBrKyspIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGFyck9mTW9tZW50c1trXS5mb3JtYXQoXCJNTS5ERC5ZWVlZXCIpO1xuICAgICAgICAgIHZhciBfY2xhc3NOYW1lc0FyciA9IGRhdGVDbGFzc2VzLmdldChfa2V5KSB8fCBbXTtcbiAgICAgICAgICBpZiAoIV9jbGFzc05hbWVzQXJyLmluY2x1ZGVzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIF9jbGFzc05hbWVzQXJyLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGRhdGVDbGFzc2VzLnNldChfa2V5LCBfY2xhc3NOYW1lc0Fycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVDbGFzc2VzO1xufVxuXG5mdW5jdGlvbiB0aW1lc1RvSW5qZWN0QWZ0ZXIoc3RhcnRPZkRheSwgY3VycmVudFRpbWUsIGN1cnJlbnRNdWx0aXBsaWVyLCBpbnRlcnZhbHMsIGluamVjdGVkVGltZXMpIHtcbiAgdmFyIGwgPSBpbmplY3RlZFRpbWVzLmxlbmd0aDtcbiAgdmFyIHRpbWVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGluamVjdGVkVGltZSA9IGFkZE1pbnV0ZXMoYWRkSG91cnMoY2xvbmVEYXRlKHN0YXJ0T2ZEYXkpLCBnZXRIb3VyKGluamVjdGVkVGltZXNbaV0pKSwgZ2V0TWludXRlKGluamVjdGVkVGltZXNbaV0pKTtcbiAgICB2YXIgbmV4dFRpbWUgPSBhZGRNaW51dGVzKGNsb25lRGF0ZShzdGFydE9mRGF5KSwgKGN1cnJlbnRNdWx0aXBsaWVyICsgMSkgKiBpbnRlcnZhbHMpO1xuXG4gICAgaWYgKGluamVjdGVkVGltZS5pc0JldHdlZW4oY3VycmVudFRpbWUsIG5leHRUaW1lKSkge1xuICAgICAgdGltZXMucHVzaChpbmplY3RlZFRpbWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGltZXM7XG59XG5cbnZhciBXcmFwcGVkWWVhckRyb3Bkb3duT3B0aW9ucyA9IG9uQ2xpY2tPdXRzaWRlKFllYXJEcm9wZG93bk9wdGlvbnMpO1xuXG52YXIgWWVhckRyb3Bkb3duID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoWWVhckRyb3Bkb3duLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBZZWFyRHJvcGRvd24oKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFllYXJEcm9wZG93bik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRyb3Bkb3duVmlzaWJsZTogZmFsc2VcbiAgICB9LCBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1pblllYXIgPSBfdGhpcy5wcm9wcy5taW5EYXRlID8gZ2V0WWVhcihfdGhpcy5wcm9wcy5taW5EYXRlKSA6IDE5MDA7XG4gICAgICB2YXIgbWF4WWVhciA9IF90aGlzLnByb3BzLm1heERhdGUgPyBnZXRZZWFyKF90aGlzLnByb3BzLm1heERhdGUpIDogMjEwMDtcblxuICAgICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSBtaW5ZZWFyOyBpIDw9IG1heFllYXI7IGkrKykge1xuICAgICAgICBvcHRpb25zLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBcIm9wdGlvblwiLFxuICAgICAgICAgIHsga2V5OiBpLCB2YWx1ZTogaSB9LFxuICAgICAgICAgIGlcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LCBfdGhpcy5vblNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5vbkNoYW5nZShlLnRhcmdldC52YWx1ZSk7XG4gICAgfSwgX3RoaXMucmVuZGVyU2VsZWN0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IF90aGlzLnByb3BzLnllYXIsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItc2VsZWN0XCIsXG4gICAgICAgICAgb25DaGFuZ2U6IF90aGlzLm9uU2VsZWN0Q2hhbmdlXG4gICAgICAgIH0sXG4gICAgICAgIF90aGlzLnJlbmRlclNlbGVjdE9wdGlvbnMoKVxuICAgICAgKTtcbiAgICB9LCBfdGhpcy5yZW5kZXJSZWFkVmlldyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGtleTogXCJyZWFkXCIsXG4gICAgICAgICAgc3R5bGU6IHsgdmlzaWJpbGl0eTogdmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIiB9LFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXJlYWQtdmlld1wiLFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2dnbGVEcm9wZG93bihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXJlYWQtdmlldy0tZG93bi1hcnJvd1wiIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItcmVhZC12aWV3LS1zZWxlY3RlZC15ZWFyXCIgfSxcbiAgICAgICAgICBfdGhpcy5wcm9wcy55ZWFyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgX3RoaXMucmVuZGVyRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkWWVhckRyb3Bkb3duT3B0aW9ucywge1xuICAgICAgICBrZXk6IFwiZHJvcGRvd25cIixcbiAgICAgICAgcmVmOiBcIm9wdGlvbnNcIixcbiAgICAgICAgeWVhcjogX3RoaXMucHJvcHMueWVhcixcbiAgICAgICAgb25DaGFuZ2U6IF90aGlzLm9uQ2hhbmdlLFxuICAgICAgICBvbkNhbmNlbDogX3RoaXMudG9nZ2xlRHJvcGRvd24sXG4gICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgIHNjcm9sbGFibGVZZWFyRHJvcGRvd246IF90aGlzLnByb3BzLnNjcm9sbGFibGVZZWFyRHJvcGRvd24sXG4gICAgICAgIHllYXJEcm9wZG93bkl0ZW1OdW1iZXI6IF90aGlzLnByb3BzLnllYXJEcm9wZG93bkl0ZW1OdW1iZXJcbiAgICAgIH0pO1xuICAgIH0sIF90aGlzLnJlbmRlclNjcm9sbE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHJvcGRvd25WaXNpYmxlID0gX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gW190aGlzLnJlbmRlclJlYWRWaWV3KCFkcm9wZG93blZpc2libGUpXTtcbiAgICAgIGlmIChkcm9wZG93blZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoX3RoaXMucmVuZGVyRHJvcGRvd24oKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICBpZiAoeWVhciA9PT0gX3RoaXMucHJvcHMueWVhcikgcmV0dXJuO1xuICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoeWVhcik7XG4gICAgfSwgX3RoaXMudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJvcGRvd25WaXNpYmxlOiAhX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKF90aGlzLnByb3BzLmRhdGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgX3RoaXMuaGFuZGxlWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlLCBldmVudCkge1xuICAgICAgX3RoaXMub25TZWxlY3QoZGF0ZSwgZXZlbnQpO1xuICAgICAgX3RoaXMuc2V0T3BlbigpO1xuICAgIH0sIF90aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKGRhdGUsIGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25TZWxlY3QpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25TZWxlY3QoZGF0ZSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIF90aGlzLnNldE9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuc2V0T3Blbikge1xuICAgICAgICBfdGhpcy5wcm9wcy5zZXRPcGVuKHRydWUpO1xuICAgICAgfVxuICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBZZWFyRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcmVuZGVyZWREcm9wZG93biA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSB7XG4gICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNjcm9sbE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNlbGVjdE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93bi1jb250YWluZXIgcmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93bi1jb250YWluZXItLVwiICsgdGhpcy5wcm9wcy5kcm9wZG93bk1vZGVcbiAgICAgIH0sXG4gICAgICByZW5kZXJlZERyb3Bkb3duXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gWWVhckRyb3Bkb3duO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5ZZWFyRHJvcGRvd24ucHJvcFR5cGVzID0ge1xuICBhZGp1c3REYXRlT25DaGFuZ2U6IFByb3BUeXBlcy5ib29sLFxuICBkcm9wZG93bk1vZGU6IFByb3BUeXBlcy5vbmVPZihbXCJzY3JvbGxcIiwgXCJzZWxlY3RcIl0pLmlzUmVxdWlyZWQsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzY3JvbGxhYmxlWWVhckRyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgeWVhcjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB5ZWFyRHJvcGRvd25JdGVtTnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICBkYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHNldE9wZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgTW9udGhEcm9wZG93bk9wdGlvbnMgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb250aERyb3Bkb3duT3B0aW9ucywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9udGhEcm9wZG93bk9wdGlvbnMoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vbnRoRHJvcGRvd25PcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnJlbmRlck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMubW9udGhOYW1lcy5tYXAoZnVuY3Rpb24gKG1vbnRoLCBpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBfdGhpcy5wcm9wcy5tb250aCA9PT0gaSA/IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtb3B0aW9uIC0tc2VsZWN0ZWRfbW9udGhcIiA6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtb3B0aW9uXCIsXG4gICAgICAgICAgICBrZXk6IG1vbnRoLFxuICAgICAgICAgICAgcmVmOiBtb250aCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IF90aGlzLm9uQ2hhbmdlLmJpbmQoX3RoaXMsIGkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdGhpcy5wcm9wcy5tb250aCA9PT0gaSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLW9wdGlvbi0tc2VsZWN0ZWRcIiB9LFxuICAgICAgICAgICAgXCJcXHUyNzEzXCJcbiAgICAgICAgICApIDogXCJcIixcbiAgICAgICAgICBtb250aFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSwgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aCk7XG4gICAgfSwgX3RoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uQ2FuY2VsKCk7XG4gICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIE1vbnRoRHJvcGRvd25PcHRpb25zLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtZHJvcGRvd25cIiB9LFxuICAgICAgdGhpcy5yZW5kZXJPcHRpb25zKClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBNb250aERyb3Bkb3duT3B0aW9ucztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGhEcm9wZG93bk9wdGlvbnMucHJvcFR5cGVzID0ge1xuICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG1vbnRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG1vbnRoTmFtZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCkuaXNSZXF1aXJlZFxufTtcblxudmFyIFdyYXBwZWRNb250aERyb3Bkb3duT3B0aW9ucyA9IG9uQ2xpY2tPdXRzaWRlKE1vbnRoRHJvcGRvd25PcHRpb25zKTtcblxudmFyIE1vbnRoRHJvcGRvd24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb250aERyb3Bkb3duLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNb250aERyb3Bkb3duKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb250aERyb3Bkb3duKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgZHJvcGRvd25WaXNpYmxlOiBmYWxzZVxuICAgIH0sIF90aGlzLnJlbmRlclNlbGVjdE9wdGlvbnMgPSBmdW5jdGlvbiAobW9udGhOYW1lcykge1xuICAgICAgcmV0dXJuIG1vbnRoTmFtZXMubWFwKGZ1bmN0aW9uIChNLCBpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwib3B0aW9uXCIsXG4gICAgICAgICAgeyBrZXk6IGksIHZhbHVlOiBpIH0sXG4gICAgICAgICAgTVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSwgX3RoaXMucmVuZGVyU2VsZWN0TW9kZSA9IGZ1bmN0aW9uIChtb250aE5hbWVzKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIHZhbHVlOiBfdGhpcy5wcm9wcy5tb250aCxcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtc2VsZWN0XCIsXG4gICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vbkNoYW5nZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zKG1vbnRoTmFtZXMpXG4gICAgICApO1xuICAgIH0sIF90aGlzLnJlbmRlclJlYWRWaWV3ID0gZnVuY3Rpb24gKHZpc2libGUsIG1vbnRoTmFtZXMpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAga2V5OiBcInJlYWRcIixcbiAgICAgICAgICBzdHlsZTogeyB2aXNpYmlsaXR5OiB2aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiIH0sXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXJlYWQtdmlld1wiLFxuICAgICAgICAgIG9uQ2xpY2s6IF90aGlzLnRvZ2dsZURyb3Bkb3duXG4gICAgICAgIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXJlYWQtdmlldy0tZG93bi1hcnJvd1wiIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXJlYWQtdmlldy0tc2VsZWN0ZWQtbW9udGhcIiB9LFxuICAgICAgICAgIG1vbnRoTmFtZXNbX3RoaXMucHJvcHMubW9udGhdXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgX3RoaXMucmVuZGVyRHJvcGRvd24gPSBmdW5jdGlvbiAobW9udGhOYW1lcykge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZE1vbnRoRHJvcGRvd25PcHRpb25zLCB7XG4gICAgICAgIGtleTogXCJkcm9wZG93blwiLFxuICAgICAgICByZWY6IFwib3B0aW9uc1wiLFxuICAgICAgICBtb250aDogX3RoaXMucHJvcHMubW9udGgsXG4gICAgICAgIG1vbnRoTmFtZXM6IG1vbnRoTmFtZXMsXG4gICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgb25DYW5jZWw6IF90aGlzLnRvZ2dsZURyb3Bkb3duXG4gICAgICB9KTtcbiAgICB9LCBfdGhpcy5yZW5kZXJTY3JvbGxNb2RlID0gZnVuY3Rpb24gKG1vbnRoTmFtZXMpIHtcbiAgICAgIHZhciBkcm9wZG93blZpc2libGUgPSBfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGU7XG5cbiAgICAgIHZhciByZXN1bHQgPSBbX3RoaXMucmVuZGVyUmVhZFZpZXcoIWRyb3Bkb3duVmlzaWJsZSwgbW9udGhOYW1lcyldO1xuICAgICAgaWYgKGRyb3Bkb3duVmlzaWJsZSkge1xuICAgICAgICByZXN1bHQudW5zaGlmdChfdGhpcy5yZW5kZXJEcm9wZG93bihtb250aE5hbWVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICBfdGhpcy50b2dnbGVEcm9wZG93bigpO1xuICAgICAgaWYgKG1vbnRoICE9PSBfdGhpcy5wcm9wcy5tb250aCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aCk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcm9wZG93blZpc2libGU6ICFfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGVcbiAgICAgIH0pO1xuICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBNb250aERyb3Bkb3duLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbG9jYWxlRGF0YSA9IGdldExvY2FsZURhdGFGb3JMb2NhbGUodGhpcy5wcm9wcy5sb2NhbGUpO1xuICAgIHZhciBtb250aE5hbWVzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV0ubWFwKHRoaXMucHJvcHMudXNlU2hvcnRNb250aEluRHJvcGRvd24gPyBmdW5jdGlvbiAoTSkge1xuICAgICAgcmV0dXJuIGdldE1vbnRoU2hvcnRJbkxvY2FsZShsb2NhbGVEYXRhLCBuZXdEYXRlKHsgTTogTSB9KSk7XG4gICAgfSA6IGZ1bmN0aW9uIChNKSB7XG4gICAgICByZXR1cm4gZ2V0TW9udGhJbkxvY2FsZShsb2NhbGVEYXRhLCBuZXdEYXRlKHsgTTogTSB9KSwgX3RoaXMyLnByb3BzLmRhdGVGb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlbmRlcmVkRHJvcGRvd24gPSB2b2lkIDA7XG4gICAgc3dpdGNoICh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkge1xuICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICByZW5kZXJlZERyb3Bkb3duID0gdGhpcy5yZW5kZXJTY3JvbGxNb2RlKG1vbnRoTmFtZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgcmVuZGVyZWREcm9wZG93biA9IHRoaXMucmVuZGVyU2VsZWN0TW9kZShtb250aE5hbWVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtZHJvcGRvd24tY29udGFpbmVyIHJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWRyb3Bkb3duLWNvbnRhaW5lci0tXCIgKyB0aGlzLnByb3BzLmRyb3Bkb3duTW9kZVxuICAgICAgfSxcbiAgICAgIHJlbmRlcmVkRHJvcGRvd25cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBNb250aERyb3Bkb3duO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Nb250aERyb3Bkb3duLnByb3BUeXBlcyA9IHtcbiAgZHJvcGRvd25Nb2RlOiBQcm9wVHlwZXMub25lT2YoW1wic2Nyb2xsXCIsIFwic2VsZWN0XCJdKS5pc1JlcXVpcmVkLFxuICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRhdGVGb3JtYXQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgbW9udGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHVzZVNob3J0TW9udGhJbkRyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVNb250aFllYXJzKG1pbkRhdGUsIG1heERhdGUpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICB2YXIgY3VyckRhdGUgPSBnZXRTdGFydE9mTW9udGgoY2xvbmVEYXRlKG1pbkRhdGUpKTtcbiAgdmFyIGxhc3REYXRlID0gZ2V0U3RhcnRPZk1vbnRoKGNsb25lRGF0ZShtYXhEYXRlKSk7XG5cbiAgd2hpbGUgKCFpc0FmdGVyKGN1cnJEYXRlLCBsYXN0RGF0ZSkpIHtcbiAgICBsaXN0LnB1c2goY2xvbmVEYXRlKGN1cnJEYXRlKSk7XG5cbiAgICBhZGRNb250aHMoY3VyckRhdGUsIDEpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbnZhciBNb250aFllYXJEcm9wZG93bk9wdGlvbnMgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb250aFllYXJEcm9wZG93bk9wdGlvbnMsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucyhwcm9wcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMucmVuZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zdGF0ZS5tb250aFllYXJzTGlzdC5tYXAoZnVuY3Rpb24gKG1vbnRoWWVhcikge1xuICAgICAgICB2YXIgbW9udGhZZWFyUG9pbnQgPSBtb250aFllYXIudmFsdWVPZigpO1xuXG4gICAgICAgIHZhciBpc1NhbWVNb250aFllYXIgPSBpc1NhbWVZZWFyKF90aGlzLnByb3BzLmRhdGUsIG1vbnRoWWVhcikgJiYgaXNTYW1lTW9udGgoX3RoaXMucHJvcHMuZGF0ZSwgbW9udGhZZWFyKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogaXNTYW1lTW9udGhZZWFyID8gXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLW9wdGlvbiAtLXNlbGVjdGVkX21vbnRoLXllYXJcIiA6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1vcHRpb25cIixcbiAgICAgICAgICAgIGtleTogbW9udGhZZWFyUG9pbnQsXG4gICAgICAgICAgICByZWY6IG1vbnRoWWVhclBvaW50LFxuICAgICAgICAgICAgb25DbGljazogX3RoaXMub25DaGFuZ2UuYmluZChfdGhpcywgbW9udGhZZWFyUG9pbnQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1NhbWVNb250aFllYXIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLW9wdGlvbi0tc2VsZWN0ZWRcIiB9LFxuICAgICAgICAgICAgXCJcXHUyNzEzXCJcbiAgICAgICAgICApIDogXCJcIixcbiAgICAgICAgICBmb3JtYXREYXRlKG1vbnRoWWVhciwgX3RoaXMucHJvcHMuZGF0ZUZvcm1hdClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aFllYXIpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aFllYXIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1vbnRoWWVhcnNMaXN0OiBnZW5lcmF0ZU1vbnRoWWVhcnMoX3RoaXMucHJvcHMubWluRGF0ZSwgX3RoaXMucHJvcHMubWF4RGF0ZSlcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1vbnRoWWVhckRyb3Bkb3duT3B0aW9ucy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBkcm9wZG93bkNsYXNzID0gY2xhc3NuYW1lcyh7XG4gICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItZHJvcGRvd25cIjogdHJ1ZSxcbiAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1kcm9wZG93bi0tc2Nyb2xsYWJsZVwiOiB0aGlzLnByb3BzLnNjcm9sbGFibGVNb250aFllYXJEcm9wZG93blxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBjbGFzc05hbWU6IGRyb3Bkb3duQ2xhc3MgfSxcbiAgICAgIHRoaXMucmVuZGVyT3B0aW9ucygpXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTW9udGhZZWFyRHJvcGRvd25PcHRpb25zO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Nb250aFllYXJEcm9wZG93bk9wdGlvbnMucHJvcFR5cGVzID0ge1xuICBtaW5EYXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb25DYW5jZWw6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzY3JvbGxhYmxlTW9udGhZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBkYXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGRhdGVGb3JtYXQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxufTtcblxudmFyIFdyYXBwZWRNb250aFllYXJEcm9wZG93bk9wdGlvbnMgPSBvbkNsaWNrT3V0c2lkZShNb250aFllYXJEcm9wZG93bk9wdGlvbnMpO1xuXG52YXIgTW9udGhZZWFyRHJvcGRvd24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb250aFllYXJEcm9wZG93biwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9udGhZZWFyRHJvcGRvd24oKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vbnRoWWVhckRyb3Bkb3duKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgZHJvcGRvd25WaXNpYmxlOiBmYWxzZVxuICAgIH0sIF90aGlzLnJlbmRlclNlbGVjdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VyckRhdGUgPSBnZXRTdGFydE9mTW9udGgobG9jYWxpemVEYXRlKF90aGlzLnByb3BzLm1pbkRhdGUsIF90aGlzLnByb3BzLmxvY2FsZSkpO1xuICAgICAgdmFyIGxhc3REYXRlID0gZ2V0U3RhcnRPZk1vbnRoKGxvY2FsaXplRGF0ZShfdGhpcy5wcm9wcy5tYXhEYXRlLCBfdGhpcy5wcm9wcy5sb2NhbGUpKTtcblxuICAgICAgdmFyIG9wdGlvbnMgPSBbXTtcblxuICAgICAgd2hpbGUgKCFpc0FmdGVyKGN1cnJEYXRlLCBsYXN0RGF0ZSkpIHtcbiAgICAgICAgdmFyIHRpbWVwb2ludCA9IGN1cnJEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgb3B0aW9ucy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJvcHRpb25cIixcbiAgICAgICAgICB7IGtleTogdGltZXBvaW50LCB2YWx1ZTogdGltZXBvaW50IH0sXG4gICAgICAgICAgZm9ybWF0RGF0ZShjdXJyRGF0ZSwgX3RoaXMucHJvcHMuZGF0ZUZvcm1hdClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgYWRkTW9udGhzKGN1cnJEYXRlLCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSwgX3RoaXMub25TZWxlY3RDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMub25DaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xuICAgIH0sIF90aGlzLnJlbmRlclNlbGVjdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIHZhbHVlOiBnZXRTdGFydE9mTW9udGgoX3RoaXMucHJvcHMuZGF0ZSkudmFsdWVPZigpLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXNlbGVjdFwiLFxuICAgICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5vblNlbGVjdENoYW5nZVxuICAgICAgICB9LFxuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zKClcbiAgICAgICk7XG4gICAgfSwgX3RoaXMucmVuZGVyUmVhZFZpZXcgPSBmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgdmFyIHllYXJNb250aCA9IGZvcm1hdERhdGUobG9jYWxpemVEYXRlKG5ld0RhdGUoX3RoaXMucHJvcHMuZGF0ZSksIF90aGlzLnByb3BzLmxvY2FsZSksIF90aGlzLnByb3BzLmRhdGVGb3JtYXQpO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGtleTogXCJyZWFkXCIsXG4gICAgICAgICAgc3R5bGU6IHsgdmlzaWJpbGl0eTogdmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIiB9LFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXJlYWQtdmlld1wiLFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2dnbGVEcm9wZG93bihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXJlYWQtdmlldy0tZG93bi1hcnJvd1wiIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItcmVhZC12aWV3LS1zZWxlY3RlZC1tb250aC15ZWFyXCIgfSxcbiAgICAgICAgICB5ZWFyTW9udGhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LCBfdGhpcy5yZW5kZXJEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRNb250aFllYXJEcm9wZG93bk9wdGlvbnMsIHtcbiAgICAgICAga2V5OiBcImRyb3Bkb3duXCIsXG4gICAgICAgIHJlZjogXCJvcHRpb25zXCIsXG4gICAgICAgIGRhdGU6IF90aGlzLnByb3BzLmRhdGUsXG4gICAgICAgIGRhdGVGb3JtYXQ6IF90aGlzLnByb3BzLmRhdGVGb3JtYXQsXG4gICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgb25DYW5jZWw6IF90aGlzLnRvZ2dsZURyb3Bkb3duLFxuICAgICAgICBtaW5EYXRlOiBsb2NhbGl6ZURhdGUoX3RoaXMucHJvcHMubWluRGF0ZSwgX3RoaXMucHJvcHMubG9jYWxlKSxcbiAgICAgICAgbWF4RGF0ZTogbG9jYWxpemVEYXRlKF90aGlzLnByb3BzLm1heERhdGUsIF90aGlzLnByb3BzLmxvY2FsZSksXG4gICAgICAgIHNjcm9sbGFibGVNb250aFllYXJEcm9wZG93bjogX3RoaXMucHJvcHMuc2Nyb2xsYWJsZU1vbnRoWWVhckRyb3Bkb3duXG4gICAgICB9KTtcbiAgICB9LCBfdGhpcy5yZW5kZXJTY3JvbGxNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRyb3Bkb3duVmlzaWJsZSA9IF90aGlzLnN0YXRlLmRyb3Bkb3duVmlzaWJsZTtcblxuICAgICAgdmFyIHJlc3VsdCA9IFtfdGhpcy5yZW5kZXJSZWFkVmlldyghZHJvcGRvd25WaXNpYmxlKV07XG4gICAgICBpZiAoZHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KF90aGlzLnJlbmRlckRyb3Bkb3duKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aFllYXJQb2ludCkge1xuICAgICAgX3RoaXMudG9nZ2xlRHJvcGRvd24oKTtcblxuICAgICAgdmFyIGNoYW5nZWREYXRlID0gbmV3RGF0ZShwYXJzZUludChtb250aFllYXJQb2ludCkpO1xuXG4gICAgICBpZiAoaXNTYW1lWWVhcihfdGhpcy5wcm9wcy5kYXRlLCBjaGFuZ2VkRGF0ZSkgJiYgaXNTYW1lTW9udGgoX3RoaXMucHJvcHMuZGF0ZSwgY2hhbmdlZERhdGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlZERhdGUpO1xuICAgIH0sIF90aGlzLnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJvcGRvd25WaXNpYmxlOiAhX3RoaXMuc3RhdGUuZHJvcGRvd25WaXNpYmxlXG4gICAgICB9KTtcbiAgICB9LCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTW9udGhZZWFyRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcmVuZGVyZWREcm9wZG93biA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSB7XG4gICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNjcm9sbE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNlbGVjdE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1kcm9wZG93bi1jb250YWluZXIgcmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1kcm9wZG93bi1jb250YWluZXItLVwiICsgdGhpcy5wcm9wcy5kcm9wZG93bk1vZGVcbiAgICAgIH0sXG4gICAgICByZW5kZXJlZERyb3Bkb3duXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTW9udGhZZWFyRHJvcGRvd247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1vbnRoWWVhckRyb3Bkb3duLnByb3BUeXBlcyA9IHtcbiAgZHJvcGRvd25Nb2RlOiBQcm9wVHlwZXMub25lT2YoW1wic2Nyb2xsXCIsIFwic2VsZWN0XCJdKS5pc1JlcXVpcmVkLFxuICBkYXRlRm9ybWF0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGxvY2FsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWF4RGF0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBtaW5EYXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGRhdGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHNjcm9sbGFibGVNb250aFllYXJEcm9wZG93bjogUHJvcFR5cGVzLmJvb2xcbn07XG5cbnZhciBEYXkgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhEYXksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERheSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF5KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLmlzRGlzYWJsZWQoKSAmJiBfdGhpcy5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIF90aGlzLmhhbmRsZU1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMuaXNEaXNhYmxlZCgpICYmIF90aGlzLnByb3BzLm9uTW91c2VFbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbk1vdXNlRW50ZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIF90aGlzLmlzU2FtZURheSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgcmV0dXJuIGlzU2FtZURheShfdGhpcy5wcm9wcy5kYXksIG90aGVyKTtcbiAgICB9LCBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIV90aGlzLnByb3BzLmlubGluZSAmJiAhX3RoaXMuaXNTYW1lRGF5KF90aGlzLnByb3BzLnNlbGVjdGVkKSAmJiBfdGhpcy5pc1NhbWVEYXkoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKTtcbiAgICB9LCBfdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzRGF5RGlzYWJsZWQoX3RoaXMucHJvcHMuZGF5LCBfdGhpcy5wcm9wcyk7XG4gICAgfSwgX3RoaXMuZ2V0SGlnaExpZ2h0ZWRDbGFzcyA9IGZ1bmN0aW9uIChkZWZhdWx0Q2xhc3NOYW1lKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXkgPSBfdGhpcyRwcm9wcy5kYXksXG4gICAgICAgICAgaGlnaGxpZ2h0RGF0ZXMgPSBfdGhpcyRwcm9wcy5oaWdobGlnaHREYXRlcztcblxuXG4gICAgICBpZiAoIWhpZ2hsaWdodERhdGVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9va2luZyBmb3IgY2xhc3NOYW1lIGluIHRoZSBNYXAgb2YgeydkYXkgc3RyaW5nLCAnY2xhc3NOYW1lJ31cbiAgICAgIHZhciBkYXlTdHIgPSBkYXkuZm9ybWF0KFwiTU0uREQuWVlZWVwiKTtcbiAgICAgIHJldHVybiBoaWdobGlnaHREYXRlcy5nZXQoZGF5U3RyKTtcbiAgICB9LCBfdGhpcy5pc0luUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgZGF5ID0gX3RoaXMkcHJvcHMyLmRheSxcbiAgICAgICAgICBzdGFydERhdGUgPSBfdGhpcyRwcm9wczIuc3RhcnREYXRlLFxuICAgICAgICAgIGVuZERhdGUgPSBfdGhpcyRwcm9wczIuZW5kRGF0ZTtcblxuICAgICAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG4gICAgfSwgX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGRheSA9IF90aGlzJHByb3BzMy5kYXksXG4gICAgICAgICAgc2VsZWN0c1N0YXJ0ID0gX3RoaXMkcHJvcHMzLnNlbGVjdHNTdGFydCxcbiAgICAgICAgICBzZWxlY3RzRW5kID0gX3RoaXMkcHJvcHMzLnNlbGVjdHNFbmQsXG4gICAgICAgICAgc2VsZWN0aW5nRGF0ZSA9IF90aGlzJHByb3BzMy5zZWxlY3RpbmdEYXRlLFxuICAgICAgICAgIHN0YXJ0RGF0ZSA9IF90aGlzJHByb3BzMy5zdGFydERhdGUsXG4gICAgICAgICAgZW5kRGF0ZSA9IF90aGlzJHByb3BzMy5lbmREYXRlO1xuXG5cbiAgICAgIGlmICghKHNlbGVjdHNTdGFydCB8fCBzZWxlY3RzRW5kKSB8fCAhc2VsZWN0aW5nRGF0ZSB8fCBfdGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0c1N0YXJ0ICYmIGVuZERhdGUgJiYgc2VsZWN0aW5nRGF0ZS5pc1NhbWVPckJlZm9yZShlbmREYXRlKSkge1xuICAgICAgICByZXR1cm4gaXNEYXlJblJhbmdlKGRheSwgc2VsZWN0aW5nRGF0ZSwgZW5kRGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RzRW5kICYmIHN0YXJ0RGF0ZSAmJiBzZWxlY3RpbmdEYXRlLmlzU2FtZU9yQWZ0ZXIoc3RhcnREYXRlKSkge1xuICAgICAgICByZXR1cm4gaXNEYXlJblJhbmdlKGRheSwgc3RhcnREYXRlLCBzZWxlY3RpbmdEYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgZGF5ID0gX3RoaXMkcHJvcHM0LmRheSxcbiAgICAgICAgICBzZWxlY3RpbmdEYXRlID0gX3RoaXMkcHJvcHM0LnNlbGVjdGluZ0RhdGUsXG4gICAgICAgICAgc3RhcnREYXRlID0gX3RoaXMkcHJvcHM0LnN0YXJ0RGF0ZSxcbiAgICAgICAgICBzZWxlY3RzU3RhcnQgPSBfdGhpcyRwcm9wczQuc2VsZWN0c1N0YXJ0O1xuXG5cbiAgICAgIGlmIChzZWxlY3RzU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIHNlbGVjdGluZ0RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIHN0YXJ0RGF0ZSk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgZGF5ID0gX3RoaXMkcHJvcHM1LmRheSxcbiAgICAgICAgICBzZWxlY3RpbmdEYXRlID0gX3RoaXMkcHJvcHM1LnNlbGVjdGluZ0RhdGUsXG4gICAgICAgICAgZW5kRGF0ZSA9IF90aGlzJHByb3BzNS5lbmREYXRlLFxuICAgICAgICAgIHNlbGVjdHNFbmQgPSBfdGhpcyRwcm9wczUuc2VsZWN0c0VuZDtcblxuXG4gICAgICBpZiAoc2VsZWN0c0VuZCkge1xuICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgZW5kRGF0ZSk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuaXNSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGRheSA9IF90aGlzJHByb3BzNi5kYXksXG4gICAgICAgICAgc3RhcnREYXRlID0gX3RoaXMkcHJvcHM2LnN0YXJ0RGF0ZSxcbiAgICAgICAgICBlbmREYXRlID0gX3RoaXMkcHJvcHM2LmVuZERhdGU7XG5cbiAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NhbWVEYXkoc3RhcnREYXRlLCBkYXkpO1xuICAgIH0sIF90aGlzLmlzUmFuZ2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgZGF5ID0gX3RoaXMkcHJvcHM3LmRheSxcbiAgICAgICAgICBzdGFydERhdGUgPSBfdGhpcyRwcm9wczcuc3RhcnREYXRlLFxuICAgICAgICAgIGVuZERhdGUgPSBfdGhpcyRwcm9wczcuZW5kRGF0ZTtcblxuICAgICAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU2FtZURheShlbmREYXRlLCBkYXkpO1xuICAgIH0sIF90aGlzLmlzV2Vla2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3ZWVrZGF5ID0gZ2V0RGF5KF90aGlzLnByb3BzLmRheSk7XG4gICAgICByZXR1cm4gd2Vla2RheSA9PT0gMCB8fCB3ZWVrZGF5ID09PSA2O1xuICAgIH0sIF90aGlzLmlzT3V0c2lkZU1vbnRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm1vbnRoICE9PSB1bmRlZmluZWQgJiYgX3RoaXMucHJvcHMubW9udGggIT09IGdldE1vbnRoKF90aGlzLnByb3BzLmRheSk7XG4gICAgfSwgX3RoaXMuZ2V0Q2xhc3NOYW1lcyA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICB2YXIgZGF5Q2xhc3NOYW1lID0gX3RoaXMucHJvcHMuZGF5Q2xhc3NOYW1lID8gX3RoaXMucHJvcHMuZGF5Q2xhc3NOYW1lKGRhdGUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGNsYXNzbmFtZXMoXCJyZWFjdC1kYXRlcGlja2VyX19kYXlcIiwgZGF5Q2xhc3NOYW1lLCBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tXCIgKyBnZXREYXlPZldlZWtDb2RlKF90aGlzLnByb3BzLmRheSksIHtcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLWRpc2FibGVkXCI6IF90aGlzLmlzRGlzYWJsZWQoKSxcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXNlbGVjdGVkXCI6IF90aGlzLmlzU2FtZURheShfdGhpcy5wcm9wcy5zZWxlY3RlZCksXG4gICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1rZXlib2FyZC1zZWxlY3RlZFwiOiBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoKSxcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzUmFuZ2VTdGFydCgpLFxuICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tcmFuZ2UtZW5kXCI6IF90aGlzLmlzUmFuZ2VFbmQoKSxcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLWluLXJhbmdlXCI6IF90aGlzLmlzSW5SYW5nZSgpLFxuICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taW4tc2VsZWN0aW5nLXJhbmdlXCI6IF90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZSgpLFxuICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tc2VsZWN0aW5nLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VTdGFydCgpLFxuICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tc2VsZWN0aW5nLXJhbmdlLWVuZFwiOiBfdGhpcy5pc1NlbGVjdGluZ1JhbmdlRW5kKCksXG4gICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS10b2RheVwiOiBfdGhpcy5pc1NhbWVEYXkobm93KF90aGlzLnByb3BzLnV0Y09mZnNldCkpLFxuICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0td2Vla2VuZFwiOiBfdGhpcy5pc1dlZWtlbmQoKSxcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLW91dHNpZGUtbW9udGhcIjogX3RoaXMuaXNPdXRzaWRlTW9udGgoKVxuICAgICAgfSwgX3RoaXMuZ2V0SGlnaExpZ2h0ZWRDbGFzcyhcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taGlnaGxpZ2h0ZWRcIikpO1xuICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBEYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5nZXRDbGFzc05hbWVzKHRoaXMucHJvcHMuZGF5KSxcbiAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljayxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhhbmRsZU1vdXNlRW50ZXIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcImRheS1cIiArIGdldERhdGUodGhpcy5wcm9wcy5kYXkpLFxuICAgICAgICByb2xlOiBcIm9wdGlvblwiXG4gICAgICB9LFxuICAgICAgZ2V0RGF0ZSh0aGlzLnByb3BzLmRheSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEYXk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkRheS5wcm9wVHlwZXMgPSB7XG4gIGRheTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBkYXlDbGFzc05hbWU6IFByb3BUeXBlcy5mdW5jLFxuICBlbmREYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBoaWdobGlnaHREYXRlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWFwKSxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgbW9udGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBwcmVTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RpbmdEYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RzRW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2VsZWN0c1N0YXJ0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RhcnREYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB1dGNPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBXZWVrTnVtYmVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoV2Vla051bWJlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gV2Vla051bWJlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgV2Vla051bWJlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFdlZWtOdW1iZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgd2Vla051bWJlckNsYXNzZXMgPSB7XG4gICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyXCI6IHRydWUsXG4gICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyLS1jbGlja2FibGVcIjogISF0aGlzLnByb3BzLm9uQ2xpY2tcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHdlZWtOdW1iZXJDbGFzc2VzKSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwid2Vlay1cIiArIHRoaXMucHJvcHMud2Vla051bWJlcixcbiAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja1xuICAgICAgfSxcbiAgICAgIHRoaXMucHJvcHMud2Vla051bWJlclxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFdlZWtOdW1iZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbldlZWtOdW1iZXIucHJvcFR5cGVzID0ge1xuICB3ZWVrTnVtYmVyOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgV2VlayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFdlZWssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFdlZWsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFdlZWspO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5Q2xpY2spIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25EYXlDbGljayhkYXksIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkRheU1vdXNlRW50ZXIoZGF5KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5oYW5kbGVXZWVrQ2xpY2sgPSBmdW5jdGlvbiAoZGF5LCB3ZWVrTnVtYmVyLCBldmVudCkge1xuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5vbldlZWtTZWxlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbldlZWtTZWxlY3QoZGF5LCB3ZWVrTnVtYmVyLCBldmVudCk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuZm9ybWF0V2Vla051bWJlciA9IGZ1bmN0aW9uIChzdGFydE9mV2Vlaykge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmZvcm1hdFdlZWtOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmZvcm1hdFdlZWtOdW1iZXIoc3RhcnRPZldlZWspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFdlZWsoc3RhcnRPZldlZWspO1xuICAgIH0sIF90aGlzLnJlbmRlckRheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhcnRPZldlZWsgPSBnZXRTdGFydE9mV2VlayhjbG9uZURhdGUoX3RoaXMucHJvcHMuZGF5KSk7XG4gICAgICB2YXIgZGF5cyA9IFtdO1xuICAgICAgdmFyIHdlZWtOdW1iZXIgPSBfdGhpcy5mb3JtYXRXZWVrTnVtYmVyKHN0YXJ0T2ZXZWVrKTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlcikge1xuICAgICAgICB2YXIgb25DbGlja0FjdGlvbiA9IF90aGlzLnByb3BzLm9uV2Vla1NlbGVjdCA/IF90aGlzLmhhbmRsZVdlZWtDbGljay5iaW5kKF90aGlzLCBzdGFydE9mV2Vlaywgd2Vla051bWJlcikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGRheXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFdlZWtOdW1iZXIsIHsga2V5OiBcIldcIiwgd2Vla051bWJlcjogd2Vla051bWJlciwgb25DbGljazogb25DbGlja0FjdGlvbiB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF5cy5jb25jYXQoWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBkYXkgPSBhZGREYXlzKGNsb25lRGF0ZShzdGFydE9mV2VlayksIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERheSwge1xuICAgICAgICAgIGtleTogb2Zmc2V0LFxuICAgICAgICAgIGRheTogZGF5LFxuICAgICAgICAgIG1vbnRoOiBfdGhpcy5wcm9wcy5tb250aCxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpcy5oYW5kbGVEYXlDbGljay5iaW5kKF90aGlzLCBkYXkpLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlci5iaW5kKF90aGlzLCBkYXkpLFxuICAgICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICBpbmNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlcyxcbiAgICAgICAgICBpbmxpbmU6IF90aGlzLnByb3BzLmlubGluZSxcbiAgICAgICAgICBoaWdobGlnaHREYXRlczogX3RoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMsXG4gICAgICAgICAgc2VsZWN0aW5nRGF0ZTogX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSxcbiAgICAgICAgICBmaWx0ZXJEYXRlOiBfdGhpcy5wcm9wcy5maWx0ZXJEYXRlLFxuICAgICAgICAgIHByZVNlbGVjdGlvbjogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLFxuICAgICAgICAgIHNlbGVjdGVkOiBfdGhpcy5wcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgICBzZWxlY3RzU3RhcnQ6IF90aGlzLnByb3BzLnNlbGVjdHNTdGFydCxcbiAgICAgICAgICBzZWxlY3RzRW5kOiBfdGhpcy5wcm9wcy5zZWxlY3RzRW5kLFxuICAgICAgICAgIHN0YXJ0RGF0ZTogX3RoaXMucHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgIGVuZERhdGU6IF90aGlzLnByb3BzLmVuZERhdGUsXG4gICAgICAgICAgZGF5Q2xhc3NOYW1lOiBfdGhpcy5wcm9wcy5kYXlDbGFzc05hbWUsXG4gICAgICAgICAgdXRjT2Zmc2V0OiBfdGhpcy5wcm9wcy51dGNPZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFdlZWsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrXCIgfSxcbiAgICAgIHRoaXMucmVuZGVyRGF5cygpXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gV2Vlaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuV2Vlay5wcm9wVHlwZXMgPSB7XG4gIGRheTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBkYXlDbGFzc05hbWU6IFByb3BUeXBlcy5mdW5jLFxuICBlbmREYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBleGNsdWRlRGF0ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgZmlsdGVyRGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGZvcm1hdFdlZWtOdW1iZXI6IFByb3BUeXBlcy5mdW5jLFxuICBoaWdobGlnaHREYXRlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWFwKSxcbiAgaW5jbHVkZURhdGVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1vbnRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvbkRheUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25EYXlNb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25XZWVrU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcHJlU2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0aW5nRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0c0VuZDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbGVjdHNTdGFydDogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dXZWVrTnVtYmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RhcnREYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB1dGNPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBGSVhFRF9IRUlHSFRfU1RBTkRBUkRfV0VFS19DT1VOVCA9IDY7XG5cbnZhciBNb250aCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vbnRoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNb250aCgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9udGgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5Q2xpY2spIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25EYXlDbGljayhkYXksIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkRheU1vdXNlRW50ZXIoZGF5KTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5oYW5kbGVNb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uTW91c2VMZWF2ZSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5pc1dlZWtJbk1vbnRoID0gZnVuY3Rpb24gKHN0YXJ0T2ZXZWVrKSB7XG4gICAgICB2YXIgZGF5ID0gX3RoaXMucHJvcHMuZGF5O1xuICAgICAgdmFyIGVuZE9mV2VlayA9IGFkZERheXMoY2xvbmVEYXRlKHN0YXJ0T2ZXZWVrKSwgNik7XG4gICAgICByZXR1cm4gaXNTYW1lTW9udGgoc3RhcnRPZldlZWssIGRheSkgfHwgaXNTYW1lTW9udGgoZW5kT2ZXZWVrLCBkYXkpO1xuICAgIH0sIF90aGlzLnJlbmRlcldlZWtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdlZWtzID0gW107XG4gICAgICB2YXIgaXNGaXhlZEhlaWdodCA9IF90aGlzLnByb3BzLmZpeGVkSGVpZ2h0O1xuICAgICAgdmFyIGN1cnJlbnRXZWVrU3RhcnQgPSBnZXRTdGFydE9mV2VlayhnZXRTdGFydE9mTW9udGgoY2xvbmVEYXRlKF90aGlzLnByb3BzLmRheSkpKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBicmVha0FmdGVyTmV4dFB1c2ggPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgd2Vla3MucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFdlZWssIHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgZGF5OiBjdXJyZW50V2Vla1N0YXJ0LFxuICAgICAgICAgIG1vbnRoOiBnZXRNb250aChfdGhpcy5wcm9wcy5kYXkpLFxuICAgICAgICAgIG9uRGF5Q2xpY2s6IF90aGlzLmhhbmRsZURheUNsaWNrLFxuICAgICAgICAgIG9uRGF5TW91c2VFbnRlcjogX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlcixcbiAgICAgICAgICBvbldlZWtTZWxlY3Q6IF90aGlzLnByb3BzLm9uV2Vla1NlbGVjdCxcbiAgICAgICAgICBmb3JtYXRXZWVrTnVtYmVyOiBfdGhpcy5wcm9wcy5mb3JtYXRXZWVrTnVtYmVyLFxuICAgICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICBpbmNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlcyxcbiAgICAgICAgICBpbmxpbmU6IF90aGlzLnByb3BzLmlubGluZSxcbiAgICAgICAgICBoaWdobGlnaHREYXRlczogX3RoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMsXG4gICAgICAgICAgc2VsZWN0aW5nRGF0ZTogX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSxcbiAgICAgICAgICBmaWx0ZXJEYXRlOiBfdGhpcy5wcm9wcy5maWx0ZXJEYXRlLFxuICAgICAgICAgIHByZVNlbGVjdGlvbjogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLFxuICAgICAgICAgIHNlbGVjdGVkOiBfdGhpcy5wcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgICBzZWxlY3RzU3RhcnQ6IF90aGlzLnByb3BzLnNlbGVjdHNTdGFydCxcbiAgICAgICAgICBzZWxlY3RzRW5kOiBfdGhpcy5wcm9wcy5zZWxlY3RzRW5kLFxuICAgICAgICAgIHNob3dXZWVrTnVtYmVyOiBfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlcnMsXG4gICAgICAgICAgc3RhcnREYXRlOiBfdGhpcy5wcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgZW5kRGF0ZTogX3RoaXMucHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICBkYXlDbGFzc05hbWU6IF90aGlzLnByb3BzLmRheUNsYXNzTmFtZSxcbiAgICAgICAgICB1dGNPZmZzZXQ6IF90aGlzLnByb3BzLnV0Y09mZnNldFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGJyZWFrQWZ0ZXJOZXh0UHVzaCkgYnJlYWs7XG5cbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50V2Vla1N0YXJ0ID0gYWRkV2Vla3MoY2xvbmVEYXRlKGN1cnJlbnRXZWVrU3RhcnQpLCAxKTtcblxuICAgICAgICAvLyBJZiBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpcyB0cnVlLCB3ZSB3aWxsIGVpdGhlciBicmVhayBvbiB0aGlzIHdlZWtcbiAgICAgICAgLy8gb3IgYnJlYWsgb24gdGhlIG5leHQgd2Vla1xuICAgICAgICB2YXIgaXNGaXhlZEFuZEZpbmFsV2VlayA9IGlzRml4ZWRIZWlnaHQgJiYgaSA+PSBGSVhFRF9IRUlHSFRfU1RBTkRBUkRfV0VFS19DT1VOVDtcbiAgICAgICAgdmFyIGlzTm9uRml4ZWRBbmRPdXRPZk1vbnRoID0gIWlzRml4ZWRIZWlnaHQgJiYgIV90aGlzLmlzV2Vla0luTW9udGgoY3VycmVudFdlZWtTdGFydCk7XG5cbiAgICAgICAgaWYgKGlzRml4ZWRBbmRGaW5hbFdlZWsgfHwgaXNOb25GaXhlZEFuZE91dE9mTW9udGgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucGVla05leHRNb250aCkge1xuICAgICAgICAgICAgYnJlYWtBZnRlck5leHRQdXNoID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3ZWVrcztcbiAgICB9LCBfdGhpcy5nZXRDbGFzc05hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgc2VsZWN0aW5nRGF0ZSA9IF90aGlzJHByb3BzLnNlbGVjdGluZ0RhdGUsXG4gICAgICAgICAgc2VsZWN0c1N0YXJ0ID0gX3RoaXMkcHJvcHMuc2VsZWN0c1N0YXJ0LFxuICAgICAgICAgIHNlbGVjdHNFbmQgPSBfdGhpcyRwcm9wcy5zZWxlY3RzRW5kO1xuXG4gICAgICByZXR1cm4gY2xhc3NuYW1lcyhcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoXCIsIHtcbiAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC0tc2VsZWN0aW5nLXJhbmdlXCI6IHNlbGVjdGluZ0RhdGUgJiYgKHNlbGVjdHNTdGFydCB8fCBzZWxlY3RzRW5kKVxuICAgICAgfSk7XG4gICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIE1vbnRoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lcygpLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSxcbiAgICAgICAgcm9sZTogXCJsaXN0Ym94XCJcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlbmRlcldlZWtzKClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBNb250aDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGgucHJvcFR5cGVzID0ge1xuICBkYXk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZGF5Q2xhc3NOYW1lOiBQcm9wVHlwZXMuZnVuYyxcbiAgZW5kRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgZXhjbHVkZURhdGVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGZpbHRlckRhdGU6IFByb3BUeXBlcy5mdW5jLFxuICBmaXhlZEhlaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIGZvcm1hdFdlZWtOdW1iZXI6IFByb3BUeXBlcy5mdW5jLFxuICBoaWdobGlnaHREYXRlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWFwKSxcbiAgaW5jbHVkZURhdGVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uRGF5Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkRheU1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbldlZWtTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBwZWVrTmV4dE1vbnRoOiBQcm9wVHlwZXMuYm9vbCxcbiAgcHJlU2VsZWN0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0aW5nRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0c0VuZDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbGVjdHNTdGFydDogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dXZWVrTnVtYmVyczogUHJvcFR5cGVzLmJvb2wsXG4gIHN0YXJ0RGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgdXRjT2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG52YXIgVGltZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWUoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgaWYgKChfdGhpcy5wcm9wcy5taW5UaW1lIHx8IF90aGlzLnByb3BzLm1heFRpbWUpICYmIGlzVGltZUluRGlzYWJsZWRSYW5nZSh0aW1lLCBfdGhpcy5wcm9wcykgfHwgX3RoaXMucHJvcHMuZXhjbHVkZVRpbWVzICYmIGlzVGltZURpc2FibGVkKHRpbWUsIF90aGlzLnByb3BzLmV4Y2x1ZGVUaW1lcykgfHwgX3RoaXMucHJvcHMuaW5jbHVkZVRpbWVzICYmICFpc1RpbWVEaXNhYmxlZCh0aW1lLCBfdGhpcy5wcm9wcy5pbmNsdWRlVGltZXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UodGltZSk7XG4gICAgfSwgX3RoaXMubGlDbGFzc2VzID0gZnVuY3Rpb24gKHRpbWUsIGN1cnJILCBjdXJyTSkge1xuICAgICAgdmFyIGNsYXNzZXMgPSBbXCJyZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbVwiXTtcblxuICAgICAgaWYgKGN1cnJIID09PSBnZXRIb3VyKHRpbWUpICYmIGN1cnJNID09PSBnZXRNaW51dGUodGltZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW0tLXNlbGVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKChfdGhpcy5wcm9wcy5taW5UaW1lIHx8IF90aGlzLnByb3BzLm1heFRpbWUpICYmIGlzVGltZUluRGlzYWJsZWRSYW5nZSh0aW1lLCBfdGhpcy5wcm9wcykgfHwgX3RoaXMucHJvcHMuZXhjbHVkZVRpbWVzICYmIGlzVGltZURpc2FibGVkKHRpbWUsIF90aGlzLnByb3BzLmV4Y2x1ZGVUaW1lcykgfHwgX3RoaXMucHJvcHMuaW5jbHVkZVRpbWVzICYmICFpc1RpbWVEaXNhYmxlZCh0aW1lLCBfdGhpcy5wcm9wcy5pbmNsdWRlVGltZXMpKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdC1pdGVtLS1kaXNhYmxlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5pbmplY3RUaW1lcyAmJiAoZ2V0SG91cih0aW1lKSAqIDYwICsgZ2V0TWludXRlKHRpbWUpKSAlIF90aGlzLnByb3BzLmludGVydmFscyAhPT0gMCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbS0taW5qZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgIH0sIF90aGlzLnJlbmRlclRpbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRpbWVzID0gW107XG4gICAgICB2YXIgZm9ybWF0ID0gX3RoaXMucHJvcHMuZm9ybWF0ID8gX3RoaXMucHJvcHMuZm9ybWF0IDogXCJoaDptbSBBXCI7XG4gICAgICB2YXIgaW50ZXJ2YWxzID0gX3RoaXMucHJvcHMuaW50ZXJ2YWxzO1xuICAgICAgdmFyIGFjdGl2ZVRpbWUgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZCA/IF90aGlzLnByb3BzLnNlbGVjdGVkIDogbmV3RGF0ZSgpO1xuICAgICAgdmFyIGN1cnJIID0gZ2V0SG91cihhY3RpdmVUaW1lKTtcbiAgICAgIHZhciBjdXJyTSA9IGdldE1pbnV0ZShhY3RpdmVUaW1lKTtcbiAgICAgIHZhciBiYXNlID0gZ2V0U3RhcnRPZkRheShuZXdEYXRlKCkpO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSAxNDQwIC8gaW50ZXJ2YWxzO1xuICAgICAgdmFyIHNvcnRlZEluamVjdFRpbWVzID0gX3RoaXMucHJvcHMuaW5qZWN0VGltZXMgJiYgX3RoaXMucHJvcHMuaW5qZWN0VGltZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlwbGllcjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGFkZE1pbnV0ZXMoY2xvbmVEYXRlKGJhc2UpLCBpICogaW50ZXJ2YWxzKTtcbiAgICAgICAgdGltZXMucHVzaChjdXJyZW50VGltZSk7XG5cbiAgICAgICAgaWYgKHNvcnRlZEluamVjdFRpbWVzKSB7XG4gICAgICAgICAgdmFyIHRpbWVzVG9JbmplY3QgPSB0aW1lc1RvSW5qZWN0QWZ0ZXIoYmFzZSwgY3VycmVudFRpbWUsIGksIGludGVydmFscywgc29ydGVkSW5qZWN0VGltZXMpO1xuICAgICAgICAgIHRpbWVzID0gdGltZXMuY29uY2F0KHRpbWVzVG9JbmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lcy5tYXAoZnVuY3Rpb24gKHRpbWUsIGkpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IF90aGlzLmhhbmRsZUNsaWNrLmJpbmQoX3RoaXMsIHRpbWUpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBfdGhpcy5saUNsYXNzZXModGltZSwgY3VyckgsIGN1cnJNKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0RGF0ZSh0aW1lLCBmb3JtYXQpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9LCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgVGltZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBjb2RlIHRvIGVuc3VyZSBzZWxlY3RlZCB0aW1lIHdpbGwgYWx3YXlzIGJlIGluIGZvY3VzIHdpdGhpbiB0aW1lIHdpbmRvdyB3aGVuIGl0IGZpcnN0IGFwcGVhcnNcbiAgICB2YXIgbXVsdGlwbGllciA9IDYwIC8gdGhpcy5wcm9wcy5pbnRlcnZhbHM7XG4gICAgdmFyIGN1cnJIID0gdGhpcy5wcm9wcy5zZWxlY3RlZCA/IGdldEhvdXIodGhpcy5wcm9wcy5zZWxlY3RlZCkgOiBnZXRIb3VyKG5ld0RhdGUoKSk7XG4gICAgdGhpcy5saXN0LnNjcm9sbFRvcCA9IDMwICogKG11bHRpcGxpZXIgKiBjdXJySCk7XG4gIH07XG5cbiAgVGltZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGhlaWdodCA9IG51bGw7XG4gICAgaWYgKHRoaXMucHJvcHMubW9udGhSZWYpIHtcbiAgICAgIGhlaWdodCA9IHRoaXMucHJvcHMubW9udGhSZWYuY2xpZW50SGVpZ2h0IC0gMzk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1jb250YWluZXIgXCIgKyAodGhpcy5wcm9wcy50b2RheUJ1dHRvbiA/IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1jb250YWluZXItLXdpdGgtdG9kYXktYnV0dG9uXCIgOiBcIlwiKVxuICAgICAgfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlciByZWFjdC1kYXRlcGlja2VyX19oZWFkZXItLXRpbWVcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlci10aW1lX19oZWFkZXJcIiB9LFxuICAgICAgICAgIHRoaXMucHJvcHMudGltZUNhcHRpb25cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWVcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1ib3hcIiB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBcInVsXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3RcIixcbiAgICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobGlzdCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5saXN0ID0gbGlzdDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3R5bGU6IGhlaWdodCA/IHsgaGVpZ2h0OiBoZWlnaHQgfSA6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lcy5iaW5kKHRoaXMpKClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFRpbWUsIG51bGwsIFt7XG4gICAga2V5OiBcImRlZmF1bHRQcm9wc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJ2YWxzOiAzMCxcbiAgICAgICAgb25UaW1lQ2hhbmdlOiBmdW5jdGlvbiBvblRpbWVDaGFuZ2UoKSB7fSxcbiAgICAgICAgdG9kYXlCdXR0b246IG51bGwsXG4gICAgICAgIHRpbWVDYXB0aW9uOiBcIlRpbWVcIlxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRpbWU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRpbWUucHJvcFR5cGVzID0ge1xuICBmb3JtYXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVUaW1lczogUHJvcFR5cGVzLmFycmF5LFxuICBpbnRlcnZhbHM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMub2JqZWN0LFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvZGF5QnV0dG9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtaW5UaW1lOiBQcm9wVHlwZXMub2JqZWN0LFxuICBtYXhUaW1lOiBQcm9wVHlwZXMub2JqZWN0LFxuICBleGNsdWRlVGltZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgbW9udGhSZWY6IFByb3BUeXBlcy5vYmplY3QsXG4gIHRpbWVDYXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbmplY3RUaW1lczogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5mdW5jdGlvbiBDYWxlbmRhckNvbnRhaW5lcihfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBcImRpdlwiLFxuICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RyaWFuZ2xlXCIgfSksXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuQ2FsZW5kYXJDb250YWluZXIucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxudmFyIERST1BET1dOX0ZPQ1VTX0NMQVNTTkFNRVMgPSBbXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXNlbGVjdFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXNlbGVjdFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItc2VsZWN0XCJdO1xuXG52YXIgaXNEcm9wZG93blNlbGVjdCA9IGZ1bmN0aW9uIGlzRHJvcGRvd25TZWxlY3QoKSB7XG4gIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgY2xhc3NOYW1lcyA9IChlbGVtZW50LmNsYXNzTmFtZSB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pO1xuICByZXR1cm4gRFJPUERPV05fRk9DVVNfQ0xBU1NOQU1FUy5zb21lKGZ1bmN0aW9uICh0ZXN0Q2xhc3NuYW1lKSB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZXMuaW5kZXhPZih0ZXN0Q2xhc3NuYW1lKSA+PSAwO1xuICB9KTtcbn07XG5cbnZhciBDYWxlbmRhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKENhbGVuZGFyLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgY3JlYXRlQ2xhc3MoQ2FsZW5kYXIsIG51bGwsIFt7XG4gICAga2V5OiBcImRlZmF1bHRQcm9wc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgICBvbkRyb3Bkb3duRm9jdXM6IGZ1bmN0aW9uIG9uRHJvcGRvd25Gb2N1cygpIHt9LFxuICAgICAgICBtb250aHNTaG93bjogMSxcbiAgICAgICAgZm9yY2VTaG93TW9udGhOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgdGltZUNhcHRpb246IFwiVGltZVwiLFxuICAgICAgICBwcmV2aW91c01vbnRoQnV0dG9uTGFiZWw6IFwiUHJldmlvdXMgTW9udGhcIlxuICAgICAgfSwgX3JlZltcInByZXZpb3VzTW9udGhCdXR0b25MYWJlbFwiXSA9IFwiTmV4dCBNb250aFwiLCBfcmVmO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENhbGVuZGFyKHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMucHJvcHMub25DbGlja091dHNpZGUoZXZlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoaXNEcm9wZG93blNlbGVjdChldmVudC50YXJnZXQpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRHJvcGRvd25Gb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXREYXRlSW5WaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgcHJlU2VsZWN0aW9uID0gX3RoaXMkcHJvcHMucHJlU2VsZWN0aW9uLFxuICAgICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgICAgb3BlblRvRGF0ZSA9IF90aGlzJHByb3BzLm9wZW5Ub0RhdGUsXG4gICAgICAgICAgdXRjT2Zmc2V0ID0gX3RoaXMkcHJvcHMudXRjT2Zmc2V0O1xuXG4gICAgICB2YXIgbWluRGF0ZSA9IGdldEVmZmVjdGl2ZU1pbkRhdGUoX3RoaXMucHJvcHMpO1xuICAgICAgdmFyIG1heERhdGUgPSBnZXRFZmZlY3RpdmVNYXhEYXRlKF90aGlzLnByb3BzKTtcbiAgICAgIHZhciBjdXJyZW50ID0gbm93KHV0Y09mZnNldCk7XG4gICAgICB2YXIgaW5pdGlhbERhdGUgPSBvcGVuVG9EYXRlIHx8IHNlbGVjdGVkIHx8IHByZVNlbGVjdGlvbjtcbiAgICAgIGlmIChpbml0aWFsRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbERhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWluRGF0ZSAmJiBpc0JlZm9yZShjdXJyZW50LCBtaW5EYXRlKSkge1xuICAgICAgICAgIHJldHVybiBtaW5EYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKG1heERhdGUgJiYgaXNBZnRlcihjdXJyZW50LCBtYXhEYXRlKSkge1xuICAgICAgICAgIHJldHVybiBtYXhEYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuXG4gICAgX3RoaXMubG9jYWxpemVEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZURhdGUoZGF0ZSwgX3RoaXMucHJvcHMubG9jYWxlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaW5jcmVhc2VNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGF0ZTogYWRkTW9udGhzKGNsb25lRGF0ZShfdGhpcy5zdGF0ZS5kYXRlKSwgMSlcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZU1vbnRoQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmRlY3JlYXNlTW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRhdGU6IHN1YnRyYWN0TW9udGhzKGNsb25lRGF0ZShfdGhpcy5zdGF0ZS5kYXRlKSwgMSlcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZU1vbnRoQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZURheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vblNlbGVjdChkYXksIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGluZ0RhdGU6IGRheSB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTW9udGhNb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHsgc2VsZWN0aW5nRGF0ZTogbnVsbCB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25ZZWFyQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uWWVhckNoYW5nZShkYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uTW9udGhDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Nb250aENoYW5nZShkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uU2VsZWN0KSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMub25TZWxlY3QoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnNldE9wZW4pIHtcbiAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRPcGVuKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU1vbnRoWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKGRhdGUpO1xuICAgICAgX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UoZGF0ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNoYW5nZVllYXIgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkYXRlOiBzZXRZZWFyKGNsb25lRGF0ZShfdGhpcy5zdGF0ZS5kYXRlKSwgeWVhcilcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZVllYXJDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2hhbmdlTW9udGggPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGF0ZTogc2V0TW9udGgoY2xvbmVEYXRlKF90aGlzLnN0YXRlLmRhdGUpLCBtb250aClcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZU1vbnRoQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNoYW5nZU1vbnRoWWVhciA9IGZ1bmN0aW9uIChtb250aFllYXIpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGF0ZTogc2V0WWVhcihzZXRNb250aChjbG9uZURhdGUoX3RoaXMuc3RhdGUuZGF0ZSksIGdldE1vbnRoKG1vbnRoWWVhcikpLCBnZXRZZWFyKG1vbnRoWWVhcikpXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVNb250aFllYXJDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF90aGlzLnN0YXRlLmRhdGU7XG5cbiAgICAgIHZhciBzdGFydE9mV2VlayA9IGdldFN0YXJ0T2ZXZWVrKGNsb25lRGF0ZShkYXRlKSk7XG4gICAgICB2YXIgZGF5TmFtZXMgPSBbXTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlcnMpIHtcbiAgICAgICAgZGF5TmFtZXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBrZXk6IFwiV1wiLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWVcIiB9LFxuICAgICAgICAgIF90aGlzLnByb3BzLndlZWtMYWJlbCB8fCBcIiNcIlxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXlOYW1lcy5jb25jYXQoWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBkYXkgPSBhZGREYXlzKGNsb25lRGF0ZShzdGFydE9mV2VlayksIG9mZnNldCk7XG4gICAgICAgIHZhciBsb2NhbGVEYXRhID0gZ2V0TG9jYWxlRGF0YShkYXkpO1xuICAgICAgICB2YXIgd2Vla0RheU5hbWUgPSBfdGhpcy5mb3JtYXRXZWVrZGF5KGxvY2FsZURhdGEsIGRheSk7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IGtleTogb2Zmc2V0LCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWVcIiB9LFxuICAgICAgICAgIHdlZWtEYXlOYW1lXG4gICAgICAgICk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF90aGlzLmZvcm1hdFdlZWtkYXkgPSBmdW5jdGlvbiAobG9jYWxlRGF0YSwgZGF5KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZm9ybWF0V2Vla0RheSkge1xuICAgICAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkV2Vla2RheUluTG9jYWxlKGxvY2FsZURhdGEsIGRheSwgX3RoaXMucHJvcHMuZm9ybWF0V2Vla0RheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMudXNlV2Vla2RheXNTaG9ydCA/IGdldFdlZWtkYXlTaG9ydEluTG9jYWxlKGxvY2FsZURhdGEsIGRheSkgOiBnZXRXZWVrZGF5TWluSW5Mb2NhbGUobG9jYWxlRGF0YSwgZGF5KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyUHJldmlvdXNNb250aEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGxQcmV2RGF5c0Rpc2FibGVkID0gYWxsRGF5c0Rpc2FibGVkQmVmb3JlKF90aGlzLnN0YXRlLmRhdGUsIFwibW9udGhcIiwgX3RoaXMucHJvcHMpO1xuXG4gICAgICBpZiAoIV90aGlzLnByb3BzLmZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbiAmJiAhX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uICYmIGFsbFByZXZEYXlzRGlzYWJsZWQgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsYXNzZXMgPSBbXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uXCIsIFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0tcHJldmlvdXNcIl07XG5cbiAgICAgIHZhciBjbGlja0hhbmRsZXIgPSBfdGhpcy5kZWNyZWFzZU1vbnRoO1xuXG4gICAgICBpZiAoYWxsUHJldkRheXNEaXNhYmxlZCAmJiBfdGhpcy5wcm9wcy5zaG93RGlzYWJsZWRNb250aE5hdmlnYXRpb24pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0tcHJldmlvdXMtLWRpc2FibGVkXCIpO1xuICAgICAgICBjbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oXCIgXCIpLFxuICAgICAgICAgIG9uQ2xpY2s6IGNsaWNrSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICBfdGhpcy5wcm9wcy5wcmV2aW91c01vbnRoQnV0dG9uTGFiZWxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlck5leHRNb250aEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGxOZXh0RGF5c0Rpc2FibGVkID0gYWxsRGF5c0Rpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgXCJtb250aFwiLCBfdGhpcy5wcm9wcyk7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuZm9yY2VTaG93TW9udGhOYXZpZ2F0aW9uICYmICFfdGhpcy5wcm9wcy5zaG93RGlzYWJsZWRNb250aE5hdmlnYXRpb24gJiYgYWxsTmV4dERheXNEaXNhYmxlZCB8fCBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NlcyA9IFtcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb25cIiwgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0XCJdO1xuICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLW5leHQtLXdpdGgtdGltZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5wcm9wcy50b2RheUJ1dHRvbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0LS13aXRoLXRvZGF5LWJ1dHRvblwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IF90aGlzLmluY3JlYXNlTW9udGg7XG5cbiAgICAgIGlmIChhbGxOZXh0RGF5c0Rpc2FibGVkICYmIF90aGlzLnByb3BzLnNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS1uZXh0LS1kaXNhYmxlZFwiKTtcbiAgICAgICAgY2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKFwiIFwiKSxcbiAgICAgICAgICBvbkNsaWNrOiBjbGlja0hhbmRsZXJcbiAgICAgICAgfSxcbiAgICAgICAgX3RoaXMucHJvcHMubmV4dE1vbnRoQnV0dG9uTGFiZWxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlckN1cnJlbnRNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfdGhpcy5zdGF0ZS5kYXRlO1xuXG4gICAgICB2YXIgY2xhc3NlcyA9IFtcInJlYWN0LWRhdGVwaWNrZXJfX2N1cnJlbnQtbW9udGhcIl07XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93WWVhckRyb3Bkb3duKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX2N1cnJlbnQtbW9udGgtLWhhc1llYXJEcm9wZG93blwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93TW9udGhEcm9wZG93bikge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoLS1oYXNNb250aERyb3Bkb3duXCIpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJEcm9wZG93bikge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoLS1oYXNNb250aFllYXJEcm9wZG93blwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKFwiIFwiKSB9LFxuICAgICAgICBmb3JtYXREYXRlKGRhdGUsIF90aGlzLnByb3BzLmRhdGVGb3JtYXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJZZWFyRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3ZlcnJpZGVIaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG93WWVhckRyb3Bkb3duIHx8IG92ZXJyaWRlSGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChZZWFyRHJvcGRvd24sIHtcbiAgICAgICAgYWRqdXN0RGF0ZU9uQ2hhbmdlOiBfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UsXG4gICAgICAgIGRhdGU6IF90aGlzLnN0YXRlLmRhdGUsXG4gICAgICAgIG9uU2VsZWN0OiBfdGhpcy5wcm9wcy5vblNlbGVjdCxcbiAgICAgICAgc2V0T3BlbjogX3RoaXMucHJvcHMuc2V0T3BlbixcbiAgICAgICAgZHJvcGRvd25Nb2RlOiBfdGhpcy5wcm9wcy5kcm9wZG93bk1vZGUsXG4gICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5jaGFuZ2VZZWFyLFxuICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICBtYXhEYXRlOiBfdGhpcy5wcm9wcy5tYXhEYXRlLFxuICAgICAgICB5ZWFyOiBnZXRZZWFyKF90aGlzLnN0YXRlLmRhdGUpLFxuICAgICAgICBzY3JvbGxhYmxlWWVhckRyb3Bkb3duOiBfdGhpcy5wcm9wcy5zY3JvbGxhYmxlWWVhckRyb3Bkb3duLFxuICAgICAgICB5ZWFyRHJvcGRvd25JdGVtTnVtYmVyOiBfdGhpcy5wcm9wcy55ZWFyRHJvcGRvd25JdGVtTnVtYmVyXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyTW9udGhEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvdmVycmlkZUhpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIV90aGlzLnByb3BzLnNob3dNb250aERyb3Bkb3duIHx8IG92ZXJyaWRlSGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb250aERyb3Bkb3duLCB7XG4gICAgICAgIGRyb3Bkb3duTW9kZTogX3RoaXMucHJvcHMuZHJvcGRvd25Nb2RlLFxuICAgICAgICBsb2NhbGU6IF90aGlzLnByb3BzLmxvY2FsZSxcbiAgICAgICAgZGF0ZUZvcm1hdDogX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCxcbiAgICAgICAgb25DaGFuZ2U6IF90aGlzLmNoYW5nZU1vbnRoLFxuICAgICAgICBtb250aDogZ2V0TW9udGgoX3RoaXMuc3RhdGUuZGF0ZSksXG4gICAgICAgIHVzZVNob3J0TW9udGhJbkRyb3Bkb3duOiBfdGhpcy5wcm9wcy51c2VTaG9ydE1vbnRoSW5Ecm9wZG93blxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlck1vbnRoWWVhckRyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG92ZXJyaWRlSGlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhckRyb3Bkb3duIHx8IG92ZXJyaWRlSGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb250aFllYXJEcm9wZG93biwge1xuICAgICAgICBkcm9wZG93bk1vZGU6IF90aGlzLnByb3BzLmRyb3Bkb3duTW9kZSxcbiAgICAgICAgbG9jYWxlOiBfdGhpcy5wcm9wcy5sb2NhbGUsXG4gICAgICAgIGRhdGVGb3JtYXQ6IF90aGlzLnByb3BzLmRhdGVGb3JtYXQsXG4gICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5jaGFuZ2VNb250aFllYXIsXG4gICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgIGRhdGU6IF90aGlzLnN0YXRlLmRhdGUsXG4gICAgICAgIHNjcm9sbGFibGVNb250aFllYXJEcm9wZG93bjogX3RoaXMucHJvcHMuc2Nyb2xsYWJsZU1vbnRoWWVhckRyb3Bkb3duXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVG9kYXlCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnByb3BzLnRvZGF5QnV0dG9uIHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190b2RheS1idXR0b25cIixcbiAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vblNlbGVjdChnZXRTdGFydE9mRGF0ZShub3coX3RoaXMucHJvcHMudXRjT2Zmc2V0KSksIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3RoaXMucHJvcHMudG9kYXlCdXR0b25cbiAgICAgICk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlck1vbnRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9udGhMaXN0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnByb3BzLm1vbnRoc1Nob3duOyArK2kpIHtcbiAgICAgICAgdmFyIG1vbnRoRGF0ZSA9IGFkZE1vbnRocyhjbG9uZURhdGUoX3RoaXMuc3RhdGUuZGF0ZSksIGkpO1xuICAgICAgICB2YXIgbW9udGhLZXkgPSBcIm1vbnRoLVwiICsgaTtcbiAgICAgICAgbW9udGhMaXN0LnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogbW9udGhLZXksXG4gICAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihkaXYpIHtcbiAgICAgICAgICAgICAgX3RoaXMubW9udGhDb250YWluZXIgPSBkaXY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWNvbnRhaW5lclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlclwiIH0sXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJDdXJyZW50TW9udGgobW9udGhEYXRlKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyX19kcm9wZG93biByZWFjdC1kYXRlcGlja2VyX19oZWFkZXJfX2Ryb3Bkb3duLS1cIiArIF90aGlzLnByb3BzLmRyb3Bkb3duTW9kZSxcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoRHJvcGRvd24oaSAhPT0gMCksXG4gICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoWWVhckRyb3Bkb3duKGkgIT09IDApLFxuICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJZZWFyRHJvcGRvd24oaSAhPT0gMClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19kYXktbmFtZXNcIiB9LFxuICAgICAgICAgICAgICBfdGhpcy5oZWFkZXIobW9udGhEYXRlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNb250aCwge1xuICAgICAgICAgICAgZGF5OiBtb250aERhdGUsXG4gICAgICAgICAgICBkYXlDbGFzc05hbWU6IF90aGlzLnByb3BzLmRheUNsYXNzTmFtZSxcbiAgICAgICAgICAgIG9uRGF5Q2xpY2s6IF90aGlzLmhhbmRsZURheUNsaWNrLFxuICAgICAgICAgICAgb25EYXlNb3VzZUVudGVyOiBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyLFxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiBfdGhpcy5oYW5kbGVNb250aE1vdXNlTGVhdmUsXG4gICAgICAgICAgICBvbldlZWtTZWxlY3Q6IF90aGlzLnByb3BzLm9uV2Vla1NlbGVjdCxcbiAgICAgICAgICAgIGZvcm1hdFdlZWtOdW1iZXI6IF90aGlzLnByb3BzLmZvcm1hdFdlZWtOdW1iZXIsXG4gICAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVEYXRlczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVzLFxuICAgICAgICAgICAgaGlnaGxpZ2h0RGF0ZXM6IF90aGlzLnByb3BzLmhpZ2hsaWdodERhdGVzLFxuICAgICAgICAgICAgc2VsZWN0aW5nRGF0ZTogX3RoaXMuc3RhdGUuc2VsZWN0aW5nRGF0ZSxcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgICAgaW5saW5lOiBfdGhpcy5wcm9wcy5pbmxpbmUsXG4gICAgICAgICAgICBmaXhlZEhlaWdodDogX3RoaXMucHJvcHMuZml4ZWRIZWlnaHQsXG4gICAgICAgICAgICBmaWx0ZXJEYXRlOiBfdGhpcy5wcm9wcy5maWx0ZXJEYXRlLFxuICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sXG4gICAgICAgICAgICBzZWxlY3RlZDogX3RoaXMucHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgICAgICBzZWxlY3RzU3RhcnQ6IF90aGlzLnByb3BzLnNlbGVjdHNTdGFydCxcbiAgICAgICAgICAgIHNlbGVjdHNFbmQ6IF90aGlzLnByb3BzLnNlbGVjdHNFbmQsXG4gICAgICAgICAgICBzaG93V2Vla051bWJlcnM6IF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVycyxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogX3RoaXMucHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgICAgZW5kRGF0ZTogX3RoaXMucHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgIHBlZWtOZXh0TW9udGg6IF90aGlzLnByb3BzLnBlZWtOZXh0TW9udGgsXG4gICAgICAgICAgICB1dGNPZmZzZXQ6IF90aGlzLnByb3BzLnV0Y09mZnNldFxuICAgICAgICAgIH0pXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vbnRoTGlzdDtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVGltZVNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZSwge1xuICAgICAgICAgIHNlbGVjdGVkOiBfdGhpcy5wcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgICBvbkNoYW5nZTogX3RoaXMucHJvcHMub25UaW1lQ2hhbmdlLFxuICAgICAgICAgIGZvcm1hdDogX3RoaXMucHJvcHMudGltZUZvcm1hdCxcbiAgICAgICAgICBpbmNsdWRlVGltZXM6IF90aGlzLnByb3BzLmluY2x1ZGVUaW1lcyxcbiAgICAgICAgICBpbnRlcnZhbHM6IF90aGlzLnByb3BzLnRpbWVJbnRlcnZhbHMsXG4gICAgICAgICAgbWluVGltZTogX3RoaXMucHJvcHMubWluVGltZSxcbiAgICAgICAgICBtYXhUaW1lOiBfdGhpcy5wcm9wcy5tYXhUaW1lLFxuICAgICAgICAgIGV4Y2x1ZGVUaW1lczogX3RoaXMucHJvcHMuZXhjbHVkZVRpbWVzLFxuICAgICAgICAgIHRpbWVDYXB0aW9uOiBfdGhpcy5wcm9wcy50aW1lQ2FwdGlvbixcbiAgICAgICAgICB0b2RheUJ1dHRvbjogX3RoaXMucHJvcHMudG9kYXlCdXR0b24sXG4gICAgICAgICAgc2hvd01vbnRoRHJvcGRvd246IF90aGlzLnByb3BzLnNob3dNb250aERyb3Bkb3duLFxuICAgICAgICAgIHNob3dNb250aFllYXJEcm9wZG93bjogX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhckRyb3Bkb3duLFxuICAgICAgICAgIHNob3dZZWFyRHJvcGRvd246IF90aGlzLnByb3BzLnNob3dZZWFyRHJvcGRvd24sXG4gICAgICAgICAgd2l0aFBvcnRhbDogX3RoaXMucHJvcHMud2l0aFBvcnRhbCxcbiAgICAgICAgICBtb250aFJlZjogX3RoaXMuc3RhdGUubW9udGhDb250YWluZXIsXG4gICAgICAgICAgaW5qZWN0VGltZXM6IF90aGlzLnByb3BzLmluamVjdFRpbWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGU6IF90aGlzLmxvY2FsaXplRGF0ZShfdGhpcy5nZXREYXRlSW5WaWV3KCkpLFxuICAgICAgc2VsZWN0aW5nRGF0ZTogbnVsbCxcbiAgICAgIG1vbnRoQ29udGFpbmVyOiBfdGhpcy5tb250aENvbnRhaW5lclxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBtb250aENvbnRhaW5lciBoZWlnaHQgaXMgbmVlZGVkIGluIHRpbWUgY29tcG9uZW50XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHRoZSBoZWlnaHQgZm9yIHRoZSB1bCBpbiB0aGUgdGltZSBjb21wb25lbnRcbiAgICAvLyBzZXRTdGF0ZSBoZXJlIHNvIGhlaWdodCBpcyBnaXZlbiBhZnRlciBmaW5hbCBjb21wb25lbnRcbiAgICAvLyBsYXlvdXQgaXMgcmVuZGVyZWRcbiAgICBpZiAodGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCkge1xuICAgICAgdGhpcy5hc3NpZ25Nb250aENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldFN0YXRlKHsgbW9udGhDb250YWluZXI6IF90aGlzMi5tb250aENvbnRhaW5lciB9KTtcbiAgICAgIH0oKTtcbiAgICB9XG4gIH07XG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gJiYgIWlzU2FtZURheSh0aGlzLnByb3BzLnByZVNlbGVjdGlvbiwgcHJldlByb3BzLnByZVNlbGVjdGlvbikpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkYXRlOiB0aGlzLmxvY2FsaXplRGF0ZSh0aGlzLnByb3BzLnByZVNlbGVjdGlvbilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5vcGVuVG9EYXRlICYmICFpc1NhbWVEYXkodGhpcy5wcm9wcy5vcGVuVG9EYXRlLCBwcmV2UHJvcHMub3BlblRvRGF0ZSkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkYXRlOiB0aGlzLmxvY2FsaXplRGF0ZSh0aGlzLnByb3BzLm9wZW5Ub0RhdGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgQ29udGFpbmVyID0gdGhpcy5wcm9wcy5jb250YWluZXIgfHwgQ2FsZW5kYXJDb250YWluZXI7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRhaW5lcixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKFwicmVhY3QtZGF0ZXBpY2tlclwiLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwge1xuICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlci0tdGltZS1vbmx5XCI6IHRoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgdGhpcy5yZW5kZXJQcmV2aW91c01vbnRoQnV0dG9uKCksXG4gICAgICB0aGlzLnJlbmRlck5leHRNb250aEJ1dHRvbigpLFxuICAgICAgdGhpcy5yZW5kZXJNb250aHMoKSxcbiAgICAgIHRoaXMucmVuZGVyVG9kYXlCdXR0b24oKSxcbiAgICAgIHRoaXMucmVuZGVyVGltZVNlY3Rpb24oKSxcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2FsZW5kYXIucHJvcFR5cGVzID0ge1xuICBhZGp1c3REYXRlT25DaGFuZ2U6IFByb3BUeXBlcy5ib29sLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY29udGFpbmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0ZUZvcm1hdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5XSkuaXNSZXF1aXJlZCxcbiAgZGF5Q2xhc3NOYW1lOiBQcm9wVHlwZXMuZnVuYyxcbiAgZHJvcGRvd25Nb2RlOiBQcm9wVHlwZXMub25lT2YoW1wic2Nyb2xsXCIsIFwic2VsZWN0XCJdKSxcbiAgZW5kRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgZXhjbHVkZURhdGVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGZpbHRlckRhdGU6IFByb3BUeXBlcy5mdW5jLFxuICBmaXhlZEhlaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIGZvcm1hdFdlZWtOdW1iZXI6IFByb3BUeXBlcy5mdW5jLFxuICBoaWdobGlnaHREYXRlczogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWFwKSxcbiAgaW5jbHVkZURhdGVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluY2x1ZGVUaW1lczogUHJvcFR5cGVzLmFycmF5LFxuICBpbmplY3RUaW1lczogUHJvcFR5cGVzLmFycmF5LFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1vbnRoc1Nob3duOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvbkNsaWNrT3V0c2lkZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25Nb250aENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uWWVhckNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIG9uRHJvcGRvd25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvbldlZWtTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBzaG93VGltZVNlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dUaW1lU2VsZWN0T25seTogUHJvcFR5cGVzLmJvb2wsXG4gIHRpbWVGb3JtYXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpbWVJbnRlcnZhbHM6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uVGltZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG1pblRpbWU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1heFRpbWU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGV4Y2x1ZGVUaW1lczogUHJvcFR5cGVzLmFycmF5LFxuICB0aW1lQ2FwdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgb3BlblRvRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgcGVla05leHRNb250aDogUHJvcFR5cGVzLmJvb2wsXG4gIHNjcm9sbGFibGVZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBzY3JvbGxhYmxlTW9udGhZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBwcmVTZWxlY3Rpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RzRW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2VsZWN0c1N0YXJ0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd01vbnRoRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBzaG93TW9udGhZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBzaG93V2Vla051bWJlcnM6IFByb3BUeXBlcy5ib29sLFxuICBzaG93WWVhckRyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RhcnREYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0b2RheUJ1dHRvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgdXNlV2Vla2RheXNTaG9ydDogUHJvcFR5cGVzLmJvb2wsXG4gIGZvcm1hdFdlZWtEYXk6IFByb3BUeXBlcy5mdW5jLFxuICB3aXRoUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgdXRjT2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB3ZWVrTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHllYXJEcm9wZG93bkl0ZW1OdW1iZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNldE9wZW46IFByb3BUeXBlcy5mdW5jLFxuICB1c2VTaG9ydE1vbnRoSW5Ecm9wZG93bjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHByZXZpb3VzTW9udGhCdXR0b25MYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgbmV4dE1vbnRoQnV0dG9uTGFiZWw6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbnZhciBwb3BwZXJQbGFjZW1lbnRQb3NpdGlvbnMgPSBbXCJhdXRvXCIsIFwiYXV0by1sZWZ0XCIsIFwiYXV0by1yaWdodFwiLCBcImJvdHRvbVwiLCBcImJvdHRvbS1lbmRcIiwgXCJib3R0b20tc3RhcnRcIiwgXCJsZWZ0XCIsIFwibGVmdC1lbmRcIiwgXCJsZWZ0LXN0YXJ0XCIsIFwicmlnaHRcIiwgXCJyaWdodC1lbmRcIiwgXCJyaWdodC1zdGFydFwiLCBcInRvcFwiLCBcInRvcC1lbmRcIiwgXCJ0b3Atc3RhcnRcIl07XG5cbnZhciBQb3BwZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhQb3BwZXJDb21wb25lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvcHBlckNvbXBvbmVudCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXJDb21wb25lbnQpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQb3BwZXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgaGlkZVBvcHBlciA9IF9wcm9wcy5oaWRlUG9wcGVyLFxuICAgICAgICBwb3BwZXJDb21wb25lbnQgPSBfcHJvcHMucG9wcGVyQ29tcG9uZW50LFxuICAgICAgICBwb3BwZXJNb2RpZmllcnMgPSBfcHJvcHMucG9wcGVyTW9kaWZpZXJzLFxuICAgICAgICBwb3BwZXJQbGFjZW1lbnQgPSBfcHJvcHMucG9wcGVyUGxhY2VtZW50LFxuICAgICAgICB0YXJnZXRDb21wb25lbnQgPSBfcHJvcHMudGFyZ2V0Q29tcG9uZW50O1xuXG5cbiAgICB2YXIgcG9wcGVyID0gdm9pZCAwO1xuXG4gICAgaWYgKCFoaWRlUG9wcGVyKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXCJyZWFjdC1kYXRlcGlja2VyLXBvcHBlclwiLCBjbGFzc05hbWUpO1xuICAgICAgcG9wcGVyID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUG9wcGVyLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgICAgICAgIG1vZGlmaWVyczogcG9wcGVyTW9kaWZpZXJzLFxuICAgICAgICAgIHBsYWNlbWVudDogcG9wcGVyUGxhY2VtZW50XG4gICAgICAgIH0sXG4gICAgICAgIHBvcHBlckNvbXBvbmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5wb3BwZXJDb250YWluZXIpIHtcbiAgICAgIHBvcHBlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQodGhpcy5wcm9wcy5wb3BwZXJDb250YWluZXIsIHt9LCBwb3BwZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgTWFuYWdlcixcbiAgICAgIG51bGwsXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBUYXJnZXQsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXItd3JhcHBlclwiIH0sXG4gICAgICAgIHRhcmdldENvbXBvbmVudFxuICAgICAgKSxcbiAgICAgIHBvcHBlclxuICAgICk7XG4gIH07XG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyQ29tcG9uZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJkZWZhdWx0UHJvcHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpZGVQb3BwZXI6IHRydWUsXG4gICAgICAgIHBvcHBlck1vZGlmaWVyczoge1xuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGVzY2FwZVdpdGhSZWZlcmVuY2U6IHRydWUsXG4gICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogXCJ2aWV3cG9ydFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb3BwZXJQbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb3BwZXJDb21wb25lbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblBvcHBlckNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgaGlkZVBvcHBlcjogUHJvcFR5cGVzLmJvb2wsXG4gIHBvcHBlckNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIHBvcHBlck1vZGlmaWVyczogUHJvcFR5cGVzLm9iamVjdCwgLy8gPGRhdGVwaWNrZXIvPiBwcm9wc1xuICBwb3BwZXJQbGFjZW1lbnQ6IFByb3BUeXBlcy5vbmVPZihwb3BwZXJQbGFjZW1lbnRQb3NpdGlvbnMpLCAvLyA8ZGF0ZXBpY2tlci8+IHByb3BzXG4gIHBvcHBlckNvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRcbn07XG5cbnZhciBvdXRzaWRlQ2xpY2tJZ25vcmVDbGFzcyA9IFwicmVhY3QtZGF0ZXBpY2tlci1pZ25vcmUtb25jbGlja291dHNpZGVcIjtcbnZhciBXcmFwcGVkQ2FsZW5kYXIgPSBvbkNsaWNrT3V0c2lkZShDYWxlbmRhcik7XG5cbi8vIENvbXBhcmVzIGRhdGVzIHllYXIrbW9udGggY29tYmluYXRpb25zXG5mdW5jdGlvbiBoYXNQcmVTZWxlY3Rpb25DaGFuZ2VkKGRhdGUxLCBkYXRlMikge1xuICBpZiAoZGF0ZTEgJiYgZGF0ZTIpIHtcbiAgICByZXR1cm4gZ2V0TW9udGgoZGF0ZTEpICE9PSBnZXRNb250aChkYXRlMikgfHwgZ2V0WWVhcihkYXRlMSkgIT09IGdldFllYXIoZGF0ZTIpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGUxICE9PSBkYXRlMjtcbn1cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2hhbmdlZChkYXRlMSwgZGF0ZTIpIHtcbiAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgcmV0dXJuICFlcXVhbHMoZGF0ZTEsIGRhdGUyKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZW5lcmFsIGRhdGVwaWNrZXIgY29tcG9uZW50LlxuICovXG5cbnZhciBEYXRlUGlja2VyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoRGF0ZVBpY2tlciwgX1JlYWN0JENvbXBvbmVudCk7XG4gIGNyZWF0ZUNsYXNzKERhdGVQaWNrZXIsIG51bGwsIFt7XG4gICAga2V5OiBcImRlZmF1bHRQcm9wc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxsb3dTYW1lRGF5OiBmYWxzZSxcbiAgICAgICAgZGF0ZUZvcm1hdDogXCJMXCIsXG4gICAgICAgIGRhdGVGb3JtYXRDYWxlbmRhcjogXCJNTU1NIFlZWVlcIixcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG5cbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIGRyb3Bkb3duTW9kZTogXCJzY3JvbGxcIixcbiAgICAgICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHt9LFxuICAgICAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHt9LFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bigpIHt9LFxuICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICAgICAgb25DbGlja091dHNpZGU6IGZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlJCQxKCkge30sXG4gICAgICAgIG9uTW9udGhDaGFuZ2U6IGZ1bmN0aW9uIG9uTW9udGhDaGFuZ2UoKSB7fSxcblxuICAgICAgICBwcmV2ZW50T3Blbk9uRm9jdXM6IGZhbHNlLFxuICAgICAgICBvblllYXJDaGFuZ2U6IGZ1bmN0aW9uIG9uWWVhckNoYW5nZSgpIHt9LFxuXG4gICAgICAgIG1vbnRoc1Nob3duOiAxLFxuICAgICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICAgIHdpdGhQb3J0YWw6IGZhbHNlLFxuICAgICAgICBzaG91bGRDbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBzaG93VGltZVNlbGVjdDogZmFsc2UsXG4gICAgICAgIHRpbWVJbnRlcnZhbHM6IDMwLFxuICAgICAgICB0aW1lQ2FwdGlvbjogXCJUaW1lXCIsXG4gICAgICAgIHByZXZpb3VzTW9udGhCdXR0b25MYWJlbDogXCJQcmV2aW91cyBNb250aFwiLFxuICAgICAgICBuZXh0TW9udGhCdXR0b25MYWJlbDogXCJOZXh0IG1vbnRoXCJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gRGF0ZVBpY2tlcihwcm9wcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVQaWNrZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLmdldFByZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vcGVuVG9EYXRlID8gbmV3RGF0ZShfdGhpcy5wcm9wcy5vcGVuVG9EYXRlKSA6IF90aGlzLnByb3BzLnNlbGVjdHNFbmQgJiYgX3RoaXMucHJvcHMuc3RhcnREYXRlID8gbmV3RGF0ZShfdGhpcy5wcm9wcy5zdGFydERhdGUpIDogX3RoaXMucHJvcHMuc2VsZWN0c1N0YXJ0ICYmIF90aGlzLnByb3BzLmVuZERhdGUgPyBuZXdEYXRlKF90aGlzLnByb3BzLmVuZERhdGUpIDogbm93KF90aGlzLnByb3BzLnV0Y09mZnNldCk7XG4gICAgfTtcblxuICAgIF90aGlzLmNhbGNJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVmYXVsdFByZVNlbGVjdGlvbiA9IF90aGlzLmdldFByZVNlbGVjdGlvbigpO1xuICAgICAgdmFyIG1pbkRhdGUgPSBnZXRFZmZlY3RpdmVNaW5EYXRlKF90aGlzLnByb3BzKTtcbiAgICAgIHZhciBtYXhEYXRlID0gZ2V0RWZmZWN0aXZlTWF4RGF0ZShfdGhpcy5wcm9wcyk7XG4gICAgICB2YXIgYm91bmRlZFByZVNlbGVjdGlvbiA9IG1pbkRhdGUgJiYgaXNCZWZvcmUoZGVmYXVsdFByZVNlbGVjdGlvbiwgbWluRGF0ZSkgPyBtaW5EYXRlIDogbWF4RGF0ZSAmJiBpc0FmdGVyKGRlZmF1bHRQcmVTZWxlY3Rpb24sIG1heERhdGUpID8gbWF4RGF0ZSA6IGRlZmF1bHRQcmVTZWxlY3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuOiBfdGhpcy5wcm9wcy5zdGFydE9wZW4gfHwgZmFsc2UsXG4gICAgICAgIHByZXZlbnRGb2N1czogZmFsc2UsXG4gICAgICAgIHByZVNlbGVjdGlvbjogX3RoaXMucHJvcHMuc2VsZWN0ZWQgPyBuZXdEYXRlKF90aGlzLnByb3BzLnNlbGVjdGVkKSA6IGJvdW5kZWRQcmVTZWxlY3Rpb24sXG4gICAgICAgIC8vIHRyYW5zZm9ybWluZyBoaWdobGlnaHRlZCBkYXlzIChwZXJoYXBzIG5lc3RlZCBhcnJheSlcbiAgICAgICAgLy8gdG8gZmxhdCBNYXAgZm9yIGZhc3RlciBhY2Nlc3MgaW4gZGF5LmpzeFxuICAgICAgICBoaWdobGlnaHREYXRlczogZ2V0SGlnaHRMaWdodERheXNNYXAoX3RoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMpLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2xlYXJQcmV2ZW50Rm9jdXNUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnByZXZlbnRGb2N1c1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnByZXZlbnRGb2N1c1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pbnB1dCAmJiBfdGhpcy5pbnB1dC5mb2N1cykge1xuICAgICAgICBfdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zZXRPcGVuID0gZnVuY3Rpb24gKG9wZW4pIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgcHJlU2VsZWN0aW9uOiBvcGVuICYmIF90aGlzLnN0YXRlLm9wZW4gPyBfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb24gOiBfdGhpcy5jYWxjSW5pdGlhbFN0YXRlKCkucHJlU2VsZWN0aW9uLFxuICAgICAgICBsYXN0UHJlU2VsZWN0Q2hhbmdlOiBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9OQVZJR0FURVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLnByZXZlbnRGb2N1cykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkZvY3VzKGV2ZW50KTtcbiAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5wcmV2ZW50T3Blbk9uRm9jdXMgJiYgIV90aGlzLnByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgX3RoaXMuc2V0T3Blbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5jYW5jZWxGb2N1c0lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmlucHV0Rm9jdXNUaW1lb3V0KTtcbiAgICAgIF90aGlzLmlucHV0Rm9jdXNUaW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZGVmZXJGb2N1c0lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2FuY2VsRm9jdXNJbnB1dCgpO1xuICAgICAgX3RoaXMuaW5wdXRGb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNldEZvY3VzKCk7XG4gICAgICB9LCAxKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRHJvcGRvd25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlLm9wZW4gJiYgIV90aGlzLnByb3BzLndpdGhQb3J0YWwpIHtcbiAgICAgICAgX3RoaXMuZGVmZXJGb2N1c0lucHV0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkJsdXIoZXZlbnQpO1xuICAgICAgfVxuICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiBmYWxzZSB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQ2FsZW5kYXJDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMucHJvcHMuaW5saW5lKSB7XG4gICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgfVxuICAgICAgX3RoaXMucHJvcHMub25DbGlja091dHNpZGUoZXZlbnQpO1xuICAgICAgaWYgKF90aGlzLnByb3BzLndpdGhQb3J0YWwpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFsbEFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYWxsQXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50ID0gYWxsQXJnc1swXTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNoYW5nZVJhdykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZVJhdy5hcHBseShfdGhpcywgYWxsQXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkICE9PSBcImZ1bmN0aW9uXCIgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5wdXRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICBsYXN0UHJlU2VsZWN0Q2hhbmdlOiBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9JTlBVVFxuICAgICAgfSk7XG4gICAgICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShldmVudC50YXJnZXQudmFsdWUsIF90aGlzLnByb3BzKTtcbiAgICAgIGlmIChkYXRlIHx8ICFldmVudC50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgX3RoaXMuc2V0U2VsZWN0ZWQoZGF0ZSwgZXZlbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVTZWxlY3QgPSBmdW5jdGlvbiAoZGF0ZSwgZXZlbnQpIHtcbiAgICAgIC8vIFByZXZlbnRpbmcgb25Gb2N1cyBldmVudCB0byBmaXggaXNzdWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYWNrZXIweDAxL3JlYWN0LWRhdGVwaWNrZXIvaXNzdWVzLzYyOFxuICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2ZW50Rm9jdXM6IHRydWUgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5wcmV2ZW50Rm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHsgcHJldmVudEZvY3VzOiBmYWxzZSB9KTtcbiAgICAgICAgfSwgNTApO1xuICAgICAgICByZXR1cm4gX3RoaXMucHJldmVudEZvY3VzVGltZW91dDtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuc2V0U2VsZWN0ZWQoZGF0ZSwgZXZlbnQpO1xuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0IHx8IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0KSB7XG4gICAgICAgIF90aGlzLnNldFByZVNlbGVjdGlvbihkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLnByb3BzLmlubGluZSkge1xuICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoZGF0ZSwgZXZlbnQsIGtlZXBJbnB1dCkge1xuICAgICAgdmFyIGNoYW5nZWREYXRlID0gZGF0ZTtcblxuICAgICAgaWYgKGNoYW5nZWREYXRlICE9PSBudWxsICYmIGlzRGF5RGlzYWJsZWQoY2hhbmdlZERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTYW1lRGF5KF90aGlzLnByb3BzLnNlbGVjdGVkLCBjaGFuZ2VkRGF0ZSkgfHwgX3RoaXMucHJvcHMuYWxsb3dTYW1lRGF5KSB7XG4gICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMucHJvcHMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoa2VlcElucHV0KSBzZWxlY3RlZCA9IG5ld0RhdGUoY2hhbmdlZERhdGUpO1xuICAgICAgICAgICAgY2hhbmdlZERhdGUgPSBzZXRUaW1lKG5ld0RhdGUoY2hhbmdlZERhdGUpLCB7XG4gICAgICAgICAgICAgIGhvdXI6IGdldEhvdXIoc2VsZWN0ZWQpLFxuICAgICAgICAgICAgICBtaW51dGU6IGdldE1pbnV0ZShzZWxlY3RlZCksXG4gICAgICAgICAgICAgIHNlY29uZDogZ2V0U2Vjb25kKHNlbGVjdGVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuaW5saW5lKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIHByZVNlbGVjdGlvbjogY2hhbmdlZERhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShjaGFuZ2VkRGF0ZSwgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vblNlbGVjdChjaGFuZ2VkRGF0ZSwgZXZlbnQpO1xuXG4gICAgICBpZiAoIWtlZXBJbnB1dCkge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnNldFByZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICB2YXIgaXNEYXRlUmFuZ2VQcmVzZW50ID0gdHlwZW9mIF90aGlzLnByb3BzLm1pbkRhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIF90aGlzLnByb3BzLm1heERhdGUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICB2YXIgaXNWYWxpZERhdGVTZWxlY3Rpb24gPSBpc0RhdGVSYW5nZVByZXNlbnQgJiYgZGF0ZSA/IGlzRGF5SW5SYW5nZShkYXRlLCBfdGhpcy5wcm9wcy5taW5EYXRlLCBfdGhpcy5wcm9wcy5tYXhEYXRlKSA6IHRydWU7XG4gICAgICBpZiAoaXNWYWxpZERhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHByZVNlbGVjdGlvbjogZGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlVGltZUNoYW5nZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZCA/IF90aGlzLnByb3BzLnNlbGVjdGVkIDogX3RoaXMuZ2V0UHJlU2VsZWN0aW9uKCk7XG4gICAgICB2YXIgY2hhbmdlZERhdGUgPSBzZXRUaW1lKGNsb25lRGF0ZShzZWxlY3RlZCksIHtcbiAgICAgICAgaG91cjogZ2V0SG91cih0aW1lKSxcbiAgICAgICAgbWludXRlOiBnZXRNaW51dGUodGltZSlcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHByZVNlbGVjdGlvbjogY2hhbmdlZERhdGVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShjaGFuZ2VkRGF0ZSk7XG4gICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgIF90aGlzLnNldFN0YXRlKHsgaW5wdXRWYWx1ZTogbnVsbCB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25JbnB1dENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiAhX3RoaXMucHJvcHMucmVhZE9ubHkpIHtcbiAgICAgICAgX3RoaXMuc2V0T3Blbih0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25JbnB1dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uS2V5RG93bihldmVudCk7XG4gICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLm9wZW4gJiYgIV90aGlzLnByb3BzLmlubGluZSAmJiAhX3RoaXMucHJvcHMucHJldmVudE9wZW5PbkZvY3VzKSB7XG4gICAgICAgIGlmIChldmVudEtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBldmVudEtleSA9PT0gXCJBcnJvd1VwXCIpIHtcbiAgICAgICAgICBfdGhpcy5vbklucHV0Q2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29weSA9IG5ld0RhdGUoX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uKTtcbiAgICAgIGlmIChldmVudEtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICgoaXNNb21lbnQoX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uKSB8fCBpc0RhdGUoX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uKSkgJiYgX3RoaXMuc3RhdGUubGFzdFByZVNlbGVjdENoYW5nZSA9PT0gUFJFU0VMRUNUX0NIQU5HRV9WSUFfTkFWSUdBVEUpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVTZWxlY3QoY29weSwgZXZlbnQpO1xuICAgICAgICAgICFfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0ICYmIF90aGlzLnNldFByZVNlbGVjdGlvbihjb3B5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudEtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRLZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5wcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XG4gICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gc3VidHJhY3REYXlzKGNvcHksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGFkZERheXMoY29weSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gc3VidHJhY3RXZWVrcyhjb3B5LCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGFkZFdlZWtzKGNvcHksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlBhZ2VVcFwiOlxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gc3VidHJhY3RNb250aHMoY29weSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiUGFnZURvd25cIjpcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IGFkZE1vbnRocyhjb3B5LCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSBzdWJ0cmFjdFllYXJzKGNvcHksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gYWRkWWVhcnMoY29weSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1NlbGVjdGlvbikgcmV0dXJuOyAvLyBMZXQgdGhlIGlucHV0IGNvbXBvbmVudCBoYW5kbGUgdGhpcyBrZXlkb3duXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHsgbGFzdFByZVNlbGVjdENoYW5nZTogUFJFU0VMRUNUX0NIQU5HRV9WSUFfTkFWSUdBVEUgfSk7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGp1c3REYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZChuZXdTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNldFByZVNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkNsZWFyQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShudWxsLCBldmVudCk7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25DbGVhckNsaWNrKCk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlckNhbGVuZGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbmxpbmUgJiYgKCFfdGhpcy5zdGF0ZS5vcGVuIHx8IF90aGlzLnByb3BzLmRpc2FibGVkIHx8IF90aGlzLnByb3BzLnJlYWRPbmx5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBXcmFwcGVkQ2FsZW5kYXIsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihlbGVtKSB7XG4gICAgICAgICAgICBfdGhpcy5jYWxlbmRhciA9IGVsZW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsb2NhbGU6IF90aGlzLnByb3BzLmxvY2FsZSxcbiAgICAgICAgICBhZGp1c3REYXRlT25DaGFuZ2U6IF90aGlzLnByb3BzLmFkanVzdERhdGVPbkNoYW5nZSxcbiAgICAgICAgICBzZXRPcGVuOiBfdGhpcy5zZXRPcGVuLFxuICAgICAgICAgIGRhdGVGb3JtYXQ6IF90aGlzLnByb3BzLmRhdGVGb3JtYXRDYWxlbmRhcixcbiAgICAgICAgICB1c2VXZWVrZGF5c1Nob3J0OiBfdGhpcy5wcm9wcy51c2VXZWVrZGF5c1Nob3J0LFxuICAgICAgICAgIGZvcm1hdFdlZWtEYXk6IF90aGlzLnByb3BzLmZvcm1hdFdlZWtEYXksXG4gICAgICAgICAgZHJvcGRvd25Nb2RlOiBfdGhpcy5wcm9wcy5kcm9wZG93bk1vZGUsXG4gICAgICAgICAgc2VsZWN0ZWQ6IF90aGlzLnByb3BzLnNlbGVjdGVkLFxuICAgICAgICAgIHByZVNlbGVjdGlvbjogX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uLFxuICAgICAgICAgIG9uU2VsZWN0OiBfdGhpcy5oYW5kbGVTZWxlY3QsXG4gICAgICAgICAgb25XZWVrU2VsZWN0OiBfdGhpcy5wcm9wcy5vbldlZWtTZWxlY3QsXG4gICAgICAgICAgb3BlblRvRGF0ZTogX3RoaXMucHJvcHMub3BlblRvRGF0ZSxcbiAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgICAgc2VsZWN0c1N0YXJ0OiBfdGhpcy5wcm9wcy5zZWxlY3RzU3RhcnQsXG4gICAgICAgICAgc2VsZWN0c0VuZDogX3RoaXMucHJvcHMuc2VsZWN0c0VuZCxcbiAgICAgICAgICBzdGFydERhdGU6IF90aGlzLnByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICBlbmREYXRlOiBfdGhpcy5wcm9wcy5lbmREYXRlLFxuICAgICAgICAgIGV4Y2x1ZGVEYXRlczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVzLFxuICAgICAgICAgIGZpbHRlckRhdGU6IF90aGlzLnByb3BzLmZpbHRlckRhdGUsXG4gICAgICAgICAgb25DbGlja091dHNpZGU6IF90aGlzLmhhbmRsZUNhbGVuZGFyQ2xpY2tPdXRzaWRlLFxuICAgICAgICAgIGZvcm1hdFdlZWtOdW1iZXI6IF90aGlzLnByb3BzLmZvcm1hdFdlZWtOdW1iZXIsXG4gICAgICAgICAgaGlnaGxpZ2h0RGF0ZXM6IF90aGlzLnN0YXRlLmhpZ2hsaWdodERhdGVzLFxuICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgIGluY2x1ZGVUaW1lczogX3RoaXMucHJvcHMuaW5jbHVkZVRpbWVzLFxuICAgICAgICAgIGluamVjdFRpbWVzOiBfdGhpcy5wcm9wcy5pbmplY3RUaW1lcyxcbiAgICAgICAgICBpbmxpbmU6IF90aGlzLnByb3BzLmlubGluZSxcbiAgICAgICAgICBwZWVrTmV4dE1vbnRoOiBfdGhpcy5wcm9wcy5wZWVrTmV4dE1vbnRoLFxuICAgICAgICAgIHNob3dNb250aERyb3Bkb3duOiBfdGhpcy5wcm9wcy5zaG93TW9udGhEcm9wZG93bixcbiAgICAgICAgICB1c2VTaG9ydE1vbnRoSW5Ecm9wZG93bjogX3RoaXMucHJvcHMudXNlU2hvcnRNb250aEluRHJvcGRvd24sXG4gICAgICAgICAgc2hvd01vbnRoWWVhckRyb3Bkb3duOiBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyRHJvcGRvd24sXG4gICAgICAgICAgc2hvd1dlZWtOdW1iZXJzOiBfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlcnMsXG4gICAgICAgICAgc2hvd1llYXJEcm9wZG93bjogX3RoaXMucHJvcHMuc2hvd1llYXJEcm9wZG93bixcbiAgICAgICAgICB3aXRoUG9ydGFsOiBfdGhpcy5wcm9wcy53aXRoUG9ydGFsLFxuICAgICAgICAgIGZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbjogX3RoaXMucHJvcHMuZm9yY2VTaG93TW9udGhOYXZpZ2F0aW9uLFxuICAgICAgICAgIHNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbjogX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uLFxuICAgICAgICAgIHNjcm9sbGFibGVZZWFyRHJvcGRvd246IF90aGlzLnByb3BzLnNjcm9sbGFibGVZZWFyRHJvcGRvd24sXG4gICAgICAgICAgc2Nyb2xsYWJsZU1vbnRoWWVhckRyb3Bkb3duOiBfdGhpcy5wcm9wcy5zY3JvbGxhYmxlTW9udGhZZWFyRHJvcGRvd24sXG4gICAgICAgICAgdG9kYXlCdXR0b246IF90aGlzLnByb3BzLnRvZGF5QnV0dG9uLFxuICAgICAgICAgIHdlZWtMYWJlbDogX3RoaXMucHJvcHMud2Vla0xhYmVsLFxuICAgICAgICAgIHV0Y09mZnNldDogX3RoaXMucHJvcHMudXRjT2Zmc2V0LFxuICAgICAgICAgIG91dHNpZGVDbGlja0lnbm9yZUNsYXNzOiBvdXRzaWRlQ2xpY2tJZ25vcmVDbGFzcyxcbiAgICAgICAgICBmaXhlZEhlaWdodDogX3RoaXMucHJvcHMuZml4ZWRIZWlnaHQsXG4gICAgICAgICAgbW9udGhzU2hvd246IF90aGlzLnByb3BzLm1vbnRoc1Nob3duLFxuICAgICAgICAgIG9uRHJvcGRvd25Gb2N1czogX3RoaXMuaGFuZGxlRHJvcGRvd25Gb2N1cyxcbiAgICAgICAgICBvbk1vbnRoQ2hhbmdlOiBfdGhpcy5wcm9wcy5vbk1vbnRoQ2hhbmdlLFxuICAgICAgICAgIG9uWWVhckNoYW5nZTogX3RoaXMucHJvcHMub25ZZWFyQ2hhbmdlLFxuICAgICAgICAgIGRheUNsYXNzTmFtZTogX3RoaXMucHJvcHMuZGF5Q2xhc3NOYW1lLFxuICAgICAgICAgIHNob3dUaW1lU2VsZWN0OiBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCxcbiAgICAgICAgICBzaG93VGltZVNlbGVjdE9ubHk6IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSxcbiAgICAgICAgICBvblRpbWVDaGFuZ2U6IF90aGlzLmhhbmRsZVRpbWVDaGFuZ2UsXG4gICAgICAgICAgdGltZUZvcm1hdDogX3RoaXMucHJvcHMudGltZUZvcm1hdCxcbiAgICAgICAgICB0aW1lSW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy50aW1lSW50ZXJ2YWxzLFxuICAgICAgICAgIG1pblRpbWU6IF90aGlzLnByb3BzLm1pblRpbWUsXG4gICAgICAgICAgbWF4VGltZTogX3RoaXMucHJvcHMubWF4VGltZSxcbiAgICAgICAgICBleGNsdWRlVGltZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVUaW1lcyxcbiAgICAgICAgICB0aW1lQ2FwdGlvbjogX3RoaXMucHJvcHMudGltZUNhcHRpb24sXG4gICAgICAgICAgY2xhc3NOYW1lOiBfdGhpcy5wcm9wcy5jYWxlbmRhckNsYXNzTmFtZSxcbiAgICAgICAgICBjb250YWluZXI6IF90aGlzLnByb3BzLmNhbGVuZGFyQ29udGFpbmVyLFxuICAgICAgICAgIHllYXJEcm9wZG93bkl0ZW1OdW1iZXI6IF90aGlzLnByb3BzLnllYXJEcm9wZG93bkl0ZW1OdW1iZXIsXG4gICAgICAgICAgcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsOiBfdGhpcy5wcm9wcy5wcmV2aW91c01vbnRoQnV0dG9uTGFiZWwsXG4gICAgICAgICAgbmV4dE1vbnRoQnV0dG9uTGFiZWw6IF90aGlzLnByb3BzLm5leHRNb250aEJ1dHRvbkxhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIF90aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJEYXRlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NsYXNzbmFtZXMsIF9SZWFjdCRjbG9uZUVsZW1lbnQ7XG5cbiAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc25hbWVzKF90aGlzLnByb3BzLmNsYXNzTmFtZSwgKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW291dHNpZGVDbGlja0lnbm9yZUNsYXNzXSA9IF90aGlzLnN0YXRlLm9wZW4sIF9jbGFzc25hbWVzKSk7XG5cbiAgICAgIHZhciBjdXN0b21JbnB1dCA9IF90aGlzLnByb3BzLmN1c3RvbUlucHV0IHx8IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwidGV4dFwiIH0pO1xuICAgICAgdmFyIGN1c3RvbUlucHV0UmVmID0gX3RoaXMucHJvcHMuY3VzdG9tSW5wdXRSZWYgfHwgXCJyZWZcIjtcbiAgICAgIHZhciBpbnB1dFZhbHVlID0gdHlwZW9mIF90aGlzLnByb3BzLnZhbHVlID09PSBcInN0cmluZ1wiID8gX3RoaXMucHJvcHMudmFsdWUgOiB0eXBlb2YgX3RoaXMuc3RhdGUuaW5wdXRWYWx1ZSA9PT0gXCJzdHJpbmdcIiA/IF90aGlzLnN0YXRlLmlucHV0VmFsdWUgOiBzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwgX3RoaXMucHJvcHMpO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGN1c3RvbUlucHV0LCAoX1JlYWN0JGNsb25lRWxlbWVudCA9IHt9LCBfUmVhY3QkY2xvbmVFbGVtZW50W2N1c3RvbUlucHV0UmVmXSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgfSwgX1JlYWN0JGNsb25lRWxlbWVudC52YWx1ZSA9IGlucHV0VmFsdWUsIF9SZWFjdCRjbG9uZUVsZW1lbnQub25CbHVyID0gX3RoaXMuaGFuZGxlQmx1ciwgX1JlYWN0JGNsb25lRWxlbWVudC5vbkNoYW5nZSA9IF90aGlzLmhhbmRsZUNoYW5nZSwgX1JlYWN0JGNsb25lRWxlbWVudC5vbkNsaWNrID0gX3RoaXMub25JbnB1dENsaWNrLCBfUmVhY3QkY2xvbmVFbGVtZW50Lm9uRm9jdXMgPSBfdGhpcy5oYW5kbGVGb2N1cywgX1JlYWN0JGNsb25lRWxlbWVudC5vbktleURvd24gPSBfdGhpcy5vbklucHV0S2V5RG93biwgX1JlYWN0JGNsb25lRWxlbWVudC5pZCA9IF90aGlzLnByb3BzLmlkLCBfUmVhY3QkY2xvbmVFbGVtZW50Lm5hbWUgPSBfdGhpcy5wcm9wcy5uYW1lLCBfUmVhY3QkY2xvbmVFbGVtZW50LmF1dG9Gb2N1cyA9IF90aGlzLnByb3BzLmF1dG9Gb2N1cywgX1JlYWN0JGNsb25lRWxlbWVudC5wbGFjZWhvbGRlciA9IF90aGlzLnByb3BzLnBsYWNlaG9sZGVyVGV4dCwgX1JlYWN0JGNsb25lRWxlbWVudC5kaXNhYmxlZCA9IF90aGlzLnByb3BzLmRpc2FibGVkLCBfUmVhY3QkY2xvbmVFbGVtZW50LmF1dG9Db21wbGV0ZSA9IF90aGlzLnByb3BzLmF1dG9Db21wbGV0ZSwgX1JlYWN0JGNsb25lRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUsIF9SZWFjdCRjbG9uZUVsZW1lbnQudGl0bGUgPSBfdGhpcy5wcm9wcy50aXRsZSwgX1JlYWN0JGNsb25lRWxlbWVudC5yZWFkT25seSA9IF90aGlzLnByb3BzLnJlYWRPbmx5LCBfUmVhY3QkY2xvbmVFbGVtZW50LnJlcXVpcmVkID0gX3RoaXMucHJvcHMucmVxdWlyZWQsIF9SZWFjdCRjbG9uZUVsZW1lbnQudGFiSW5kZXggPSBfdGhpcy5wcm9wcy50YWJJbmRleCwgX1JlYWN0JGNsb25lRWxlbWVudCkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJDbGVhckJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5pc0NsZWFyYWJsZSAmJiBfdGhpcy5wcm9wcy5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19jbG9zZS1pY29uXCIsXG4gICAgICAgICAgb25DbGljazogX3RoaXMub25DbGVhckNsaWNrLFxuICAgICAgICAgIHRpdGxlOiBfdGhpcy5wcm9wcy5jbGVhckJ1dHRvblRpdGxlLFxuICAgICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNhbGNJbml0aWFsU3RhdGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBEYXRlUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICBpZiAocHJldlByb3BzLmlubGluZSAmJiBoYXNQcmVTZWxlY3Rpb25DaGFuZ2VkKHByZXZQcm9wcy5zZWxlY3RlZCwgdGhpcy5wcm9wcy5zZWxlY3RlZCkpIHtcbiAgICAgIHRoaXMuc2V0UHJlU2VsZWN0aW9uKHRoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLmhpZ2hsaWdodERhdGVzICE9PSB0aGlzLnByb3BzLmhpZ2hsaWdodERhdGVzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGlnaGxpZ2h0RGF0ZXM6IGdldEhpZ2h0TGlnaHREYXlzTWFwKHRoaXMucHJvcHMuaGlnaGxpZ2h0RGF0ZXMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcmV2U3RhdGUuZm9jdXNlZCAmJiBoYXNTZWxlY3Rpb25DaGFuZ2VkKHByZXZQcm9wcy5zZWxlY3RlZCwgdGhpcy5wcm9wcy5zZWxlY3RlZCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbnB1dFZhbHVlOiBudWxsIH0pO1xuICAgIH1cbiAgfTtcblxuICBEYXRlUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJQcmV2ZW50Rm9jdXNUaW1lb3V0KCk7XG4gIH07XG5cbiAgRGF0ZVBpY2tlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjYWxlbmRhciA9IHRoaXMucmVuZGVyQ2FsZW5kYXIoKTtcblxuICAgIGlmICh0aGlzLnByb3BzLmlubGluZSAmJiAhdGhpcy5wcm9wcy53aXRoUG9ydGFsKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMud2l0aFBvcnRhbCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIG51bGwsXG4gICAgICAgICF0aGlzLnByb3BzLmlubGluZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19pbnB1dC1jb250YWluZXJcIiB9LFxuICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZUlucHV0KCksXG4gICAgICAgICAgdGhpcy5yZW5kZXJDbGVhckJ1dHRvbigpXG4gICAgICAgICkgOiBudWxsLFxuICAgICAgICB0aGlzLnN0YXRlLm9wZW4gfHwgdGhpcy5wcm9wcy5pbmxpbmUgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fcG9ydGFsXCIgfSxcbiAgICAgICAgICBjYWxlbmRhclxuICAgICAgICApIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQb3BwZXJDb21wb25lbnQsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5wb3BwZXJDbGFzc05hbWUsXG4gICAgICBoaWRlUG9wcGVyOiAhdGhpcy5zdGF0ZS5vcGVuIHx8IHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgdGhpcy5wcm9wcy5yZWFkT25seSxcbiAgICAgIHBvcHBlck1vZGlmaWVyczogdGhpcy5wcm9wcy5wb3BwZXJNb2RpZmllcnMsXG4gICAgICB0YXJnZXRDb21wb25lbnQ6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2lucHV0LWNvbnRhaW5lclwiIH0sXG4gICAgICAgIHRoaXMucmVuZGVyRGF0ZUlucHV0KCksXG4gICAgICAgIHRoaXMucmVuZGVyQ2xlYXJCdXR0b24oKVxuICAgICAgKSxcbiAgICAgIHBvcHBlckNvbnRhaW5lcjogdGhpcy5wcm9wcy5wb3BwZXJDb250YWluZXIsXG4gICAgICBwb3BwZXJDb21wb25lbnQ6IGNhbGVuZGFyLFxuICAgICAgcG9wcGVyUGxhY2VtZW50OiB0aGlzLnByb3BzLnBvcHBlclBsYWNlbWVudFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBEYXRlUGlja2VyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5EYXRlUGlja2VyLnByb3BUeXBlcyA9IHtcbiAgYWRqdXN0RGF0ZU9uQ2hhbmdlOiBQcm9wVHlwZXMuYm9vbCxcbiAgYWxsb3dTYW1lRGF5OiBQcm9wVHlwZXMuYm9vbCxcbiAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICBjYWxlbmRhckNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2FsZW5kYXJDb250YWluZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY3VzdG9tSW5wdXQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBjdXN0b21JbnB1dFJlZjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIGRhdGVGb3JtYXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICBkYXRlRm9ybWF0Q2FsZW5kYXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRheUNsYXNzTmFtZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb246IFByb3BUeXBlcy5ib29sLFxuICBkcm9wZG93bk1vZGU6IFByb3BUeXBlcy5vbmVPZihbXCJzY3JvbGxcIiwgXCJzZWxlY3RcIl0pLmlzUmVxdWlyZWQsXG4gIGVuZERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGV4Y2x1ZGVEYXRlczogUHJvcFR5cGVzLmFycmF5LFxuICBmaWx0ZXJEYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZml4ZWRIZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBmb3JtYXRXZWVrTnVtYmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgaGlnaGxpZ2h0RGF0ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVEYXRlczogUHJvcFR5cGVzLmFycmF5LFxuICBpbmNsdWRlVGltZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaW5qZWN0VGltZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgaXNDbGVhcmFibGU6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1vbnRoc1Nob3duOiBQcm9wVHlwZXMubnVtYmVyLFxuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBvbldlZWtTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNsaWNrT3V0c2lkZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2hhbmdlUmF3OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW9udGhDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICBvblllYXJDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICBvcGVuVG9EYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBwZWVrTmV4dE1vbnRoOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGxhY2Vob2xkZXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBwb3BwZXJDb250YWluZXI6IFByb3BUeXBlcy5mdW5jLFxuICBwb3BwZXJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsIC8vIDxQb3BwZXJDb21wb25lbnQvPiBwcm9wc1xuICBwb3BwZXJNb2RpZmllcnM6IFByb3BUeXBlcy5vYmplY3QsIC8vIDxQb3BwZXJDb21wb25lbnQvPiBwcm9wc1xuICBwb3BwZXJQbGFjZW1lbnQ6IFByb3BUeXBlcy5vbmVPZihwb3BwZXJQbGFjZW1lbnRQb3NpdGlvbnMpLCAvLyA8UG9wcGVyQ29tcG9uZW50Lz4gcHJvcHNcbiAgcHJldmVudE9wZW5PbkZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIHNjcm9sbGFibGVZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBzY3JvbGxhYmxlTW9udGhZZWFyRHJvcGRvd246IFByb3BUeXBlcy5ib29sLFxuICBzZWxlY3RlZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0c0VuZDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbGVjdHNTdGFydDogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dNb250aERyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd01vbnRoWWVhckRyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd1dlZWtOdW1iZXJzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd1llYXJEcm9wZG93bjogUHJvcFR5cGVzLmJvb2wsXG4gIGZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dEaXNhYmxlZE1vbnRoTmF2aWdhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gIHN0YXJ0RGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgc3RhcnRPcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpbWVDYXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9kYXlCdXR0b246IFByb3BUeXBlcy5zdHJpbmcsXG4gIHVzZVdlZWtkYXlzU2hvcnQ6IFByb3BUeXBlcy5ib29sLFxuICBmb3JtYXRXZWVrRGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgdXRjT2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2Vla0xhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3aXRoUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgeWVhckRyb3Bkb3duSXRlbU51bWJlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgc2hvdWxkQ2xvc2VPblNlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dUaW1lU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd1RpbWVTZWxlY3RPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgdGltZUZvcm1hdDogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGltZUludGVydmFsczogUHJvcFR5cGVzLm51bWJlcixcbiAgbWluVGltZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgbWF4VGltZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgZXhjbHVkZVRpbWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIHVzZVNob3J0TW9udGhJbkRyb3Bkb3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2xlYXJCdXR0b25UaXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBuZXh0TW9udGhCdXR0b25MYWJlbDogUHJvcFR5cGVzLnN0cmluZ1xufTtcbnZhciBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9JTlBVVCA9IFwiaW5wdXRcIjtcbnZhciBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9OQVZJR0FURSA9IFwibmF2aWdhdGVcIjtcblxuZXhwb3J0IHsgQ2FsZW5kYXJDb250YWluZXIgfTtcbmV4cG9ydCBkZWZhdWx0IERhdGVQaWNrZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRlcGlja2VyL2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB0aHJvdyBlcnI7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgc29tZSBET00gbm9kZSBpcyBvdXIgQ29tcG9uZW50J3Mgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlRm91bmQoY3VycmVudCwgY29tcG9uZW50Tm9kZSwgaWdub3JlQ2xhc3MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IGNvbXBvbmVudE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTVkcgPHVzZS8+IGVsZW1lbnRzIGRvIG5vdCB0ZWNobmljYWxseSByZXNpZGUgaW4gdGhlIHJlbmRlcmVkIERPTSwgc29cbiAgLy8gdGhleSBkbyBub3QgaGF2ZSBjbGFzc0xpc3QgZGlyZWN0bHksIGJ1dCB0aGV5IG9mZmVyIGEgbGluayB0byB0aGVpclxuICAvLyBjb3JyZXNwb25kaW5nIGVsZW1lbnQsIHdoaWNoIGNhbiBoYXZlIGNsYXNzTGlzdC4gVGhpcyBleHRyYSBjaGVjayBpcyBmb3JcbiAgLy8gdGhhdCBjYXNlLlxuICAvLyBTZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3N0cnVjdC5odG1sI0ludGVyZmFjZVNWR1VzZUVsZW1lbnRcbiAgLy8gRGlzY3Vzc2lvbjogaHR0cHM6Ly9naXRodWIuY29tL1BvbWF4L3JlYWN0LW9uY2xpY2tvdXRzaWRlL3B1bGwvMTdcblxuXG4gIGlmIChjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIGN1cnJlbnQuY29ycmVzcG9uZGluZ0VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcyk7XG59XG4vKipcbiAqIFRyeSB0byBmaW5kIG91ciBub2RlIGluIGEgaGllcmFyY2h5IG9mIG5vZGVzLCByZXR1cm5pbmcgdGhlIGRvY3VtZW50XG4gKiBub2RlIGFzIGhpZ2hlc3Qgbm9kZSBpZiBvdXIgbm9kZSBpcyBub3QgZm91bmQgaW4gdGhlIHBhdGggdXAuXG4gKi9cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3QoY3VycmVudCwgY29tcG9uZW50Tm9kZSwgaWdub3JlQ2xhc3MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IGNvbXBvbmVudE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBzb3VyY2U9bG9jYWwgdGhlbiB0aGlzIGV2ZW50IGNhbWUgZnJvbSAnc29tZXdoZXJlJ1xuICAvLyBpbnNpZGUgYW5kIHNob3VsZCBiZSBpZ25vcmVkLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyB3aXRoXG4gIC8vIGEgbGF5ZXJlZCBhcHByb2FjaCwgdG9vLCBidXQgdGhhdCByZXF1aXJlcyBnb2luZyBiYWNrIHRvXG4gIC8vIHRoaW5raW5nIGluIHRlcm1zIG9mIERvbSBub2RlIG5lc3RpbmcsIHJ1bm5pbmcgY291bnRlclxuICAvLyB0byBSZWFjdCdzICd5b3Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIERPTScgcGhpbG9zb3BoeS5cblxuXG4gIHdoaWxlIChjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICBpZiAoaXNOb2RlRm91bmQoY3VycmVudCwgY29tcG9uZW50Tm9kZSwgaWdub3JlQ2xhc3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBicm93c2VyIHNjcm9sbGJhciB3YXMgY2xpY2tlZFxuICovXG5cbmZ1bmN0aW9uIGNsaWNrZWRTY3JvbGxiYXIoZXZ0KSB7XG4gIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPD0gZXZ0LmNsaWVudFggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA8PSBldnQuY2xpZW50WTtcbn1cblxuLy8gaWRlYWxseSB3aWxsIGdldCByZXBsYWNlZCB3aXRoIGV4dGVybmFsIGRlcFxuLy8gd2hlbiByYWZyZXgvZGV0ZWN0LXBhc3NpdmUtZXZlbnRzIzQgYW5kIHJhZnJleC9kZXRlY3QtcGFzc2l2ZS1ldmVudHMjNSBnZXQgbWVyZ2VkIGluXG52YXIgdGVzdFBhc3NpdmVFdmVudFN1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXNzaXZlID0gZmFsc2U7XG4gIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHBhc3NpdmUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0Jywgbm9vcCwgb3B0aW9ucyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIG5vb3AsIG9wdGlvbnMpO1xuICByZXR1cm4gcGFzc2l2ZTtcbn07XG5cbmZ1bmN0aW9uIGF1dG9JbmMoc2VlZCkge1xuICBpZiAoc2VlZCA9PT0gdm9pZCAwKSB7XG4gICAgc2VlZCA9IDA7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiArK3NlZWQ7XG4gIH07XG59XG5cbnZhciB1aWQgPSBhdXRvSW5jKCk7XG5cbnZhciBwYXNzaXZlRXZlbnRTdXBwb3J0O1xudmFyIGhhbmRsZXJzTWFwID0ge307XG52YXIgZW5hYmxlZEluc3RhbmNlcyA9IHt9O1xudmFyIHRvdWNoRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddO1xudmFyIElHTk9SRV9DTEFTU19OQU1FID0gJ2lnbm9yZS1yZWFjdC1vbmNsaWNrb3V0c2lkZSc7XG4vKipcbiAqIE9wdGlvbnMgZm9yIGFkZEV2ZW50SGFuZGxlciBhbmQgcmVtb3ZlRXZlbnRIYW5kbGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyT3B0aW9ucyhpbnN0YW5jZSwgZXZlbnROYW1lKSB7XG4gIHZhciBoYW5kbGVyT3B0aW9ucyA9IG51bGw7XG4gIHZhciBpc1RvdWNoRXZlbnQgPSB0b3VjaEV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xO1xuXG4gIGlmIChpc1RvdWNoRXZlbnQgJiYgcGFzc2l2ZUV2ZW50U3VwcG9ydCkge1xuICAgIGhhbmRsZXJPcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogIWluc3RhbmNlLnByb3BzLnByZXZlbnREZWZhdWx0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyT3B0aW9ucztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdGhlIEhPQyBmdW5jdGlvbiB0aGF0IHlvdSdsbCB1c2VcbiAqIGluIG9yZGVyIHRvIGltcGFydCBvbk91dHNpZGVDbGljayBsaXN0ZW5pbmcgdG8gYW5cbiAqIGFyYml0cmFyeSBjb21wb25lbnQuIEl0IGdldHMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlXG4gKiBib290c3RyYXBwaW5nIGNvZGUgdG8geWllbGQgYW4gaW5zdGFuY2Ugb2YgdGhlXG4gKiBvbkNsaWNrT3V0c2lkZUhPQyBmdW5jdGlvbiBkZWZpbmVkIGluc2lkZSBzZXR1cEhPQygpLlxuICovXG5cblxuZnVuY3Rpb24gb25DbGlja091dHNpZGVIT0MoV3JhcHBlZENvbXBvbmVudCwgY29uZmlnKSB7XG4gIHZhciBfY2xhc3MsIF90ZW1wO1xuXG4gIHJldHVybiBfdGVtcCA9IF9jbGFzcyA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShvbkNsaWNrT3V0c2lkZSwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrT3V0c2lkZShwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuX19vdXRzaWRlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXMuX19jbGlja091dHNpZGVIYW5kbGVyUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF90aGlzLl9fY2xpY2tPdXRzaWRlSGFuZGxlclByb3AoZXZlbnQpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluc3RhbmNlID0gX3RoaXMuZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLnByb3BzLmhhbmRsZUNsaWNrT3V0c2lkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzLmhhbmRsZUNsaWNrT3V0c2lkZShldmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5oYW5kbGVDbGlja091dHNpZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oYW5kbGVDbGlja091dHNpZGUoZXZlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JhcHBlZENvbXBvbmVudCBsYWNrcyBhIGhhbmRsZUNsaWNrT3V0c2lkZShldmVudCkgZnVuY3Rpb24gZm9yIHByb2Nlc3Npbmcgb3V0c2lkZSBjbGljayBldmVudHMuJyk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5lbmFibGVPbkNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZW5hYmxlZEluc3RhbmNlc1tfdGhpcy5fdWlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc2l2ZUV2ZW50U3VwcG9ydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwYXNzaXZlRXZlbnRTdXBwb3J0ID0gdGVzdFBhc3NpdmVFdmVudFN1cHBvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYWJsZWRJbnN0YW5jZXNbX3RoaXMuX3VpZF0gPSB0cnVlO1xuICAgICAgICB2YXIgZXZlbnRzID0gX3RoaXMucHJvcHMuZXZlbnRUeXBlcztcblxuICAgICAgICBpZiAoIWV2ZW50cy5mb3JFYWNoKSB7XG4gICAgICAgICAgZXZlbnRzID0gW2V2ZW50c107XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVyc01hcFtfdGhpcy5fdWlkXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlT25DbGlja091dHNpZGUpIHJldHVybjtcbiAgICAgICAgICBpZiAoX3RoaXMuY29tcG9uZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5leGNsdWRlU2Nyb2xsYmFyICYmIGNsaWNrZWRTY3JvbGxiYXIoZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAoZmluZEhpZ2hlc3QoY3VycmVudCwgX3RoaXMuY29tcG9uZW50Tm9kZSwgX3RoaXMucHJvcHMub3V0c2lkZUNsaWNrSWdub3JlQ2xhc3MpICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLl9fb3V0c2lkZUNsaWNrSGFuZGxlcihldmVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyc01hcFtfdGhpcy5fdWlkXSwgZ2V0RXZlbnRIYW5kbGVyT3B0aW9ucyhfdGhpcywgZXZlbnROYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuZGlzYWJsZU9uQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgZW5hYmxlZEluc3RhbmNlc1tfdGhpcy5fdWlkXTtcbiAgICAgICAgdmFyIGZuID0gaGFuZGxlcnNNYXBbX3RoaXMuX3VpZF07XG5cbiAgICAgICAgaWYgKGZuICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgZXZlbnRzID0gX3RoaXMucHJvcHMuZXZlbnRUeXBlcztcblxuICAgICAgICAgIGlmICghZXZlbnRzLmZvckVhY2gpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGdldEV2ZW50SGFuZGxlck9wdGlvbnMoX3RoaXMsIGV2ZW50TmFtZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc01hcFtfdGhpcy5fdWlkXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuZ2V0UmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICByZXR1cm4gX3RoaXMuaW5zdGFuY2VSZWYgPSByZWY7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5fdWlkID0gdWlkKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgV3JhcHBlZENvbXBvbmVudCdzIGluc3RhbmNlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gb25DbGlja091dHNpZGUucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gICAgICBpZiAoIVdyYXBwZWRDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSB0aGlzLmluc3RhbmNlUmVmO1xuICAgICAgcmV0dXJuIHJlZi5nZXRJbnN0YW5jZSA/IHJlZi5nZXRJbnN0YW5jZSgpIDogcmVmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY2xpY2sgbGlzdGVuZXJzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50LFxuICAgICAqIGxpbmtlZCB0byB0aGlzIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgICAqL1xuICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgLy8gSWYgd2UgYXJlIGluIGFuIGVudmlyb25tZW50IHdpdGhvdXQgYSBET00gc3VjaFxuICAgICAgLy8gYXMgc2hhbGxvdyByZW5kZXJpbmcgb3Igc25hcHNob3RzIHRoZW4gd2UgZXhpdFxuICAgICAgLy8gZWFybHkgdG8gcHJldmVudCBhbnkgdW5oYW5kbGVkIGVycm9ycyBiZWluZyB0aHJvd24uXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLmhhbmRsZUNsaWNrT3V0c2lkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9fY2xpY2tPdXRzaWRlSGFuZGxlclByb3AgPSBjb25maWcuaGFuZGxlQ2xpY2tPdXRzaWRlKGluc3RhbmNlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX19jbGlja091dHNpZGVIYW5kbGVyUHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JhcHBlZENvbXBvbmVudCBsYWNrcyBhIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIG91dHNpZGUgY2xpY2sgZXZlbnRzIHNwZWNpZmllZCBieSB0aGUgaGFuZGxlQ2xpY2tPdXRzaWRlIGNvbmZpZyBvcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wb25lbnROb2RlID0gZmluZERPTU5vZGUodGhpcy5nZXRJbnN0YW5jZSgpKTtcbiAgICAgIHRoaXMuZW5hYmxlT25DbGlja091dHNpZGUoKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMuZ2V0SW5zdGFuY2UoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRvY3VtZW50J3MgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuXG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuZGlzYWJsZU9uQ2xpY2tPdXRzaWRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW4gYmUgY2FsbGVkIHRvIGV4cGxpY2l0bHkgZW5hYmxlIGV2ZW50IGxpc3RlbmluZ1xuICAgICAqIGZvciBjbGlja3MgYW5kIHRvdWNoZXMgb3V0c2lkZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFBhc3MtdGhyb3VnaCByZW5kZXJcbiAgICAgKi9cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBleGNsdWRlU2Nyb2xsYmFyID0gX3Byb3BzLmV4Y2x1ZGVTY3JvbGxiYXIsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbXCJleGNsdWRlU2Nyb2xsYmFyXCJdKTtcblxuICAgICAgaWYgKFdyYXBwZWRDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgcHJvcHMucmVmID0gdGhpcy5nZXRSZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy53cmFwcGVkUmVmID0gdGhpcy5nZXRSZWY7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLmRpc2FibGVPbkNsaWNrT3V0c2lkZSA9IHRoaXMuZGlzYWJsZU9uQ2xpY2tPdXRzaWRlO1xuICAgICAgcHJvcHMuZW5hYmxlT25DbGlja091dHNpZGUgPSB0aGlzLmVuYWJsZU9uQ2xpY2tPdXRzaWRlO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgcHJvcHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gb25DbGlja091dHNpZGU7XG4gIH0oQ29tcG9uZW50KSwgX2NsYXNzLmRpc3BsYXlOYW1lID0gXCJPbkNsaWNrT3V0c2lkZShcIiArIChXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgKyBcIilcIiwgX2NsYXNzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBldmVudFR5cGVzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZXhjbHVkZVNjcm9sbGJhcjogY29uZmlnICYmIGNvbmZpZy5leGNsdWRlU2Nyb2xsYmFyIHx8IGZhbHNlLFxuICAgIG91dHNpZGVDbGlja0lnbm9yZUNsYXNzOiBJR05PUkVfQ0xBU1NfTkFNRSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZVxuICB9LCBfY2xhc3MuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZ2V0Q2xhc3MgPyBXcmFwcGVkQ29tcG9uZW50LmdldENsYXNzKCkgOiBXcmFwcGVkQ29tcG9uZW50O1xuICB9LCBfdGVtcDtcbn1cblxuZXhwb3J0IHsgSUdOT1JFX0NMQVNTX05BTUUgfTtcbmV4cG9ydCBkZWZhdWx0IG9uQ2xpY2tPdXRzaWRlSE9DO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtb25jbGlja291dHNpZGUvZGlzdC9yZWFjdC1vbmNsaWNrb3V0c2lkZS5lcy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBNYW5hZ2VyIH0gZnJvbSAnLi9NYW5hZ2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFyZ2V0IH0gZnJvbSAnLi9UYXJnZXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3BwZXIsIHBsYWNlbWVudHMgfSBmcm9tICcuL1BvcHBlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFycm93IH0gZnJvbSAnLi9BcnJvdyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcG9wcGVyL2xpYi9yZWFjdC1wb3BwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG52YXIgTWFuYWdlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNYW5hZ2VyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNYW5hZ2VyKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYW5hZ2VyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBNYW5hZ2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFuYWdlcikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLl9zZXRUYXJnZXROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLl90YXJnZXROb2RlID0gbm9kZTtcbiAgICB9LCBfdGhpcy5fZ2V0VGFyZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fdGFyZ2V0Tm9kZTtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYW5hZ2VyLCBbe1xuICAgIGtleTogJ2dldENoaWxkQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvcHBlck1hbmFnZXI6IHtcbiAgICAgICAgICBzZXRUYXJnZXROb2RlOiB0aGlzLl9zZXRUYXJnZXROb2RlLFxuICAgICAgICAgIGdldFRhcmdldE5vZGU6IHRoaXMuX2dldFRhcmdldE5vZGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB0YWcgPSBfcHJvcHMudGFnLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsndGFnJywgJ2NoaWxkcmVuJ10pO1xuXG4gICAgICBpZiAodGFnICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcsIHJlc3RQcm9wcywgY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYW5hZ2VyO1xufShDb21wb25lbnQpO1xuXG5NYW5hZ2VyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBwb3BwZXJNYW5hZ2VyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5NYW5hZ2VyLnByb3BUeXBlcyA9IHtcbiAgdGFnOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbF0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5NYW5hZ2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBNYW5hZ2VyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudmFyIFRhcmdldCA9IGZ1bmN0aW9uIFRhcmdldChwcm9wcywgY29udGV4dCkge1xuICB2YXIgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIGNvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHVuZGVmaW5lZCA/ICdkaXYnIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbJ2NvbXBvbmVudCcsICdpbm5lclJlZicsICdjaGlsZHJlbiddKTtcblxuICB2YXIgcG9wcGVyTWFuYWdlciA9IGNvbnRleHQucG9wcGVyTWFuYWdlcjtcblxuICB2YXIgdGFyZ2V0UmVmID0gZnVuY3Rpb24gdGFyZ2V0UmVmKG5vZGUpIHtcbiAgICBwb3BwZXJNYW5hZ2VyLnNldFRhcmdldE5vZGUobm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpbm5lclJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5uZXJSZWYobm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGFyZ2V0UHJvcHMgPSB7IHJlZjogdGFyZ2V0UmVmIH07XG4gICAgcmV0dXJuIGNoaWxkcmVuKHsgdGFyZ2V0UHJvcHM6IHRhcmdldFByb3BzLCByZXN0UHJvcHM6IHJlc3RQcm9wcyB9KTtcbiAgfVxuXG4gIHZhciBjb21wb25lbnRQcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0UHJvcHMpO1xuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBvbmVudFByb3BzLnJlZiA9IHRhcmdldFJlZjtcbiAgfSBlbHNlIHtcbiAgICBjb21wb25lbnRQcm9wcy5pbm5lclJlZiA9IHRhcmdldFJlZjtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIGNoaWxkcmVuKTtcbn07XG5cblRhcmdldC5jb250ZXh0VHlwZXMgPSB7XG4gIHBvcHBlck1hbmFnZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuVGFyZ2V0LnByb3BUeXBlcyA9IHtcbiAgY29tcG9uZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRhcmdldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1wb3BwZXIvbGliL1RhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUG9wcGVySlMgZnJvbSAncG9wcGVyLmpzJztcblxuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gUG9wcGVySlMucGxhY2VtZW50cztcblxudmFyIFBvcHBlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQb3BwZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvcHBlcigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBQb3BwZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQb3BwZXIpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHt9LCBfdGhpcy5fc2V0QXJyb3dOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLl9hcnJvd05vZGUgPSBub2RlO1xuICAgIH0sIF90aGlzLl9nZXRUYXJnZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMudGFyZ2V0O1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuY29udGV4dC5wb3BwZXJNYW5hZ2VyIHx8ICFfdGhpcy5jb250ZXh0LnBvcHBlck1hbmFnZXIuZ2V0VGFyZ2V0Tm9kZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG1pc3NpbmcuIFBvcHBlciBtdXN0IGJlIGdpdmVuIGEgdGFyZ2V0IGZyb20gdGhlIFBvcHBlciBNYW5hZ2VyLCBvciBhcyBhIHByb3AuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMuY29udGV4dC5wb3BwZXJNYW5hZ2VyLmdldFRhcmdldE5vZGUoKTtcbiAgICB9LCBfdGhpcy5fZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YS5vZmZzZXRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gZGF0YS5vZmZzZXRzW2tleV07XG4gICAgICB9KTtcbiAgICB9LCBfdGhpcy5faXNEYXRhRGlydHkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KF90aGlzLl9nZXRPZmZzZXRzKF90aGlzLnN0YXRlLmRhdGEpKSAhPT0gSlNPTi5zdHJpbmdpZnkoX3RoaXMuX2dldE9mZnNldHMoZGF0YSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuX3VwZGF0ZVN0YXRlTW9kaWZpZXIgPSB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgb3JkZXI6IDkwMCxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihkYXRhKSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNEYXRhRGlydHkoZGF0YSkpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuX2dldFBvcHBlclN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdGF0ZS5kYXRhO1xuXG5cbiAgICAgIGlmICghX3RoaXMuX3BvcHBlciB8fCAhZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHBvc2l0aW9uOiBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uXG4gICAgICB9LCBkYXRhLnN0eWxlcyk7XG4gICAgfSwgX3RoaXMuX2dldFBvcHBlclBsYWNlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zdGF0ZS5kYXRhID8gX3RoaXMuc3RhdGUuZGF0YS5wbGFjZW1lbnQgOiB1bmRlZmluZWQ7XG4gICAgfSwgX3RoaXMuX2dldFBvcHBlckhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISFfdGhpcy5zdGF0ZS5kYXRhICYmIF90aGlzLnN0YXRlLmRhdGEuaGlkZSA/ICcnIDogdW5kZWZpbmVkO1xuICAgIH0sIF90aGlzLl9nZXRBcnJvd1N0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5kYXRhIHx8ICFfdGhpcy5zdGF0ZS5kYXRhLm9mZnNldHMuYXJyb3cpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlJGRhdGEkb2ZmcyA9IF90aGlzLnN0YXRlLmRhdGEub2Zmc2V0cy5hcnJvdyxcbiAgICAgICAgICAgIHRvcCA9IF90aGlzJHN0YXRlJGRhdGEkb2Zmcy50b3AsXG4gICAgICAgICAgICBsZWZ0ID0gX3RoaXMkc3RhdGUkZGF0YSRvZmZzLmxlZnQ7XG5cbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5faGFuZGxlUG9wcGVyUmVmID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLl9wb3BwZXJOb2RlID0gbm9kZTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIF90aGlzLl9jcmVhdGVQb3BwZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9kZXN0cm95UG9wcGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMucHJvcHMuaW5uZXJSZWYpIHtcbiAgICAgICAgX3RoaXMucHJvcHMuaW5uZXJSZWYobm9kZSk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuX3NjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX3BvcHBlciAmJiBfdGhpcy5fcG9wcGVyLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ2dldENoaWxkQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvcHBlcjoge1xuICAgICAgICAgIHNldEFycm93Tm9kZTogdGhpcy5fc2V0QXJyb3dOb2RlLFxuICAgICAgICAgIGdldEFycm93U3R5bGU6IHRoaXMuX2dldEFycm93U3R5bGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUobGFzdFByb3BzKSB7XG4gICAgICBpZiAobGFzdFByb3BzLnBsYWNlbWVudCAhPT0gdGhpcy5wcm9wcy5wbGFjZW1lbnQgfHwgbGFzdFByb3BzLmV2ZW50c0VuYWJsZWQgIT09IHRoaXMucHJvcHMuZXZlbnRzRW5hYmxlZCB8fCBsYXN0UHJvcHMudGFyZ2V0ICE9PSB0aGlzLnByb3BzLnRhcmdldCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95UG9wcGVyKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wcy5jaGlsZHJlbiAhPT0gdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLl9kZXN0cm95UG9wcGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZVBvcHBlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVQb3BwZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcGxhY2VtZW50ID0gX3Byb3BzLnBsYWNlbWVudCxcbiAgICAgICAgICBldmVudHNFbmFibGVkID0gX3Byb3BzLmV2ZW50c0VuYWJsZWQ7XG5cbiAgICAgIHZhciBtb2RpZmllcnMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcy5tb2RpZmllcnMsIHtcbiAgICAgICAgYXBwbHlTdHlsZTogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICB1cGRhdGVTdGF0ZTogdGhpcy5fdXBkYXRlU3RhdGVNb2RpZmllclxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5fYXJyb3dOb2RlKSB7XG4gICAgICAgIG1vZGlmaWVycy5hcnJvdyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLm1vZGlmaWVycy5hcnJvdyB8fCB7fSwge1xuICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX2Fycm93Tm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXJKUyh0aGlzLl9nZXRUYXJnZXROb2RlKCksIHRoaXMuX3BvcHBlck5vZGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGV2ZW50c0VuYWJsZWQ6IGV2ZW50c0VuYWJsZWQsXG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgICB9KTtcblxuICAgICAgLy8gVE9ETzogbG9vayBpbnRvIHNldFRpbWVvdXQgc2NoZWR1bGVVcGRhdGUgY2FsbCwgd2l0aG91dCBpdCwgdGhlIHBvcHBlciB3aWxsIG5vdCBwb3NpdGlvbiBwcm9wZXJseSBvbiBjcmVhdGlvblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX3NjaGVkdWxlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZGVzdHJveVBvcHBlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95UG9wcGVyKCkge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnQgPSBfcHJvcHMyLmNvbXBvbmVudCxcbiAgICAgICAgICBpbm5lclJlZiA9IF9wcm9wczIuaW5uZXJSZWYsXG4gICAgICAgICAgcGxhY2VtZW50ID0gX3Byb3BzMi5wbGFjZW1lbnQsXG4gICAgICAgICAgZXZlbnRzRW5hYmxlZCA9IF9wcm9wczIuZXZlbnRzRW5hYmxlZCxcbiAgICAgICAgICBtb2RpZmllcnMgPSBfcHJvcHMyLm1vZGlmaWVycyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW4sXG4gICAgICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsnY29tcG9uZW50JywgJ2lubmVyUmVmJywgJ3BsYWNlbWVudCcsICdldmVudHNFbmFibGVkJywgJ21vZGlmaWVycycsICdjaGlsZHJlbiddKTtcblxuICAgICAgdmFyIHBvcHBlclN0eWxlID0gdGhpcy5fZ2V0UG9wcGVyU3R5bGUoKTtcbiAgICAgIHZhciBwb3BwZXJQbGFjZW1lbnQgPSB0aGlzLl9nZXRQb3BwZXJQbGFjZW1lbnQoKTtcbiAgICAgIHZhciBwb3BwZXJIaWRlID0gdGhpcy5fZ2V0UG9wcGVySGlkZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3BwZXJQcm9wcyA9IHtcbiAgICAgICAgICByZWY6IHRoaXMuX2hhbmRsZVBvcHBlclJlZixcbiAgICAgICAgICBzdHlsZTogcG9wcGVyU3R5bGUsXG4gICAgICAgICAgJ2RhdGEtcGxhY2VtZW50JzogcG9wcGVyUGxhY2VtZW50LFxuICAgICAgICAgICdkYXRhLXgtb3V0LW9mLWJvdW5kYXJpZXMnOiBwb3BwZXJIaWRlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjaGlsZHJlbih7XG4gICAgICAgICAgcG9wcGVyUHJvcHM6IHBvcHBlclByb3BzLFxuICAgICAgICAgIHJlc3RQcm9wczogcmVzdFByb3BzLFxuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlOiB0aGlzLl9zY2hlZHVsZVVwZGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudFByb3BzID0gX2V4dGVuZHMoe30sIHJlc3RQcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHJlc3RQcm9wcy5zdHlsZSwgcG9wcGVyU3R5bGUpLFxuICAgICAgICAnZGF0YS1wbGFjZW1lbnQnOiBwb3BwZXJQbGFjZW1lbnQsXG4gICAgICAgICdkYXRhLXgtb3V0LW9mLWJvdW5kYXJpZXMnOiBwb3BwZXJIaWRlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbXBvbmVudFByb3BzLnJlZiA9IHRoaXMuX2hhbmRsZVBvcHBlclJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudFByb3BzLmlubmVyUmVmID0gdGhpcy5faGFuZGxlUG9wcGVyUmVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIGNvbXBvbmVudFByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHBlcjtcbn0oQ29tcG9uZW50KTtcblxuUG9wcGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcG9wcGVyTWFuYWdlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblBvcHBlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcG9wcGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5Qb3BwZXIucHJvcFR5cGVzID0ge1xuICBjb21wb25lbnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBsYWNlbWVudDogUHJvcFR5cGVzLm9uZU9mKHBsYWNlbWVudHMpLFxuICBldmVudHNFbmFibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgbW9kaWZpZXJzOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gIHRhcmdldDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gIC8vIHRoZSBmb2xsb3dpbmcgY2hlY2sgaXMgbmVlZGVkIGZvciBTU1JcbiAgUHJvcFR5cGVzLmluc3RhbmNlT2YodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gRWxlbWVudCA6IE9iamVjdCksIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGNsaWVudFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgY2xpZW50SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgfSldKVxufTtcblBvcHBlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbXBvbmVudDogJ2RpdicsXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG4gIG1vZGlmaWVyczoge31cbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvUG9wcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjZcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhPZGRuZXNzID0gcmVmZXJlbmNlLndpZHRoICUgMiA9PT0gcG9wcGVyLndpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZS53aWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyLndpZHRoICUgMiA9PT0gMTtcbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aE9kZG5lc3MgPyBNYXRoLnJvdW5kIDogTWF0aC5mbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IE1hdGgucm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnZhciBBcnJvdyA9IGZ1bmN0aW9uIEFycm93KHByb3BzLCBjb250ZXh0KSB7XG4gIHZhciBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgY29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdW5kZWZpbmVkID8gJ3NwYW4nIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbJ2NvbXBvbmVudCcsICdpbm5lclJlZicsICdjaGlsZHJlbiddKTtcblxuICB2YXIgcG9wcGVyID0gY29udGV4dC5wb3BwZXI7XG5cbiAgdmFyIGFycm93UmVmID0gZnVuY3Rpb24gYXJyb3dSZWYobm9kZSkge1xuICAgIHBvcHBlci5zZXRBcnJvd05vZGUobm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpbm5lclJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5uZXJSZWYobm9kZSk7XG4gICAgfVxuICB9O1xuICB2YXIgYXJyb3dTdHlsZSA9IHBvcHBlci5nZXRBcnJvd1N0eWxlKCk7XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBhcnJvd1Byb3BzID0ge1xuICAgICAgcmVmOiBhcnJvd1JlZixcbiAgICAgIHN0eWxlOiBhcnJvd1N0eWxlXG4gICAgfTtcbiAgICByZXR1cm4gY2hpbGRyZW4oeyBhcnJvd1Byb3BzOiBhcnJvd1Byb3BzLCByZXN0UHJvcHM6IHJlc3RQcm9wcyB9KTtcbiAgfVxuXG4gIHZhciBjb21wb25lbnRQcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0UHJvcHMsIHtcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIGFycm93U3R5bGUsIHJlc3RQcm9wcy5zdHlsZSlcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29tcG9uZW50UHJvcHMucmVmID0gYXJyb3dSZWY7XG4gIH0gZWxzZSB7XG4gICAgY29tcG9uZW50UHJvcHMuaW5uZXJSZWYgPSBhcnJvd1JlZjtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIGNoaWxkcmVuKTtcbn07XG5cbkFycm93LmNvbnRleHRUeXBlcyA9IHtcbiAgcG9wcGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cbkFycm93LnByb3BUeXBlcyA9IHtcbiAgY29tcG9uZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFycm93O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXBvcHBlci9saWIvQXJyb3cuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgRm9ybSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0J1xyXG5pbXBvcnQgQ29sbGVjdGlvbkVkaXRvciBmcm9tICcuL2NvbGxlY3Rpb25lZGl0b3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRzRWRpdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLnN0YXRlID0ge31cclxuICB9XHJcbiAgXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3QgbWUgPSB0aGlzO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XHJcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5wcm9wcy5ldmVudHM7XHJcbiAgICB2YXIgYWN0aW9uT3B0aW9ucyA9IFtdO1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmFjdGlvbnMpKXtcclxuICAgICAgICB0aGlzLnByb3BzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhKXtcclxuICAgICAgICAgICAgYWN0aW9uT3B0aW9ucy5wdXNoKHt0ZXh0OiBhLCB2YWx1ZTogYX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHRhcmdldE9wdGlvbnMgPSBbLi4udGhpcy5wcm9wcy50YXJnZXRzXTtcclxuICAgXHJcbiAgICBsZXQgcmVzID0gW107XHJcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKXtcclxuICAgICAgbGV0IGtleSA9IGUgKyBcIl9ldmVudHNcIjtcclxuICAgICAgbGV0IGV2ZW50ID0gZGF0YSAhPSB1bmRlZmluZWQgPyBkYXRhW2VdIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZihldmVudCA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGV2ZW50ID0ge307XHJcbiAgICAgIH1cclxuICAgICBcclxuICAgICAgaWYoZXZlbnQuYWN0aW9ucyA9PSB1bmRlZmluZWQpIGV2ZW50LmFjdGlvbnMgPSBbXTtcclxuICAgICAgaWYoZXZlbnQudGFyZ2V0cyA9PSB1bmRlZmluZWQpIGV2ZW50LnRhcmdldHMgPSBbXTtcclxuICAgICAgaWYoZXZlbnQucGFyYW1ldGVycyA9PSB1bmRlZmluZWQpIGV2ZW50LnBhcmFtZXRlcnMgPSBbXTtcclxuICAgICAgXHJcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkoZXZlbnQuYWN0aW9ucykpe1xyXG4gICAgICAgIGV2ZW50LmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhKXtcclxuICAgICAgICAgICAgbGV0IGlzRmluZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYWN0aW9uT3B0aW9ucy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpZihhID09IGFjdGlvbk9wdGlvbnNbaV0udmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRmluZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFpc0ZpbmQpe1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uT3B0aW9ucy5wdXNoKHt0ZXh0OiBhLCB2YWx1ZTogYX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgaWYoQXJyYXkuaXNBcnJheShldmVudC50YXJnZXRzKSl7XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG4gICAgICAgICAgICBsZXQgaXNGaW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0YXJnZXRPcHRpb25zLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKGEgPT0gdGFyZ2V0T3B0aW9uc1tpXS52YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIWlzRmluZCl7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPcHRpb25zLnB1c2goe3RleHQ6IGEsIHZhbHVlOiBhfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgIHJlcy5wdXNoKDxkaXYga2V5PXtrZXl9PlxyXG4gICAgICAgIDxGb3JtLkNoZWNrYm94IHdpZHRoPXszfSBrZXk9XCJhY3RpdmVcIiBsYWJlbD17ZX0gbmFtZT1cImFjdGl2ZVwiIGNoZWNrZWQ9e2V2ZW50LmFjdGl2ZX0gb25DaGFuZ2U9e21lLmhhbmRsZUNoYW5nZS5iaW5kKG1lLCBlKX0gLz5cclxuICAgICAgICA8ZGl2IGtleT1cImRpdkdyb3VwXCIgc3R5bGU9e2V2ZW50LmFjdGl2ZSA/IHt9IDogeyBkaXNwbGF5OiAnbm9uZScgfX0+XHJcbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIGtleT1cIkdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybS5Ecm9wZG93biBrZXk9XCJhY3Rpb25zXCIgbGFiZWw9XCJBY3Rpb25zXCIgbXVsdGlwbGUgc2VhcmNoIHNlbGVjdGlvbiBhbGxvd0FkZGl0aW9ucyBcclxuICAgICAgICAgICAgICAgIG5hbWU9XCJhY3Rpb25zXCIgb3B0aW9ucz17YWN0aW9uT3B0aW9uc30gdmFsdWU9e2V2ZW50LmFjdGlvbnN9IFxyXG4gICAgICAgICAgICAgICAgb25BZGRJdGVtPXttZS5hY3Rpb25zT25BZGRJdGVtLmJpbmQobWUpfSBvbkNoYW5nZT17bWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUsIGUpfSAvPlxyXG4gICAgICAgICAgICAgICAgPENvbGxlY3Rpb25FZGl0b3Iga2V5PVwicGFyYW1ldGVyc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17WyduYW1lJywgJ3ZhbHVlJ119IFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiUGFyYW1ldGVyc1wiIFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9XCJwYXJhbWV0ZXJzXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2V2ZW50LnBhcmFtZXRlcnN9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e21lLmhhbmRsZUNoYW5nZS5iaW5kKG1lLCBlKX0vPlxyXG4gICAgICAgICAgICAgICAgPEZvcm0uRHJvcGRvd24ga2V5PVwidGFyZ2V0c1wiIGxhYmVsPVwiVGFyZ2V0c1wiIG11bHRpcGxlIHNlYXJjaCBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBuYW1lPVwidGFyZ2V0c1wiIG9wdGlvbnM9e3RhcmdldE9wdGlvbnN9IHZhbHVlPXtldmVudC50YXJnZXRzfSBcclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17bWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUsIGUpfS8+XHJcbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICA8L2Rpdj4pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiA8ZGl2PntyZXN9PC9kaXY+O1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlQ2hhbmdlKGV2ZW50TmFtZSwgZSwge25hbWUsIHZhbHVlLCBjaGVja2VkfSl7XHJcbiAgICB2YXIgZXZlbnQgPSB0aGlzLnByb3BzLmRhdGFbZXZlbnROYW1lXTtcclxuICAgIGlmKGV2ZW50ID09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgZXZlbnQgPSB7fTtcclxuICAgICAgICB0aGlzLnByb3BzLmRhdGFbZXZlbnROYW1lXSA9IGV2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHZhbHVlID09IHVuZGVmaW5lZCAmJiBjaGVja2VkICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgZXZlbnRbbmFtZV0gPSBjaGVja2VkO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBldmVudFtuYW1lXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICBpZih2YWx1ZSAhPSB1bmRlZmluZWQgJiYgdmFsdWUgIT0gXCJcIil7XHJcbiAgICAgICAgICAgIGV2ZW50LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYodGhpcy5wcm9wcy5vbkNoYW5nZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLCB7bmFtZTogdGhpcy5wcm9wcy5uYW1lLCB2YWx1ZTogdGhpcy5wcm9wcy5kYXRhfSk7XHJcbiAgfVxyXG5cclxuICBhY3Rpb25zT25BZGRJdGVtKGUsIHsgdmFsdWUgfSl7XHJcbiAgICAgIGlmKHRoaXMucHJvcHMub25BZGRpdGlvbkFjdGlvbnMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMucHJvcHMub25BZGRpdGlvbkFjdGlvbnMoZSwgeyB2YWx1ZSB9KTtcclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udHJvbC9ldmVudHNlZGl0b3IuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgSlNPTjUgZnJvbSAnanNvbjUnXHJcbmltcG9ydCB7IE1lbnUgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnVHcm91cCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge307XHJcblxyXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hY3RpdmVpdGVtID0gcHJvcHMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3BzLmFjdGl2ZWl0ZW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmFjdGl2ZWl0ZW0gPSBwcm9wcy5hY3RpdmVpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHByZXZTdGF0ZS5hY3RpdmVpdGVtICE9PSBuZXh0UHJvcHMudmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4ge2FjdGl2ZWl0ZW06IG5leHRQcm9wcy52YWx1ZX07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVJdGVtQ2xpY2soZSwge25hbWV9KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaGFuZGxlRXZlbnQgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLnByb3BzLmhhbmRsZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIGUsXHJcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMucHJvcHMubmFtZSxcclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogXCJvbkl0ZW1DbGlja1wiLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge3RhcmdldDogbmFtZX1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2FjdGl2ZWl0ZW06IG5hbWV9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVJdGVtQ2xpY2syKHAsIGUpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUl0ZW1DbGljayhlLCBwKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnByb3BzW1wiZGF0YS1pdGVtc1wiXTtcclxuICAgICAgICBpZiAoaXRlbXMgPT0gdW5kZWZpbmVkIHx8IGl0ZW1zID09IFwiXCIpIHtcclxuICAgICAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zID0gSlNPTjUucGFyc2UoaXRlbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbmRlckl0ZW1zKGl0ZW1zKTtcclxuXHJcbiAgICB2YXIgY29udHJvbFByb3BzID0ge307XHJcbiAgICBmb3IodmFyIHAgaW4gdGhpcy5wcm9wcyl7XHJcbiAgICAgICAgaWYocCA9PSBcImRhdGEtaXRlbXNcIiB8fCBwID09ICdhY3RpdmVpdGVtJyB8fCBwID09ICdoYW5kbGVFdmVudCcgfHwgcCA9PSAnbGluaycpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRyb2xQcm9wc1twXSA9IHRoaXMucHJvcHNbcF07XHJcbiAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gKDxNZW51IHsuLi5jb250cm9sUHJvcHN9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9NZW51Pik7XHJcbiAgICB9XHJcblxyXG4gIHJlbmRlckl0ZW1zKGl0ZW1zLCBrZXlQcmVmaXgpe1xyXG4gICAgbGV0IGNoaWxkcmVuID0gW107XHJcbiAgICBpZihrZXlQcmVmaXggPT09IHVuZGVmaW5lZClcclxuICAgICAga2V5UHJlZml4ID0gXCJcIjtcclxuXHJcbiAgICBmb3IobGV0IGk9MDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKXtcclxuICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpXTtcclxuXHJcbiAgICAgIGlmKGl0ZW0udmlzaWJsZUNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkICYmIGl0ZW0udmlzaWJsZUNvbmRpdGlvbiAhPT0gbnVsbCAmJiBpdGVtLnZpc2libGVDb25kaXRpb24gIT09IFwiXCIpe1xyXG4gICAgICAgIGxldCBhcmdzID0gJyc7XHJcbiAgICAgICAgbGV0IGJvZHkgPSAncmV0dXJuICcgKyBpdGVtLnZpc2libGVDb25kaXRpb247XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBpZighbmV3IEZ1bmN0aW9uKGFyZ3MsIGJvZHkpKCkpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goZSl7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGtleSA9IFN0cmluZyhrZXlQcmVmaXgpICsgU3RyaW5nKGkpO1xyXG4gICAgICBsZXQgdGl0bGVTcGFuID0gPHNwYW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tfX2h0bWw6IGl0ZW0udGl0bGV9fS8+O1xyXG4gICAgICBpZihBcnJheS5pc0FycmF5KGl0ZW0uY2hpbGRyZW4pICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaCg8TWVudS5JdGVtPlxyXG4gICAgICAgICAgPE1lbnUuSGVhZGVyPnt0aXRsZVNwYW59PC9NZW51LkhlYWRlcj5cclxuICAgICAgICAgIDxNZW51Lk1lbnU+XHJcbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckl0ZW1zKGl0ZW0uY2hpbGRyZW4sIGtleSArIFwiX1wiKX1cclxuICAgICAgICAgIDwvTWVudS5NZW51PlxyXG4gICAgICAgIDwvTWVudS5JdGVtPik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucHJvcHMubGluayA/XHJcbiAgICAgICAgICAgIDxhIHN0eWxlPXt7Y29sb3I6XCJpbmhlcml0XCJ9fSBocmVmPXtpdGVtLnRhcmdldH0gb25DbGljaz17dGhpcy5oYW5kbGVJdGVtQ2xpY2syLmJpbmQodGhpcywge25hbWU6IGl0ZW0udGFyZ2V0fSl9Pnt0aXRsZVNwYW59PC9hPjpcclxuICAgICAgICAgICAgdGl0bGVTcGFuO1xyXG5cclxuICAgICAgICBjaGlsZHJlbi5wdXNoKDxNZW51Lkl0ZW1cclxuICAgICAgICAgIGtleT17a2V5fVxyXG4gICAgICAgICAgbmFtZT17aXRlbS50YXJnZXR9XHJcbiAgICAgICAgICBhY3RpdmU9e3RoaXMuc3RhdGUuYWN0aXZlaXRlbSA9PT0gaXRlbS50YXJnZXR9XHJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUl0ZW1DbGljay5iaW5kKHRoaXMpfT57Y29udGVudH08L01lbnUuSXRlbT4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbnRyb2wvbWVudWdyb3VwLmpzeCIsIi8qXHJcbkZpbHRlciBvYmplY3Qgc3RydWN0dXJlOlxyXG5sZXQgZmlsdGVyID0gW1xyXG57Y29sdW1uOiBcIk5hbWVcIiB8IFwiTmFtZTEsTmFtZTIsTmFtZTNcIiB8IFwiKlwiLFxyXG52YWx1ZTogdmFsdWUsXHJcbnRlcm06IFwiPlwiIHwgXCI8XCIgfCBcIj1cIiB8IFwiPj1cIiB8IFwiPD1cIiB8IFwiIT1cIiB8IFwibGlrZVwiIHwgXCJsaWtlKlwiIHwgXCIqbGlrZVwiIHwgXCIqbGlrZSpcIlxyXG5dXHJcblwiKmxpa2UqXCIgPT09IFwibGlrZVwiXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQge0lucHV0LENoZWNrYm94fSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuaW1wb3J0IFJlYWN0RGF0YUdyaWQgZnJvbSAncmVhY3QtZGF0YS1ncmlkJztcclxuaW1wb3J0IHtSb3d9IGZyb20gJ3JlYWN0LWRhdGEtZ3JpZCc7XHJcbmltcG9ydCB7RnVuY3Rpb25hbEZpbHRlcixGaWx0ZXJUZXJtc30gZnJvbSAnLi4vZnVuY3Rpb25hbGZpbHRlcidcclxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuY2xhc3MgQ2hlY2tCb3hGb3JtYXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgcmVuZGVyKCl7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCb29sZWFuKHRoaXMucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIHJldHVybiAoPENoZWNrYm94IGNoZWNrZWQ9e3ZhbHVlfSBkaXNhYmxlZC8+KTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTnVtYmVyRm9ybWF0dGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuICg8c3BhbiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PjxkaXYgdGl0bGU9e3ZhbHVlfT57dmFsdWV9PC9kaXY+PC9zcGFuPik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERhdGVGb3JtYXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbW9tZW50KHRoaXMucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIGxldCBzdHJWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgaWYodmFsdWUuaXNWYWxpZCgpKXtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdCA9ICh3aW5kb3cuRFdLaXRMYW5nICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkRXS2l0TGFuZy5jb21tb24gIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRMYW5nLmNvbW1vbi5kYXRlRm9ybWF0ICE9IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5EV0tpdExhbmcuY29tbW9uLmRhdGVGb3JtYXQgXHJcbiAgICAgICAgICAgICAgICA6IFwiTFwiO1xyXG4gICAgICAgICAgICBzdHJWYWx1ZSA9IHZhbHVlLmZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKDxzcGFuIHN0eWxlPXt7dGV4dEFsaWduOiAncmlnaHQnfX0+PGRpdiB0aXRsZT17c3RyVmFsdWV9PntzdHJWYWx1ZX08L2Rpdj48L3NwYW4+KTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgRGF0ZVRpbWVGb3JtYXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbW9tZW50KHRoaXMucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIGxldCBzdHJWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgaWYodmFsdWUuaXNWYWxpZCgpKXtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdCA9ICh3aW5kb3cuRFdLaXRMYW5nICE9PSB1bmRlZmluZWQgJiYgRFdLaXRMYW5nLmNvbW1vbiAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5EV0tpdExhbmcuY29tbW9uLmRhdGVGb3JtYXQgIT0gdW5kZWZpbmVkKSBcclxuICAgICAgICAgICAgICAgID8gd2luZG93LkRXS2l0TGFuZy5jb21tb24uZGF0ZUZvcm1hdCArIFwiIFwiICsgXHJcbiAgICAgICAgICAgICAgICAod2luZG93LkRXS2l0TGFuZy5jb21tb24udGltZUZvcm1hdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LkRXS2l0TGFuZy5jb21tb24udGltZUZvcm1hdDogXCJISDptbVwiKVxyXG4gICAgICAgICAgICAgICAgOiBcIkRELk1NLllZWVkgSEg6bW1cIjtcclxuICAgICAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS5mb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICg8c3BhbiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PjxkaXYgdGl0bGU9e3N0clZhbHVlfT57c3RyVmFsdWV9PC9kaXY+PC9zcGFuPik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFRpbWVGb3JtYXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbW9tZW50KHRoaXMucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIGxldCBzdHJWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgaWYodmFsdWUuaXNWYWxpZCgpKXtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdCA9ICh3aW5kb3cuRFdLaXRMYW5nICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkRXS2l0TGFuZy5jb21tb24gIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRMYW5nLmNvbW1vbi50aW1lRm9ybWF0ICE9IHVuZGVmaW5lZCkgXHJcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5EV0tpdExhbmcuY29tbW9uLnRpbWVGb3JtYXQgXHJcbiAgICAgICAgICAgICAgICA6IFwiSEg6bW1cIjtcclxuICAgICAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS5mb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICg8c3BhbiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PjxkaXYgdGl0bGU9e3N0clZhbHVlfT57c3RyVmFsdWV9PC9kaXY+PC9zcGFuPik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGpzb25FcXVhbCA9XHJcbiAgICBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcclxuICAgIH07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkVmlldyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgaXRlbXM6IFtdLFxyXG4gICAgICAgICAgICBzb3J0OiBcIlwiLFxyXG4gICAgICAgICAgICBkZWZhdWx0U29ydDogcHJvcHMuZGVmYXVsdFNvcnQsXHJcbiAgICAgICAgICAgIGZpbHRlcjogcHJvcHMuZmlsdGVyLFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogMjAsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXhlczogW10sXHJcbiAgICAgICAgICAgIHJvd3NDb3VudDogR3JpZFZpZXcuc3RhdGljSXNTZXJ2ZXJNb2RlKHByb3BzKT8gdW5kZWZpbmVkIDogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFqc29uRXF1YWwocHJldlN0YXRlLmZpbHRlciwgbmV4dFByb3BzLmZpbHRlcikpIHtcclxuICAgICAgICAgICAgbmV3U3RhdGUgPSB7ZmlsdGVyOiBuZXh0UHJvcHMuZmlsdGVyfTtcclxuICAgICAgICAgICAgaWYgKCFHcmlkVmlldy5zdGF0aWNJc1NlcnZlck1vZGUobmV4dFByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBBcnJheS5pc0FycmF5KG5leHRQcm9wcy52YWx1ZSkgPyBHcmlkVmlldy5zdGF0aWNHZXRTb3J0ZWRBbmRGaWx0ZXJlZEl0ZW1zKG5leHRQcm9wcy52YWx1ZSwgbmV4dFByb3BzLmZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGUuc29ydCxuZXh0UHJvcHMuZGVmYXVsdFNvcnQpIDogW107XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pdGVtcyA9IG5ld0l0ZW1zO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuc2VsZWN0ZWRJbmRleGVzID0gW107XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5yb3dzQ291bnQgPSBuZXdJdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pdGVtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuc2VsZWN0ZWRJbmRleGVzID0gW107XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5yb3dzQ291bnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghR3JpZFZpZXcuc3RhdGljSXNTZXJ2ZXJNb2RlKG5leHRQcm9wcykgJiYgcHJldlN0YXRlLm9yaWdpbmFsSXRlbXMgIT09IG5leHRQcm9wcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gQXJyYXkuaXNBcnJheShuZXh0UHJvcHMudmFsdWUpID8gR3JpZFZpZXcuc3RhdGljR2V0U29ydGVkQW5kRmlsdGVyZWRJdGVtcyhuZXh0UHJvcHMudmFsdWUsIHByZXZTdGF0ZS5maWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlLnNvcnQsIG5leHRQcm9wcy5kZWZhdWx0U29ydCkgOiBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pdGVtcyA9IG5ld0l0ZW1zO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUucm93c0NvdW50ID0gbmV3SXRlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuc2VsZWN0ZWRJbmRleGVzID0gW107XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5vcmlnaW5hbEl0ZW1zID0gbmV4dFByb3BzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBpc0VkaXRGb3JtTW9kYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZWRpdEZvcm1TaG93VHlwZSA9PT0gXCJtb2RhbFwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2VydmVyTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gR3JpZFZpZXcuc3RhdGljSXNTZXJ2ZXJNb2RlKHRoaXMucHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzdGF0aWNJc1NlcnZlck1vZGUocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMucGFnZXJUeXBlID09PSBcInNlcnZlclwiO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZnJlc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZXJ2ZXJNb2RlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcm93c0NvdW50OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLnZhbHVlKSA/IEdyaWRWaWV3LnN0YXRpY0dldFNvcnRlZEFuZEZpbHRlcmVkSXRlbXModGhpcy5wcm9wcy52YWx1ZSwgdGhpcy5zdGF0ZS5maWx0ZXIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnQsIHRoaXMucHJvcHMuZGVmYXVsdFNvcnQpIDogW107XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXRlbXM6IG5ld0l0ZW1zLFxyXG4gICAgICAgICAgICAgICAgcm93c0NvdW50OiBuZXdJdGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJdGVtczogdGhpcy5wcm9wcy52YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0U2VsZWN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ZXM6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcclxuICAgICAgICBsZXQgc3R5bGUgPSB7Li4udGhpcy5wcm9wcy5zdHlsZX07XHJcbiAgICAgICAgbGV0IGdyaWRQcm9wcyA9IHRoaXMuZ2V0R3JpZFByb3BzQnlQYWdlclR5cGUodGhpcy5wcm9wcy5wYWdlclR5cGUpO1xyXG4gICAgICAgIGdyaWRQcm9wcy5jb2x1bW5zID0gdGhpcy5nZXRDb2x1bW5zKCk7XHJcbiAgICAgICAgZ3JpZFByb3BzLnJvd0tleSA9IHRoaXMucHJvcHMucm93S2V5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yb3dIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzLnJvd0hlaWdodCAhPT0gXCJcIilcclxuICAgICAgICAgICAgZ3JpZFByb3BzLnJvd0hlaWdodCA9IHRoaXMucHJvcHMucm93SGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5hdXRvSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHN0eWxlLm1pbkhlaWdodCA9IHRoaXMucHJvcHMubWluSGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vZmZTZXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzLm9mZlNldCAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJ2NhbGMoMTAwdmggLSAnICsgdGhpcy5wcm9wcy5vZmZTZXQgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IChjbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiAoY2xhc3NOYW1lICsgXCIgXCIpKSArIFwiZHdraXQtZ3JpZHZpZXctYXV0b0hlaWdodFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubWluSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5taW5IZWlnaHQgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGdyaWRQcm9wcy5taW5IZWlnaHQgPSB0aGlzLnByb3BzLm1pbkhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKEJvb2xlYW4odGhpcy5wcm9wcy5maWx0ZXJSb3cpKSB7XHJcbiAgICAgICAgLy8gICAgIGdyaWRQcm9wcy50b29sYmFyID0gPFRvb2xiYXIgZW5hYmxlRmlsdGVyPXt0cnVlfS8+O1xyXG4gICAgICAgIC8vICAgICBncmlkUHJvcHMub25BZGRGaWx0ZXIgPSB0aGlzLmhhbmRsZUZpbHRlckNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8vICAgICBncmlkUHJvcHMub25DbGVhckZpbHRlcnMgPSB0aGlzLm9uQ2xlYXJGaWx0ZXJzLmJpbmQodGhpcyk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnByb3BzLm11bHRpc2VsZWN0KSkge1xyXG4gICAgICAgICAgICBncmlkUHJvcHMucm93U2VsZWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgb25Sb3dzU2VsZWN0ZWQ6IHRoaXMub25Sb3dzU2VsZWN0ZWQuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIG9uUm93c0Rlc2VsZWN0ZWQ6IHRoaXMub25Sb3dzRGVzZWxlY3RlZC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0Qnk6IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PXt0aGlzLnByb3BzLm5hbWV9IG5hbWU9e3RoaXMucHJvcHMubmFtZX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtzdHlsZX0+XHJcbiAgICAgICAgICAgIDxSZWFjdERhdGFHcmlkIGtleT1cImdyaWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB7Li4uZ3JpZFByb3BzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzQ291bnQ9e3RoaXMuc3RhdGUucm93c0NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByb3dHZXR0ZXI9e3RoaXMuZ3JpZFJvd0dldHRlci5iaW5kKHRoaXMpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvblJvd0NsaWNrPXt0aGlzLmdyaWRPblJvd0NsaWNrLmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uR3JpZFNvcnQ9e3RoaXMuaGFuZGxlR3JpZFNvcnQuYmluZCh0aGlzKX0vPlxyXG4gICAgICAgIDwvZGl2PjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb2x1bW5zKCkge1xyXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICBsZXQgY29sdW1ucztcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb2x1bW5zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29sdW1ucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuY29sdW1ucykpIHtcclxuICAgICAgICAgICAgY29sdW1ucyA9IHRoaXMucHJvcHMuY29sdW1ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbHVtbnMgPSBKU09OLnBhcnNlKHRoaXMucHJvcHMuY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0ud2lkdGggIT09IG51bGwgJiYgaXRlbS53aWR0aCAhPT0gXCJcIiAmJiBpdGVtLndpZHRoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSBOdW1iZXIoaXRlbS53aWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGl0ZW0uc29ydGFibGUgIT09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIGl0ZW0uc29ydGFibGUgPSAhQm9vbGVhbihtZS5wcm9wcy5kaXNhYmxlU29ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5maWx0ZXJhYmxlID0gQm9vbGVhbihtZS5wcm9wcy5maWx0ZXJSb3cpO1xyXG4gICAgICAgICAgICBpdGVtLnJlc2l6YWJsZSA9IEJvb2xlYW4oaXRlbS5yZXNpemFibGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgIGl0ZW0uZm9ybWF0dGVyID0gTnVtYmVyRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5mb3JtYXR0ZXIgPSBDaGVja0JveEZvcm1hdHRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZGF0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdHRlciA9IERhdGVGb3JtYXR0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50eXBlID09PSBcInRpbWVcIikge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5mb3JtYXR0ZXIgPSBUaW1lRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmZvcm1hdHRlciA9IERhdGVUaW1lRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJjdXN0b21cIikge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5nZXRSb3dNZXRhRGF0YSA9IChyb3cpID0+IHJvdztcclxuICAgICAgICAgICAgICAgIGl0ZW0uZm9ybWF0dGVyID0gKGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmN1c3RvbUZvcm1hdHRlciA9PSB1bmRlZmluZWQgfHwgdHlwZW9mKGl0ZW0uY3VzdG9tRm9ybWF0dGVyKSAhPSBcImZ1bmN0aW9uXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY3VzdG9tRm9ybWF0dGVyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBhcmdzLmRlcGVuZGVudFZhbHVlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZ3MudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaXRlbVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEdyaWRQcm9wc0J5UGFnZXJUeXBlKCkge1xyXG4gICAgICAgIGxldCBncmlkUHJvcHMgPSB7fTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFnZXJUeXBlID0gdGhpcy5wcm9wcy5wYWdlclR5cGU7XHJcbiAgICAgICAgaWYgKHBhZ2VyVHlwZSA9PT0gXCJzZXJ2ZXJcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBhZ2VTaXplID0gdGhpcy5wcm9wcy5wYWdlU2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmlkUHJvcHMucm93UmVuZGVyZXIgPSBSb3dMb2FkaW5nUmVuZGVyZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnJvd3NDb3VudCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yb3dzQ291bnQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMuc3RhdGUuaXRlbXMgPSB0aGlzLmdldFNvcnRlZEFuZEZpbHRlcmVkSXRlbXModGhpcy5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy90aGlzLnN0YXRlLnJvd3NDb3VudCA9IHRoaXMuc3RhdGUuaXRlbXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ3JpZFByb3BzO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzdGF0aWNHZXRTb3J0ZWRBbmRGaWx0ZXJlZEl0ZW1zKGFycmF5LGZpbHRlcixzb3J0LGRlZmF1bHRTb3J0KVxyXG4gICAge1xyXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGlmIChhcnJheSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zID0gYXJyYXkuZmlsdGVyKChyKSA9PiBmaWx0ZXIuSXNSb3dNYXRjaGVkKHIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW1zID0gYXJyYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY3VycmVudFNvcnQgPSBzb3J0O1xyXG4gICAgICAgIGlmIChzb3J0ID09PSAnTk9ORScgfHwgc29ydCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNvcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRTb3J0ID0gZGVmYXVsdFNvcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbmRleFNwYWNlID0gY3VycmVudFNvcnQuaW5kZXhPZihcIiBcIik7XHJcbiAgICAgICAgY29uc3Qgc29ydENvbHVtbiA9IGN1cnJlbnRTb3J0LnN1YnN0cmluZygwLCBpbmRleFNwYWNlKTtcclxuICAgICAgICBjb25zdCBzb3J0RGlyZWN0aW9uID0gY3VycmVudFNvcnQuc3Vic3RyaW5nKGluZGV4U3BhY2UgKyAxLCBjdXJyZW50U29ydC5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvL1NvcnRpbmdcclxuICAgICAgICBjb25zdCBjb21wYXJlciA9IChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhVmFsdWUgPSAoYVtzb3J0Q29sdW1uXSAhPT0gdW5kZWZpbmVkICAmJiBhW3NvcnRDb2x1bW5dICE9PSBudWxsICYmIGFbc29ydENvbHVtbl0udG9Mb3dlckNhc2UgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgID8gYVtzb3J0Q29sdW1uXS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgICA6IGFbc29ydENvbHVtbl07XHJcbiAgICAgICAgICAgIGxldCBiVmFsdWUgPSAoYltzb3J0Q29sdW1uXSAhPT0gdW5kZWZpbmVkICYmIGJbc29ydENvbHVtbl0gIT09IG51bGwgJiYgYltzb3J0Q29sdW1uXS50b0xvd2VyQ2FzZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgPyBiW3NvcnRDb2x1bW5dLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgIDogYltzb3J0Q29sdW1uXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhVmFsdWUgPT09IGJWYWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFWYWx1ZSA9PT0gbnVsbCB8fCBhVmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJWYWx1ZSA9PT0gbnVsbCB8fCBiVmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSAnQVNDJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsdWUgPiBiVmFsdWUpID8gMSA6IC0xO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnREaXJlY3Rpb24gPT09ICdERVNDJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsdWUgPCBiVmFsdWUpID8gMSA6IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaXRlbXMuc2xpY2UoMCkuc29ydChjb21wYXJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2VsZXRlZFJvd0tleXMoKSB7XHJcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xyXG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqID0gbWUuZ3JpZFJvd0dldHRlcihpbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzLnB1c2gob2JqW21lLnByb3BzLnJvd0tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkS2V5cztcclxuICAgIH1cclxuXHJcbiAgICBncmlkUm93R2V0dGVyKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFnZXJUeXBlID0gdGhpcy5wcm9wcy5wYWdlclR5cGU7XHJcbiAgICAgICAgaWYgKHBhZ2VyVHlwZSA9PT0gXCJzZXJ2ZXJcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pdGVtc1tpbmRleF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZVNpemUgPSB0aGlzLnN0YXRlLnBhZ2VTaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkUGFnZShpbmRleCwgcGFnZVNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFnZXJUeXBlID09PSBcInNlcnZlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLml0ZW1zW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7Li4udGhpcy5zdGF0ZS5pdGVtc1tpbmRleF19OyAvL0RXS0lULTExNVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2FkUGFnZShzdGFydEluZGV4LCBwYWdlU2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pdGVtc1tpICsgc3RhcnRJbmRleF0gPSB7X19sb2FkaW5nOiB0cnVlfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdyaWRWaWV3OiBGb3IgcGFnaW5nIG9uIHNlcnZlciBuZWVkIHRvIHNldCBnZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wgZnVuYyFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgc29ydFN0cmluZyA9IHRoaXMuc3RhdGUuc29ydDtcclxuICAgICAgICAgICAgaWYgKHNvcnRTdHJpbmcgPT09IFwiXCIgJiYgdGhpcy5wcm9wcy5kZWZhdWx0U29ydCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgc29ydFN0cmluZyA9IHRoaXMucHJvcHMuZGVmYXVsdFNvcnQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCh0aGlzLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogdGhpcy5zdGF0ZS5maWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRoaXMuc3RhdGUuZmlsdGVyLkdldEZpbHRlckFzT2JqZWN0cygpIDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgc29ydDogc29ydFN0cmluZ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh7c0luZGV4LCBwU2l6ZSwgcm93c0NvdW50LCBpdGVtc30pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm93c0NvdW50ID09PSB1bmRlZmluZWQgfHwgaXRlbXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZS5yb3dzQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZS5yb3dzQ291bnQgPSByb3dzQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZS5pdGVtc1tzSW5kZXggKyBpXSA9IGl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc3RhdGUuaXRlbXNbc0luZGV4ICsgaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ3JpZE9uUm93Q2xpY2socm93SWR4LCByb3cpIHtcclxuICAgICAgICBpZiAocm93ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgdGltZW5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucm93Q2xpY2tUaW1lICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yb3dDbGlja1RpbWUucm93SWR4ID09PSByb3dJZHggJiYgKHRpbWVub3cgLSB0aGlzLnJvd0NsaWNrVGltZS50aW1lKSA8PSAxMDAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93Q2xpY2tUaW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLm9uUm93RGJsQ2xpY2socm93SWR4LCByb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dDbGlja1RpbWUgPSB7XHJcbiAgICAgICAgICAgICAgICByb3dJZHg6IHJvd0lkeCxcclxuICAgICAgICAgICAgICAgIHRpbWU6IHRpbWVub3dcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmhhbmRsZUV2ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuaGFuZGxlRXZlbnQoe2tleTogdGhpcy5wcm9wcy5uYW1lLCBldmVudE5hbWU6IFwib25Sb3dDbGlja1wiLCBwYXJhbWV0ZXJzOiB7cm93SWR4LCByb3d9fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Sb3dEYmxDbGljayhyb3dJZHgsIHJvdykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmhhbmRsZUV2ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5oYW5kbGVFdmVudCh7a2V5OiB0aGlzLnByb3BzLm5hbWUsIGV2ZW50TmFtZTogXCJvblJvd0RibENsaWNrXCIsIHBhcmFtZXRlcnM6IHtyb3dJZHgsIHJvd319KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Sb3dzU2VsZWN0ZWQocm93cykge1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRleGVzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGV4ZXMuY29uY2F0KHJvd3MubWFwKHIgPT4gci5yb3dJZHgpKTtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5oYW5kbGVFdmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuaGFuZGxlRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLnByb3BzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWU6IFwib25TZWxlY3Rpb25DaGFuZ2VkXCIsXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7c2VsZWN0ZWRJbmRleGVzOiB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kZXhlc31cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvblJvd3NEZXNlbGVjdGVkKHJvd3MpIHtcclxuICAgICAgICBsZXQgcm93SW5kZXhlcyA9IHJvd3MubWFwKHIgPT4gci5yb3dJZHgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRleGVzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGV4ZXMuZmlsdGVyKGkgPT4gcm93SW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaGFuZGxlRXZlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLmhhbmRsZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5wcm9wcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBcIm9uU2VsZWN0aW9uQ2hhbmdlZFwiLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge3NlbGVjdGVkSW5kZXhlczogdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGV4ZXN9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlR3JpZFNvcnQoc29ydENvbHVtbiwgc29ydERpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlRGVsdGEgPSB7fTtcclxuICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gXCJOT05FXCIpXHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuc29ydCA9IFwiXCI7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLnNvcnQgPSBzb3J0Q29sdW1uICsgXCIgXCIgKyBzb3J0RGlyZWN0aW9uO1xyXG5cclxuICAgICAgICBjb25zdCBwYWdlclR5cGUgPSB0aGlzLnByb3BzLnBhZ2VyVHlwZTtcclxuICAgICAgICBpZiAocGFnZXJUeXBlID09PSBcInNlcnZlclwiKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuaXRlbXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuaXRlbXMgPSBHcmlkVmlldy5zdGF0aWNHZXRTb3J0ZWRBbmRGaWx0ZXJlZEl0ZW1zKHRoaXMucHJvcHMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmZpbHRlciwgc3RhdGVEZWx0YS5zb3J0LCB0aGlzLnByb3BzLmRlZmF1bHRTb3J0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlRGVsdGEuc2VsZWN0ZWRJbmRleGVzID0gW107XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZURlbHRhKTtcclxuICAgIH07XHJcblxyXG4gICAgaGFuZGxlRmlsdGVyQ2hhbmdlKGZpbHRlcikge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlRGVsdGEgPSB7fTtcclxuICAgICAgICBsZXQga2V5ID0gZmlsdGVyLmNvbHVtbi5rZXk7XHJcbiAgICAgICAgbGV0IGlkID0gXCJjb2x1bW5maWx0ZXJfXCIgKyBrZXk7XHJcbiAgICAgICAgc3RhdGVEZWx0YS5maWx0ZXIgPSB0aGlzLnN0YXRlLmZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGhpcy5zdGF0ZS5maWx0ZXIgOiBuZXcgRnVuY3Rpb25hbEZpbHRlcihbXSx0aGlzLnByb3BzLmNvbHVtbnMubWFwKGM9PmMua2V5KSkgO1xyXG4gICAgICAgIHN0YXRlRGVsdGEuZmlsdGVyLlJlbW92ZUZpbHRlcih7bmFtZToga2V5LCBpZDogaWR9KTtcclxuICAgICAgICBpZiAoZmlsdGVyLmZpbHRlclRlcm0gIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgc3RhdGVEZWx0YS5maWx0ZXIuQWRkRmlsdGVyKHtuYW1lczogW2tleV0sIGV4cGVjdGVkOiBmaWx0ZXIuZmlsdGVyVGVybSwgdGVybTogRmlsdGVyVGVybXMuTGlrZSwgaWQ6IGlkfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChHcmlkVmlldy5zdGF0aWNJc1NlcnZlck1vZGUodGhpcy5wcm9wcykpIHtcclxuICAgICAgICAgICAgc3RhdGVEZWx0YS5pdGVtcyA9IFtdO1xyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLnNlbGVjdGVkSW5kZXhlcyA9IFtdO1xyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLnJvd3NDb3VudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuaXRlbXMgPSBHcmlkVmlldy5zdGF0aWNHZXRTb3J0ZWRBbmRGaWx0ZXJlZEl0ZW1zKHRoaXMucHJvcHMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZURlbHRhLmZpbHRlciwgdGhpcy5zdGF0ZS5zb3J0LCB0aGlzLnByb3BzLmRlZmF1bHRTb3J0KTtcclxuICAgICAgICAgICAgc3RhdGVEZWx0YS5zZWxlY3RlZEluZGV4ZXMgPSBbXTtcclxuICAgICAgICAgICAgc3RhdGVEZWx0YS5yb3dzQ291bnQgPSBzdGF0ZURlbHRhLml0ZW1zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZURlbHRhKTtcclxuICAgIH07XHJcblxyXG4gICAgb25DbGVhckZpbHRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7ZmlsdGVyOiB0aGlzLnByb3BzLmZpbHRlcn0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLy8tLS0tLS0tLS0tXHJcbiAgICAvLy9SZXNpemVcclxuICAgIC8vLy0tLS0tLS0tLS1cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWNhbGNTaXplUGFyYW1zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjYWxjU2l6ZVBhcmFtcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzTW91bnRlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnByb3BzLmF1dG9IZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGggPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGdyaWRIZWlnaHQ6IGggLSB0aGlzLnByb3BzLmRlbHRhSGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUm93TG9hZGluZ1JlbmRlcmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIHNldFNjcm9sbExlZnQoc2Nyb2xsQnkpIHtcclxuICAgICAgICB0aGlzLnJvdy5zZXRTY3JvbGxMZWZ0KHNjcm9sbEJ5KTtcclxuICAgIH07XHJcblxyXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnJvdy5fX2xvYWRpbmcgPyAnZHdraXQtZ3JpZHZpZXctcm93bG9hZGluZycgOiBcIlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT17dGhpcy5nZXRDbGFzc05hbWUoKX0+PFJvdyByZWY9e25vZGUgPT4gdGhpcy5yb3cgPSBub2RlfSB7Li4udGhpcy5wcm9wc30vPjwvZGl2Pik7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udHJvbC9ncmlkdmlldy5qc3giLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC1kYXRhLWdyaWQnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QtZG9tXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJlYWN0RGF0YUdyaWRcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3REYXRhR3JpZFwiXSA9IGZhY3Rvcnkocm9vdFtcIlJlYWN0XCJdLCByb290W1wiUmVhY3RET01cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMwKTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblxuXHRpZiAoZmFsc2UpIHtcblx0ICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgIFN5bWJvbC5mb3IgJiZcblx0ICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0ICAgIDB4ZWFjNztcblxuXHQgIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdCAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuXHQgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcblx0ICB9O1xuXG5cdCAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG5cdCAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuXHQgIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG5cdH0gZWxzZSB7XG5cdCAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cblx0ICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NykoKTtcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogNCAqLyxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXG5cdCAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG5cdCAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcblx0ICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG5cdCovXG5cdC8qIGdsb2JhbCBkZWZpbmUgKi9cblxuXHQoZnVuY3Rpb24gKCkge1xuXHRcdCd1c2Ugc3RyaWN0JztcblxuXHRcdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRcdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0XHR9IGVsc2UgaWYgKHRydWUpIHtcblx0XHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRcdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0XHR9LmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0XHR9XG5cdH0oKSk7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGdldENvbHVtbjogZnVuY3Rpb24gZ2V0Q29sdW1uKGNvbHVtbnMsIGlkeCkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1ucykpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnNbaWR4XTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIEltbXV0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnMuZ2V0KGlkeCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBzcGxpY2VDb2x1bW46IGZ1bmN0aW9uIHNwbGljZUNvbHVtbihtZXRyaWNzLCBpZHgsIGNvbHVtbikge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0cmljcy5jb2x1bW5zKSkge1xuXHQgICAgICBtZXRyaWNzLmNvbHVtbnMuc3BsaWNlKGlkeCwgMSwgY29sdW1uKTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIEltbXV0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgbWV0cmljcy5jb2x1bW5zID0gbWV0cmljcy5jb2x1bW5zLnNwbGljZShpZHgsIDEsIGNvbHVtbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWV0cmljcztcblx0ICB9LFxuXHQgIGdldFNpemU6IGZ1bmN0aW9uIGdldFNpemUoY29sdW1ucykge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1ucykpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnMubGVuZ3RoO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgSW1tdXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICByZXR1cm4gY29sdW1ucy5zaXplO1xuXHQgICAgfVxuXHQgIH0sXG5cblxuXHQgIC8vIExvZ2ljIGV4dGVudGVkIHRvIGFsbG93IGZvciBmdW5jdGlvbnMgdG8gYmUgcGFzc2VkIGRvd24gaW4gY29sdW1uLmVkaXRhYmxlXG5cdCAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gZGVpY2RlIHdoZXRoZXIgd2UgY2FuIGJlIGVkdGluZyBmcm9tIGEgY2VsbCBsZXZlbFxuXHQgIGNhbkVkaXQ6IGZ1bmN0aW9uIGNhbkVkaXQoY29sLCByb3dEYXRhLCBlbmFibGVDZWxsU2VsZWN0KSB7XG5cdCAgICBpZiAoIWNvbCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgaWYgKGNvbC5lZGl0YWJsZSAhPSBudWxsICYmIHR5cGVvZiBjb2wuZWRpdGFibGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIGVuYWJsZUNlbGxTZWxlY3QgPT09IHRydWUgJiYgY29sLmVkaXRhYmxlKHJvd0RhdGEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGVuYWJsZUNlbGxTZWxlY3QgPT09IHRydWUgJiYgKCEhY29sLmVkaXRvciB8fCAhIWNvbC5lZGl0YWJsZSk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoY29sdW1uLCBwcm9wZXJ0eSkge1xuXHQgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXHQgICAgaWYgKGNvbHVtbi50b0pTT04gJiYgY29sdW1uLmdldCkge1xuXHQgICAgICB2YWx1ZSA9IGNvbHVtbi5nZXQocHJvcGVydHkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFsdWUgPSBjb2x1bW5bcHJvcGVydHldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0fTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Lypcblx0XHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcblx0Ki9cblx0Ly8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGlzdCA9IFtdO1xuXG5cdFx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRcdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcblx0XHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuXHRcdH07XG5cblx0XHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRcdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gbGlzdDtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKlxuXHRcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuXHQqL1xuXHR2YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0XHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHRcdHZhciBtZW1vO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qoc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXHRcdH0pLFxuXHRcdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cdFx0fSksXG5cdFx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdFx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0XHRpZihmYWxzZSkge1xuXHRcdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdFx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdFx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0XHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0XHR9XG5cdFx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHRcdHZhciBzdHlsZXMgPSBbXTtcblx0XHR2YXIgbmV3U3R5bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHRcdHZhciBpZCA9IGl0ZW1bMF07XG5cdFx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHlsZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XG5cdFx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHRcdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRcdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0XHRpZihpZHggPj0gMCkge1xuXHRcdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRcdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJldHVybiBzdHlsZUVsZW1lbnQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XG5cdFx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdFx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0XHRyZXR1cm4gbGlua0VsZW1lbnQ7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRcdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHRcdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxuXHRcdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHVwZGF0ZShvYmopO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqKSB7XG5cdFx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdHZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblx0XHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHRcdH07XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHRcdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRcdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0XHR2YXIgY3NzID0gb2JqLmNzcztcblx0XHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0XHRpZihtZWRpYSkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHRcdH1cblxuXHRcdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xuXHRcdHZhciBjc3MgPSBvYmouY3NzO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdFx0aWYoc291cmNlTWFwKSB7XG5cdFx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHRcdH1cblxuXHRcdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdFx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0XHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRcdGlmKG9sZFNyYylcblx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85X187XG5cbi8qKiovIH0pLFxuLyogMTAgKi8sXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgc2VsZWN0ZWQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LmlzUmVxdWlyZWQsXG5cdCAgY29waWVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICBkcmFnZ2VkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICBvbkNlbGxDbGljazogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgb25DZWxsRG91YmxlQ2xpY2s6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYy5pc1JlcXVpcmVkLFxuXHQgIG9uQ29tbWl0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBvbkNvbW1pdENhbmNlbDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgaGFuZGxlRHJhZ0VudGVyUm93OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBoYW5kbGVUZXJtaW5hdGVEcmFnOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBnZXRDZWxsQWN0aW9uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdHZhciBFeGNlbENvbHVtblNoYXBlID0ge1xuXHQgIG5hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubm9kZS5pc1JlcXVpcmVkLFxuXHQgIGtleTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICB3aWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBmaWx0ZXJhYmxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEV4Y2VsQ29sdW1uU2hhcGU7XG5cbi8qKiovIH0pLFxuLyogMTMgKi8sXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFdpdGhQcm9wZXJ0aWVzKG9yaWdpbmFsT2JqLCBwcm9wZXJ0aWVzKSB7XG5cdCAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgIGZvciAodmFyIF9pdGVyYXRvciA9IHByb3BlcnRpZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG5cdCAgICB2YXIgX3JlZjtcblxuXHQgICAgaWYgKF9pc0FycmF5KSB7XG5cdCAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcblx0ICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuXHQgICAgICBfcmVmID0gX2kudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwcm9wZXJ0eSA9IF9yZWY7XG5cblx0ICAgIGlmIChwcm9wZXJ0eSBpbiBvcmlnaW5hbE9iaikge1xuXHQgICAgICByZXN1bHRbcHJvcGVydHldID0gb3JpZ2luYWxPYmpbcHJvcGVydHldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVPYmplY3RXaXRoUHJvcGVydGllcztcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cblx0Ly8gbG9hZCB0aGUgc3R5bGVzXG5cdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDEpO1xuXHRpZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxuXHR2YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KShjb250ZW50LCB7fSk7XG5cdGlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5cdGlmKGZhbHNlKSB7XG5cdFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0XHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlYWN0LWRhdGEtZ3JpZC1oZWFkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZGF0YS1ncmlkLWhlYWRlci5jc3NcIik7XG5cdFx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMTYgKi8sXG4vKiAxNyAqLyxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblxuXHQoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHQgICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHQgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdCAgKGdsb2JhbC5JbW11dGFibGUgPSBmYWN0b3J5KCkpO1xuXHR9KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO3ZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cdCAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY3Rvciwgc3VwZXJDbGFzcykge1xuXHQgICAgaWYgKHN1cGVyQ2xhc3MpIHtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcblx0ICAgIH1cblx0ICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBJdGVyYWJsZSh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaXNJdGVyYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG5cdCAgICB9XG5cblxuXHQgIGNyZWF0ZUNsYXNzKEtleWVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcblx0ICAgIGZ1bmN0aW9uIEtleWVkSXRlcmFibGUodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUgOiBLZXllZFNlcSh2YWx1ZSk7XG5cdCAgICB9XG5cblxuXHQgIGNyZWF0ZUNsYXNzKEluZGV4ZWRJdGVyYWJsZSwgSXRlcmFibGUpO1xuXHQgICAgZnVuY3Rpb24gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcblx0ICAgIH1cblxuXG5cdCAgY3JlYXRlQ2xhc3MoU2V0SXRlcmFibGUsIEl0ZXJhYmxlKTtcblx0ICAgIGZ1bmN0aW9uIFNldEl0ZXJhYmxlKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpc0l0ZXJhYmxlKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IFNldFNlcSh2YWx1ZSk7XG5cdCAgICB9XG5cblxuXG5cdCAgZnVuY3Rpb24gaXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG5cdCAgICByZXR1cm4gISEobWF5YmVJdGVyYWJsZSAmJiBtYXliZUl0ZXJhYmxlW0lTX0lURVJBQkxFX1NFTlRJTkVMXSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG5cdCAgICByZXR1cm4gISEobWF5YmVLZXllZCAmJiBtYXliZUtleWVkW0lTX0tFWUVEX1NFTlRJTkVMXSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuXHQgICAgcmV0dXJuICEhKG1heWJlSW5kZXhlZCAmJiBtYXliZUluZGV4ZWRbSVNfSU5ERVhFRF9TRU5USU5FTF0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuXHQgICAgcmV0dXJuIGlzS2V5ZWQobWF5YmVBc3NvY2lhdGl2ZSkgfHwgaXNJbmRleGVkKG1heWJlQXNzb2NpYXRpdmUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcblx0ICAgIHJldHVybiAhIShtYXliZU9yZGVyZWQgJiYgbWF5YmVPcmRlcmVkW0lTX09SREVSRURfU0VOVElORUxdKTtcblx0ICB9XG5cblx0ICBJdGVyYWJsZS5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcblx0ICBJdGVyYWJsZS5pc0tleWVkID0gaXNLZXllZDtcblx0ICBJdGVyYWJsZS5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG5cdCAgSXRlcmFibGUuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG5cdCAgSXRlcmFibGUuaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG5cdCAgSXRlcmFibGUuS2V5ZWQgPSBLZXllZEl0ZXJhYmxlO1xuXHQgIEl0ZXJhYmxlLkluZGV4ZWQgPSBJbmRleGVkSXRlcmFibGU7XG5cdCAgSXRlcmFibGUuU2V0ID0gU2V0SXRlcmFibGU7XG5cblxuXHQgIHZhciBJU19JVEVSQUJMRV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG5cdCAgdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcblx0ICB2YXIgSVNfSU5ERVhFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcblx0ICB2YXIgSVNfT1JERVJFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuXHQgIC8vIFVzZWQgZm9yIHNldHRpbmcgcHJvdG90eXBlIG1ldGhvZHMgdGhhdCBJRTggY2hva2VzIG9uLlxuXHQgIHZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuXHQgIC8vIENvbnN0YW50cyBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRyaWUgbm9kZXMuXG5cdCAgdmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG5cdCAgdmFyIFNJWkUgPSAxIDw8IFNISUZUO1xuXHQgIHZhciBNQVNLID0gU0laRSAtIDE7XG5cblx0ICAvLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuXHQgIC8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG5cdCAgdmFyIE5PVF9TRVQgPSB7fTtcblxuXHQgIC8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cblx0ICB2YXIgQ0hBTkdFX0xFTkdUSCA9IHsgdmFsdWU6IGZhbHNlIH07XG5cdCAgdmFyIERJRF9BTFRFUiA9IHsgdmFsdWU6IGZhbHNlIH07XG5cblx0ICBmdW5jdGlvbiBNYWtlUmVmKHJlZikge1xuXHQgICAgcmVmLnZhbHVlID0gZmFsc2U7XG5cdCAgICByZXR1cm4gcmVmO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIFNldFJlZihyZWYpIHtcblx0ICAgIHJlZiAmJiAocmVmLnZhbHVlID0gdHJ1ZSk7XG5cdCAgfVxuXG5cdCAgLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuXHQgIC8vIHRvIHRyaWVzLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgb25seSBldmVyIGVxdWFsIGl0c2VsZiwgYW5kIHdpbGwgbm90IGVxdWFsXG5cdCAgLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG5cdCAgZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cblx0ICAvLyBodHRwOi8vanNwZXJmLmNvbS9jb3B5LWFycmF5LWlubGluZVxuXHQgIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcblx0ICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHQgICAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIGFyci5sZW5ndGggLSBvZmZzZXQpO1xuXHQgICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuXHQgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuXHQgICAgICBuZXdBcnJbaWldID0gYXJyW2lpICsgb2Zmc2V0XTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdBcnI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG5cdCAgICBpZiAoaXRlci5zaXplID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgaXRlci5zaXplID0gaXRlci5fX2l0ZXJhdGUocmV0dXJuVHJ1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaXRlci5zaXplO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuXHQgICAgLy8gVGhpcyBpbXBsZW1lbnRzIFwiaXMgYXJyYXkgaW5kZXhcIiB3aGljaCB0aGUgRUNNQVN0cmluZyBzcGVjIGRlZmluZXMgYXM6XG5cdCAgICAvL1xuXHQgICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuXHQgICAgLy8gICAgIFRvU3RyaW5nKFRvVWludDMyKFApKSBpcyBlcXVhbCB0byBQIGFuZCBUb1VpbnQzMihQKSBpcyBub3QgZXF1YWxcblx0ICAgIC8vICAgICB0byAyXjMy4oiSMS5cblx0ICAgIC8vXG5cdCAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXktZXhvdGljLW9iamVjdHNcblx0ICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG5cdCAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcblx0ICAgICAgaWYgKCcnICsgdWludDMySW5kZXggIT09IGluZGV4IHx8IHVpbnQzMkluZGV4ID09PSA0Mjk0OTY3Mjk1KSB7XG5cdCAgICAgICAgcmV0dXJuIE5hTjtcblx0ICAgICAgfVxuXHQgICAgICBpbmRleCA9IHVpbnQzMkluZGV4O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpIHtcblx0ICAgIHJldHVybiAoYmVnaW4gPT09IDAgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG5cdCAgICAgIChlbmQgPT09IHVuZGVmaW5lZCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA+PSBzaXplKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG5cdCAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBzaXplLCAwKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuXHQgICAgcmV0dXJuIHJlc29sdmVJbmRleChlbmQsIHNpemUsIHNpemUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG5cdCAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCA/XG5cdCAgICAgIGRlZmF1bHRJbmRleCA6XG5cdCAgICAgIGluZGV4IDwgMCA/XG5cdCAgICAgICAgTWF0aC5tYXgoMCwgc2l6ZSArIGluZGV4KSA6XG5cdCAgICAgICAgc2l6ZSA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgIGluZGV4IDpcblx0ICAgICAgICAgIE1hdGgubWluKHNpemUsIGluZGV4KTtcblx0ICB9XG5cblx0ICAvKiBnbG9iYWwgU3ltYm9sICovXG5cblx0ICB2YXIgSVRFUkFURV9LRVlTID0gMDtcblx0ICB2YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xuXHQgIHZhciBJVEVSQVRFX0VOVFJJRVMgPSAyO1xuXG5cdCAgdmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cdCAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5cdCAgdmFyIElURVJBVE9SX1NZTUJPTCA9IFJFQUxfSVRFUkFUT1JfU1lNQk9MIHx8IEZBVVhfSVRFUkFUT1JfU1lNQk9MO1xuXG5cblx0ICBmdW5jdGlvbiBJdGVyYXRvcihuZXh0KSB7XG5cdCAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG5cdCAgICB9XG5cblx0ICAgIEl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xuXHQgICAgfTtcblxuXG5cdCAgSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcblx0ICBJdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcblx0ICBJdGVyYXRvci5FTlRSSUVTID0gSVRFUkFURV9FTlRSSUVTO1xuXG5cdCAgSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPVxuXHQgIEl0ZXJhdG9yLnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxuXHQgIEl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXG5cdCAgZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuXHQgICAgdmFyIHZhbHVlID0gdHlwZSA9PT0gMCA/IGsgOiB0eXBlID09PSAxID8gdiA6IFtrLCB2XTtcblx0ICAgIGl0ZXJhdG9yUmVzdWx0ID8gKGl0ZXJhdG9yUmVzdWx0LnZhbHVlID0gdmFsdWUpIDogKGl0ZXJhdG9yUmVzdWx0ID0ge1xuXHQgICAgICB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBpdGVyYXRvclJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpdGVyYXRvckRvbmUoKSB7XG5cdCAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaGFzSXRlcmF0b3IobWF5YmVJdGVyYWJsZSkge1xuXHQgICAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpc0l0ZXJhdG9yKG1heWJlSXRlcmF0b3IpIHtcblx0ICAgIHJldHVybiBtYXliZUl0ZXJhdG9yICYmIHR5cGVvZiBtYXliZUl0ZXJhdG9yLm5leHQgPT09ICdmdW5jdGlvbic7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcblx0ICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSk7XG5cdCAgICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpIHtcblx0ICAgIHZhciBpdGVyYXRvckZuID0gaXRlcmFibGUgJiYgKFxuXHQgICAgICAoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuXHQgICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF1cblx0ICAgICk7XG5cdCAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcblx0ICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcblx0ICB9XG5cblx0ICBjcmVhdGVDbGFzcyhTZXEsIEl0ZXJhYmxlKTtcblx0ICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG5cdCAgICAgICAgaXNJdGVyYWJsZSh2YWx1ZSkgPyB2YWx1ZS50b1NlcSgpIDogc2VxRnJvbVZhbHVlKHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgU2VxLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuXHQgICAgICByZXR1cm4gU2VxKGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICBTZXEucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblxuXHQgICAgU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgeycsICd9Jyk7XG5cdCAgICB9O1xuXG5cdCAgICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuXHQgICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcblx0ICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9jYWNoZS5sZW5ndGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuXHQgICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuXHQgICAgICByZXR1cm4gc2VxSXRlcmF0ZSh0aGlzLCBmbiwgcmV2ZXJzZSwgdHJ1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuXHQgICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICByZXR1cm4gc2VxSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSwgdHJ1ZSk7XG5cdCAgICB9O1xuXG5cblxuXHQgIGNyZWF0ZUNsYXNzKEtleWVkU2VxLCBTZXEpO1xuXHQgICAgZnVuY3Rpb24gS2V5ZWRTZXEodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHQgICAgICAgIGVtcHR5U2VxdWVuY2UoKS50b0tleWVkU2VxKCkgOlxuXHQgICAgICAgIGlzSXRlcmFibGUodmFsdWUpID9cblx0ICAgICAgICAgIChpc0tleWVkKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKSkgOlxuXHQgICAgICAgICAga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblxuXG5cdCAgY3JlYXRlQ2xhc3MoSW5kZXhlZFNlcSwgU2VxKTtcblx0ICAgIGZ1bmN0aW9uIEluZGV4ZWRTZXEodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuXHQgICAgICAgICFpc0l0ZXJhYmxlKHZhbHVlKSA/IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIDpcblx0ICAgICAgICBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLmVudHJ5U2VxKCkgOiB2YWx1ZS50b0luZGV4ZWRTZXEoKTtcblx0ICAgIH1cblxuXHQgICAgSW5kZXhlZFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcblx0ICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSBbJywgJ10nKTtcblx0ICAgIH07XG5cblx0ICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG5cdCAgICAgIHJldHVybiBzZXFJdGVyYXRlKHRoaXMsIGZuLCByZXZlcnNlLCBmYWxzZSk7XG5cdCAgICB9O1xuXG5cdCAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICByZXR1cm4gc2VxSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSwgZmFsc2UpO1xuXHQgICAgfTtcblxuXG5cblx0ICBjcmVhdGVDbGFzcyhTZXRTZXEsIFNlcSk7XG5cdCAgICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcblx0ICAgICAgICAhaXNJdGVyYWJsZSh2YWx1ZSkgPyBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSA6XG5cdCAgICAgICAgaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS5lbnRyeVNlcSgpIDogdmFsdWVcblx0ICAgICAgKS50b1NldFNlcSgpO1xuXHQgICAgfVxuXG5cdCAgICBTZXRTZXEub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG5cdCAgICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXG5cblxuXHQgIFNlcS5pc1NlcSA9IGlzU2VxO1xuXHQgIFNlcS5LZXllZCA9IEtleWVkU2VxO1xuXHQgIFNlcS5TZXQgPSBTZXRTZXE7XG5cdCAgU2VxLkluZGV4ZWQgPSBJbmRleGVkU2VxO1xuXG5cdCAgdmFyIElTX1NFUV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG5cdCAgU2VxLnByb3RvdHlwZVtJU19TRVFfU0VOVElORUxdID0gdHJ1ZTtcblxuXG5cblx0ICBjcmVhdGVDbGFzcyhBcnJheVNlcSwgSW5kZXhlZFNlcSk7XG5cdCAgICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuXHQgICAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuXHQgICAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG5cdCAgICB9XG5cblx0ICAgIEFycmF5U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX2FycmF5W3dyYXBJbmRleCh0aGlzLCBpbmRleCldIDogbm90U2V0VmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG5cdCAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG5cdCAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcblx0ICAgICAgICBpZiAoZm4oYXJyYXlbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0sIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICAgIHJldHVybiBpaSArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpaTtcblx0ICAgIH07XG5cblx0ICAgIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcblx0ICAgICAgdmFyIG1heEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcblx0ICAgICAgdmFyIGlpID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuXHQgICAgICAgIHtyZXR1cm4gaWkgPiBtYXhJbmRleCA/XG5cdCAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG5cdCAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSsrIDogaWkrK10pfVxuXHQgICAgICApO1xuXHQgICAgfTtcblxuXG5cblx0ICBjcmVhdGVDbGFzcyhPYmplY3RTZXEsIEtleWVkU2VxKTtcblx0ICAgIGZ1bmN0aW9uIE9iamVjdFNlcShvYmplY3QpIHtcblx0ICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXHQgICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG5cdCAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuXHQgICAgICB0aGlzLnNpemUgPSBrZXlzLmxlbmd0aDtcblx0ICAgIH1cblxuXHQgICAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIGlmIChub3RTZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhcyhrZXkpKSB7XG5cdCAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9vYmplY3Rba2V5XTtcblx0ICAgIH07XG5cblx0ICAgIE9iamVjdFNlcS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9vYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcblx0ICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuXHQgICAgICB2YXIgbWF4SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG5cdCAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcblx0ICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcblx0ICAgICAgICBpZiAoZm4ob2JqZWN0W2tleV0sIGtleSwgdGhpcykgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaWk7XG5cdCAgICB9O1xuXG5cdCAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG5cdCAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcblx0ICAgICAgdmFyIG1heEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuXHQgICAgICB2YXIgaWkgPSAwO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcblx0ICAgICAgICByZXR1cm4gaWkrKyA+IG1heEluZGV4ID9cblx0ICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcblx0ICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgIE9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cblx0ICBjcmVhdGVDbGFzcyhJdGVyYWJsZVNlcSwgSW5kZXhlZFNlcSk7XG5cdCAgICBmdW5jdGlvbiBJdGVyYWJsZVNlcShpdGVyYWJsZSkge1xuXHQgICAgICB0aGlzLl9pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuXHQgICAgICB0aGlzLnNpemUgPSBpdGVyYWJsZS5sZW5ndGggfHwgaXRlcmFibGUuc2l6ZTtcblx0ICAgIH1cblxuXHQgICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcblx0ICAgICAgaWYgKHJldmVyc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGU7XG5cdCAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICBpZiAoaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcblx0ICAgICAgICB2YXIgc3RlcDtcblx0ICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdCAgICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgfTtcblxuXHQgICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgaWYgKHJldmVyc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGU7XG5cdCAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblxuXG5cdCAgY3JlYXRlQ2xhc3MoSXRlcmF0b3JTZXEsIEluZGV4ZWRTZXEpO1xuXHQgICAgZnVuY3Rpb24gSXRlcmF0b3JTZXEoaXRlcmF0b3IpIHtcblx0ICAgICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcblx0ICAgICAgdGhpcy5faXRlcmF0b3JDYWNoZSA9IFtdO1xuXHQgICAgfVxuXG5cdCAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcblx0ICAgICAgdmFyIGNhY2hlID0gdGhpcy5faXRlcmF0b3JDYWNoZTtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB3aGlsZSAoaXRlcmF0aW9ucyA8IGNhY2hlLmxlbmd0aCkge1xuXHQgICAgICAgIGlmIChmbihjYWNoZVtpdGVyYXRpb25zXSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICB2YXIgc3RlcDtcblx0ICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgIHZhciB2YWwgPSBzdGVwLnZhbHVlO1xuXHQgICAgICAgIGNhY2hlW2l0ZXJhdGlvbnNdID0gdmFsO1xuXHQgICAgICAgIGlmIChmbih2YWwsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG5cdCAgICB9O1xuXG5cdCAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcblx0ICAgICAgdmFyIGNhY2hlID0gdGhpcy5faXRlcmF0b3JDYWNoZTtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICBpZiAoaXRlcmF0aW9ucyA+PSBjYWNoZS5sZW5ndGgpIHtcblx0ICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gc3RlcDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNhY2hlW2l0ZXJhdGlvbnNdID0gc3RlcC52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucywgY2FjaGVbaXRlcmF0aW9ucysrXSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXG5cblxuXHQgIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuXHQgIGZ1bmN0aW9uIGlzU2VxKG1heWJlU2VxKSB7XG5cdCAgICByZXR1cm4gISEobWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NFTlRJTkVMXSk7XG5cdCAgfVxuXG5cdCAgdmFyIEVNUFRZX1NFUTtcblxuXHQgIGZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG5cdCAgICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuXHQgICAgdmFyIHNlcSA9XG5cdCAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gbmV3IEFycmF5U2VxKHZhbHVlKS5mcm9tRW50cnlTZXEoKSA6XG5cdCAgICAgIGlzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhdG9yU2VxKHZhbHVlKS5mcm9tRW50cnlTZXEoKSA6XG5cdCAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuXHQgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gbmV3IE9iamVjdFNlcSh2YWx1ZSkgOlxuXHQgICAgICB1bmRlZmluZWQ7XG5cdCAgICBpZiAoIXNlcSkge1xuXHQgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgICAgICdFeHBlY3RlZCBBcnJheSBvciBpdGVyYWJsZSBvYmplY3Qgb2YgW2ssIHZdIGVudHJpZXMsICcrXG5cdCAgICAgICAgJ29yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2VxO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcblx0ICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuXHQgICAgaWYgKCFzZXEpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcblx0ICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2VxO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuXHQgICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgfHxcblx0ICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgbmV3IE9iamVjdFNlcSh2YWx1ZSkpO1xuXHQgICAgaWYgKCFzZXEpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcblx0ICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlcywgb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcblx0ICAgICAgKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzZXE7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgPyBuZXcgQXJyYXlTZXEodmFsdWUpIDpcblx0ICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpIDpcblx0ICAgICAgaGFzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhYmxlU2VxKHZhbHVlKSA6XG5cdCAgICAgIHVuZGVmaW5lZFxuXHQgICAgKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXFJdGVyYXRlKHNlcSwgZm4sIHJldmVyc2UsIHVzZUtleXMpIHtcblx0ICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG5cdCAgICBpZiAoY2FjaGUpIHtcblx0ICAgICAgdmFyIG1heEluZGV4ID0gY2FjaGUubGVuZ3RoIC0gMTtcblx0ICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuXHQgICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuXHQgICAgICAgIGlmIChmbihlbnRyeVsxXSwgdXNlS2V5cyA/IGVudHJ5WzBdIDogaWksIHNlcSkgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaWk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2VxLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXFJdGVyYXRvcihzZXEsIHR5cGUsIHJldmVyc2UsIHVzZUtleXMpIHtcblx0ICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG5cdCAgICBpZiAoY2FjaGUpIHtcblx0ICAgICAgdmFyIG1heEluZGV4ID0gY2FjaGUubGVuZ3RoIC0gMTtcblx0ICAgICAgdmFyIGlpID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG5cdCAgICAgICAgcmV0dXJuIGlpKysgPiBtYXhJbmRleCA/XG5cdCAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG5cdCAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBlbnRyeVswXSA6IGlpIC0gMSwgZW50cnlbMV0pO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzZXEuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZyb21KUyhqc29uLCBjb252ZXJ0ZXIpIHtcblx0ICAgIHJldHVybiBjb252ZXJ0ZXIgP1xuXHQgICAgICBmcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwgJycsIHsnJzoganNvbn0pIDpcblx0ICAgICAgZnJvbUpTRGVmYXVsdChqc29uKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBmcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwga2V5LCBwYXJlbnRKU09OKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuXHQgICAgICByZXR1cm4gY29udmVydGVyLmNhbGwocGFyZW50SlNPTiwga2V5LCBJbmRleGVkU2VxKGpzb24pLm1hcChmdW5jdGlvbih2LCBrKSAge3JldHVybiBmcm9tSlNXaXRoKGNvbnZlcnRlciwgdiwgaywganNvbil9KSk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuXHQgICAgICByZXR1cm4gY29udmVydGVyLmNhbGwocGFyZW50SlNPTiwga2V5LCBLZXllZFNlcShqc29uKS5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pfSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGpzb247XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZnJvbUpTRGVmYXVsdChqc29uKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuXHQgICAgICByZXR1cm4gSW5kZXhlZFNlcShqc29uKS5tYXAoZnJvbUpTRGVmYXVsdCkudG9MaXN0KCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuXHQgICAgICByZXR1cm4gS2V5ZWRTZXEoanNvbikubWFwKGZyb21KU0RlZmF1bHQpLnRvTWFwKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ganNvbjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpc1BsYWluT2JqKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgJiYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcblx0ICAgKiBhbmQgU2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjS2V5X2VxdWFsaXR5KVxuXHQgICAqXG5cdCAgICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG5cdCAgICogdmFsdWUsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGJ5XG5cdCAgICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuXHQgICAqXG5cdCAgICogVGhpcyBpcyBleHRlbmRlZCBmdXJ0aGVyIHRvIGFsbG93IE9iamVjdHMgdG8gZGVzY3JpYmUgdGhlIHZhbHVlcyB0aGV5XG5cdCAgICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG5cdCAgICpcblx0ICAgKiBOb3RlOiBiZWNhdXNlIG9mIHRoaXMgZXh0ZW5zaW9uLCB0aGUga2V5IGVxdWFsaXR5IG9mIEltbXV0YWJsZS5NYXAgYW5kIHRoZVxuXHQgICAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG5cdCAgICpcblx0ICAgKiAjIyMgRGVmaW5pbmcgY3VzdG9tIHZhbHVlc1xuXHQgICAqXG5cdCAgICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcblx0ICAgKiBgdmFsdWVPZmAuIEZvciBleGFtcGxlLCBgRGF0ZWAgcmVwcmVzZW50cyBhIHZhbHVlIGJ5IHJldHVybmluZyBhIHVuaXhcblx0ICAgKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcblx0ICAgKlxuXHQgICAqICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTsgLy8gRnJpIEZlYiAxMyAyMDA5IC4uLlxuXHQgICAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcblx0ICAgKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG5cdCAgICogICAgIGFzc2VydCggZGF0ZTEgIT09IGRhdGUyICk7XG5cdCAgICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuXHQgICAqXG5cdCAgICogTm90ZTogb3ZlcnJpZGluZyBgdmFsdWVPZmAgbWF5IGhhdmUgb3RoZXIgaW1wbGljYXRpb25zIGlmIHlvdSB1c2UgdGhpcyBvYmplY3Rcblx0ICAgKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuXHQgICAqXG5cdCAgICogRm9yIG1vcmUgY29tcGxleCB0eXBlcywgZXNwZWNpYWxseSBjb2xsZWN0aW9ucywgaW1wbGVtZW50aW5nIGB2YWx1ZU9mYCBtYXlcblx0ICAgKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuXHQgICAqXG5cdCAgICogYGVxdWFsc2AgdGFrZXMgYW5vdGhlciBvYmplY3QsIHByZXN1bWFibHkgb2Ygc2ltaWxhciB0eXBlLCBhbmQgcmV0dXJucyB0cnVlXG5cdCAgICogaWYgdGhlIGl0IGlzIGVxdWFsLiBFcXVhbGl0eSBpcyBzeW1tZXRyaWNhbCwgc28gdGhlIHNhbWUgcmVzdWx0IHNob3VsZCBiZVxuXHQgICAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cblx0ICAgKlxuXHQgICAqICAgICBhc3NlcnQoIGEuZXF1YWxzKGIpID09PSBiLmVxdWFscyhhKSApO1xuXHQgICAqXG5cdCAgICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuXHQgICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aGUgdmFsdWUgb2JqZWN0IGluIGEgTWFwIG9yIFNldC4gWW91IG11c3Rcblx0ICAgKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG5cdCAgICpcblx0ICAgKiBBbHNvLCBhbiBpbXBvcnRhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlc2UgbWV0aG9kcyBtdXN0IGJlIHVwaGVsZDogaWYgdHdvXG5cdCAgICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3Rcblx0ICAgKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuXHQgICAqIGFuZCB3aGlsZSB1bmRlc2lyYWJsZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgYWNjZXB0YWJsZS5cblx0ICAgKlxuXHQgICAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcblx0ICAgKiAgICAgICBhc3NlcnQoIGEuaGFzaENvZGUoKSA9PT0gYi5oYXNoQ29kZSgpICk7XG5cdCAgICogICAgIH1cblx0ICAgKlxuXHQgICAqIEFsbCBJbW11dGFibGUgY29sbGVjdGlvbnMgaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuXHQgICAqXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcblx0ICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICAgICAgdHlwZW9mIHZhbHVlQi52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhbHVlQSA9IHZhbHVlQS52YWx1ZU9mKCk7XG5cdCAgICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG5cdCAgICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZUEuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICAgICAgdHlwZW9mIHZhbHVlQi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgICAgICB2YWx1ZUEuZXF1YWxzKHZhbHVlQikpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcblx0ICAgIGlmIChhID09PSBiKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoXG5cdCAgICAgICFpc0l0ZXJhYmxlKGIpIHx8XG5cdCAgICAgIGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplIHx8XG5cdCAgICAgIGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiYgYi5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJiBhLl9faGFzaCAhPT0gYi5fX2hhc2ggfHxcblx0ICAgICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuXHQgICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuXHQgICAgICBpc09yZGVyZWQoYSkgIT09IGlzT3JkZXJlZChiKVxuXHQgICAgKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG5cdCAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG5cdCAgICAgIHZhciBlbnRyaWVzID0gYS5lbnRyaWVzKCk7XG5cdCAgICAgIHJldHVybiBiLmV2ZXJ5KGZ1bmN0aW9uKHYsIGspICB7XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG5cdCAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGlzKGVudHJ5WzFdLCB2KSAmJiAobm90QXNzb2NpYXRpdmUgfHwgaXMoZW50cnlbMF0sIGspKTtcblx0ICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcblxuXHQgICAgaWYgKGEuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYS5jYWNoZVJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgYS5jYWNoZVJlc3VsdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgXyA9IGE7XG5cdCAgICAgICAgYSA9IGI7XG5cdCAgICAgICAgYiA9IF87XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGFsbEVxdWFsID0gdHJ1ZTtcblx0ICAgIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG5cdCAgICAgIGlmIChub3RBc3NvY2lhdGl2ZSA/ICFhLmhhcyh2KSA6XG5cdCAgICAgICAgICBmbGlwcGVkID8gIWlzKHYsIGEuZ2V0KGssIE5PVF9TRVQpKSA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdikpIHtcblx0ICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBhbGxFcXVhbCAmJiBhLnNpemUgPT09IGJTaXplO1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNsYXNzKFJlcGVhdCwgSW5kZXhlZFNlcSk7XG5cblx0ICAgIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcblx0ICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcGVhdCkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcblx0ICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgIGlmIChFTVBUWV9SRVBFQVQpIHtcblx0ICAgICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIEVNUFRZX1JFUEVBVCA9IHRoaXM7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgUmVwZWF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuICdSZXBlYXQgW10nO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcblx0ICAgIH07XG5cblx0ICAgIFJlcGVhdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAgUmVwZWF0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuXHQgICAgfTtcblxuXHQgICAgUmVwZWF0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcblx0ICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG5cdCAgICAgIHJldHVybiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpID8gdGhpcyA6XG5cdCAgICAgICAgbmV3IFJlcGVhdCh0aGlzLl92YWx1ZSwgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSk7XG5cdCAgICB9O1xuXG5cdCAgICBSZXBlYXQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXG5cdCAgICBSZXBlYXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuXHQgICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAtMTtcblx0ICAgIH07XG5cblx0ICAgIFJlcGVhdC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuXHQgICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfTtcblxuXHQgICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuXHQgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGhpcy5zaXplOyBpaSsrKSB7XG5cdCAgICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaWk7XG5cdCAgICB9O1xuXG5cdCAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciBpaSA9IDA7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSBcblx0ICAgICAgICB7cmV0dXJuIGlpIDwgdGhpcyQwLnNpemUgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHRoaXMkMC5fdmFsdWUpIDogaXRlcmF0b3JEb25lKCl9XG5cdCAgICAgICk7XG5cdCAgICB9O1xuXG5cdCAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdCAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJlcGVhdCA/XG5cdCAgICAgICAgaXModGhpcy5fdmFsdWUsIG90aGVyLl92YWx1ZSkgOlxuXHQgICAgICAgIGRlZXBFcXVhbChvdGhlcik7XG5cdCAgICB9O1xuXG5cblx0ICB2YXIgRU1QVFlfUkVQRUFUO1xuXG5cdCAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcblx0ICAgIGlmICghY29uZGl0aW9uKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNsYXNzKFJhbmdlLCBJbmRleGVkU2VxKTtcblxuXHQgICAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuXHQgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcblx0ICAgICAgfVxuXHQgICAgICBpbnZhcmlhbnQoc3RlcCAhPT0gMCwgJ0Nhbm5vdCBzdGVwIGEgUmFuZ2UgYnkgMCcpO1xuXHQgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGVuZCA9IEluZmluaXR5O1xuXHQgICAgICB9XG5cdCAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5hYnMoc3RlcCk7XG5cdCAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuXHQgICAgICAgIHN0ZXAgPSAtc3RlcDtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuXHQgICAgICB0aGlzLl9lbmQgPSBlbmQ7XG5cdCAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuXHQgICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXAgLSAxKSArIDEpO1xuXHQgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG5cdCAgICAgICAgaWYgKEVNUFRZX1JBTkdFKSB7XG5cdCAgICAgICAgICByZXR1cm4gRU1QVFlfUkFOR0U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAnUmFuZ2UgWyAnICtcblx0ICAgICAgICB0aGlzLl9zdGFydCArICcuLi4nICsgdGhpcy5fZW5kICtcblx0ICAgICAgICAodGhpcy5fc3RlcCAhPT0gMSA/ICcgYnkgJyArIHRoaXMuX3N0ZXAgOiAnJykgK1xuXHQgICAgICAnIF0nO1xuXHQgICAgfTtcblxuXHQgICAgUmFuZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID9cblx0ICAgICAgICB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwIDpcblx0ICAgICAgICBub3RTZXRWYWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG5cdCAgICAgIHZhciBwb3NzaWJsZUluZGV4ID0gKHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQpIC8gdGhpcy5fc3RlcDtcblx0ICAgICAgcmV0dXJuIHBvc3NpYmxlSW5kZXggPj0gMCAmJlxuXHQgICAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcblx0ICAgICAgICBwb3NzaWJsZUluZGV4ID09PSBNYXRoLmZsb29yKHBvc3NpYmxlSW5kZXgpO1xuXHQgICAgfTtcblxuXHQgICAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuXHQgICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgYmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG5cdCAgICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuXHQgICAgICBpZiAoZW5kIDw9IGJlZ2luKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSgwLCAwKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLCB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksIHRoaXMuX3N0ZXApO1xuXHQgICAgfTtcblxuXHQgICAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuXHQgICAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuXHQgICAgICBpZiAob2Zmc2V0VmFsdWUgJSB0aGlzLl9zdGVwID09PSAwKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuXHQgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG5cdCAgICAgICAgICByZXR1cm4gaW5kZXhcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfTtcblxuXHQgICAgUmFuZ2UucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIG1heEluZGV4ID0gdGhpcy5zaXplIC0gMTtcblx0ICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuXHQgICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcblx0ICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuXHQgICAgICAgIGlmIChmbih2YWx1ZSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGlpICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaWk7XG5cdCAgICB9O1xuXG5cdCAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIG1heEluZGV4ID0gdGhpcy5zaXplIC0gMTtcblx0ICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuXHQgICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcblx0ICAgICAgdmFyIGlpID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgdmFyIHYgPSB2YWx1ZTtcblx0ICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuXHQgICAgICAgIHJldHVybiBpaSA+IG1heEluZGV4ID8gaXRlcmF0b3JEb25lKCkgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHYpO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHQgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSYW5nZSA/XG5cdCAgICAgICAgdGhpcy5fc3RhcnQgPT09IG90aGVyLl9zdGFydCAmJlxuXHQgICAgICAgIHRoaXMuX2VuZCA9PT0gb3RoZXIuX2VuZCAmJlxuXHQgICAgICAgIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwIDpcblx0ICAgICAgICBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuXHQgICAgfTtcblxuXG5cdCAgdmFyIEVNUFRZX1JBTkdFO1xuXG5cdCAgY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbiwgSXRlcmFibGUpO1xuXHQgICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcblx0ICAgICAgdGhyb3cgVHlwZUVycm9yKCdBYnN0cmFjdCcpO1xuXHQgICAgfVxuXG5cblx0ICBjcmVhdGVDbGFzcyhLZXllZENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIEtleWVkQ29sbGVjdGlvbigpIHt9XG5cblx0ICBjcmVhdGVDbGFzcyhJbmRleGVkQ29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24oKSB7fVxuXG5cdCAgY3JlYXRlQ2xhc3MoU2V0Q29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gU2V0Q29sbGVjdGlvbigpIHt9XG5cblxuXHQgIENvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG5cdCAgQ29sbGVjdGlvbi5JbmRleGVkID0gSW5kZXhlZENvbGxlY3Rpb247XG5cdCAgQ29sbGVjdGlvbi5TZXQgPSBTZXRDb2xsZWN0aW9uO1xuXG5cdCAgdmFyIGltdWwgPVxuXHQgICAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yID9cblx0ICAgIE1hdGguaW11bCA6XG5cdCAgICBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcblx0ICAgICAgYSA9IGEgfCAwOyAvLyBpbnRcblx0ICAgICAgYiA9IGIgfCAwOyAvLyBpbnRcblx0ICAgICAgdmFyIGMgPSBhICYgMHhmZmZmO1xuXHQgICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG5cdCAgICAgIC8vIFNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydC5cblx0ICAgICAgcmV0dXJuIChjICogZCkgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApIHwgMDsgLy8gaW50XG5cdCAgICB9O1xuXG5cdCAgLy8gdjggaGFzIGFuIG9wdGltaXphdGlvbiBmb3Igc3RvcmluZyAzMS1iaXQgc2lnbmVkIG51bWJlcnMuXG5cdCAgLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cblx0ICAvLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG5cdCAgLy8gdGhlIHNpZ24gYml0LlxuXHQgIGZ1bmN0aW9uIHNtaShpMzIpIHtcblx0ICAgIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweEJGRkZGRkZGKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBoYXNoKG8pIHtcblx0ICAgIGlmIChvID09PSBmYWxzZSB8fCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIG8gPSBvLnZhbHVlT2YoKTtcblx0ICAgICAgaWYgKG8gPT09IGZhbHNlIHx8IG8gPT09IG51bGwgfHwgbyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChvID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXHQgICAgdmFyIHR5cGUgPSB0eXBlb2Ygbztcblx0ICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICBpZiAobyAhPT0gbyB8fCBvID09PSBJbmZpbml0eSkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBoID0gbyB8IDA7XG5cdCAgICAgIGlmIChoICE9PSBvKSB7XG5cdCAgICAgICAgaCBePSBvICogMHhGRkZGRkZGRjtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAobyA+IDB4RkZGRkZGRkYpIHtcblx0ICAgICAgICBvIC89IDB4RkZGRkZGRkY7XG5cdCAgICAgICAgaCBePSBvO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzbWkoaCk7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuIG8ubGVuZ3RoID4gU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA/IGNhY2hlZEhhc2hTdHJpbmcobykgOiBoYXNoU3RyaW5nKG8pO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybiBvLmhhc2hDb2RlKCk7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgcmV0dXJuIGhhc2hKU09iaihvKTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygby50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gaGFzaFN0cmluZyhvLnRvU3RyaW5nKCkpO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhY2hlZEhhc2hTdHJpbmcoc3RyaW5nKSB7XG5cdCAgICB2YXIgaGFzaCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuXHQgICAgaWYgKGhhc2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHJpbmcpO1xuXHQgICAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcblx0ICAgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcblx0ICAgICAgICBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblx0ICAgICAgfVxuXHQgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG5cdCAgICAgIHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddID0gaGFzaDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBoYXNoO1xuXHQgIH1cblxuXHQgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hpbmctc3RyaW5nc1xuXHQgIGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG5cdCAgICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG5cdCAgICAvLyBUaGUgaGFzaCBjb2RlIGZvciBhIHN0cmluZyBpcyBjb21wdXRlZCBhc1xuXHQgICAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcblx0ICAgIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG5cdCAgICAvLyB0aGUgc3RyaW5nLiBXZSBcIm1vZFwiIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzFcblx0ICAgIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cblx0ICAgIHZhciBoYXNoID0gMDtcblx0ICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG5cdCAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyBzdHJpbmcuY2hhckNvZGVBdChpaSkgfCAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNtaShoYXNoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG5cdCAgICB2YXIgaGFzaDtcblx0ICAgIGlmICh1c2luZ1dlYWtNYXApIHtcblx0ICAgICAgaGFzaCA9IHdlYWtNYXAuZ2V0KG9iaik7XG5cdCAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBoYXNoID0gb2JqW1VJRF9IQVNIX0tFWV07XG5cdCAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNhbkRlZmluZVByb3BlcnR5KSB7XG5cdCAgICAgIGhhc2ggPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG5cdCAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGhhc2ggPSBnZXRJRU5vZGVIYXNoKG9iaik7XG5cdCAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBoYXNoID0gKytvYmpIYXNoVUlEO1xuXHQgICAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG5cdCAgICAgIG9iakhhc2hVSUQgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG5cdCAgICAgIHdlYWtNYXAuc2V0KG9iaiwgaGFzaCk7XG5cdCAgICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leHRlbnNpYmxlIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkIGFzIGtleXMuJyk7XG5cdCAgICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuXHQgICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG5cdCAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuXHQgICAgICAgICd3cml0YWJsZSc6IGZhbHNlLFxuXHQgICAgICAgICd2YWx1ZSc6IGhhc2hcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2UgaWYgKG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG5cdCAgICAgICAgICAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSkge1xuXHQgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG5cdCAgICAgIC8vIHdlJ2xsIGhpamFjayBvbmUgb2YgdGhlIGxlc3MtdXNlZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRvXG5cdCAgICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG5cdCAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuXHQgICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgfTtcblx0ICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV0gPSBoYXNoO1xuXHQgICAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNvdWxkbid0IGdldCB0aGUgSUUgYHVuaXF1ZUlEYCB0byB1c2UgYXMgYSBoYXNoXG5cdCAgICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuXHQgICAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcblx0ICAgICAgLy8gaXRzZWxmLlxuXHQgICAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2g7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiBvYmplY3QuJyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBoYXNoO1xuXHQgIH1cblxuXHQgIC8vIEdldCByZWZlcmVuY2VzIHRvIEVTNSBvYmplY3QgbWV0aG9kcy5cblx0ICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuXHQgIC8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxuXHQgIHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSgpKTtcblxuXHQgIC8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcblx0ICAvLyBhbmQgYXZvaWQgbWVtb3J5IGxlYWtzIGZyb20gdGhlIElFIGNsb25lTm9kZSBidWcuXG5cdCAgZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG5cdCAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuXHQgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0ICAgICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcblx0ICAgICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuXHQgICAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcblx0ICAgICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxuXHQgIHZhciB1c2luZ1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJztcblx0ICB2YXIgd2Vha01hcDtcblx0ICBpZiAodXNpbmdXZWFrTWFwKSB7XG5cdCAgICB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0ICB9XG5cblx0ICB2YXIgb2JqSGFzaFVJRCA9IDA7XG5cblx0ICB2YXIgVUlEX0hBU0hfS0VZID0gJ19faW1tdXRhYmxlaGFzaF9fJztcblx0ICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG5cdCAgfVxuXG5cdCAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcblx0ICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG5cdCAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuXHQgIHZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxuXHQgIGZ1bmN0aW9uIGFzc2VydE5vdEluZmluaXRlKHNpemUpIHtcblx0ICAgIGludmFyaWFudChcblx0ICAgICAgc2l6ZSAhPT0gSW5maW5pdHksXG5cdCAgICAgICdDYW5ub3QgcGVyZm9ybSB0aGlzIGFjdGlvbiB3aXRoIGFuIGluZmluaXRlIHNpemUuJ1xuXHQgICAgKTtcblx0ICB9XG5cblx0ICBjcmVhdGVDbGFzcyhNYXAsIEtleWVkQ29sbGVjdGlvbik7XG5cblx0ICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cblx0ICAgIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5TWFwKCkgOlxuXHQgICAgICAgIGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcblx0ICAgICAgICBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuXHQgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcblx0ICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG5cdCAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBNYXAub2YgPSBmdW5jdGlvbigpIHt2YXIga2V5VmFsdWVzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdCAgICAgIHJldHVybiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmFsdWUgZm9yIGtleTogJyArIGtleVZhbHVlc1tpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuXHQgICAgfTtcblxuXHQgICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuXHQgICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcm9vdCA/XG5cdCAgICAgICAgdGhpcy5fcm9vdC5nZXQoMCwgdW5kZWZpbmVkLCBrLCBub3RTZXRWYWx1ZSkgOlxuXHQgICAgICAgIG5vdFNldFZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuXHQgICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG5cdCAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLnNldEluID0gZnVuY3Rpb24oa2V5UGF0aCwgdikge1xuXHQgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihrZXlQYXRoLCBOT1RfU0VULCBmdW5jdGlvbigpICB7cmV0dXJuIHZ9KTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS5kZWxldGVJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oa2V5UGF0aCwgZnVuY3Rpb24oKSAge3JldHVybiBOT1RfU0VUfSk7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG5cdCAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0ICAgICAgICBrKHRoaXMpIDpcblx0ICAgICAgICB0aGlzLnVwZGF0ZUluKFtrXSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS51cGRhdGVJbiA9IGZ1bmN0aW9uKGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG5cdCAgICAgIGlmICghdXBkYXRlcikge1xuXHQgICAgICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcblx0ICAgICAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwTWFwKFxuXHQgICAgICAgIHRoaXMsXG5cdCAgICAgICAgZm9yY2VJdGVyYXRvcihrZXlQYXRoKSxcblx0ICAgICAgICBub3RTZXRWYWx1ZSxcblx0ICAgICAgICB1cGRhdGVyXG5cdCAgICAgICk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyB1bmRlZmluZWQgOiB1cGRhdGVkVmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcblx0ICAgICAgICB0aGlzLnNpemUgPSAwO1xuXHQgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZW1wdHlNYXAoKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuXHQgICAgTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuXHQgICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCB1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuXHQgICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBtZXJnZXIsIGl0ZXJzKTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUubWVyZ2VJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0ICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oXG5cdCAgICAgICAga2V5UGF0aCxcblx0ICAgICAgICBlbXB0eU1hcCgpLFxuXHQgICAgICAgIGZ1bmN0aW9uKG0gKSB7cmV0dXJuIHR5cGVvZiBtLm1lcmdlID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgIG0ubWVyZ2UuYXBwbHkobSwgaXRlcnMpIDpcblx0ICAgICAgICAgIGl0ZXJzW2l0ZXJzLmxlbmd0aCAtIDFdfVxuXHQgICAgICApO1xuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXAgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcblx0ICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgZGVlcE1lcmdlciwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuXHQgICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcEluID0gZnVuY3Rpb24oa2V5UGF0aCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuXHQgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihcblx0ICAgICAgICBrZXlQYXRoLFxuXHQgICAgICAgIGVtcHR5TWFwKCksXG5cdCAgICAgICAgZnVuY3Rpb24obSApIHtyZXR1cm4gdHlwZW9mIG0ubWVyZ2VEZWVwID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgIG0ubWVyZ2VEZWVwLmFwcGx5KG0sIGl0ZXJzKSA6XG5cdCAgICAgICAgICBpdGVyc1tpdGVycy5sZW5ndGggLSAxXX1cblx0ICAgICAgKTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcblx0ICAgICAgLy8gTGF0ZSBiaW5kaW5nXG5cdCAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG5cdCAgICAgIC8vIExhdGUgYmluZGluZ1xuXHQgICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG5cdCAgICBNYXAucHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBmdW5jdGlvbihmbikge1xuXHQgICAgICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG5cdCAgICAgIGZuKG11dGFibGUpO1xuXHQgICAgICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUuYXNNdXRhYmxlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiB0aGlzLl9fZW5zdXJlT3duZXIobmV3IE93bmVySUQoKSk7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmFzSW1tdXRhYmxlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSk7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgdGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lml0ZXJhdGUoZnVuY3Rpb24oZW50cnkgKSB7XG5cdCAgICAgICAgaXRlcmF0aW9ucysrO1xuXHQgICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMCk7XG5cdCAgICAgIH0sIHJldmVyc2UpO1xuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcblx0ICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFvd25lcklEKSB7XG5cdCAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG5cdCAgICB9O1xuXG5cblx0ICBmdW5jdGlvbiBpc01hcChtYXliZU1hcCkge1xuXHQgICAgcmV0dXJuICEhKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TRU5USU5FTF0pO1xuXHQgIH1cblxuXHQgIE1hcC5pc01hcCA9IGlzTWFwO1xuXG5cdCAgdmFyIElTX01BUF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX01BUF9fQEAnO1xuXG5cdCAgdmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG5cdCAgTWFwUHJvdG90eXBlW0lTX01BUF9TRU5USU5FTF0gPSB0cnVlO1xuXHQgIE1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcblx0ICBNYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW47XG5cblxuXHQgIC8vICNwcmFnbWEgVHJpZSBOb2Rlc1xuXG5cblxuXHQgICAgZnVuY3Rpb24gQXJyYXlNYXBOb2RlKG93bmVySUQsIGVudHJpZXMpIHtcblx0ICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcblx0ICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcblx0ICAgIH1cblxuXHQgICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcblx0ICAgICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcblx0ICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcblx0ICAgICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcblx0ICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuXHQgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcblx0ICAgICAgdmFyIGlkeCA9IDA7XG5cdCAgICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG5cdCAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cblx0ICAgICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuXHQgICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cblx0ICAgICAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG5cdCAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcblx0ICAgICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cblx0ICAgICAgaWYgKGV4aXN0cykge1xuXHQgICAgICAgIGlmIChyZW1vdmVkKSB7XG5cdCAgICAgICAgICBpZHggPT09IGxlbiAtIDEgPyBuZXdFbnRyaWVzLnBvcCgpIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzRWRpdGFibGUpIHtcblx0ICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG5ldyBBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3RW50cmllcyk7XG5cdCAgICB9O1xuXG5cblxuXG5cdCAgICBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG5cdCAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuXHQgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG5cdCAgICB9XG5cblx0ICAgIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgYml0ID0gKDEgPDwgKChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLKSk7XG5cdCAgICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcblx0ICAgICAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwID8gbm90U2V0VmFsdWUgOlxuXHQgICAgICAgIHRoaXMubm9kZXNbcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKV0uZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpO1xuXHQgICAgfTtcblxuXHQgICAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuXHQgICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIga2V5SGFzaEZyYWcgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblx0ICAgICAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG5cdCAgICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcblx0ICAgICAgdmFyIGV4aXN0cyA9IChiaXRtYXAgJiBiaXQpICE9PSAwO1xuXG5cdCAgICAgIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcblx0ICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2Rlcztcblx0ICAgICAgdmFyIG5vZGUgPSBleGlzdHMgPyBub2Rlc1tpZHhdIDogdW5kZWZpbmVkO1xuXHQgICAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuXG5cdCAgICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA+PSBNQVhfQklUTUFQX0lOREVYRURfU0laRSkge1xuXHQgICAgICAgIHJldHVybiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBrZXlIYXNoRnJhZywgbmV3Tm9kZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZXhpc3RzICYmICFuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMiAmJiBpc0xlYWZOb2RlKG5vZGVzW2lkeCBeIDFdKSkge1xuXHQgICAgICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDEgJiYgaXNMZWFmTm9kZShuZXdOb2RlKSkge1xuXHQgICAgICAgIHJldHVybiBuZXdOb2RlO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcblx0ICAgICAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQgOiBiaXRtYXAgfCBiaXQ7XG5cdCAgICAgIHZhciBuZXdOb2RlcyA9IGV4aXN0cyA/IG5ld05vZGUgP1xuXHQgICAgICAgIHNldEluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpIDpcblx0ICAgICAgICBzcGxpY2VPdXQobm9kZXMsIGlkeCwgaXNFZGl0YWJsZSkgOlxuXHQgICAgICAgIHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG5cdCAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG5cdCAgICAgICAgdGhpcy5iaXRtYXAgPSBuZXdCaXRtYXA7XG5cdCAgICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcblx0ICAgIH07XG5cblxuXG5cblx0ICAgIGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG5cdCAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcblx0ICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuXHQgICAgfVxuXG5cdCAgICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuXHQgICAgICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIDogbm90U2V0VmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcblx0ICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuXHQgICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXHQgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuXHQgICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cblx0ICAgICAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG5cdCAgICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuXHQgICAgICBpZiAoIW5vZGUpIHtcblx0ICAgICAgICBuZXdDb3VudCsrO1xuXHQgICAgICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG5cdCAgICAgICAgbmV3Q291bnQtLTtcblx0ICAgICAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuXHQgICAgICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcblx0ICAgICAgdmFyIG5ld05vZGVzID0gc2V0SW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cblx0ICAgICAgaWYgKGlzRWRpdGFibGUpIHtcblx0ICAgICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG5cdCAgICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG5cdCAgICB9O1xuXG5cblxuXG5cdCAgICBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG5cdCAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG5cdCAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG5cdCAgICB9XG5cblx0ICAgIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcblx0ICAgICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcblx0ICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcblx0ICAgICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuXHQgICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cblx0ICAgICAgaWYgKGtleUhhc2ggIT09IHRoaXMua2V5SGFzaCkge1xuXHQgICAgICAgIGlmIChyZW1vdmVkKSB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcblx0ICAgICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcblx0ICAgICAgdmFyIGlkeCA9IDA7XG5cdCAgICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG5cdCAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cblx0ICAgICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuXHQgICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cblx0ICAgICAgaWYgKHJlbW92ZWQgJiYgbGVuID09PSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG5cdCAgICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG5cdCAgICAgIGlmIChleGlzdHMpIHtcblx0ICAgICAgICBpZiAocmVtb3ZlZCkge1xuXHQgICAgICAgICAgaWR4ID09PSBsZW4gLSAxID8gbmV3RW50cmllcy5wb3AoKSA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG5cdCAgICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBuZXdFbnRyaWVzKTtcblx0ICAgIH07XG5cblxuXG5cblx0ICAgIGZ1bmN0aW9uIFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkge1xuXHQgICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuXHQgICAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuXHQgICAgICB0aGlzLmVudHJ5ID0gZW50cnk7XG5cdCAgICB9XG5cblx0ICAgIFZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICBWYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuXHQgICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXHQgICAgICB2YXIga2V5TWF0Y2ggPSBpcyhrZXksIHRoaXMuZW50cnlbMF0pO1xuXHQgICAgICBpZiAoa2V5TWF0Y2ggPyB2YWx1ZSA9PT0gdGhpcy5lbnRyeVsxXSA6IHJlbW92ZWQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIFNldFJlZihkaWRBbHRlcik7XG5cblx0ICAgICAgaWYgKHJlbW92ZWQpIHtcblx0ICAgICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChrZXlNYXRjaCkge1xuXHQgICAgICAgIGlmIChvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRCkge1xuXHQgICAgICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblx0ICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcblx0ICAgIH07XG5cblxuXG5cdCAgLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuXHQgIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG5cdCAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcblx0ICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuXHQgICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcblx0ICAgICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID1cblx0ICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG5cdCAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuXHQgICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG5cdCAgICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG5cdCAgICAgIGlmIChub2RlICYmIG5vZGUuaXRlcmF0ZShmbiwgcmV2ZXJzZSkgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG5cdCAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoTWFwSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuXHQgICAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcblx0ICAgICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuXHQgICAgfVxuXG5cdCAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdCAgICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuXHQgICAgICB3aGlsZSAoc3RhY2spIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcblx0ICAgICAgICB2YXIgbWF4SW5kZXg7XG5cdCAgICAgICAgaWYgKG5vZGUuZW50cnkpIHtcblx0ICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cmllcykge1xuXHQgICAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJpZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBtYXhJbmRleCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF07XG5cdCAgICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG5cdCAgICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIHN1Yk5vZGUuZW50cnkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuXHQgICAgfTtcblxuXG5cdCAgZnVuY3Rpb24gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeSkge1xuXHQgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBtYXBJdGVyYXRvckZyYW1lKG5vZGUsIHByZXYpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG5vZGU6IG5vZGUsXG5cdCAgICAgIGluZGV4OiAwLFxuXHQgICAgICBfX3ByZXY6IHByZXZcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoKSB7XG5cdCAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShNYXBQcm90b3R5cGUpO1xuXHQgICAgbWFwLnNpemUgPSBzaXplO1xuXHQgICAgbWFwLl9yb290ID0gcm9vdDtcblx0ICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgbWFwLl9faGFzaCA9IGhhc2g7XG5cdCAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG5cdCAgICByZXR1cm4gbWFwO1xuXHQgIH1cblxuXHQgIHZhciBFTVBUWV9NQVA7XG5cdCAgZnVuY3Rpb24gZW1wdHlNYXAoKSB7XG5cdCAgICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1cGRhdGVNYXAobWFwLCBrLCB2KSB7XG5cdCAgICB2YXIgbmV3Um9vdDtcblx0ICAgIHZhciBuZXdTaXplO1xuXHQgICAgaWYgKCFtYXAuX3Jvb3QpIHtcblx0ICAgICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcblx0ICAgICAgICByZXR1cm4gbWFwO1xuXHQgICAgICB9XG5cdCAgICAgIG5ld1NpemUgPSAxO1xuXHQgICAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoQ0hBTkdFX0xFTkdUSCk7XG5cdCAgICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoRElEX0FMVEVSKTtcblx0ICAgICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUobWFwLl9yb290LCBtYXAuX19vd25lcklELCAwLCB1bmRlZmluZWQsIGssIHYsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcblx0ICAgICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBtYXA7XG5cdCAgICAgIH1cblx0ICAgICAgbmV3U2l6ZSA9IG1hcC5zaXplICsgKGRpZENoYW5nZVNpemUudmFsdWUgPyB2ID09PSBOT1RfU0VUID8gLTEgOiAxIDogMCk7XG5cdCAgICB9XG5cdCAgICBpZiAobWFwLl9fb3duZXJJRCkge1xuXHQgICAgICBtYXAuc2l6ZSA9IG5ld1NpemU7XG5cdCAgICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG5cdCAgICAgIG1hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gbWFwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld1NpemUsIG5ld1Jvb3QpIDogZW1wdHlNYXAoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuXHQgICAgaWYgKCFub2RlKSB7XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuXHQgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICB9XG5cdCAgICAgIFNldFJlZihkaWRBbHRlcik7XG5cdCAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblx0ICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBub2RlLnVwZGF0ZShvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuXHQgICAgcmV0dXJuIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBtZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBlbnRyeSkge1xuXHQgICAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuXHQgICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblx0ICAgIHZhciBpZHgyID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cblx0ICAgIHZhciBuZXdOb2RlO1xuXHQgICAgdmFyIG5vZGVzID0gaWR4MSA9PT0gaWR4MiA/XG5cdCAgICAgIFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV0gOlxuXHQgICAgICAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksIGlkeDEgPCBpZHgyID8gW25vZGUsIG5ld05vZGVdIDogW25ld05vZGUsIG5vZGVdKTtcblxuXHQgICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSkge1xuXHQgICAgaWYgKCFvd25lcklEKSB7XG5cdCAgICAgIG93bmVySUQgPSBuZXcgT3duZXJJRCgpO1xuXHQgICAgfVxuXHQgICAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcblx0ICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlbnRyaWVzLmxlbmd0aDsgaWkrKykge1xuXHQgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2lpXTtcblx0ICAgICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBub2RlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgY291bnQsIGV4Y2x1ZGluZykge1xuXHQgICAgdmFyIGJpdG1hcCA9IDA7XG5cdCAgICB2YXIgcGFja2VkSUkgPSAwO1xuXHQgICAgdmFyIHBhY2tlZE5vZGVzID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIGZvciAodmFyIGlpID0gMCwgYml0ID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG5cdCAgICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuXHQgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIGlpICE9PSBleGNsdWRpbmcpIHtcblx0ICAgICAgICBiaXRtYXAgfD0gYml0O1xuXHQgICAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBpbmNsdWRpbmcsIG5vZGUpIHtcblx0ICAgIHZhciBjb3VudCA9IDA7XG5cdCAgICB2YXIgZXhwYW5kZWROb2RlcyA9IG5ldyBBcnJheShTSVpFKTtcblx0ICAgIGZvciAodmFyIGlpID0gMDsgYml0bWFwICE9PSAwOyBpaSsrLCBiaXRtYXAgPj4+PSAxKSB7XG5cdCAgICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgZXhwYW5kZWROb2Rlc1tpbmNsdWRpbmddID0gbm9kZTtcblx0ICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG1lcmdlSW50b01hcFdpdGgobWFwLCBtZXJnZXIsIGl0ZXJhYmxlcykge1xuXHQgICAgdmFyIGl0ZXJzID0gW107XG5cdCAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcmFibGVzLmxlbmd0aDsgaWkrKykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBpdGVyYWJsZXNbaWldO1xuXHQgICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuXHQgICAgICBpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB7XG5cdCAgICAgICAgaXRlciA9IGl0ZXIubWFwKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZyb21KUyh2KX0pO1xuXHQgICAgICB9XG5cdCAgICAgIGl0ZXJzLnB1c2goaXRlcik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgobWFwLCBtZXJnZXIsIGl0ZXJzKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWVwTWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSB7XG5cdCAgICByZXR1cm4gZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwICYmIGlzSXRlcmFibGUodmFsdWUpID9cblx0ICAgICAgZXhpc3RpbmcubWVyZ2VEZWVwKHZhbHVlKSA6XG5cdCAgICAgIGlzKGV4aXN0aW5nLCB2YWx1ZSkgPyBleGlzdGluZyA6IHZhbHVlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSAge1xuXHQgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwV2l0aCAmJiBpc0l0ZXJhYmxlKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiBleGlzdGluZy5tZXJnZURlZXBXaXRoKG1lcmdlciwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBuZXh0VmFsdWUgPSBtZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpO1xuXHQgICAgICByZXR1cm4gaXMoZXhpc3RpbmcsIG5leHRWYWx1ZSkgPyBleGlzdGluZyA6IG5leHRWYWx1ZTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgoY29sbGVjdGlvbiwgbWVyZ2VyLCBpdGVycykge1xuXHQgICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24oeCApIHtyZXR1cm4geC5zaXplICE9PSAwfSk7XG5cdCAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCAmJiAhY29sbGVjdGlvbi5fX293bmVySUQgJiYgaXRlcnMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIHJldHVybiBjb2xsZWN0aW9uLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oY29sbGVjdGlvbiApIHtcblx0ICAgICAgdmFyIG1lcmdlSW50b01hcCA9IG1lcmdlciA/XG5cdCAgICAgICAgZnVuY3Rpb24odmFsdWUsIGtleSkgIHtcblx0ICAgICAgICAgIGNvbGxlY3Rpb24udXBkYXRlKGtleSwgTk9UX1NFVCwgZnVuY3Rpb24oZXhpc3RpbmcgKVxuXHQgICAgICAgICAgICB7cmV0dXJuIGV4aXN0aW5nID09PSBOT1RfU0VUID8gdmFsdWUgOiBtZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpfVxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9IDpcblx0ICAgICAgICBmdW5jdGlvbih2YWx1ZSwga2V5KSAge1xuXHQgICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG5cdCAgICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvTWFwKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlSW5EZWVwTWFwKGV4aXN0aW5nLCBrZXlQYXRoSXRlciwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcblx0ICAgIHZhciBpc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuXHQgICAgdmFyIHN0ZXAgPSBrZXlQYXRoSXRlci5uZXh0KCk7XG5cdCAgICBpZiAoc3RlcC5kb25lKSB7XG5cdCAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gaXNOb3RTZXQgPyBub3RTZXRWYWx1ZSA6IGV4aXN0aW5nO1xuXHQgICAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuXHQgICAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuXHQgICAgfVxuXHQgICAgaW52YXJpYW50KFxuXHQgICAgICBpc05vdFNldCB8fCAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc2V0KSxcblx0ICAgICAgJ2ludmFsaWQga2V5UGF0aCdcblx0ICAgICk7XG5cdCAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcblx0ICAgIHZhciBuZXh0RXhpc3RpbmcgPSBpc05vdFNldCA/IE5PVF9TRVQgOiBleGlzdGluZy5nZXQoa2V5LCBOT1RfU0VUKTtcblx0ICAgIHZhciBuZXh0VXBkYXRlZCA9IHVwZGF0ZUluRGVlcE1hcChcblx0ICAgICAgbmV4dEV4aXN0aW5nLFxuXHQgICAgICBrZXlQYXRoSXRlcixcblx0ICAgICAgbm90U2V0VmFsdWUsXG5cdCAgICAgIHVwZGF0ZXJcblx0ICAgICk7XG5cdCAgICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZyA/IGV4aXN0aW5nIDpcblx0ICAgICAgbmV4dFVwZGF0ZWQgPT09IE5PVF9TRVQgPyBleGlzdGluZy5yZW1vdmUoa2V5KSA6XG5cdCAgICAgIChpc05vdFNldCA/IGVtcHR5TWFwKCkgOiBleGlzdGluZykuc2V0KGtleSwgbmV4dFVwZGF0ZWQpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHBvcENvdW50KHgpIHtcblx0ICAgIHggPSB4IC0gKCh4ID4+IDEpICYgMHg1NTU1NTU1NSk7XG5cdCAgICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuXHQgICAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcblx0ICAgIHggPSB4ICsgKHggPj4gOCk7XG5cdCAgICB4ID0geCArICh4ID4+IDE2KTtcblx0ICAgIHJldHVybiB4ICYgMHg3Zjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXRJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcblx0ICAgIHZhciBuZXdBcnJheSA9IGNhbkVkaXQgPyBhcnJheSA6IGFyckNvcHkoYXJyYXkpO1xuXHQgICAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcblx0ICAgIHJldHVybiBuZXdBcnJheTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcblx0ICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuXHQgICAgaWYgKGNhbkVkaXQgJiYgaWR4ICsgMSA9PT0gbmV3TGVuKSB7XG5cdCAgICAgIGFycmF5W2lkeF0gPSB2YWw7XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0ICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuXHQgICAgdmFyIGFmdGVyID0gMDtcblx0ICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcblx0ICAgICAgaWYgKGlpID09PSBpZHgpIHtcblx0ICAgICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG5cdCAgICAgICAgYWZ0ZXIgPSAtMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld0FycmF5O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG5cdCAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcblx0ICAgIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG5cdCAgICAgIGFycmF5LnBvcCgpO1xuXHQgICAgICByZXR1cm4gYXJyYXk7XG5cdCAgICB9XG5cdCAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcblx0ICAgIHZhciBhZnRlciA9IDA7XG5cdCAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG5cdCAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG5cdCAgICAgICAgYWZ0ZXIgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld0FycmF5O1xuXHQgIH1cblxuXHQgIHZhciBNQVhfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblx0ICB2YXIgTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUgPSBTSVpFIC8gMjtcblx0ICB2YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxuXHQgIGNyZWF0ZUNsYXNzKExpc3QsIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuXHQgICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuXHQgICAgZnVuY3Rpb24gTGlzdCh2YWx1ZSkge1xuXHQgICAgICB2YXIgZW1wdHkgPSBlbXB0eUxpc3QoKTtcblx0ICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gZW1wdHk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUodmFsdWUpO1xuXHQgICAgICB2YXIgc2l6ZSA9IGl0ZXIuc2l6ZTtcblx0ICAgICAgaWYgKHNpemUgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gZW1wdHk7XG5cdCAgICAgIH1cblx0ICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG5cdCAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgU0laRSkge1xuXHQgICAgICAgIHJldHVybiBtYWtlTGlzdCgwLCBzaXplLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGl0ZXIudG9BcnJheSgpKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcblx0ICAgICAgICBsaXN0LnNldFNpemUoc2l6ZSk7XG5cdCAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpICB7cmV0dXJuIGxpc3Quc2V0KGksIHYpfSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBMaXN0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuXHQgICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cblx0ICAgIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG5cdCAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG5cdCAgICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuXHQgICAgICAgIHZhciBub2RlID0gbGlzdE5vZGVGb3IodGhpcywgaW5kZXgpO1xuXHQgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcblx0ICAgIH07XG5cblx0ICAgIExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdCAgICAgIHJldHVybiAhdGhpcy5oYXMoaW5kZXgpID8gdGhpcyA6XG5cdCAgICAgICAgaW5kZXggPT09IDAgPyB0aGlzLnNoaWZ0KCkgOlxuXHQgICAgICAgIGluZGV4ID09PSB0aGlzLnNpemUgLSAxID8gdGhpcy5wb3AoKSA6XG5cdCAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuXHQgICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcblx0ICAgICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuXHQgICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl90YWlsID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVtcHR5TGlzdCgpO1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcblx0ICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcblx0ICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnNpemU7XG5cdCAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcblx0ICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIG9sZFNpemUgKyB2YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuXHQgICAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcblx0ICAgIH07XG5cblx0ICAgIExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG5cdCAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG5cdCAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcblx0ICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIC12YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuXHQgICAgICAgICAgbGlzdC5zZXQoaWksIHZhbHVlc1tpaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAxKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuXHQgICAgTGlzdC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcblx0ICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIExpc3QucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuXHQgICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgbWVyZ2VyLCBpdGVycyk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXAgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcblx0ICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIGRlZXBNZXJnZXIsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cblx0ICAgIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuXHQgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcblx0ICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcblx0ICAgICAgICB0aGlzLFxuXHQgICAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG5cdCAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG5cdCAgICAgICk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuXHQgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gRE9ORSA/XG5cdCAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG5cdCAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGluZGV4KyssIHZhbHVlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuXHQgICAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG5cdCAgICAgIHZhciB2YWx1ZTtcblx0ICAgICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuXHQgICAgICAgIGlmIChmbih2YWx1ZSwgaW5kZXgrKywgdGhpcykgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgfTtcblxuXHQgICAgTGlzdC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcblx0ICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFvd25lcklEKSB7XG5cdCAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYWtlTGlzdCh0aGlzLl9vcmlnaW4sIHRoaXMuX2NhcGFjaXR5LCB0aGlzLl9sZXZlbCwgdGhpcy5fcm9vdCwgdGhpcy5fdGFpbCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuXHQgICAgfTtcblxuXG5cdCAgZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuXHQgICAgcmV0dXJuICEhKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TRU5USU5FTF0pO1xuXHQgIH1cblxuXHQgIExpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG5cdCAgdmFyIElTX0xJU1RfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9MSVNUX19AQCc7XG5cblx0ICB2YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuXHQgIExpc3RQcm90b3R5cGVbSVNfTElTVF9TRU5USU5FTF0gPSB0cnVlO1xuXHQgIExpc3RQcm90b3R5cGVbREVMRVRFXSA9IExpc3RQcm90b3R5cGUucmVtb3ZlO1xuXHQgIExpc3RQcm90b3R5cGUuc2V0SW4gPSBNYXBQcm90b3R5cGUuc2V0SW47XG5cdCAgTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9XG5cdCAgTGlzdFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5yZW1vdmVJbjtcblx0ICBMaXN0UHJvdG90eXBlLnVwZGF0ZSA9IE1hcFByb3RvdHlwZS51cGRhdGU7XG5cdCAgTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IE1hcFByb3RvdHlwZS51cGRhdGVJbjtcblx0ICBMaXN0UHJvdG90eXBlLm1lcmdlSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VJbjtcblx0ICBMaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluO1xuXHQgIExpc3RQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuXHQgIExpc3RQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcblx0ICBMaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXHQgIExpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xuXG5cblxuXHQgICAgZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcblx0ICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuXHQgICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG5cdCAgICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG5cdCAgICAgIGlmIChpbmRleCA9PT0gbGV2ZWwgPyAxIDw8IGxldmVsIDogMCB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBvcmlnaW5JbmRleCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcblx0ICAgICAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcblx0ICAgICAgdmFyIG5ld0NoaWxkO1xuXHQgICAgICBpZiAobGV2ZWwgPiAwKSB7XG5cdCAgICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG5cdCAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuXHQgICAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG5cdCAgICAgIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuXHQgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuXHQgICAgICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAobmV3Q2hpbGQpIHtcblx0ICAgICAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZWRpdGFibGU7XG5cdCAgICB9O1xuXG5cdCAgICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQWZ0ZXIgPSBmdW5jdGlvbihvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcblx0ICAgICAgaWYgKGluZGV4ID09PSAobGV2ZWwgPyAxIDw8IGxldmVsIDogMCkgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuXHQgICAgICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgbmV3Q2hpbGQ7XG5cdCAgICAgIGlmIChsZXZlbCA+IDApIHtcblx0ICAgICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W3NpemVJbmRleF07XG5cdCAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG5cdCAgICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiBzaXplSW5kZXggPT09IHRoaXMuYXJyYXkubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcblx0ICAgICAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuXHQgICAgICBpZiAobmV3Q2hpbGQpIHtcblx0ICAgICAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVkaXRhYmxlO1xuXHQgICAgfTtcblxuXG5cblx0ICB2YXIgRE9ORSA9IHt9O1xuXG5cdCAgZnVuY3Rpb24gaXRlcmF0ZUxpc3QobGlzdCwgcmV2ZXJzZSkge1xuXHQgICAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG5cdCAgICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcblx0ICAgIHZhciB0YWlsUG9zID0gZ2V0VGFpbE9mZnNldChyaWdodCk7XG5cdCAgICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cblx0ICAgIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cblx0ICAgIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlT3JMZWFmKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcblx0ICAgICAgcmV0dXJuIGxldmVsID09PSAwID9cblx0ICAgICAgICBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIDpcblx0ICAgICAgICBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG5cdCAgICAgIHZhciBhcnJheSA9IG9mZnNldCA9PT0gdGFpbFBvcyA/IHRhaWwgJiYgdGFpbC5hcnJheSA6IG5vZGUgJiYgbm9kZS5hcnJheTtcblx0ICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG5cdCAgICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuXHQgICAgICBpZiAodG8gPiBTSVpFKSB7XG5cdCAgICAgICAgdG8gPSBTSVpFO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpICB7XG5cdCAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG5cdCAgICAgICAgICByZXR1cm4gRE9ORTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuXHQgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG5cdCAgICAgIHZhciB2YWx1ZXM7XG5cdCAgICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcblx0ICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcblx0ICAgICAgdmFyIHRvID0gKChyaWdodCAtIG9mZnNldCkgPj4gbGV2ZWwpICsgMTtcblx0ICAgICAgaWYgKHRvID4gU0laRSkge1xuXHQgICAgICAgIHRvID0gU0laRTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIGlmICh2YWx1ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gRE9ORSkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBET05FO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuXHQgICAgICAgICAgdmFsdWVzID0gaXRlcmF0ZU5vZGVPckxlYWYoXG5cdCAgICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sIGxldmVsIC0gU0hJRlQsIG9mZnNldCArIChpZHggPDwgbGV2ZWwpXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG5cdCAgICB2YXIgbGlzdCA9IE9iamVjdC5jcmVhdGUoTGlzdFByb3RvdHlwZSk7XG5cdCAgICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcblx0ICAgIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcblx0ICAgIGxpc3QuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG5cdCAgICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuXHQgICAgbGlzdC5fcm9vdCA9IHJvb3Q7XG5cdCAgICBsaXN0Ll90YWlsID0gdGFpbDtcblx0ICAgIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcblx0ICAgIGxpc3QuX19oYXNoID0gaGFzaDtcblx0ICAgIGxpc3QuX19hbHRlcmVkID0gZmFsc2U7XG5cdCAgICByZXR1cm4gbGlzdDtcblx0ICB9XG5cblx0ICB2YXIgRU1QVFlfTElTVDtcblx0ICBmdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG5cdCAgICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcblx0ICAgIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuXHQgICAgaWYgKGluZGV4ICE9PSBpbmRleCkge1xuXHQgICAgICByZXR1cm4gbGlzdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSB8fCBpbmRleCA8IDApIHtcblx0ICAgICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuXHQgICAgICAgIGluZGV4IDwgMCA/XG5cdCAgICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIGluZGV4KS5zZXQoMCwgdmFsdWUpIDpcblx0ICAgICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG5cdCAgICB2YXIgbmV3VGFpbCA9IGxpc3QuX3RhaWw7XG5cdCAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cdCAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKERJRF9BTFRFUik7XG5cdCAgICBpZiAoaW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcblx0ICAgICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5ld1Jvb3QgPSB1cGRhdGVWTm9kZShuZXdSb290LCBsaXN0Ll9fb3duZXJJRCwgbGlzdC5fbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBsaXN0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAobGlzdC5fX293bmVySUQpIHtcblx0ICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG5cdCAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuXHQgICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcblx0ICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gbGlzdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtYWtlTGlzdChsaXN0Ll9vcmlnaW4sIGxpc3QuX2NhcGFjaXR5LCBsaXN0Ll9sZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcblx0ICAgIHZhciBpZHggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG5cdCAgICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG5cdCAgICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5ld05vZGU7XG5cblx0ICAgIGlmIChsZXZlbCA+IDApIHtcblx0ICAgICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuXHQgICAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUobG93ZXJOb2RlLCBvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcblx0ICAgICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICAgIH1cblx0ICAgICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG5cdCAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IG5ld0xvd2VyTm9kZTtcblx0ICAgICAgcmV0dXJuIG5ld05vZGU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICB9XG5cblx0ICAgIFNldFJlZihkaWRBbHRlcik7XG5cblx0ICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuXHQgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWR4ID09PSBuZXdOb2RlLmFycmF5Lmxlbmd0aCAtIDEpIHtcblx0ICAgICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld05vZGU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG5cdCAgICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuXHQgICAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG5cdCAgICAgIHJldHVybiBsaXN0Ll90YWlsO1xuXHQgICAgfVxuXHQgICAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcblx0ICAgICAgdmFyIG5vZGUgPSBsaXN0Ll9yb290O1xuXHQgICAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcblx0ICAgICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG5cdCAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbKHJhd0luZGV4ID4+PiBsZXZlbCkgJiBNQVNLXTtcblx0ICAgICAgICBsZXZlbCAtPSBTSElGVDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXRMaXN0Qm91bmRzKGxpc3QsIGJlZ2luLCBlbmQpIHtcblx0ICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuXHQgICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcblx0ICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGJlZ2luID0gYmVnaW4gfCAwO1xuXHQgICAgfVxuXHQgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGVuZCA9IGVuZCB8IDA7XG5cdCAgICB9XG5cdCAgICB2YXIgb3duZXIgPSBsaXN0Ll9fb3duZXJJRCB8fCBuZXcgT3duZXJJRCgpO1xuXHQgICAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcblx0ICAgIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuXHQgICAgdmFyIG5ld09yaWdpbiA9IG9sZE9yaWdpbiArIGJlZ2luO1xuXHQgICAgdmFyIG5ld0NhcGFjaXR5ID0gZW5kID09PSB1bmRlZmluZWQgPyBvbGRDYXBhY2l0eSA6IGVuZCA8IDAgPyBvbGRDYXBhY2l0eSArIGVuZCA6IG9sZE9yaWdpbiArIGVuZDtcblx0ICAgIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcblx0ICAgICAgcmV0dXJuIGxpc3Q7XG5cdCAgICB9XG5cblx0ICAgIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cblx0ICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3Q2FwYWNpdHkpIHtcblx0ICAgICAgcmV0dXJuIGxpc3QuY2xlYXIoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5ld0xldmVsID0gbGlzdC5fbGV2ZWw7XG5cdCAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cblx0ICAgIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuXHQgICAgdmFyIG9mZnNldFNoaWZ0ID0gMDtcblx0ICAgIHdoaWxlIChuZXdPcmlnaW4gKyBvZmZzZXRTaGlmdCA8IDApIHtcblx0ICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW3VuZGVmaW5lZCwgbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuXHQgICAgICBuZXdMZXZlbCArPSBTSElGVDtcblx0ICAgICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcblx0ICAgIH1cblx0ICAgIGlmIChvZmZzZXRTaGlmdCkge1xuXHQgICAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG5cdCAgICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcblx0ICAgICAgbmV3Q2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG5cdCAgICAgIG9sZENhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgb2xkVGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQob2xkQ2FwYWNpdHkpO1xuXHQgICAgdmFyIG5ld1RhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG5ld0NhcGFjaXR5KTtcblxuXHQgICAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuXHQgICAgd2hpbGUgKG5ld1RhaWxPZmZzZXQgPj0gMSA8PCAobmV3TGV2ZWwgKyBTSElGVCkpIHtcblx0ICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sIG93bmVyKTtcblx0ICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG5cdCAgICB9XG5cblx0ICAgIC8vIExvY2F0ZSBvciBjcmVhdGUgdGhlIG5ldyB0YWlsLlxuXHQgICAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuXHQgICAgdmFyIG5ld1RhaWwgPSBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCA/XG5cdCAgICAgIGxpc3ROb2RlRm9yKGxpc3QsIG5ld0NhcGFjaXR5IC0gMSkgOlxuXHQgICAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCA/IG5ldyBWTm9kZShbXSwgb3duZXIpIDogb2xkVGFpbDtcblxuXHQgICAgLy8gTWVyZ2UgVGFpbCBpbnRvIHRyZWUuXG5cdCAgICBpZiAob2xkVGFpbCAmJiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJiBuZXdPcmlnaW4gPCBvbGRDYXBhY2l0eSAmJiBvbGRUYWlsLmFycmF5Lmxlbmd0aCkge1xuXHQgICAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG5cdCAgICAgIHZhciBub2RlID0gbmV3Um9vdDtcblx0ICAgICAgZm9yICh2YXIgbGV2ZWwgPSBuZXdMZXZlbDsgbGV2ZWwgPiBTSElGVDsgbGV2ZWwgLT0gU0hJRlQpIHtcblx0ICAgICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG5cdCAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG5cdCAgICAgIH1cblx0ICAgICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJZiB0aGUgc2l6ZSBoYXMgYmVlbiByZWR1Y2VkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSB0YWlsIG5lZWRzIHRvIGJlIHRyaW1tZWQuXG5cdCAgICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuXHQgICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdDYXBhY2l0eSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG5cdCAgICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcblx0ICAgICAgbmV3T3JpZ2luIC09IG5ld1RhaWxPZmZzZXQ7XG5cdCAgICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG5cdCAgICAgIG5ld0xldmVsID0gU0hJRlQ7XG5cdCAgICAgIG5ld1Jvb3QgPSBudWxsO1xuXHQgICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuXHQgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgcm9vdCBoYXMgYmVlbiB0cmltbWVkLCBnYXJiYWdlIGNvbGxlY3QuXG5cdCAgICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuXHQgICAgICBvZmZzZXRTaGlmdCA9IDA7XG5cblx0ICAgICAgLy8gSWRlbnRpZnkgdGhlIG5ldyB0b3Agcm9vdCBub2RlIG9mIHRoZSBzdWJ0cmVlIG9mIHRoZSBvbGQgcm9vdC5cblx0ICAgICAgd2hpbGUgKG5ld1Jvb3QpIHtcblx0ICAgICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG5cdCAgICAgICAgaWYgKGJlZ2luSW5kZXggIT09IChuZXdUYWlsT2Zmc2V0ID4+PiBuZXdMZXZlbCkgJiBNQVNLKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJlZ2luSW5kZXgpIHtcblx0ICAgICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG5ld0xldmVsIC09IFNISUZUO1xuXHQgICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gVHJpbSB0aGUgbmV3IHNpZGVzIG9mIHRoZSBuZXcgcm9vdC5cblx0ICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG5cdCAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG5cdCAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIob3duZXIsIG5ld0xldmVsLCBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnQpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChvZmZzZXRTaGlmdCkge1xuXHQgICAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcblx0ICAgICAgICBuZXdDYXBhY2l0eSAtPSBvZmZzZXRTaGlmdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobGlzdC5fX293bmVySUQpIHtcblx0ICAgICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG5cdCAgICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcblx0ICAgICAgbGlzdC5fY2FwYWNpdHkgPSBuZXdDYXBhY2l0eTtcblx0ICAgICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcblx0ICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG5cdCAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuXHQgICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcblx0ICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gbGlzdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWVyZ2VJbnRvTGlzdFdpdGgobGlzdCwgbWVyZ2VyLCBpdGVyYWJsZXMpIHtcblx0ICAgIHZhciBpdGVycyA9IFtdO1xuXHQgICAgdmFyIG1heFNpemUgPSAwO1xuXHQgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJhYmxlcy5sZW5ndGg7IGlpKyspIHtcblx0ICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVzW2lpXTtcblx0ICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUodmFsdWUpO1xuXHQgICAgICBpZiAoaXRlci5zaXplID4gbWF4U2l6ZSkge1xuXHQgICAgICAgIG1heFNpemUgPSBpdGVyLnNpemU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkge1xuXHQgICAgICAgIGl0ZXIgPSBpdGVyLm1hcChmdW5jdGlvbih2ICkge3JldHVybiBmcm9tSlModil9KTtcblx0ICAgICAgfVxuXHQgICAgICBpdGVycy5wdXNoKGl0ZXIpO1xuXHQgICAgfVxuXHQgICAgaWYgKG1heFNpemUgPiBsaXN0LnNpemUpIHtcblx0ICAgICAgbGlzdCA9IGxpc3Quc2V0U2l6ZShtYXhTaXplKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChsaXN0LCBtZXJnZXIsIGl0ZXJzKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBnZXRUYWlsT2Zmc2V0KHNpemUpIHtcblx0ICAgIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKChzaXplIC0gMSkgPj4+IFNISUZUKSA8PCBTSElGVCk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoT3JkZXJlZE1hcCwgTWFwKTtcblxuXHQgICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuXHQgICAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZE1hcCgpIDpcblx0ICAgICAgICBpc09yZGVyZWRNYXAodmFsdWUpID8gdmFsdWUgOlxuXHQgICAgICAgIGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuXHQgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcblx0ICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG5cdCAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuXHQgICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cblx0ICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IHRoaXMuX21hcC5nZXQoayk7XG5cdCAgICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG5cdCAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgdGhpcy5zaXplID0gMDtcblx0ICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcblx0ICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuXHQgICAgfTtcblxuXHQgICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuXHQgICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcblx0ICAgIH07XG5cblx0ICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG5cdCAgICB9O1xuXG5cdCAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX2xpc3Qud2FzQWx0ZXJlZCgpO1xuXHQgICAgfTtcblxuXHQgICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuXHQgICAgICAgIGZ1bmN0aW9uKGVudHJ5ICkge3JldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMCl9LFxuXHQgICAgICAgIHJldmVyc2Vcblx0ICAgICAgKTtcblx0ICAgIH07XG5cblx0ICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG5cdCAgICB9O1xuXG5cdCAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuXHQgICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG5cdCAgICAgIHZhciBuZXdMaXN0ID0gdGhpcy5fbGlzdC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuXHQgICAgICBpZiAoIW93bmVySUQpIHtcblx0ICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuXHQgICAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcblx0ICAgIH07XG5cblxuXHQgIGZ1bmN0aW9uIGlzT3JkZXJlZE1hcChtYXliZU9yZGVyZWRNYXApIHtcblx0ICAgIHJldHVybiBpc01hcChtYXliZU9yZGVyZWRNYXApICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRNYXApO1xuXHQgIH1cblxuXHQgIE9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG5cdCAgT3JkZXJlZE1hcC5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXHQgIE9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cblxuXG5cdCAgZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG5cdCAgICB2YXIgb21hcCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZE1hcC5wcm90b3R5cGUpO1xuXHQgICAgb21hcC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuXHQgICAgb21hcC5fbWFwID0gbWFwO1xuXHQgICAgb21hcC5fbGlzdCA9IGxpc3Q7XG5cdCAgICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICBvbWFwLl9faGFzaCA9IGhhc2g7XG5cdCAgICByZXR1cm4gb21hcDtcblx0ICB9XG5cblx0ICB2YXIgRU1QVFlfT1JERVJFRF9NQVA7XG5cdCAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkTWFwKCkge1xuXHQgICAgcmV0dXJuIEVNUFRZX09SREVSRURfTUFQIHx8IChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG5cdCAgICB2YXIgbWFwID0gb21hcC5fbWFwO1xuXHQgICAgdmFyIGxpc3QgPSBvbWFwLl9saXN0O1xuXHQgICAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuXHQgICAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcblx0ICAgIHZhciBuZXdNYXA7XG5cdCAgICB2YXIgbmV3TGlzdDtcblx0ICAgIGlmICh2ID09PSBOT1RfU0VUKSB7IC8vIHJlbW92ZWRcblx0ICAgICAgaWYgKCFoYXMpIHtcblx0ICAgICAgICByZXR1cm4gb21hcDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobGlzdC5zaXplID49IFNJWkUgJiYgbGlzdC5zaXplID49IG1hcC5zaXplICogMikge1xuXHQgICAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbihlbnRyeSwgaWR4KSAge3JldHVybiBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IGlkeH0pO1xuXHQgICAgICAgIG5ld01hcCA9IG5ld0xpc3QudG9LZXllZFNlcSgpLm1hcChmdW5jdGlvbihlbnRyeSApIHtyZXR1cm4gZW50cnlbMF19KS5mbGlwKCkudG9NYXAoKTtcblx0ICAgICAgICBpZiAob21hcC5fX293bmVySUQpIHtcblx0ICAgICAgICAgIG5ld01hcC5fX293bmVySUQgPSBuZXdMaXN0Ll9fb3duZXJJRCA9IG9tYXAuX19vd25lcklEO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdNYXAgPSBtYXAucmVtb3ZlKGspO1xuXHQgICAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChoYXMpIHtcblx0ICAgICAgICBpZiAodiA9PT0gbGlzdC5nZXQoaSlbMV0pIHtcblx0ICAgICAgICAgIHJldHVybiBvbWFwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBuZXdNYXAgPSBtYXA7XG5cdCAgICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbmV3TWFwID0gbWFwLnNldChrLCBsaXN0LnNpemUpO1xuXHQgICAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuXHQgICAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcblx0ICAgICAgb21hcC5fbWFwID0gbmV3TWFwO1xuXHQgICAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcblx0ICAgICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICAgIHJldHVybiBvbWFwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoVG9LZXllZFNlcXVlbmNlLCBLZXllZFNlcSk7XG5cdCAgICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuXHQgICAgICB0aGlzLl9pdGVyID0gaW5kZXhlZDtcblx0ICAgICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG5cdCAgICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcblx0ICAgIH1cblxuXHQgICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcblx0ICAgIH07XG5cblx0ICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pdGVyLmhhcyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuXHQgICAgfTtcblxuXHQgICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSk7XG5cdCAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuXHQgICAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIHRoaXMkMC5faXRlci50b1NlcSgpLnJldmVyc2UoKX07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG5cdCAgICB9O1xuXG5cdCAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCk7XG5cdCAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuXHQgICAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSAge3JldHVybiB0aGlzJDAuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KX07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuXHQgICAgfTtcblxuXHQgICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICB2YXIgaWk7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShcblx0ICAgICAgICB0aGlzLl91c2VLZXlzID9cblx0ICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKHYsIGssIHRoaXMkMCl9IDpcblx0ICAgICAgICAgICgoaWkgPSByZXZlcnNlID8gcmVzb2x2ZVNpemUodGhpcykgOiAwKSxcblx0ICAgICAgICAgICAgZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgcmV2ZXJzZSA/IC0taWkgOiBpaSsrLCB0aGlzJDApfSksXG5cdCAgICAgICAgcmV2ZXJzZVxuXHQgICAgICApO1xuXHQgICAgfTtcblxuXHQgICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICBpZiAodGhpcy5fdXNlS2V5cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcblx0ICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHJlc29sdmVTaXplKHRoaXMpIDogMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuXHQgICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gLS1paSA6IGlpKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG5cdCAgY3JlYXRlQ2xhc3MoVG9JbmRleGVkU2VxdWVuY2UsIEluZGV4ZWRTZXEpO1xuXHQgICAgZnVuY3Rpb24gVG9JbmRleGVkU2VxdWVuY2UoaXRlcikge1xuXHQgICAgICB0aGlzLl9pdGVyID0gaXRlcjtcblx0ICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuXHQgICAgfVxuXG5cdCAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDApfSwgcmV2ZXJzZSk7XG5cdCAgICB9O1xuXG5cdCAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG5cdCAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcClcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cblxuXHQgIGNyZWF0ZUNsYXNzKFRvU2V0U2VxdWVuY2UsIFNldFNlcSk7XG5cdCAgICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcblx0ICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG5cdCAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcblx0ICAgIH1cblxuXHQgICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgdiwgdGhpcyQwKX0sIHJldmVyc2UpO1xuXHQgICAgfTtcblxuXHQgICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuXHQgICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBzdGVwLnZhbHVlLCBzdGVwLnZhbHVlLCBzdGVwKTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cblxuXHQgIGNyZWF0ZUNsYXNzKEZyb21FbnRyaWVzU2VxdWVuY2UsIEtleWVkU2VxKTtcblx0ICAgIGZ1bmN0aW9uIEZyb21FbnRyaWVzU2VxdWVuY2UoZW50cmllcykge1xuXHQgICAgICB0aGlzLl9pdGVyID0gZW50cmllcztcblx0ICAgICAgdGhpcy5zaXplID0gZW50cmllcy5zaXplO1xuXHQgICAgfVxuXG5cdCAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5faXRlci50b1NlcSgpO1xuXHQgICAgfTtcblxuXHQgICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKGVudHJ5ICkge1xuXHQgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcblx0ICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cblx0ICAgICAgICBpZiAoZW50cnkpIHtcblx0ICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuXHQgICAgICAgICAgdmFyIGluZGV4ZWRJdGVyYWJsZSA9IGlzSXRlcmFibGUoZW50cnkpO1xuXHQgICAgICAgICAgcmV0dXJuIGZuKFxuXHQgICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcblx0ICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG5cdCAgICAgICAgICAgIHRoaXMkMFxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHJldmVyc2UpO1xuXHQgICAgfTtcblxuXHQgICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gc3RlcDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG5cdCAgICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG5cdCAgICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cblx0ICAgICAgICAgIGlmIChlbnRyeSkge1xuXHQgICAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ZWRJdGVyYWJsZSA9IGlzSXRlcmFibGUoZW50cnkpO1xuXHQgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcblx0ICAgICAgICAgICAgICB0eXBlLFxuXHQgICAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuXHQgICAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuXHQgICAgICAgICAgICAgIHN0ZXBcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXG5cdCAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cblx0ICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cblx0ICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG5cdCAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuXHQgICAgY2FjaGVSZXN1bHRUaHJvdWdoO1xuXG5cblx0ICBmdW5jdGlvbiBmbGlwRmFjdG9yeShpdGVyYWJsZSkge1xuXHQgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG5cdCAgICBmbGlwU2VxdWVuY2UuX2l0ZXIgPSBpdGVyYWJsZTtcblx0ICAgIGZsaXBTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcblx0ICAgIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZX07XG5cdCAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBpdGVyYWJsZS5yZXZlcnNlLmFwcGx5KHRoaXMpOyAvLyBzdXBlci5yZXZlcnNlKClcblx0ICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS5yZXZlcnNlKCl9O1xuXHQgICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcblx0ICAgIH07XG5cdCAgICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5pbmNsdWRlcyhrZXkpfTtcblx0ICAgIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKGtleSApIHtyZXR1cm4gaXRlcmFibGUuaGFzKGtleSl9O1xuXHQgICAgZmxpcFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuXHQgICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZm4oaywgdiwgdGhpcyQwKSAhPT0gZmFsc2V9LCByZXZlcnNlKTtcblx0ICAgIH1cblx0ICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcblx0ICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuXHQgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuXHQgICAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG5cdCAgICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuXHQgICAgICAgICAgICBzdGVwLnZhbHVlWzFdID0gaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBzdGVwO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdG9yKFxuXHQgICAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG5cdCAgICAgICAgcmV2ZXJzZVxuXHQgICAgICApO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcblx0ICB9XG5cblxuXHQgIGZ1bmN0aW9uIG1hcEZhY3RvcnkoaXRlcmFibGUsIG1hcHBlciwgY29udGV4dCkge1xuXHQgICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcblx0ICAgIG1hcHBlZFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuXHQgICAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5oYXMoa2V5KX07XG5cdCAgICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSAge1xuXHQgICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuXHQgICAgICByZXR1cm4gdiA9PT0gTk9UX1NFVCA/XG5cdCAgICAgICAgbm90U2V0VmFsdWUgOlxuXHQgICAgICAgIG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpO1xuXHQgICAgfTtcblx0ICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdGUoXG5cdCAgICAgICAgZnVuY3Rpb24odiwgaywgYykgIHtyZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMCkgIT09IGZhbHNlfSxcblx0ICAgICAgICByZXZlcnNlXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcblx0ICAgICAgICAgIHJldHVybiBzdGVwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuXHQgICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcblx0ICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcblx0ICAgICAgICAgIHR5cGUsXG5cdCAgICAgICAgICBrZXksXG5cdCAgICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBpdGVyYWJsZSksXG5cdCAgICAgICAgICBzdGVwXG5cdCAgICAgICAgKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiByZXZlcnNlRmFjdG9yeShpdGVyYWJsZSwgdXNlS2V5cykge1xuXHQgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuXHQgICAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGl0ZXJhYmxlO1xuXHQgICAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcblx0ICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGV9O1xuXHQgICAgaWYgKGl0ZXJhYmxlLmZsaXApIHtcblx0ICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmbGlwU2VxdWVuY2UgPSBmbGlwRmFjdG9yeShpdGVyYWJsZSk7XG5cdCAgICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLmZsaXAoKX07XG5cdCAgICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgXG5cdCAgICAgIHtyZXR1cm4gaXRlcmFibGUuZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpfTtcblx0ICAgIHJldmVyc2VkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5IClcblx0ICAgICAge3JldHVybiBpdGVyYWJsZS5oYXModXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5KX07XG5cdCAgICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXJhYmxlLmluY2x1ZGVzKHZhbHVlKX07XG5cdCAgICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuXHQgICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbih2LCBrLCB0aGlzJDApfSwgIXJldmVyc2UpO1xuXHQgICAgfTtcblx0ICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9XG5cdCAgICAgIGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpICB7cmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgIXJldmVyc2UpfTtcblx0ICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuXHQgIH1cblxuXG5cdCAgZnVuY3Rpb24gZmlsdGVyRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG5cdCAgICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuXHQgICAgaWYgKHVzZUtleXMpIHtcblx0ICAgICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge1xuXHQgICAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG5cdCAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGl0ZXJhYmxlKTtcblx0ICAgICAgfTtcblx0ICAgICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgIHtcblx0ICAgICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuXHQgICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpID9cblx0ICAgICAgICAgIHYgOiBub3RTZXRWYWx1ZTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG5cdCAgICAgICAgICBpdGVyYXRpb25zKys7XG5cdCAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHJldmVyc2UpO1xuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgIH07XG5cdCAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gc3RlcDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG5cdCAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG5cdCAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeVsxXTtcblx0ICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBpdGVyYWJsZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgdXNlS2V5cyA/IGtleSA6IGl0ZXJhdGlvbnMrKywgdmFsdWUsIHN0ZXApO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuXHQgICAgdmFyIGdyb3VwcyA9IE1hcCgpLmFzTXV0YWJsZSgpO1xuXHQgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG5cdCAgICAgIGdyb3Vwcy51cGRhdGUoXG5cdCAgICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSxcblx0ICAgICAgICAwLFxuXHQgICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIGEgKyAxfVxuXHQgICAgICApO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZ3JvdXBzLmFzSW1tdXRhYmxlKCk7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiBncm91cEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuXHQgICAgdmFyIGlzS2V5ZWRJdGVyID0gaXNLZXllZChpdGVyYWJsZSk7XG5cdCAgICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChpdGVyYWJsZSkgPyBPcmRlcmVkTWFwKCkgOiBNYXAoKSkuYXNNdXRhYmxlKCk7XG5cdCAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcblx0ICAgICAgZ3JvdXBzLnVwZGF0ZShcblx0ICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpLFxuXHQgICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIChhID0gYSB8fCBbXSwgYS5wdXNoKGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdiksIGEpfVxuXHQgICAgICApO1xuXHQgICAgfSk7XG5cdCAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG5cdCAgICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbihhcnIgKSB7cmV0dXJuIHJlaWZ5KGl0ZXJhYmxlLCBjb2VyY2UoYXJyKSl9KTtcblx0ICB9XG5cblxuXHQgIGZ1bmN0aW9uIHNsaWNlRmFjdG9yeShpdGVyYWJsZSwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuXHQgICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG5cblx0ICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuXHQgICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcblx0ICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGJlZ2luID0gYmVnaW4gfCAwO1xuXHQgICAgfVxuXHQgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmIChlbmQgPT09IEluZmluaXR5KSB7XG5cdCAgICAgICAgZW5kID0gb3JpZ2luYWxTaXplO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVuZCA9IGVuZCB8IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgb3JpZ2luYWxTaXplKSkge1xuXHQgICAgICByZXR1cm4gaXRlcmFibGU7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuXHQgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cblx0ICAgIC8vIGJlZ2luIG9yIGVuZCB3aWxsIGJlIE5hTiBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYXMgbmVnYXRpdmUgbnVtYmVycyBhbmRcblx0ICAgIC8vIHRoaXMgaXRlcmFibGUncyBzaXplIGlzIHVua25vd24uIEluIHRoYXQgY2FzZSwgY2FjaGUgZmlyc3Qgc28gdGhlcmUgaXNcblx0ICAgIC8vIGEga25vd24gc2l6ZSBhbmQgdGhlc2UgZG8gbm90IHJlc29sdmUgdG8gTmFOLlxuXHQgICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG5cdCAgICAgIHJldHVybiBzbGljZUZhY3RvcnkoaXRlcmFibGUudG9TZXEoKS5jYWNoZVJlc3VsdCgpLCBiZWdpbiwgZW5kLCB1c2VLZXlzKTtcblx0ICAgIH1cblxuXHQgICAgLy8gTm90ZTogcmVzb2x2ZWRFbmQgaXMgdW5kZWZpbmVkIHdoZW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlJ3MgbGVuZ3RoIGlzXG5cdCAgICAvLyB1bmtub3duIGFuZCB0aGlzIHNsaWNlIGRpZCBub3Qgc3VwcGx5IGFuIGVuZCBhbmQgc2hvdWxkIGNvbnRhaW4gYWxsXG5cdCAgICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuXHQgICAgLy8gSW4gdGhhdCBjYXNlLCByZXNvbHZlZFNpemUgd2lsbCBiZSBOYU4gYW5kIHNsaWNlU2l6ZSB3aWxsIHJlbWFpbiB1bmRlZmluZWQuXG5cdCAgICB2YXIgcmVzb2x2ZWRTaXplID0gcmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luO1xuXHQgICAgdmFyIHNsaWNlU2l6ZTtcblx0ICAgIGlmIChyZXNvbHZlZFNpemUgPT09IHJlc29sdmVkU2l6ZSkge1xuXHQgICAgICBzbGljZVNpemUgPSByZXNvbHZlZFNpemUgPCAwID8gMCA6IHJlc29sdmVkU2l6ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHNsaWNlU2VxID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcblxuXHQgICAgLy8gSWYgaXRlcmFibGUuc2l6ZSBpcyB1bmRlZmluZWQsIHRoZSBzaXplIG9mIHRoZSByZWFsaXplZCBzbGljZVNlcSBpc1xuXHQgICAgLy8gdW5rbm93biBhdCB0aGlzIHBvaW50IHVubGVzcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNsaWNlIGlzIDBcblx0ICAgIHNsaWNlU2VxLnNpemUgPSBzbGljZVNpemUgPT09IDAgPyBzbGljZVNpemUgOiBpdGVyYWJsZS5zaXplICYmIHNsaWNlU2l6ZSB8fCB1bmRlZmluZWQ7XG5cblx0ICAgIGlmICghdXNlS2V5cyAmJiBpc1NlcShpdGVyYWJsZSkgJiYgc2xpY2VTaXplID49IDApIHtcblx0ICAgICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcblx0ICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHNsaWNlU2l6ZSA/XG5cdCAgICAgICAgICBpdGVyYWJsZS5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSkgOlxuXHQgICAgICAgICAgbm90U2V0VmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJldmVyc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHNraXBwZWQgPSAwO1xuXHQgICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG5cdCAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuXHQgICAgICAgICAgaXRlcmF0aW9ucysrO1xuXHQgICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMCkgIT09IGZhbHNlICYmXG5cdCAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgfTtcblxuXHQgICAgc2xpY2VTZXEuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuXHQgICAgICB2YXIgaXRlcmF0b3IgPSBzbGljZVNpemUgIT09IDAgJiYgaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgdmFyIHNraXBwZWQgPSAwO1xuXHQgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIHdoaWxlIChza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSB7XG5cdCAgICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPiBzbGljZVNpemUpIHtcblx0ICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcblx0ICAgICAgICAgIHJldHVybiBzdGVwO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG5cdCAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzbGljZVNlcTtcblx0ICB9XG5cblxuXHQgIGZ1bmN0aW9uIHRha2VXaGlsZUZhY3RvcnkoaXRlcmFibGUsIHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgdmFyIHRha2VTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG5cdCAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cdCAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSBcblx0ICAgICAgICB7cmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDApfVxuXHQgICAgICApO1xuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgIH07XG5cdCAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG5cdCAgICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICBpZiAoIWl0ZXJhdGluZykge1xuXHQgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG5cdCAgICAgICAgICByZXR1cm4gc3RlcDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcblx0ICAgICAgICB2YXIgayA9IGVudHJ5WzBdO1xuXHQgICAgICAgIHZhciB2ID0gZW50cnlbMV07XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDApKSB7XG5cdCAgICAgICAgICBpdGVyYXRpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOlxuXHQgICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcblx0ICB9XG5cblxuXHQgIGZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoaXRlcmFibGUsIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuXHQgICAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG5cdCAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgaWYgKHJldmVyc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuXHQgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cdCAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuXHQgICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG5cdCAgICAgICAgICBpdGVyYXRpb25zKys7XG5cdCAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgIH07XG5cdCAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG5cdCAgICAgIHZhciBza2lwcGluZyA9IHRydWU7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgdmFyIHN0ZXAsIGssIHY7XG5cdCAgICAgICAgZG8ge1xuXHQgICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcblx0ICAgICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHVuZGVmaW5lZCwgc3RlcCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcblx0ICAgICAgICAgIGsgPSBlbnRyeVswXTtcblx0ICAgICAgICAgIHYgPSBlbnRyeVsxXTtcblx0ICAgICAgICAgIHNraXBwaW5nICYmIChza2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMCkpO1xuXHQgICAgICAgIH0gd2hpbGUgKHNraXBwaW5nKTtcblx0ICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6XG5cdCAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gc2tpcFNlcXVlbmNlO1xuXHQgIH1cblxuXG5cdCAgZnVuY3Rpb24gY29uY2F0RmFjdG9yeShpdGVyYWJsZSwgdmFsdWVzKSB7XG5cdCAgICB2YXIgaXNLZXllZEl0ZXJhYmxlID0gaXNLZXllZChpdGVyYWJsZSk7XG5cdCAgICB2YXIgaXRlcnMgPSBbaXRlcmFibGVdLmNvbmNhdCh2YWx1ZXMpLm1hcChmdW5jdGlvbih2ICkge1xuXHQgICAgICBpZiAoIWlzSXRlcmFibGUodikpIHtcblx0ICAgICAgICB2ID0gaXNLZXllZEl0ZXJhYmxlID9cblx0ICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHYpIDpcblx0ICAgICAgICAgIGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuXHQgICAgICB9IGVsc2UgaWYgKGlzS2V5ZWRJdGVyYWJsZSkge1xuXHQgICAgICAgIHYgPSBLZXllZEl0ZXJhYmxlKHYpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB2O1xuXHQgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHYuc2l6ZSAhPT0gMH0pO1xuXG5cdCAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHJldHVybiBpdGVyYWJsZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG5cdCAgICAgIGlmIChzaW5nbGV0b24gPT09IGl0ZXJhYmxlIHx8XG5cdCAgICAgICAgICBpc0tleWVkSXRlcmFibGUgJiYgaXNLZXllZChzaW5nbGV0b24pIHx8XG5cdCAgICAgICAgICBpc0luZGV4ZWQoaXRlcmFibGUpICYmIGlzSW5kZXhlZChzaW5nbGV0b24pKSB7XG5cdCAgICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgY29uY2F0U2VxID0gbmV3IEFycmF5U2VxKGl0ZXJzKTtcblx0ICAgIGlmIChpc0tleWVkSXRlcmFibGUpIHtcblx0ICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvS2V5ZWRTZXEoKTtcblx0ICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChpdGVyYWJsZSkpIHtcblx0ICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG5cdCAgICB9XG5cdCAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEuZmxhdHRlbih0cnVlKTtcblx0ICAgIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKFxuXHQgICAgICBmdW5jdGlvbihzdW0sIHNlcSkgIHtcblx0ICAgICAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG5cdCAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgMFxuXHQgICAgKTtcblx0ICAgIHJldHVybiBjb25jYXRTZXE7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiBmbGF0dGVuRmFjdG9yeShpdGVyYWJsZSwgZGVwdGgsIHVzZUtleXMpIHtcblx0ICAgIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuXHQgICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuXHQgICAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuXHQgICAgICAgICAgaWYgKCghZGVwdGggfHwgY3VycmVudERlcHRoIDwgZGVwdGgpICYmIGlzSXRlcmFibGUodikpIHtcblx0ICAgICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucysrLCB0aGlzJDApID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiAhc3RvcHBlZDtcblx0ICAgICAgICB9LCByZXZlcnNlKTtcblx0ICAgICAgfVxuXHQgICAgICBmbGF0RGVlcChpdGVyYWJsZSwgMCk7XG5cdCAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgfVxuXHQgICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgdmFyIHN0YWNrID0gW107XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG5cdCAgICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG5cdCAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuXHQgICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuXHQgICAgICAgICAgICB2ID0gdlsxXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmICgoIWRlcHRoIHx8IHN0YWNrLmxlbmd0aCA8IGRlcHRoKSAmJiBpc0l0ZXJhYmxlKHYpKSB7XG5cdCAgICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuXHQgICAgICAgICAgICBpdGVyYXRvciA9IHYuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmbGF0U2VxdWVuY2U7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShpdGVyYWJsZSwgbWFwcGVyLCBjb250ZXh0KSB7XG5cdCAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG5cdCAgICByZXR1cm4gaXRlcmFibGUudG9TZXEoKS5tYXAoXG5cdCAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSkpfVxuXHQgICAgKS5mbGF0dGVuKHRydWUpO1xuXHQgIH1cblxuXG5cdCAgZnVuY3Rpb24gaW50ZXJwb3NlRmFjdG9yeShpdGVyYWJsZSwgc2VwYXJhdG9yKSB7XG5cdCAgICB2YXIgaW50ZXJwb3NlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcblx0ICAgIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZSAmJiBpdGVyYWJsZS5zaXplICogMiAtMTtcblx0ICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspIFxuXHQgICAgICAgIHtyZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDApICE9PSBmYWxzZSkgJiZcblx0ICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMCkgIT09IGZhbHNlfSxcblx0ICAgICAgICByZXZlcnNlXG5cdCAgICAgICk7XG5cdCAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgfTtcblx0ICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG5cdCAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuXHQgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cdCAgICAgIHZhciBzdGVwO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICBpZiAoIXN0ZXAgfHwgaXRlcmF0aW9ucyAlIDIpIHtcblx0ICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdGVwO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaXRlcmF0aW9ucyAlIDIgP1xuXHQgICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcikgOlxuXHQgICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xuXHQgIH1cblxuXG5cdCAgZnVuY3Rpb24gc29ydEZhY3RvcnkoaXRlcmFibGUsIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuXHQgICAgaWYgKCFjb21wYXJhdG9yKSB7XG5cdCAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcblx0ICAgIH1cblx0ICAgIHZhciBpc0tleWVkSXRlcmFibGUgPSBpc0tleWVkKGl0ZXJhYmxlKTtcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIgZW50cmllcyA9IGl0ZXJhYmxlLnRvU2VxKCkubWFwKFxuXHQgICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGl0ZXJhYmxlKSA6IHZdfVxuXHQgICAgKS50b0FycmF5KCk7XG5cdCAgICBlbnRyaWVzLnNvcnQoZnVuY3Rpb24oYSwgYikgIHtyZXR1cm4gY29tcGFyYXRvcihhWzNdLCBiWzNdKSB8fCBhWzJdIC0gYlsyXX0pLmZvckVhY2goXG5cdCAgICAgIGlzS2V5ZWRJdGVyYWJsZSA/XG5cdCAgICAgIGZ1bmN0aW9uKHYsIGkpICB7IGVudHJpZXNbaV0ubGVuZ3RoID0gMjsgfSA6XG5cdCAgICAgIGZ1bmN0aW9uKHYsIGkpICB7IGVudHJpZXNbaV0gPSB2WzFdOyB9XG5cdCAgICApO1xuXHQgICAgcmV0dXJuIGlzS2V5ZWRJdGVyYWJsZSA/IEtleWVkU2VxKGVudHJpZXMpIDpcblx0ICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSA/IEluZGV4ZWRTZXEoZW50cmllcykgOlxuXHQgICAgICBTZXRTZXEoZW50cmllcyk7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiBtYXhGYWN0b3J5KGl0ZXJhYmxlLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcblx0ICAgIGlmICghY29tcGFyYXRvcikge1xuXHQgICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG5cdCAgICB9XG5cdCAgICBpZiAobWFwcGVyKSB7XG5cdCAgICAgIHZhciBlbnRyeSA9IGl0ZXJhYmxlLnRvU2VxKClcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIFt2LCBtYXBwZXIodiwgaywgaXRlcmFibGUpXX0pXG5cdCAgICAgICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGF9KTtcblx0ICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGl0ZXJhYmxlLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGF9KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcblx0ICAgIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcblx0ICAgIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcblx0ICAgIC8vIHRoZXkgYXJlIG5vdCBlcXVhbCBhbmQgYiBpcyBpbiBmYWN0IGEgbnVsbGlzaCB2YWx1ZS5cblx0ICAgIHJldHVybiAoY29tcCA9PT0gMCAmJiBiICE9PSBhICYmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiICE9PSBiKSkgfHwgY29tcCA+IDA7XG5cdCAgfVxuXG5cblx0ICBmdW5jdGlvbiB6aXBXaXRoRmFjdG9yeShrZXlJdGVyLCB6aXBwZXIsIGl0ZXJzKSB7XG5cdCAgICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG5cdCAgICB6aXBTZXF1ZW5jZS5zaXplID0gbmV3IEFycmF5U2VxKGl0ZXJzKS5tYXAoZnVuY3Rpb24oaSApIHtyZXR1cm4gaS5zaXplfSkubWluKCk7XG5cdCAgICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuXHQgICAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cblx0ICAgIHppcFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG5cdCAgICAgIC8qIGdlbmVyaWM6XG5cdCAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuXHQgICAgICB2YXIgc3RlcDtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdCAgICAgICAgaXRlcmF0aW9ucysrO1xuXHQgICAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgICAgKi9cblx0ICAgICAgLy8gaW5kZXhlZDpcblx0ICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcblx0ICAgICAgdmFyIHN0ZXA7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuXHQgICAgfTtcblx0ICAgIHppcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9ycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpIClcblx0ICAgICAgICB7cmV0dXJuIChpID0gSXRlcmFibGUoaSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKX1cblx0ICAgICAgKTtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB2YXIgaXNEb25lID0gZmFsc2U7XG5cdCAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuXHQgICAgICAgIHZhciBzdGVwcztcblx0ICAgICAgICBpZiAoIWlzRG9uZSkge1xuXHQgICAgICAgICAgc3RlcHMgPSBpdGVyYXRvcnMubWFwKGZ1bmN0aW9uKGkgKSB7cmV0dXJuIGkubmV4dCgpfSk7XG5cdCAgICAgICAgICBpc0RvbmUgPSBzdGVwcy5zb21lKGZ1bmN0aW9uKHMgKSB7cmV0dXJuIHMuZG9uZX0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNEb25lKSB7XG5cdCAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuXHQgICAgICAgICAgdHlwZSxcblx0ICAgICAgICAgIGl0ZXJhdGlvbnMrKyxcblx0ICAgICAgICAgIHppcHBlci5hcHBseShudWxsLCBzdGVwcy5tYXAoZnVuY3Rpb24ocyApIHtyZXR1cm4gcy52YWx1ZX0pKVxuXHQgICAgICAgICk7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiB6aXBTZXF1ZW5jZVxuXHQgIH1cblxuXG5cdCAgLy8gI3ByYWdtYSBIZWxwZXIgRnVuY3Rpb25zXG5cblx0ICBmdW5jdGlvbiByZWlmeShpdGVyLCBzZXEpIHtcblx0ICAgIHJldHVybiBpc1NlcShpdGVyKSA/IHNlcSA6IGl0ZXIuY29uc3RydWN0b3Ioc2VxKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG5cdCAgICBpZiAoZW50cnkgIT09IE9iamVjdChlbnRyeSkpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlc29sdmVTaXplKGl0ZXIpIHtcblx0ICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG5cdCAgICByZXR1cm4gZW5zdXJlU2l6ZShpdGVyKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKSB7XG5cdCAgICByZXR1cm4gaXNLZXllZChpdGVyYWJsZSkgPyBLZXllZEl0ZXJhYmxlIDpcblx0ICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSA/IEluZGV4ZWRJdGVyYWJsZSA6XG5cdCAgICAgIFNldEl0ZXJhYmxlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG1ha2VTZXF1ZW5jZShpdGVyYWJsZSkge1xuXHQgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG5cdCAgICAgIChcblx0ICAgICAgICBpc0tleWVkKGl0ZXJhYmxlKSA/IEtleWVkU2VxIDpcblx0ICAgICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZFNlcSA6XG5cdCAgICAgICAgU2V0U2VxXG5cdCAgICAgICkucHJvdG90eXBlXG5cdCAgICApO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhY2hlUmVzdWx0VGhyb3VnaCgpIHtcblx0ICAgIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG5cdCAgICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcblx0ICAgICAgdGhpcy5zaXplID0gdGhpcy5faXRlci5zaXplO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0LmNhbGwodGhpcyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuXHQgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZvcmNlSXRlcmF0b3Ioa2V5UGF0aCkge1xuXHQgICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcihrZXlQYXRoKTtcblx0ICAgIGlmICghaXRlcikge1xuXHQgICAgICAvLyBBcnJheSBtaWdodCBub3QgYmUgaXRlcmFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCwgc28gd2UgbmVlZCBhIGZhbGxiYWNrXG5cdCAgICAgIC8vIHRvIG91ciB3cmFwcGVkIHR5cGUuXG5cdCAgICAgIGlmICghaXNBcnJheUxpa2Uoa2V5UGF0aCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBpdGVyYWJsZSBvciBhcnJheS1saWtlOiAnICsga2V5UGF0aCk7XG5cdCAgICAgIH1cblx0ICAgICAgaXRlciA9IGdldEl0ZXJhdG9yKEl0ZXJhYmxlKGtleVBhdGgpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBpdGVyO1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNsYXNzKFJlY29yZCwgS2V5ZWRDb2xsZWN0aW9uKTtcblxuXHQgICAgZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcblx0ICAgICAgdmFyIGhhc0luaXRpYWxpemVkO1xuXG5cdCAgICAgIHZhciBSZWNvcmRUeXBlID0gZnVuY3Rpb24gUmVjb3JkKHZhbHVlcykge1xuXHQgICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG5cdCAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcblx0ICAgICAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG5cdCAgICAgICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG5cdCAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuXHQgICAgICAgICAgc2V0UHJvcHMoUmVjb3JkVHlwZVByb3RvdHlwZSwga2V5cyk7XG5cdCAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLnNpemUgPSBrZXlzLmxlbmd0aDtcblx0ICAgICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX25hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fa2V5cyA9IGtleXM7XG5cdCAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9kZWZhdWx0VmFsdWVzID0gZGVmYXVsdFZhbHVlcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbWFwID0gTWFwKHZhbHVlcyk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSBSZWNvcmRUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb3JkUHJvdG90eXBlKTtcblx0ICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cblx0ICAgICAgcmV0dXJuIFJlY29yZFR5cGU7XG5cdCAgICB9XG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZyhyZWNvcmROYW1lKHRoaXMpICsgJyB7JywgJ30nKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrKTtcblx0ICAgIH07XG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUpIHtcblx0ICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuXHQgICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRWYWx1ZXNba107XG5cdCAgICAgIHJldHVybiB0aGlzLl9tYXAgPyB0aGlzLl9tYXAuZ2V0KGssIGRlZmF1bHRWYWwpIDogZGVmYXVsdFZhbDtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5jbGVhcigpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBSZWNvcmRUeXBlID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgcmV0dXJuIFJlY29yZFR5cGUuX2VtcHR5IHx8IChSZWNvcmRUeXBlLl9lbXB0eSA9IG1ha2VSZWNvcmQodGhpcywgZW1wdHlNYXAoKSkpO1xuXHQgICAgfTtcblxuXHQgICAgUmVjb3JkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG5cdCAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgdW5rbm93biBrZXkgXCInICsgayArICdcIiBvbiAnICsgcmVjb3JkTmFtZSh0aGlzKSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLmhhcyhrKSkge1xuXHQgICAgICAgIHZhciBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdFZhbHVlc1trXTtcblx0ICAgICAgICBpZiAodiA9PT0gZGVmYXVsdFZhbCkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLnNldChrLCB2KTtcblx0ICAgICAgaWYgKHRoaXMuX19vd25lcklEIHx8IG5ld01hcCA9PT0gdGhpcy5fbWFwKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwKTtcblx0ICAgIH07XG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAucmVtb3ZlKGspO1xuXHQgICAgICBpZiAodGhpcy5fX293bmVySUQgfHwgbmV3TWFwID09PSB0aGlzLl9tYXApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXApO1xuXHQgICAgfTtcblxuXHQgICAgUmVjb3JkLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuXHQgICAgfTtcblxuXHQgICAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gS2V5ZWRJdGVyYWJsZSh0aGlzLl9kZWZhdWx0VmFsdWVzKS5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gdGhpcyQwLmdldChrKX0pLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG5cdCAgICB9O1xuXG5cdCAgICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHJldHVybiBLZXllZEl0ZXJhYmxlKHRoaXMuX2RlZmF1bHRWYWx1ZXMpLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiB0aGlzJDAuZ2V0KGspfSkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcblx0ICAgIH07XG5cblx0ICAgIFJlY29yZC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcblx0ICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcblx0ICAgICAgaWYgKCFvd25lcklEKSB7XG5cdCAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXAsIG93bmVySUQpO1xuXHQgICAgfTtcblxuXG5cdCAgdmFyIFJlY29yZFByb3RvdHlwZSA9IFJlY29yZC5wcm90b3R5cGU7XG5cdCAgUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuXHQgIFJlY29yZFByb3RvdHlwZS5kZWxldGVJbiA9XG5cdCAgUmVjb3JkUHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLnJlbW92ZUluO1xuXHQgIFJlY29yZFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5tZXJnZTtcblx0ICBSZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlV2l0aDtcblx0ICBSZWNvcmRQcm90b3R5cGUubWVyZ2VJbiA9IE1hcFByb3RvdHlwZS5tZXJnZUluO1xuXHQgIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXAgPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwO1xuXHQgIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGg7XG5cdCAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcEluID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluO1xuXHQgIFJlY29yZFByb3RvdHlwZS5zZXRJbiA9IE1hcFByb3RvdHlwZS5zZXRJbjtcblx0ICBSZWNvcmRQcm90b3R5cGUudXBkYXRlID0gTWFwUHJvdG90eXBlLnVwZGF0ZTtcblx0ICBSZWNvcmRQcm90b3R5cGUudXBkYXRlSW4gPSBNYXBQcm90b3R5cGUudXBkYXRlSW47XG5cdCAgUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcblx0ICBSZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcblx0ICBSZWNvcmRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5cblxuXHQgIGZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgbWFwLCBvd25lcklEKSB7XG5cdCAgICB2YXIgcmVjb3JkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobGlrZVJlY29yZCkpO1xuXHQgICAgcmVjb3JkLl9tYXAgPSBtYXA7XG5cdCAgICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcblx0ICAgIHJldHVybiByZWNvcmQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcblx0ICAgIHJldHVybiByZWNvcmQuX25hbWUgfHwgcmVjb3JkLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1JlY29yZCc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2V0UHJvcHMocHJvdG90eXBlLCBuYW1lcykge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgbmFtZXMuZm9yRWFjaChzZXRQcm9wLmJpbmQodW5kZWZpbmVkLCBwcm90b3R5cGUpKTtcblx0ICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXRQcm9wKHByb3RvdHlwZSwgbmFtZSkge1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcblx0ICAgICAgfSxcblx0ICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgIGludmFyaWFudCh0aGlzLl9fb3duZXJJRCwgJ0Nhbm5vdCBzZXQgb24gYW4gaW1tdXRhYmxlIHJlY29yZC4nKTtcblx0ICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNsYXNzKFNldCwgU2V0Q29sbGVjdGlvbik7XG5cblx0ICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cblx0ICAgIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2V0KCkgOlxuXHQgICAgICAgIGlzU2V0KHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcblx0ICAgICAgICBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuXHQgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG5cdCAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuXHQgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHNldC5hZGQodil9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgU2V0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuXHQgICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgU2V0LmZyb21LZXlzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRJdGVyYWJsZSh2YWx1ZSkua2V5U2VxKCkpO1xuXHQgICAgfTtcblxuXHQgICAgU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG5cdCAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cblx0ICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB0cnVlKSk7XG5cdCAgICB9O1xuXG5cdCAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuXHQgICAgfTtcblxuXHQgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5jbGVhcigpKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuXHQgICAgU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuXHQgICAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbih4ICkge3JldHVybiB4LnNpemUgIT09IDB9KTtcblx0ICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcblx0ICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG5cdCAgICAgICAgICBTZXRJdGVyYWJsZShpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHNldC5hZGQodmFsdWUpfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdCAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpdGVyICkge3JldHVybiBTZXRJdGVyYWJsZShpdGVyKX0pO1xuXHQgICAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcblx0ICAgICAgICBvcmlnaW5hbFNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuXHQgICAgICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbihpdGVyICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pKSB7XG5cdCAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0ICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIFNldEl0ZXJhYmxlKGl0ZXIpfSk7XG5cdCAgICAgIHZhciBvcmlnaW5hbFNldCA9IHRoaXM7XG5cdCAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuXHQgICAgICAgIG9yaWdpbmFsU2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG5cdCAgICAgICAgICBpZiAoaXRlcnMuc29tZShmdW5jdGlvbihpdGVyICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pKSB7XG5cdCAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudW5pb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgICAgIHJldHVybiB0aGlzLnVuaW9uLmFwcGx5KHRoaXMsIGl0ZXJzKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcblx0ICAgICAgLy8gTGF0ZSBiaW5kaW5nXG5cdCAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG5cdCAgICAgIC8vIExhdGUgYmluZGluZ1xuXHQgICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcblx0ICAgICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdGUoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gZm4oaywgaywgdGhpcyQwKX0sIHJldmVyc2UpO1xuXHQgICAgfTtcblxuXHQgICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbWFwLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiBrfSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcblx0ICAgIH07XG5cblx0ICAgIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcblx0ICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuXHQgICAgICBpZiAoIW93bmVySUQpIHtcblx0ICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9fbWFrZShuZXdNYXAsIG93bmVySUQpO1xuXHQgICAgfTtcblxuXG5cdCAgZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcblx0ICAgIHJldHVybiAhIShtYXliZVNldCAmJiBtYXliZVNldFtJU19TRVRfU0VOVElORUxdKTtcblx0ICB9XG5cblx0ICBTZXQuaXNTZXQgPSBpc1NldDtcblxuXHQgIHZhciBJU19TRVRfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9TRVRfX0BAJztcblxuXHQgIHZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuXHQgIFNldFByb3RvdHlwZVtJU19TRVRfU0VOVElORUxdID0gdHJ1ZTtcblx0ICBTZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG5cdCAgU2V0UHJvdG90eXBlLm1lcmdlRGVlcCA9IFNldFByb3RvdHlwZS5tZXJnZTtcblx0ICBTZXRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IFNldFByb3RvdHlwZS5tZXJnZVdpdGg7XG5cdCAgU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcblx0ICBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcblx0ICBTZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5cblx0ICBTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuXHQgIFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlU2V0O1xuXG5cdCAgZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG5cdCAgICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuXHQgICAgICBzZXQuc2l6ZSA9IG5ld01hcC5zaXplO1xuXHQgICAgICBzZXQuX21hcCA9IG5ld01hcDtcblx0ICAgICAgcmV0dXJuIHNldDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwID8gc2V0IDpcblx0ICAgICAgbmV3TWFwLnNpemUgPT09IDAgPyBzZXQuX19lbXB0eSgpIDpcblx0ICAgICAgc2V0Ll9fbWFrZShuZXdNYXApO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG5cdCAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuXHQgICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG5cdCAgICBzZXQuX21hcCA9IG1hcDtcblx0ICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgcmV0dXJuIHNldDtcblx0ICB9XG5cblx0ICB2YXIgRU1QVFlfU0VUO1xuXHQgIGZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuXHQgICAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoT3JkZXJlZFNldCwgU2V0KTtcblxuXHQgICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuXHQgICAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZFNldCgpIDpcblx0ICAgICAgICBpc09yZGVyZWRTZXQodmFsdWUpID8gdmFsdWUgOlxuXHQgICAgICAgIGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuXHQgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG5cdCAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuXHQgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHNldC5hZGQodil9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcblx0ICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcyhLZXllZEl0ZXJhYmxlKHZhbHVlKS5rZXlTZXEoKSk7XG5cdCAgICB9O1xuXG5cdCAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuXHQgICAgfTtcblxuXG5cdCAgZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuXHQgICAgcmV0dXJuIGlzU2V0KG1heWJlT3JkZXJlZFNldCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZFNldCk7XG5cdCAgfVxuXG5cdCAgT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cblx0ICB2YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuXHQgIE9yZGVyZWRTZXRQcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cdCAgT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuXHQgIE9yZGVyZWRTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZU9yZGVyZWRTZXQ7XG5cblx0ICBmdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcblx0ICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuXHQgICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG5cdCAgICBzZXQuX21hcCA9IG1hcDtcblx0ICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuXHQgICAgcmV0dXJuIHNldDtcblx0ICB9XG5cblx0ICB2YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG5cdCAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkU2V0KCkge1xuXHQgICAgcmV0dXJuIEVNUFRZX09SREVSRURfU0VUIHx8IChFTVBUWV9PUkRFUkVEX1NFVCA9IG1ha2VPcmRlcmVkU2V0KGVtcHR5T3JkZXJlZE1hcCgpKSk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoU3RhY2ssIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuXHQgICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuXHQgICAgZnVuY3Rpb24gU3RhY2sodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVN0YWNrKCkgOlxuXHQgICAgICAgIGlzU3RhY2sodmFsdWUpID8gdmFsdWUgOlxuXHQgICAgICAgIGVtcHR5U3RhY2soKS51bnNoaWZ0QWxsKHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgU3RhY2sub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG5cdCAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICBTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG5cdCAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcblx0ICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuXHQgICAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG5cdCAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIFN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG5cdCAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcblx0ICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcblx0ICAgICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuXHQgICAgICAgIGhlYWQgPSB7XG5cdCAgICAgICAgICB2YWx1ZTogYXJndW1lbnRzW2lpXSxcblx0ICAgICAgICAgIG5leHQ6IGhlYWRcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG5cdCAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG5cdCAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG5cdCAgICB9O1xuXG5cdCAgICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uKGl0ZXIpIHtcblx0ICAgICAgaXRlciA9IEluZGV4ZWRJdGVyYWJsZShpdGVyKTtcblx0ICAgICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG5cdCAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplO1xuXHQgICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG5cdCAgICAgIGl0ZXIucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG5cdCAgICAgICAgbmV3U2l6ZSsrO1xuXHQgICAgICAgIGhlYWQgPSB7XG5cdCAgICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgICBuZXh0OiBoZWFkXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG5cdCAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG5cdCAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG5cdCAgICB9O1xuXG5cdCAgICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuXHQgICAgfTtcblxuXHQgICAgU3RhY2sucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIFN0YWNrLnByb3RvdHlwZS51bnNoaWZ0QWxsID0gZnVuY3Rpb24oaXRlcikge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoQWxsKGl0ZXIpO1xuXHQgICAgfTtcblxuXHQgICAgU3RhY2sucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcblx0ICAgICAgICB0aGlzLnNpemUgPSAwO1xuXHQgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG5cdCAgICB9O1xuXG5cdCAgICBTdGFjay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG5cdCAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcblx0ICAgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG5cdCAgICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG5cdCAgICAgICAgLy8gc3VwZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG5cdCAgICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplIC0gcmVzb2x2ZWRCZWdpbjtcblx0ICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuXHQgICAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG5cdCAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcblx0ICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuXHQgICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuXHQgICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuXHQgICAgfTtcblxuXHQgICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cblx0ICAgIFN0YWNrLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuXHQgICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIW93bmVySUQpIHtcblx0ICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG5cdCAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWFrZVN0YWNrKHRoaXMuc2l6ZSwgdGhpcy5faGVhZCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuXHQgICAgfTtcblxuXHQgICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuXHQgICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG5cdCAgICAgIGlmIChyZXZlcnNlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLl9faXRlcmF0ZShmbik7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG5cdCAgICAgIHdoaWxlIChub2RlKSB7XG5cdCAgICAgICAgaWYgKGZuKG5vZGUudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaXRlcmF0aW9ucztcblx0ICAgIH07XG5cblx0ICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuXHQgICAgICBpZiAocmV2ZXJzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5fX2l0ZXJhdG9yKHR5cGUpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuXHQgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcblx0ICAgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcblx0ICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG5cdCAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblxuXHQgIGZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuXHQgICAgcmV0dXJuICEhKG1heWJlU3RhY2sgJiYgbWF5YmVTdGFja1tJU19TVEFDS19TRU5USU5FTF0pO1xuXHQgIH1cblxuXHQgIFN0YWNrLmlzU3RhY2sgPSBpc1N0YWNrO1xuXG5cdCAgdmFyIElTX1NUQUNLX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfU1RBQ0tfX0BAJztcblxuXHQgIHZhciBTdGFja1Byb3RvdHlwZSA9IFN0YWNrLnByb3RvdHlwZTtcblx0ICBTdGFja1Byb3RvdHlwZVtJU19TVEFDS19TRU5USU5FTF0gPSB0cnVlO1xuXHQgIFN0YWNrUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcblx0ICBTdGFja1Byb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuXHQgIFN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXHQgIFN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZDtcblxuXG5cdCAgZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcblx0ICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcblx0ICAgIG1hcC5zaXplID0gc2l6ZTtcblx0ICAgIG1hcC5faGVhZCA9IGhlYWQ7XG5cdCAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcblx0ICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuXHQgICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIG1hcDtcblx0ICB9XG5cblx0ICB2YXIgRU1QVFlfU1RBQ0s7XG5cdCAgZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcblx0ICAgIHJldHVybiBFTVBUWV9TVEFDSyB8fCAoRU1QVFlfU1RBQ0sgPSBtYWtlU3RhY2soMCkpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENvbnRyaWJ1dGVzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuXHQgICAgdmFyIGtleUNvcGllciA9IGZ1bmN0aW9uKGtleSApIHsgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTsgfTtcblx0ICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcblx0ICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcblx0ICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG5cdCAgICByZXR1cm4gY3Rvcjtcblx0ICB9XG5cblx0ICBJdGVyYWJsZS5JdGVyYXRvciA9IEl0ZXJhdG9yO1xuXG5cdCAgbWl4aW4oSXRlcmFibGUsIHtcblxuXHQgICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuXHQgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG5cdCAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUgfHwgMCk7XG5cdCAgICAgIHRoaXMudmFsdWVTZXEoKS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaSkgIHsgYXJyYXlbaV0gPSB2OyB9KTtcblx0ICAgICAgcmV0dXJuIGFycmF5O1xuXHQgICAgfSxcblxuXHQgICAgdG9JbmRleGVkU2VxOiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvSlM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChcblx0ICAgICAgICBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlMgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b0pTKCkgOiB2YWx1ZX1cblx0ICAgICAgKS5fX3RvSlMoKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKFxuXHQgICAgICAgIGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9KU09OKCkgOiB2YWx1ZX1cblx0ICAgICAgKS5fX3RvSlMoKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvTWFwOiBmdW5jdGlvbigpIHtcblx0ICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuXHQgICAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcblx0ICAgICAgdmFyIG9iamVjdCA9IHt9O1xuXHQgICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAgeyBvYmplY3Rba10gPSB2OyB9KTtcblx0ICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH0sXG5cblx0ICAgIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0ICAgICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuXHQgICAgfSxcblxuXHQgICAgdG9PcmRlcmVkU2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuXHQgICAgICByZXR1cm4gT3JkZXJlZFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG5cdCAgICB9LFxuXG5cdCAgICB0b1NldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0ICAgICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG5cdCAgICB9LFxuXG5cdCAgICB0b1NldFNlcTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvU2VxOiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKSA/IHRoaXMudG9JbmRleGVkU2VxKCkgOlxuXHQgICAgICAgIGlzS2V5ZWQodGhpcykgPyB0aGlzLnRvS2V5ZWRTZXEoKSA6XG5cdCAgICAgICAgdGhpcy50b1NldFNlcSgpO1xuXHQgICAgfSxcblxuXHQgICAgdG9TdGFjazogZnVuY3Rpb24oKSB7XG5cdCAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0ICAgICAgcmV0dXJuIFN0YWNrKGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcblx0ICAgIH0sXG5cblx0ICAgIHRvTGlzdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0ICAgICAgcmV0dXJuIExpc3QoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuXHQgICAgfSxcblxuXG5cdCAgICAvLyAjIyMgQ29tbW9uIEphdmFTY3JpcHQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXG5cdCAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiAnW0l0ZXJhYmxlXSc7XG5cdCAgICB9LFxuXG5cdCAgICBfX3RvU3RyaW5nOiBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG5cdCAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGhlYWQgKyAnICcgKyB0aGlzLnRvU2VxKCkubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcikuam9pbignLCAnKSArICcgJyArIHRhaWw7XG5cdCAgICB9LFxuXG5cblx0ICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuXHQgICAgY29uY2F0OiBmdW5jdGlvbigpIHt2YXIgdmFsdWVzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCBjb25jYXRGYWN0b3J5KHRoaXMsIHZhbHVlcykpO1xuXHQgICAgfSxcblxuXHQgICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSl9KTtcblx0ICAgIH0sXG5cblx0ICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG5cdCAgICB9LFxuXG5cdCAgICBldmVyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG5cdCAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG5cdCAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG5cdCAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuXHQgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG5cdCAgICB9LFxuXG5cdCAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcblx0ICAgIH0sXG5cblx0ICAgIGZpbmQ6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcblx0ICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcblx0ICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcblx0ICAgIH0sXG5cblx0ICAgIGZvckVhY2g6IGZ1bmN0aW9uKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcblx0ICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlKGNvbnRleHQgPyBzaWRlRWZmZWN0LmJpbmQoY29udGV4dCkgOiBzaWRlRWZmZWN0KTtcblx0ICAgIH0sXG5cblx0ICAgIGpvaW46IGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuXHQgICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuXHQgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuXHQgICAgICB2YXIgam9pbmVkID0gJyc7XG5cdCAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtcblx0ICAgICAgICBpc0ZpcnN0ID8gKGlzRmlyc3QgPSBmYWxzZSkgOiAoam9pbmVkICs9IHNlcGFyYXRvcik7XG5cdCAgICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gam9pbmVkO1xuXHQgICAgfSxcblxuXHQgICAga2V5czogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcblx0ICAgIH0sXG5cblx0ICAgIG1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuXHQgICAgfSxcblxuXHQgICAgcmVkdWNlOiBmdW5jdGlvbihyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG5cdCAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG5cdCAgICAgIHZhciByZWR1Y3Rpb247XG5cdCAgICAgIHZhciB1c2VGaXJzdDtcblx0ICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdCAgICAgICAgdXNlRmlyc3QgPSB0cnVlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlZHVjdGlvbiA9IGluaXRpYWxSZWR1Y3Rpb247XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcblx0ICAgICAgICBpZiAodXNlRmlyc3QpIHtcblx0ICAgICAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG5cdCAgICAgICAgICByZWR1Y3Rpb24gPSB2O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcmVkdWN0aW9uO1xuXHQgICAgfSxcblxuXHQgICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcblx0ICAgICAgdmFyIHJldmVyc2VkID0gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpO1xuXHQgICAgICByZXR1cm4gcmV2ZXJzZWQucmVkdWNlLmFwcGx5KHJldmVyc2VkLCBhcmd1bWVudHMpO1xuXHQgICAgfSxcblxuXHQgICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG5cdCAgICB9LFxuXG5cdCAgICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcblx0ICAgIH0sXG5cblx0ICAgIHNvbWU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuXHQgICAgfSxcblxuXHQgICAgc29ydDogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuXHQgICAgfSxcblxuXHQgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG5cdCAgICB9LFxuXG5cblx0ICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG5cdCAgICBidXRMYXN0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuXHQgICAgfSxcblxuXHQgICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24oKSAge3JldHVybiB0cnVlfSk7XG5cdCAgICB9LFxuXG5cdCAgICBjb3VudDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiBlbnN1cmVTaXplKFxuXHQgICAgICAgIHByZWRpY2F0ZSA/IHRoaXMudG9TZXEoKS5maWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSA6IHRoaXNcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cblx0ICAgIGNvdW50Qnk6IGZ1bmN0aW9uKGdyb3VwZXIsIGNvbnRleHQpIHtcblx0ICAgICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuXHQgICAgfSxcblxuXHQgICAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuXHQgICAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcblx0ICAgIH0sXG5cblx0ICAgIGVudHJ5U2VxOiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcztcblx0ICAgICAgaWYgKGl0ZXJhYmxlLl9jYWNoZSkge1xuXHQgICAgICAgIC8vIFdlIGNhY2hlIGFzIGFuIGVudHJpZXMgYXJyYXksIHNvIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgY2FjaGUhXG5cdCAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShpdGVyYWJsZS5fY2FjaGUpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBlbnRyaWVzU2VxdWVuY2UgPSBpdGVyYWJsZS50b1NlcSgpLm1hcChlbnRyeU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG5cdCAgICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLnRvU2VxKCl9O1xuXHQgICAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuXHQgICAgfSxcblxuXHQgICAgZmlsdGVyTm90OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcblx0ICAgIH0sXG5cblx0ICAgIGZpbmRFbnRyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcblx0ICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcblx0ICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcblx0ICAgICAgICAgIGZvdW5kID0gW2ssIHZdO1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBmb3VuZDtcblx0ICAgIH0sXG5cblx0ICAgIGZpbmRLZXk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuXHQgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG5cdCAgICB9LFxuXG5cdCAgICBmaW5kTGFzdDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG5cdCAgICB9LFxuXG5cdCAgICBmaW5kTGFzdEVudHJ5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuXHQgICAgfSxcblxuXHQgICAgZmluZExhc3RLZXk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcblx0ICAgIH0sXG5cblx0ICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIGZsYXRNYXA6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG5cdCAgICB9LFxuXG5cdCAgICBmbGF0dGVuOiBmdW5jdGlvbihkZXB0aCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcblx0ICAgIH0sXG5cblx0ICAgIGZyb21FbnRyeVNlcTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldDogZnVuY3Rpb24oc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKF8sIGtleSkgIHtyZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRJbjogZnVuY3Rpb24oc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcblx0ICAgICAgdmFyIG5lc3RlZCA9IHRoaXM7XG5cdCAgICAgIC8vIE5vdGU6IGluIGFuIEVTNiBlbnZpcm9ubWVudCwgd2Ugd291bGQgcHJlZmVyOlxuXHQgICAgICAvLyBmb3IgKHZhciBrZXkgb2Ygc2VhcmNoS2V5UGF0aCkge1xuXHQgICAgICB2YXIgaXRlciA9IGZvcmNlSXRlcmF0b3Ioc2VhcmNoS2V5UGF0aCk7XG5cdCAgICAgIHZhciBzdGVwO1xuXHQgICAgICB3aGlsZSAoIShzdGVwID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcblx0ICAgICAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcblx0ICAgICAgICBuZXN0ZWQgPSBuZXN0ZWQgJiYgbmVzdGVkLmdldCA/IG5lc3RlZC5nZXQoa2V5LCBOT1RfU0VUKSA6IE5PVF9TRVQ7XG5cdCAgICAgICAgaWYgKG5lc3RlZCA9PT0gTk9UX1NFVCkge1xuXHQgICAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmVzdGVkO1xuXHQgICAgfSxcblxuXHQgICAgZ3JvdXBCeTogZnVuY3Rpb24oZ3JvdXBlciwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG5cdCAgICB9LFxuXG5cdCAgICBoYXM6IGZ1bmN0aW9uKHNlYXJjaEtleSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcblx0ICAgIH0sXG5cblx0ICAgIGhhc0luOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldEluKHNlYXJjaEtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuXHQgICAgfSxcblxuXHQgICAgaXNTdWJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcblx0ICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuXHQgICAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSl9KTtcblx0ICAgIH0sXG5cblx0ICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcblx0ICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmlzU3Vic2V0ID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuXHQgICAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcblx0ICAgIH0sXG5cblx0ICAgIGtleU9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG5cdCAgICB9LFxuXG5cdCAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChrZXlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuXHQgICAgfSxcblxuXHQgICAgbGFzdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLmZpcnN0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBsYXN0S2V5T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkua2V5T2Yoc2VhcmNoVmFsdWUpO1xuXHQgICAgfSxcblxuXHQgICAgbWF4OiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG5cdCAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuXHQgICAgfSxcblxuXHQgICAgbWF4Qnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuXHQgICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuXHQgICAgfSxcblxuXHQgICAgbWluOiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG5cdCAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcik7XG5cdCAgICB9LFxuXG5cdCAgICBtaW5CeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG5cdCAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvciwgbWFwcGVyKTtcblx0ICAgIH0sXG5cblx0ICAgIHJlc3Q6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcblx0ICAgIH0sXG5cblx0ICAgIHNraXA6IGZ1bmN0aW9uKGFtb3VudCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcblx0ICAgIH0sXG5cblx0ICAgIHNraXBMYXN0OiBmdW5jdGlvbihhbW91bnQpIHtcblx0ICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuc2tpcChhbW91bnQpLnJldmVyc2UoKSk7XG5cdCAgICB9LFxuXG5cdCAgICBza2lwV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcblx0ICAgIH0sXG5cblx0ICAgIHNraXBVbnRpbDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG5cdCAgICB9LFxuXG5cdCAgICBzb3J0Qnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG5cdCAgICB9LFxuXG5cdCAgICB0YWtlOiBmdW5jdGlvbihhbW91bnQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYW1vdW50KSk7XG5cdCAgICB9LFxuXG5cdCAgICB0YWtlTGFzdDogZnVuY3Rpb24oYW1vdW50KSB7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLnRha2UoYW1vdW50KS5yZXZlcnNlKCkpO1xuXHQgICAgfSxcblxuXHQgICAgdGFrZVdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG5cdCAgICB9LFxuXG5cdCAgICB0YWtlVW50aWw6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuXHQgICAgfSxcblxuXHQgICAgdmFsdWVTZXE6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b0luZGV4ZWRTZXEoKTtcblx0ICAgIH0sXG5cblxuXHQgICAgLy8gIyMjIEhhc2hhYmxlIE9iamVjdFxuXG5cdCAgICBoYXNoQ29kZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoSXRlcmFibGUodGhpcykpO1xuXHQgICAgfVxuXG5cblx0ICAgIC8vICMjIyBJbnRlcm5hbFxuXG5cdCAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cblx0ICAgIC8vIGFic3RyYWN0IF9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSlcblx0ICB9KTtcblxuXHQgIC8vIHZhciBJU19JVEVSQUJMRV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG5cdCAgLy8gdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcblx0ICAvLyB2YXIgSVNfSU5ERVhFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcblx0ICAvLyB2YXIgSVNfT1JERVJFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuXHQgIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcblx0ICBJdGVyYWJsZVByb3RvdHlwZVtJU19JVEVSQUJMRV9TRU5USU5FTF0gPSB0cnVlO1xuXHQgIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBJdGVyYWJsZVByb3RvdHlwZS52YWx1ZXM7XG5cdCAgSXRlcmFibGVQcm90b3R5cGUuX190b0pTID0gSXRlcmFibGVQcm90b3R5cGUudG9BcnJheTtcblx0ICBJdGVyYWJsZVByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG5cdCAgSXRlcmFibGVQcm90b3R5cGUuaW5zcGVjdCA9XG5cdCAgSXRlcmFibGVQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfTtcblx0ICBJdGVyYWJsZVByb3RvdHlwZS5jaGFpbiA9IEl0ZXJhYmxlUHJvdG90eXBlLmZsYXRNYXA7XG5cdCAgSXRlcmFibGVQcm90b3R5cGUuY29udGFpbnMgPSBJdGVyYWJsZVByb3RvdHlwZS5pbmNsdWRlcztcblxuXHQgIG1peGluKEtleWVkSXRlcmFibGUsIHtcblxuXHQgICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cblx0ICAgIGZsaXA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuXHQgICAgfSxcblxuXHQgICAgbWFwRW50cmllczogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG5cdCAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblx0ICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsXG5cdCAgICAgICAgdGhpcy50b1NlcSgpLm1hcChcblx0ICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIFtrLCB2XSwgaXRlcmF0aW9ucysrLCB0aGlzJDApfVxuXHQgICAgICAgICkuZnJvbUVudHJ5U2VxKClcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cblx0ICAgIG1hcEtleXM6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcyxcblx0ICAgICAgICB0aGlzLnRvU2VxKCkuZmxpcCgpLm1hcChcblx0ICAgICAgICAgIGZ1bmN0aW9uKGssIHYpICB7cmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMCl9XG5cdCAgICAgICAgKS5mbGlwKClcblx0ICAgICAgKTtcblx0ICAgIH1cblxuXHQgIH0pO1xuXG5cdCAgdmFyIEtleWVkSXRlcmFibGVQcm90b3R5cGUgPSBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZTtcblx0ICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlW0lTX0tFWUVEX1NFTlRJTkVMXSA9IHRydWU7XG5cdCAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcztcblx0ICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9KUyA9IEl0ZXJhYmxlUHJvdG90eXBlLnRvT2JqZWN0O1xuXHQgIEtleWVkSXRlcmFibGVQcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpfTtcblxuXG5cblx0ICBtaXhpbihJbmRleGVkSXRlcmFibGUsIHtcblxuXHQgICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuXHQgICAgdG9LZXllZFNlcTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcblx0ICAgIH0sXG5cblxuXHQgICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG5cdCAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG5cdCAgICB9LFxuXG5cdCAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuXHQgICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuXHQgICAgfSxcblxuXHQgICAgaW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcblx0ICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuXHQgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcblx0ICAgIH0sXG5cblx0ICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuXHQgICAgICB2YXIga2V5ID0gdGhpcy5sYXN0S2V5T2Yoc2VhcmNoVmFsdWUpO1xuXHQgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcblx0ICAgIH0sXG5cblx0ICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcblx0ICAgIH0sXG5cblx0ICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcblx0ICAgIH0sXG5cblx0ICAgIHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIHJlbW92ZU51bSAvKiwgLi4udmFsdWVzKi8pIHtcblx0ICAgICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfCAwLCAwKTtcblx0ICAgICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG5cdCAgICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cblx0ICAgICAgLy8gb25seSBjYWxsIGNvdW50KCkgaWYgdGhlIG51bWJlciBpcyBpbiBmYWN0IG5lZ2F0aXZlLlxuXHQgICAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcblx0ICAgICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcblx0ICAgICAgcmV0dXJuIHJlaWZ5KFxuXHQgICAgICAgIHRoaXMsXG5cdCAgICAgICAgbnVtQXJncyA9PT0gMSA/XG5cdCAgICAgICAgICBzcGxpY2VkIDpcblx0ICAgICAgICAgIHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG5cdCAgICAgICk7XG5cdCAgICB9LFxuXG5cblx0ICAgIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG5cdCAgICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG5cdCAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG5cdCAgICB9LFxuXG5cdCAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcblx0ICAgIH0sXG5cblx0ICAgIGZsYXR0ZW46IGZ1bmN0aW9uKGRlcHRoKSB7XG5cdCAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldDogZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG5cdCAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcblx0ICAgICAgcmV0dXJuIChpbmRleCA8IDAgfHwgKHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHxcblx0ICAgICAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+IHRoaXMuc2l6ZSkpKSA/XG5cdCAgICAgICAgbm90U2V0VmFsdWUgOlxuXHQgICAgICAgIHRoaXMuZmluZChmdW5jdGlvbihfLCBrZXkpICB7cmV0dXJuIGtleSA9PT0gaW5kZXh9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcblx0ICAgIH0sXG5cblx0ICAgIGhhczogZnVuY3Rpb24oaW5kZXgpIHtcblx0ICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuXHQgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgP1xuXHQgICAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemUgOlxuXHQgICAgICAgIHRoaXMuaW5kZXhPZihpbmRleCkgIT09IC0xXG5cdCAgICAgICk7XG5cdCAgICB9LFxuXG5cdCAgICBpbnRlcnBvc2U6IGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJwb3NlRmFjdG9yeSh0aGlzLCBzZXBhcmF0b3IpKTtcblx0ICAgIH0sXG5cblx0ICAgIGludGVybGVhdmU6IGZ1bmN0aW9uKC8qLi4uaXRlcmFibGVzKi8pIHtcblx0ICAgICAgdmFyIGl0ZXJhYmxlcyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcblx0ICAgICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgaXRlcmFibGVzKTtcblx0ICAgICAgdmFyIGludGVybGVhdmVkID0gemlwcGVkLmZsYXR0ZW4odHJ1ZSk7XG5cdCAgICAgIGlmICh6aXBwZWQuc2l6ZSkge1xuXHQgICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGl0ZXJhYmxlcy5sZW5ndGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcblx0ICAgIH0sXG5cblx0ICAgIGtleVNlcTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBSYW5nZSgwLCB0aGlzLnNpemUpO1xuXHQgICAgfSxcblxuXHQgICAgbGFzdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldCgtMSk7XG5cdCAgICB9LFxuXG5cdCAgICBza2lwV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG5cdCAgICB9LFxuXG5cdCAgICB6aXA6IGZ1bmN0aW9uKC8qLCAuLi5pdGVyYWJsZXMgKi8pIHtcblx0ICAgICAgdmFyIGl0ZXJhYmxlcyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcblx0ICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGl0ZXJhYmxlcykpO1xuXHQgICAgfSxcblxuXHQgICAgemlwV2l0aDogZnVuY3Rpb24oemlwcGVyLyosIC4uLml0ZXJhYmxlcyAqLykge1xuXHQgICAgICB2YXIgaXRlcmFibGVzID0gYXJyQ29weShhcmd1bWVudHMpO1xuXHQgICAgICBpdGVyYWJsZXNbMF0gPSB0aGlzO1xuXHQgICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBpdGVyYWJsZXMpKTtcblx0ICAgIH1cblxuXHQgIH0pO1xuXG5cdCAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19JTkRFWEVEX1NFTlRJTkVMXSA9IHRydWU7XG5cdCAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG5cdCAgbWl4aW4oU2V0SXRlcmFibGUsIHtcblxuXHQgICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcblx0ICAgIH0sXG5cblx0ICAgIGluY2x1ZGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuXHQgICAgfSxcblxuXG5cdCAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuXHQgICAga2V5U2VxOiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcblx0ICAgIH1cblxuXHQgIH0pO1xuXG5cdCAgU2V0SXRlcmFibGUucHJvdG90eXBlLmhhcyA9IEl0ZXJhYmxlUHJvdG90eXBlLmluY2x1ZGVzO1xuXHQgIFNldEl0ZXJhYmxlLnByb3RvdHlwZS5jb250YWlucyA9IFNldEl0ZXJhYmxlLnByb3RvdHlwZS5pbmNsdWRlcztcblxuXG5cdCAgLy8gTWl4aW4gc3ViY2xhc3Nlc1xuXG5cdCAgbWl4aW4oS2V5ZWRTZXEsIEtleWVkSXRlcmFibGUucHJvdG90eXBlKTtcblx0ICBtaXhpbihJbmRleGVkU2VxLCBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlKTtcblx0ICBtaXhpbihTZXRTZXEsIFNldEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cblx0ICBtaXhpbihLZXllZENvbGxlY3Rpb24sIEtleWVkSXRlcmFibGUucHJvdG90eXBlKTtcblx0ICBtaXhpbihJbmRleGVkQ29sbGVjdGlvbiwgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cdCAgbWl4aW4oU2V0Q29sbGVjdGlvbiwgU2V0SXRlcmFibGUucHJvdG90eXBlKTtcblxuXG5cdCAgLy8gI3ByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cblx0ICBmdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuXHQgICAgcmV0dXJuIGs7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuXHQgICAgcmV0dXJuIFtrLCB2XTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbmVnKHByZWRpY2F0ZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVmYXVsdFppcHBlcigpIHtcblx0ICAgIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVmYXVsdE5lZ0NvbXBhcmF0b3IoYSwgYikge1xuXHQgICAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGhhc2hJdGVyYWJsZShpdGVyYWJsZSkge1xuXHQgICAgaWYgKGl0ZXJhYmxlLnNpemUgPT09IEluZmluaXR5KSB7XG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXHQgICAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoaXRlcmFibGUpO1xuXHQgICAgdmFyIGtleWVkID0gaXNLZXllZChpdGVyYWJsZSk7XG5cdCAgICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcblx0ICAgIHZhciBzaXplID0gaXRlcmFibGUuX19pdGVyYXRlKFxuXHQgICAgICBrZXllZCA/XG5cdCAgICAgICAgb3JkZXJlZCA/XG5cdCAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpIHwgMDsgfSA6XG5cdCAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSB8IDA7IH0gOlxuXHQgICAgICAgIG9yZGVyZWQgP1xuXHQgICAgICAgICAgZnVuY3Rpb24odiApIHsgaCA9IDMxICogaCArIGhhc2godikgfCAwOyB9IDpcblx0ICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7IGggPSBoICsgaGFzaCh2KSB8IDA7IH1cblx0ICAgICk7XG5cdCAgICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpIHtcblx0ICAgIGggPSBpbXVsKGgsIDB4Q0M5RTJENTEpO1xuXHQgICAgaCA9IGltdWwoaCA8PCAxNSB8IGggPj4+IC0xNSwgMHgxQjg3MzU5Myk7XG5cdCAgICBoID0gaW11bChoIDw8IDEzIHwgaCA+Pj4gLTEzLCA1KTtcblx0ICAgIGggPSAoaCArIDB4RTY1NDZCNjQgfCAwKSBeIHNpemU7XG5cdCAgICBoID0gaW11bChoIF4gaCA+Pj4gMTYsIDB4ODVFQkNBNkIpO1xuXHQgICAgaCA9IGltdWwoaCBeIGggPj4+IDEzLCAweEMyQjJBRTM1KTtcblx0ICAgIGggPSBzbWkoaCBeIGggPj4+IDE2KTtcblx0ICAgIHJldHVybiBoO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGhhc2hNZXJnZShhLCBiKSB7XG5cdCAgICByZXR1cm4gYSBeIGIgKyAweDlFMzc3OUI5ICsgKGEgPDwgNikgKyAoYSA+PiAyKSB8IDA7IC8vIGludFxuXHQgIH1cblxuXHQgIHZhciBJbW11dGFibGUgPSB7XG5cblx0ICAgIEl0ZXJhYmxlOiBJdGVyYWJsZSxcblxuXHQgICAgU2VxOiBTZXEsXG5cdCAgICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuXHQgICAgTWFwOiBNYXAsXG5cdCAgICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuXHQgICAgTGlzdDogTGlzdCxcblx0ICAgIFN0YWNrOiBTdGFjayxcblx0ICAgIFNldDogU2V0LFxuXHQgICAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcblxuXHQgICAgUmVjb3JkOiBSZWNvcmQsXG5cdCAgICBSYW5nZTogUmFuZ2UsXG5cdCAgICBSZXBlYXQ6IFJlcGVhdCxcblxuXHQgICAgaXM6IGlzLFxuXHQgICAgZnJvbUpTOiBmcm9tSlNcblxuXHQgIH07XG5cblx0ICByZXR1cm4gSW1tdXRhYmxlO1xuXG5cdH0pKTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG5cdCAgdmFyIGdldFR5cGUgPSB7fTtcblx0ICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cblx0Ly8gbG9hZCB0aGUgc3R5bGVzXG5cdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApO1xuXHRpZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxuXHR2YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KShjb250ZW50LCB7fSk7XG5cdGlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5cdGlmKGZhbHNlKSB7XG5cdFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0XHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlYWN0LWRhdGEtZ3JpZC1jb3JlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlYWN0LWRhdGEtZ3JpZC1jb3JlLmNzc1wiKTtcblx0XHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdFx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG5cdH1cblxuLyoqKi8gfSksXG4vKiAyMSAqLyxcbi8qIDIyICovLFxuLyogMjMgKi8sXG4vKiAyNCAqLyxcbi8qIDI1ICovLFxuLyogMjYgKi8sXG4vKiAyNyAqLyxcbi8qIDI4ICovLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG5cdC8vIGxvYWQgdGhlIHN0eWxlc1xuXHR2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQyKTtcblx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cdC8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cblx0dmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoY29udGVudCwge30pO1xuXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcblx0Ly8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuXHRpZihmYWxzZSkge1xuXHRcdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdFx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9yZWFjdC1kYXRhLWdyaWQtcm93LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlYWN0LWRhdGEtZ3JpZC1yb3cuY3NzXCIpO1xuXHRcdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0XHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfa2V5bWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpO1xuXG5cdHZhciBfa2V5bWlycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleW1pcnJvcik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdHZhciBjb25zdGFudHMgPSB7XG5cdCAgVXBkYXRlQWN0aW9uczogKDAsIF9rZXltaXJyb3IyWydkZWZhdWx0J10pKHtcblx0ICAgIENFTExfVVBEQVRFOiBudWxsLFxuXHQgICAgQ09MVU1OX0ZJTEw6IG51bGwsXG5cdCAgICBDT1BZX1BBU1RFOiBudWxsLFxuXHQgICAgQ0VMTF9EUkFHOiBudWxsXG5cdCAgfSksXG5cdCAgRHJhZ0l0ZW1UeXBlczoge1xuXHQgICAgQ29sdW1uOiAnY29sdW1uJ1xuXHQgIH0sXG5cdCAgQ2VsbEV4cGFuZDoge1xuXHQgICAgRE9XTl9UUklBTkdMRTogU3RyaW5nLmZyb21DaGFyQ29kZSgnOTY2MCcpLFxuXHQgICAgUklHSFRfVFJJQU5HTEU6IFN0cmluZy5mcm9tQ2hhckNvZGUoJzk2NTQnKVxuXHQgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc2hhbGxvd0Nsb25lT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cdHZhciBzYW1lQ29sdW1uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpO1xuXHR2YXIgQ29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgZ2V0U2Nyb2xsYmFyU2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXHR2YXIgaXNDb2x1bW5zSW1tdXRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cblx0ZnVuY3Rpb24gc2V0Q29sdW1uV2lkdGhzKGNvbHVtbnMsIHRvdGFsV2lkdGgpIHtcblx0ICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuXHQgICAgdmFyIGNvbEluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBjb2x1bW4pO1xuXHQgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuXHQgICAgICBpZiAoL14oWzAtOV0rKSUkLy5leGVjKGNvbHVtbi53aWR0aC50b1N0cmluZygpKSkge1xuXHQgICAgICAgIGNvbEluZm8ud2lkdGggPSBNYXRoLmZsb29yKGNvbHVtbi53aWR0aCAvIDEwMCAqIHRvdGFsV2lkdGgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29sSW5mbztcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldERlZmZlcmVkQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHVuYWxsb2NhdGVkV2lkdGgsIG1pbkNvbHVtbldpZHRoKSB7XG5cdCAgdmFyIGRlZmZlcmVkQ29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG5cdCAgICByZXR1cm4gIWMud2lkdGg7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcblx0ICAgIGlmICghY29sdW1uLndpZHRoICYmIGNvbHVtbi53aWR0aCAhPT0gMCkge1xuXHQgICAgICBpZiAodW5hbGxvY2F0ZWRXaWR0aCA8PSAwKSB7XG5cdCAgICAgICAgY29sdW1uLndpZHRoID0gbWluQ29sdW1uV2lkdGg7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gTWF0aC5mbG9vcih1bmFsbG9jYXRlZFdpZHRoIC8gQ29sdW1uVXRpbHMuZ2V0U2l6ZShkZWZmZXJlZENvbHVtbnMpKTtcblx0ICAgICAgICBpZiAoY29sdW1uV2lkdGggPCBtaW5Db2x1bW5XaWR0aCkge1xuXHQgICAgICAgICAgY29sdW1uLndpZHRoID0gbWluQ29sdW1uV2lkdGg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbHVtbldpZHRoO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbHVtbjtcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldENvbHVtbk9mZnNldHMoY29sdW1ucykge1xuXHQgIHZhciBsZWZ0ID0gMDtcblx0ICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuXHQgICAgY29sdW1uLmxlZnQgPSBsZWZ0O1xuXHQgICAgbGVmdCArPSBjb2x1bW4ud2lkdGg7XG5cdCAgICByZXR1cm4gY29sdW1uO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBjb2x1bW4gbWV0cmljcyBjYWxjdWxhdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtDb2x1bW5NZXRyaWNzVHlwZX0gbWV0cmljc1xuXHQgKi9cblx0ZnVuY3Rpb24gcmVjYWxjdWxhdGUobWV0cmljcykge1xuXHQgIC8vIGNvbXB1dGUgd2lkdGggZm9yIGNvbHVtbnMgd2hpY2ggc3BlY2lmeSB3aWR0aFxuXHQgIHZhciBjb2x1bW5zID0gc2V0Q29sdW1uV2lkdGhzKG1ldHJpY3MuY29sdW1ucywgbWV0cmljcy50b3RhbFdpZHRoKTtcblxuXHQgIHZhciB1bmFsbG9jYXRlZFdpZHRoID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcblx0ICAgIHJldHVybiBjLndpZHRoO1xuXHQgIH0pLnJlZHVjZShmdW5jdGlvbiAodywgY29sdW1uKSB7XG5cdCAgICByZXR1cm4gdyAtIGNvbHVtbi53aWR0aDtcblx0ICB9LCBtZXRyaWNzLnRvdGFsV2lkdGgpO1xuXHQgIHVuYWxsb2NhdGVkV2lkdGggLT0gZ2V0U2Nyb2xsYmFyU2l6ZSgpO1xuXG5cdCAgdmFyIHdpZHRoID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcblx0ICAgIHJldHVybiBjLndpZHRoO1xuXHQgIH0pLnJlZHVjZShmdW5jdGlvbiAodywgY29sdW1uKSB7XG5cdCAgICByZXR1cm4gdyArIGNvbHVtbi53aWR0aDtcblx0ICB9LCAwKTtcblxuXHQgIC8vIGNvbXB1dGUgd2lkdGggZm9yIGNvbHVtbnMgd2hpY2ggZG9lc24ndCBzcGVjaWZ5IHdpZHRoXG5cdCAgY29sdW1ucyA9IHNldERlZmZlcmVkQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHVuYWxsb2NhdGVkV2lkdGgsIG1ldHJpY3MubWluQ29sdW1uV2lkdGgpO1xuXG5cdCAgLy8gY29tcHV0ZSBsZWZ0IG9mZnNldFxuXHQgIGNvbHVtbnMgPSBzZXRDb2x1bW5PZmZzZXRzKGNvbHVtbnMpO1xuXG5cdCAgcmV0dXJuIHtcblx0ICAgIGNvbHVtbnM6IGNvbHVtbnMsXG5cdCAgICB3aWR0aDogd2lkdGgsXG5cdCAgICB0b3RhbFdpZHRoOiBtZXRyaWNzLnRvdGFsV2lkdGgsXG5cdCAgICBtaW5Db2x1bW5XaWR0aDogbWV0cmljcy5taW5Db2x1bW5XaWR0aFxuXHQgIH07XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIGNvbHVtbiBtZXRyaWNzIGNhbGN1bGF0aW9uIGJ5IHJlc2l6aW5nIGEgY29sdW1uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NvbHVtbk1ldHJpY3NUeXBlfSBtZXRyaWNzXG5cdCAqIEBwYXJhbSB7Q29sdW1ufSBjb2x1bW5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNpemVDb2x1bW4obWV0cmljcywgaW5kZXgsIHdpZHRoKSB7XG5cdCAgdmFyIGNvbHVtbiA9IENvbHVtblV0aWxzLmdldENvbHVtbihtZXRyaWNzLmNvbHVtbnMsIGluZGV4KTtcblx0ICB2YXIgbWV0cmljc0Nsb25lID0gc2hhbGxvd0Nsb25lT2JqZWN0KG1ldHJpY3MpO1xuXHQgIG1ldHJpY3NDbG9uZS5jb2x1bW5zID0gbWV0cmljcy5jb2x1bW5zLnNsaWNlKDApO1xuXG5cdCAgdmFyIHVwZGF0ZWRDb2x1bW4gPSBzaGFsbG93Q2xvbmVPYmplY3QoY29sdW1uKTtcblx0ICB1cGRhdGVkQ29sdW1uLndpZHRoID0gTWF0aC5tYXgod2lkdGgsIG1ldHJpY3NDbG9uZS5taW5Db2x1bW5XaWR0aCk7XG5cblx0ICBtZXRyaWNzQ2xvbmUgPSBDb2x1bW5VdGlscy5zcGxpY2VDb2x1bW4obWV0cmljc0Nsb25lLCBpbmRleCwgdXBkYXRlZENvbHVtbik7XG5cblx0ICByZXR1cm4gcmVjYWxjdWxhdGUobWV0cmljc0Nsb25lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFyZUNvbHVtbnNJbW11dGFibGUocHJldkNvbHVtbnMsIG5leHRDb2x1bW5zKSB7XG5cdCAgcmV0dXJuIGlzQ29sdW1uc0ltbXV0YWJsZShwcmV2Q29sdW1ucykgJiYgaXNDb2x1bW5zSW1tdXRhYmxlKG5leHRDb2x1bW5zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVFYWNoQ29sdW1uKHByZXZDb2x1bW5zLCBuZXh0Q29sdW1ucywgaXNTYW1lQ29sdW1uKSB7XG5cdCAgdmFyIGkgPSB2b2lkIDA7XG5cdCAgdmFyIGxlbiA9IHZvaWQgMDtcblx0ICB2YXIgY29sdW1uID0gdm9pZCAwO1xuXHQgIHZhciBwcmV2Q29sdW1uc0J5S2V5ID0ge307XG5cdCAgdmFyIG5leHRDb2x1bW5zQnlLZXkgPSB7fTtcblxuXHQgIGlmIChDb2x1bW5VdGlscy5nZXRTaXplKHByZXZDb2x1bW5zKSAhPT0gQ29sdW1uVXRpbHMuZ2V0U2l6ZShuZXh0Q29sdW1ucykpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBDb2x1bW5VdGlscy5nZXRTaXplKHByZXZDb2x1bW5zKTsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBjb2x1bW4gPSBwcmV2Q29sdW1uc1tpXTtcblx0ICAgIHByZXZDb2x1bW5zQnlLZXlbY29sdW1uLmtleV0gPSBjb2x1bW47XG5cdCAgfVxuXG5cdCAgZm9yIChpID0gMCwgbGVuID0gQ29sdW1uVXRpbHMuZ2V0U2l6ZShuZXh0Q29sdW1ucyk7IGkgPCBsZW47IGkrKykge1xuXHQgICAgY29sdW1uID0gbmV4dENvbHVtbnNbaV07XG5cdCAgICBuZXh0Q29sdW1uc0J5S2V5W2NvbHVtbi5rZXldID0gY29sdW1uO1xuXHQgICAgdmFyIHByZXZDb2x1bW4gPSBwcmV2Q29sdW1uc0J5S2V5W2NvbHVtbi5rZXldO1xuXHQgICAgaWYgKHByZXZDb2x1bW4gPT09IHVuZGVmaW5lZCB8fCAhaXNTYW1lQ29sdW1uKHByZXZDb2x1bW4sIGNvbHVtbikpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZvciAoaSA9IDAsIGxlbiA9IENvbHVtblV0aWxzLmdldFNpemUocHJldkNvbHVtbnMpOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGNvbHVtbiA9IHByZXZDb2x1bW5zW2ldO1xuXHQgICAgdmFyIG5leHRDb2x1bW4gPSBuZXh0Q29sdW1uc0J5S2V5W2NvbHVtbi5rZXldO1xuXHQgICAgaWYgKG5leHRDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2FtZUNvbHVtbnMocHJldkNvbHVtbnMsIG5leHRDb2x1bW5zLCBpc1NhbWVDb2x1bW4pIHtcblx0ICBpZiAoYXJlQ29sdW1uc0ltbXV0YWJsZShwcmV2Q29sdW1ucywgbmV4dENvbHVtbnMpKSB7XG5cdCAgICByZXR1cm4gcHJldkNvbHVtbnMgPT09IG5leHRDb2x1bW5zO1xuXHQgIH1cblxuXHQgIHJldHVybiBjb21wYXJlRWFjaENvbHVtbihwcmV2Q29sdW1ucywgbmV4dENvbHVtbnMsIGlzU2FtZUNvbHVtbik7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgcmVjYWxjdWxhdGU6IHJlY2FsY3VsYXRlLCByZXNpemVDb2x1bW46IHJlc2l6ZUNvbHVtbiwgc2FtZUNvbHVtbjogc2FtZUNvbHVtbiwgc2FtZUNvbHVtbnM6IHNhbWVDb2x1bW5zIH07XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHNpemUgPSB2b2lkIDA7XG5cblx0ZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyU2l6ZSgpIHtcblx0ICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIG91dGVyLnN0eWxlLndpZHRoID0gJzUwcHgnO1xuXHQgICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gJzUwcHgnO1xuXHQgICAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgb3V0ZXIuc3R5bGUudG9wID0gJy0yMDBweCc7XG5cdCAgICBvdXRlci5zdHlsZS5sZWZ0ID0gJy0yMDBweCc7XG5cblx0ICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4Jztcblx0ICAgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG5cdCAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcblxuXHQgICAgdmFyIG91dGVyV2lkdGggPSBvdXRlci5jbGllbnRXaWR0aDtcblx0ICAgIG91dGVyLnN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnO1xuXHQgICAgdmFyIGlubmVyV2lkdGggPSBpbm5lci5jbGllbnRXaWR0aDtcblxuXHQgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cblx0ICAgIHNpemUgPSBvdXRlcldpZHRoIC0gaW5uZXJXaWR0aDtcblx0ICB9XG5cblx0ICByZXR1cm4gc2l6ZTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gZ2V0U2Nyb2xsYmFyU2l6ZTtcblxuLyoqKi8gfSksXG4vKiAzMyAqLyxcbi8qIDM0ICovLFxuLyogMzUgKi8sXG4vKiAzNiAqLyxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuXHQvLyBsb2FkIHRoZSBzdHlsZXNcblx0dmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG5cdGlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXHQvLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG5cdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKGNvbnRlbnQsIHt9KTtcblx0aWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cdC8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcblx0aWYoZmFsc2UpIHtcblx0XHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRcdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZGF0YS1ncmlkLWNlbGwuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZGF0YS1ncmlkLWNlbGwuY3NzXCIpO1xuXHRcdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0XHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDM4ICovLFxuLyogMzkgKi8sXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfdW5kZXJzY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG5cdHZhciBfdW5kZXJzY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91bmRlcnNjb3JlKTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHR2YXIgX0NlbGxBY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cblx0dmFyIF9DZWxsQWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NlbGxBY3Rpb24pO1xuXG5cdHZhciBfQ2VsbEV4cGFuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblxuXHR2YXIgX0NlbGxFeHBhbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2VsbEV4cGFuZCk7XG5cblx0dmFyIF9DaGlsZFJvd0RlbGV0ZUJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3KTtcblxuXHR2YXIgX0NoaWxkUm93RGVsZXRlQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoaWxkUm93RGVsZXRlQnV0dG9uKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBqb2luQ2xhc3NlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBFZGl0b3JDb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XG5cdHZhciBFeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgQ2VsbE1ldGFEYXRhU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIFNpbXBsZUNlbGxGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblx0dmFyIENvbHVtblV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGNyZWF0ZU9iamVjdFdpdGhQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cblx0Ly8gVGhlIGxpc3Qgb2YgdGhlIHByb3BUeXBlcyB0aGF0IHdlIHdhbnQgdG8gaW5jbHVkZSBpbiB0aGUgQ2VsbCBkaXZcblx0dmFyIGtub3duRGl2UHJvcGVydHlLZXlzID0gWydoZWlnaHQnLCAndGFiSW5kZXgnLCAndmFsdWUnXTtcblxuXHR2YXIgQ2VsbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKENlbGwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gQ2VsbCgpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICBpc0NlbGxWYWx1ZUNoYW5naW5nOiBmYWxzZSxcblx0ICAgICAgaXNMb2NrQ2hhbmdpbmc6IGZhbHNlXG5cdCAgICB9LCBfdGhpcy5vbkNlbGxDbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSAhPSBudWxsICYmIG1ldGEub25DZWxsQ2xpY2sgJiYgdHlwZW9mIG1ldGEub25DZWxsQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBtZXRhLm9uQ2VsbENsaWNrKHsgcm93SWR4OiBfdGhpcy5wcm9wcy5yb3dJZHgsIGlkeDogX3RoaXMucHJvcHMuaWR4IH0sIGUpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5vbkNlbGxGb2N1cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG1ldGEgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGE7XG5cdCAgICAgIGlmIChtZXRhICE9IG51bGwgJiYgbWV0YS5vbkNlbGxGb2N1cyAmJiB0eXBlb2YgbWV0YS5vbkNlbGxGb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIG1ldGEub25DZWxsRm9jdXMoeyByb3dJZHg6IF90aGlzLnByb3BzLnJvd0lkeCwgaWR4OiBfdGhpcy5wcm9wcy5pZHggfSk7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLm9uQ2VsbENvbnRleHRNZW51ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgbWV0YSA9IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YTtcblx0ICAgICAgaWYgKG1ldGEgIT0gbnVsbCAmJiBtZXRhLm9uQ2VsbENvbnRleHRNZW51ICYmIHR5cGVvZiBtZXRhLm9uQ2VsbENvbnRleHRNZW51ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgbWV0YS5vbkNlbGxDb250ZXh0TWVudSh7IHJvd0lkeDogX3RoaXMucHJvcHMucm93SWR4LCBpZHg6IF90aGlzLnByb3BzLmlkeCB9KTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25DZWxsRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgbWV0YSA9IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YTtcblx0ICAgICAgaWYgKG1ldGEgIT0gbnVsbCAmJiBtZXRhLm9uQ2VsbERvdWJsZUNsaWNrICYmIHR5cGVvZiBtZXRhLm9uQ2VsbERvdWJsZUNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgbWV0YS5vbkNlbGxEb3VibGVDbGljayh7IHJvd0lkeDogX3RoaXMucHJvcHMucm93SWR4LCBpZHg6IF90aGlzLnByb3BzLmlkeCB9LCBlKTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25DZWxsRXhwYW5kID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgICAgdmFyIG1ldGEgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGE7XG5cdCAgICAgIGlmIChtZXRhICE9IG51bGwgJiYgbWV0YS5vbkNlbGxFeHBhbmQgIT0gbnVsbCkge1xuXHQgICAgICAgIG1ldGEub25DZWxsRXhwYW5kKHsgcm93SWR4OiBfdGhpcy5wcm9wcy5yb3dJZHgsIGlkeDogX3RoaXMucHJvcHMuaWR4LCByb3dEYXRhOiBfdGhpcy5wcm9wcy5yb3dEYXRhLCBleHBhbmRBcmdzOiBfdGhpcy5wcm9wcy5leHBhbmRhYmxlT3B0aW9ucyB9KTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25DZWxsS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmIChfdGhpcy5jYW5FeHBhbmQoKSAmJiBlLmtleSA9PT0gJ0VudGVyJykge1xuXHQgICAgICAgIF90aGlzLm9uQ2VsbEV4cGFuZChlKTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25EZWxldGVTdWJSb3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSAhPSBudWxsICYmIG1ldGEub25EZWxldGVTdWJSb3cgIT0gbnVsbCkge1xuXHQgICAgICAgIG1ldGEub25EZWxldGVTdWJSb3coeyByb3dJZHg6IF90aGlzLnByb3BzLnJvd0lkeCwgaWR4OiBfdGhpcy5wcm9wcy5pZHgsIHJvd0RhdGE6IF90aGlzLnByb3BzLnJvd0RhdGEsIGV4cGFuZEFyZ3M6IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zIH0pO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5vbkRyYWdIYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSAhPSBudWxsICYmIG1ldGEub25EcmFnSGFuZGxlRG91YmxlQ2xpY2sgJiYgdHlwZW9mIG1ldGEub25EcmFnSGFuZGxlRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBtZXRhLm9uRHJhZ0hhbmRsZURvdWJsZUNsaWNrKHsgcm93SWR4OiBfdGhpcy5wcm9wcy5yb3dJZHgsIGlkeDogX3RoaXMucHJvcHMuaWR4LCByb3dEYXRhOiBfdGhpcy5nZXRSb3dEYXRhKCksIGU6IGUgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLm9uRHJhZ092ZXIgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB9LCBfdGhpcy5nZXRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHN0eWxlID0ge1xuXHQgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQgICAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy5jb2x1bW4ud2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiBfdGhpcy5wcm9wcy5oZWlnaHQsXG5cdCAgICAgICAgbGVmdDogX3RoaXMucHJvcHMuY29sdW1uLmxlZnRcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIHN0eWxlO1xuXHQgICAgfSwgX3RoaXMuZ2V0Rm9ybWF0dGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgY29sID0gX3RoaXMucHJvcHMuY29sdW1uO1xuXHQgICAgICBpZiAoX3RoaXMuaXNBY3RpdmUoKSkge1xuXHQgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRhaW5lciwgeyByb3dEYXRhOiBfdGhpcy5nZXRSb3dEYXRhKCksIHJvd0lkeDogX3RoaXMucHJvcHMucm93SWR4LCB2YWx1ZTogX3RoaXMucHJvcHMudmFsdWUsIGlkeDogX3RoaXMucHJvcHMuaWR4LCBjZWxsTWV0YURhdGE6IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YSwgY29sdW1uOiBjb2wsIGhlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0IH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmNvbHVtbi5mb3JtYXR0ZXI7XG5cdCAgICB9LCBfdGhpcy5nZXRSb3dEYXRhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF90aGlzLnByb3BzO1xuXG5cdCAgICAgIHJldHVybiBwcm9wcy5yb3dEYXRhLnRvSlNPTiA/IHByb3BzLnJvd0RhdGEudG9KU09OKCkgOiBwcm9wcy5yb3dEYXRhO1xuXHQgICAgfSwgX3RoaXMuZ2V0Rm9ybWF0dGVyRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBjb252ZW50aW9uIGJhc2VkIG1ldGhvZCB0byBnZXQgY29ycmVzcG9uZGluZyBJZCBvciBOYW1lIG9mIGFueSBOYW1lIG9yIElkIHByb3BlcnR5XG5cdCAgICAgIGlmICh0eXBlb2YgX3RoaXMucHJvcHMuY29sdW1uLmdldFJvd01ldGFEYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmNvbHVtbi5nZXRSb3dNZXRhRGF0YShfdGhpcy5nZXRSb3dEYXRhKCksIF90aGlzLnByb3BzLmNvbHVtbik7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLmdldENlbGxDbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGNsYXNzTmFtZSA9IGpvaW5DbGFzc2VzKF90aGlzLnByb3BzLmNvbHVtbi5jZWxsQ2xhc3MsICdyZWFjdC1ncmlkLUNlbGwnLCBfdGhpcy5wcm9wcy5jbGFzc05hbWUsIF90aGlzLnByb3BzLmNvbHVtbi5sb2NrZWQgPyAncmVhY3QtZ3JpZC1DZWxsLS1sb2NrZWQnIDogbnVsbCk7XG5cdCAgICAgIHZhciBleHRyYUNsYXNzZXMgPSBqb2luQ2xhc3Nlcyh7XG5cdCAgICAgICAgJ3Jvdy1zZWxlY3RlZCc6IF90aGlzLnByb3BzLmlzUm93U2VsZWN0ZWQsXG5cdCAgICAgICAgZWRpdGluZzogX3RoaXMuaXNBY3RpdmUoKSxcblx0ICAgICAgICBjb3BpZWQ6IF90aGlzLmlzQ29waWVkKCkgfHwgX3RoaXMud2FzRHJhZ2dlZE92ZXIoKSB8fCBfdGhpcy5pc0RyYWdnZWRPdmVyVXB3YXJkcygpIHx8IF90aGlzLmlzRHJhZ2dlZE92ZXJEb3dud2FyZHMoKSxcblx0ICAgICAgICAnaXMtZHJhZ2dlZC1vdmVyLXVwJzogX3RoaXMuaXNEcmFnZ2VkT3ZlclVwd2FyZHMoKSxcblx0ICAgICAgICAnaXMtZHJhZ2dlZC1vdmVyLWRvd24nOiBfdGhpcy5pc0RyYWdnZWRPdmVyRG93bndhcmRzKCksXG5cdCAgICAgICAgJ3dhcy1kcmFnZ2VkLW92ZXInOiBfdGhpcy53YXNEcmFnZ2VkT3ZlcigpLFxuXHQgICAgICAgICdjZWxsLXRvb2x0aXAnOiBfdGhpcy5wcm9wcy50b29sdGlwID8gdHJ1ZSA6IGZhbHNlLFxuXHQgICAgICAgICdyZGctY2hpbGQtY2VsbCc6IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zICYmIF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zLnN1YlJvd0RldGFpbHMgJiYgX3RoaXMucHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMudHJlZURlcHRoID4gMCxcblx0ICAgICAgICAnbGFzdC1jb2x1bW4nOiBfdGhpcy5wcm9wcy5jb2x1bW4uaXNMYXN0Q29sdW1uXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gam9pbkNsYXNzZXMoY2xhc3NOYW1lLCBleHRyYUNsYXNzZXMpO1xuXHQgICAgfSwgX3RoaXMuZ2V0VXBkYXRlQ2VsbENsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gX3RoaXMucHJvcHMuY29sdW1uLmdldFVwZGF0ZUNlbGxDbGFzcyA/IF90aGlzLnByb3BzLmNvbHVtbi5nZXRVcGRhdGVDZWxsQ2xhc3MoX3RoaXMucHJvcHMuc2VsZWN0ZWRDb2x1bW4sIF90aGlzLnByb3BzLmNvbHVtbiwgX3RoaXMuc3RhdGUuaXNDZWxsVmFsdWVDaGFuZ2luZykgOiAnJztcblx0ICAgIH0sIF90aGlzLmlzQ29sdW1uU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG1ldGEuc2VsZWN0ZWQgJiYgbWV0YS5zZWxlY3RlZC5pZHggPT09IF90aGlzLnByb3BzLmlkeDtcblx0ICAgIH0sIF90aGlzLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG1ldGEuc2VsZWN0ZWQgJiYgbWV0YS5zZWxlY3RlZC5yb3dJZHggPT09IF90aGlzLnByb3BzLnJvd0lkeCAmJiBtZXRhLnNlbGVjdGVkLmlkeCA9PT0gX3RoaXMucHJvcHMuaWR4O1xuXHQgICAgfSwgX3RoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBtZXRhID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhO1xuXHQgICAgICBpZiAobWV0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBfdGhpcy5pc1NlbGVjdGVkKCkgJiYgbWV0YS5zZWxlY3RlZC5hY3RpdmUgPT09IHRydWU7XG5cdCAgICB9LCBfdGhpcy5pc0NlbGxTZWxlY3Rpb25DaGFuZ2luZyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcblx0ICAgICAgdmFyIG1ldGEgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGE7XG5cdCAgICAgIGlmIChtZXRhID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG5leHRTZWxlY3RlZCA9IG5leHRQcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQ7XG5cdCAgICAgIGlmIChtZXRhLnNlbGVjdGVkICYmIG5leHRTZWxlY3RlZCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5pZHggPT09IG5leHRTZWxlY3RlZC5pZHggfHwgX3RoaXMucHJvcHMuaWR4ID09PSBtZXRhLnNlbGVjdGVkLmlkeDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSwgX3RoaXMuaXNDZWxsU2VsZWN0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG1ldGEgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGE7XG5cdCAgICAgIGlmIChtZXRhID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1ldGEuZW5hYmxlQ2VsbFNlbGVjdDtcblx0ICAgIH0sIF90aGlzLmhhc0NoYW5nZWREZXBlbmRlbnRWYWx1ZXMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG5cdCAgICAgIHZhciBjdXJyZW50Q29sdW1uID0gX3RoaXMucHJvcHMuY29sdW1uO1xuXHQgICAgICB2YXIgaGFzQ2hhbmdlZERlcGVuZGVudFZhbHVlcyA9IGZhbHNlO1xuXG5cdCAgICAgIGlmIChjdXJyZW50Q29sdW1uLmdldFJvd01ldGFEYXRhKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRSb3dNZXRhRGF0YSA9IGN1cnJlbnRDb2x1bW4uZ2V0Um93TWV0YURhdGEoX3RoaXMuZ2V0Um93RGF0YSgpLCBjdXJyZW50Q29sdW1uKTtcblx0ICAgICAgICB2YXIgbmV4dENvbHVtbiA9IG5leHRQcm9wcy5jb2x1bW47XG5cdCAgICAgICAgdmFyIG5leHRSb3dNZXRhRGF0YSA9IG5leHRDb2x1bW4uZ2V0Um93TWV0YURhdGEoX3RoaXMuZ2V0Um93RGF0YShuZXh0UHJvcHMpLCBuZXh0Q29sdW1uKTtcblxuXHQgICAgICAgIGhhc0NoYW5nZWREZXBlbmRlbnRWYWx1ZXMgPSAhX3VuZGVyc2NvcmUyWydkZWZhdWx0J10uaXNFcXVhbChjdXJyZW50Um93TWV0YURhdGEsIG5leHRSb3dNZXRhRGF0YSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gaGFzQ2hhbmdlZERlcGVuZGVudFZhbHVlcztcblx0ICAgIH0sIF90aGlzLmFwcGx5VXBkYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciB1cGRhdGVDZWxsQ2xhc3MgPSBfdGhpcy5nZXRVcGRhdGVDZWxsQ2xhc3MoKTtcblx0ICAgICAgLy8gLT4gcmVtb3ZpbmcgdGhlIGNsYXNzXG5cdCAgICAgIGlmICh1cGRhdGVDZWxsQ2xhc3MgIT0gbnVsbCAmJiB1cGRhdGVDZWxsQ2xhc3MgIT09ICcnKSB7XG5cdCAgICAgICAgdmFyIGNlbGxET01Ob2RlID0gX3RoaXMubm9kZTtcblx0ICAgICAgICBpZiAoY2VsbERPTU5vZGUuY2xhc3NMaXN0KSB7XG5cdCAgICAgICAgICBjZWxsRE9NTm9kZS5jbGFzc0xpc3QucmVtb3ZlKHVwZGF0ZUNlbGxDbGFzcyk7XG5cdCAgICAgICAgICAvLyAtPiBhbmQgcmUtYWRkaW5nIHRoZSBjbGFzc1xuXHQgICAgICAgICAgY2VsbERPTU5vZGUuY2xhc3NMaXN0LmFkZCh1cGRhdGVDZWxsQ2xhc3MpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY2VsbERPTU5vZGUuY2xhc3NOYW1lLmluZGV4T2YodXBkYXRlQ2VsbENsYXNzKSA9PT0gLTEpIHtcblx0ICAgICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgY2xhc3NMaXN0LCBub3IgKEkgdGhpbmspIGFsdGVyaW5nIGVsZW1lbnQuY2xhc3NOYW1lXG5cdCAgICAgICAgICAvLyB3aXRob3V0IHJlcGxhY2luZyBpdCB3aG9sZXNhbGUuXG5cdCAgICAgICAgICBjZWxsRE9NTm9kZS5jbGFzc05hbWUgPSBjZWxsRE9NTm9kZS5jbGFzc05hbWUgKyAnICcgKyB1cGRhdGVDZWxsQ2xhc3M7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcblx0ICAgICAgdmFyIG5vZGUgPSBfdGhpcy5ub2RlO1xuXHQgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgIHZhciB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIHNjcm9sbExlZnQgKyAncHgsIDBweCwgMHB4KSc7XG5cdCAgICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdCAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLnJlbW92ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG5vZGUgPSBfdGhpcy5ub2RlO1xuXHQgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gbnVsbDtcblx0ICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLmlzQ29waWVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgY29waWVkID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmNvcGllZDtcblx0ICAgICAgcmV0dXJuIGNvcGllZCAmJiBjb3BpZWQucm93SWR4ID09PSBfdGhpcy5wcm9wcy5yb3dJZHggJiYgY29waWVkLmlkeCA9PT0gX3RoaXMucHJvcHMuaWR4O1xuXHQgICAgfSwgX3RoaXMuaXNEcmFnZ2VkT3ZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGRyYWdnZWQgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuZHJhZ2dlZDtcblx0ICAgICAgcmV0dXJuIGRyYWdnZWQgJiYgZHJhZ2dlZC5vdmVyUm93SWR4ID09PSBfdGhpcy5wcm9wcy5yb3dJZHggJiYgZHJhZ2dlZC5pZHggPT09IF90aGlzLnByb3BzLmlkeDtcblx0ICAgIH0sIF90aGlzLndhc0RyYWdnZWRPdmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZHJhZ2dlZCA9IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5kcmFnZ2VkO1xuXHQgICAgICByZXR1cm4gZHJhZ2dlZCAmJiAoZHJhZ2dlZC5vdmVyUm93SWR4IDwgX3RoaXMucHJvcHMucm93SWR4ICYmIF90aGlzLnByb3BzLnJvd0lkeCA8IGRyYWdnZWQucm93SWR4IHx8IGRyYWdnZWQub3ZlclJvd0lkeCA+IF90aGlzLnByb3BzLnJvd0lkeCAmJiBfdGhpcy5wcm9wcy5yb3dJZHggPiBkcmFnZ2VkLnJvd0lkeCkgJiYgZHJhZ2dlZC5pZHggPT09IF90aGlzLnByb3BzLmlkeDtcblx0ICAgIH0sIF90aGlzLmlzRHJhZ2dlZENlbGxDaGFuZ2luZyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcblx0ICAgICAgdmFyIGlzQ2hhbmdpbmcgPSB2b2lkIDA7XG5cdCAgICAgIHZhciBkcmFnZ2VkID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmRyYWdnZWQ7XG5cdCAgICAgIHZhciBuZXh0RHJhZ2dlZCA9IG5leHRQcm9wcy5jZWxsTWV0YURhdGEuZHJhZ2dlZDtcblx0ICAgICAgaWYgKGRyYWdnZWQpIHtcblx0ICAgICAgICBpc0NoYW5naW5nID0gbmV4dERyYWdnZWQgJiYgX3RoaXMucHJvcHMuaWR4ID09PSBuZXh0RHJhZ2dlZC5pZHggfHwgZHJhZ2dlZCAmJiBfdGhpcy5wcm9wcy5pZHggPT09IGRyYWdnZWQuaWR4O1xuXHQgICAgICAgIHJldHVybiBpc0NoYW5naW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSwgX3RoaXMuaXNDb3B5Q2VsbENoYW5naW5nID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuXHQgICAgICB2YXIgaXNDaGFuZ2luZyA9IHZvaWQgMDtcblx0ICAgICAgdmFyIGNvcGllZCA9IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5jb3BpZWQ7XG5cdCAgICAgIHZhciBuZXh0Q29waWVkID0gbmV4dFByb3BzLmNlbGxNZXRhRGF0YS5jb3BpZWQ7XG5cdCAgICAgIGlmIChjb3BpZWQpIHtcblx0ICAgICAgICBpc0NoYW5naW5nID0gbmV4dENvcGllZCAmJiBfdGhpcy5wcm9wcy5pZHggPT09IG5leHRDb3BpZWQuaWR4IHx8IGNvcGllZCAmJiBfdGhpcy5wcm9wcy5pZHggPT09IGNvcGllZC5pZHg7XG5cdCAgICAgICAgcmV0dXJuIGlzQ2hhbmdpbmc7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSwgX3RoaXMuaXNEcmFnZ2VkT3ZlclVwd2FyZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBkcmFnZ2VkID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmRyYWdnZWQ7XG5cdCAgICAgIHJldHVybiAhX3RoaXMuaXNTZWxlY3RlZCgpICYmIF90aGlzLmlzRHJhZ2dlZE92ZXIoKSAmJiBfdGhpcy5wcm9wcy5yb3dJZHggPCBkcmFnZ2VkLnJvd0lkeDtcblx0ICAgIH0sIF90aGlzLmlzRHJhZ2dlZE92ZXJEb3dud2FyZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBkcmFnZ2VkID0gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmRyYWdnZWQ7XG5cdCAgICAgIHJldHVybiAhX3RoaXMuaXNTZWxlY3RlZCgpICYmIF90aGlzLmlzRHJhZ2dlZE92ZXIoKSAmJiBfdGhpcy5wcm9wcy5yb3dJZHggPiBkcmFnZ2VkLnJvd0lkeDtcblx0ICAgIH0sIF90aGlzLmlzRm9jdXNlZE9uQm9keSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lICYmIHR5cGVvZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdib2R5Jztcblx0ICAgIH0sIF90aGlzLmlzRm9jdXNlZE9uQ2VsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZigncmVhY3QtZ3JpZC1DZWxsJykgIT09IC0xO1xuXHQgICAgfSwgX3RoaXMuY2hlY2tGb2N1cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzLmlzU2VsZWN0ZWQoKSAmJiAhX3RoaXMuaXNBY3RpdmUoKSkge1xuXHQgICAgICAgIGlmIChfdGhpcy5wcm9wcy5pc1Njcm9sbGluZyAmJiAhX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmlzU2Nyb2xsaW5nVmVydGljYWxseVdpdGhLZXlib2FyZCAmJiAhX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmlzU2Nyb2xsaW5nSG9yaXpvbnRhbGx5V2l0aEtleWJvYXJkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIElmIHRoZSBlbmFibGVDZWxsQXV0b0ZvY3VzIGlzIHNldCBpbiB0aGUgUmVhY3REYXRhR3JpZCBwcm9wcywgaXQgd2lsbCBhbGxvdyB0aGUgY2VsbCB0byB0YWtlIGZvY3VzIHdoZW4gdGhlIGJyb3dzZXIgaXMgZm9jdXNlZCBvbiB0aGUgYm9keS5cblx0ICAgICAgICAvLyBPdGhlcndpc2UsIG9ubHkgZm9jdXMgdG8gdGhlIGN1cnJlbnQgY2VsbCBpZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBub2RlIGluIHRoZSBkb2N1bWVudCBpcyB3aXRoaW4gdGhlIGRhdGEgZ3JpZC5cblx0ICAgICAgICAvLyBNZWFuaW5nIGZvY3VzIHNob3VsZCBub3QgYmUgc3RvbGVuIGZyb20gZWxlbWVudHMgdGhhdCB0aGUgZ3JpZCBkb2VzbnQgY29udHJvbC5cblx0ICAgICAgICB2YXIgY2VsbEF1dG9Gb2N1c0VuYWJsZWQgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEgJiYgX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmVuYWJsZUNlbGxBdXRvRm9jdXM7XG5cdCAgICAgICAgdmFyIGRhdGFHcmlkRE9NTm9kZSA9IF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YSAmJiBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuZ2V0RGF0YUdyaWRET01Ob2RlID8gX3RoaXMucHJvcHMuY2VsbE1ldGFEYXRhLmdldERhdGFHcmlkRE9NTm9kZSgpIDogbnVsbDtcblx0ICAgICAgICBpZiAoX3RoaXMuaXNGb2N1c2VkT25DZWxsKCkgfHwgY2VsbEF1dG9Gb2N1c0VuYWJsZWQgJiYgX3RoaXMuaXNGb2N1c2VkT25Cb2R5KCkgfHwgZGF0YUdyaWRET01Ob2RlICYmIGRhdGFHcmlkRE9NTm9kZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuXHQgICAgICAgICAgdmFyIGNlbGxET01Ob2RlID0gX3RoaXMubm9kZTtcblx0ICAgICAgICAgIGlmIChjZWxsRE9NTm9kZSkge1xuXHQgICAgICAgICAgICBjZWxsRE9NTm9kZS5mb2N1cygpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMuY2FuRWRpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmNvbHVtbi5lZGl0b3IgIT0gbnVsbCB8fCBfdGhpcy5wcm9wcy5jb2x1bW4uZWRpdGFibGU7XG5cdCAgICB9LCBfdGhpcy5jYW5FeHBhbmQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5leHBhbmRhYmxlT3B0aW9ucyAmJiBfdGhpcy5wcm9wcy5leHBhbmRhYmxlT3B0aW9ucy5jYW5FeHBhbmQ7XG5cdCAgICB9LCBfdGhpcy5jcmVhdGVDb2x1bUV2ZW50Q2FsbEJhY2sgPSBmdW5jdGlvbiAob25Db2x1bW5FdmVudCwgaW5mbykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBvbkNvbHVtbkV2ZW50KGUsIGluZm8pO1xuXHQgICAgICB9O1xuXHQgICAgfSwgX3RoaXMuY3JlYXRlQ2VsbEV2ZW50Q2FsbEJhY2sgPSBmdW5jdGlvbiAoZ3JpZEV2ZW50LCBjb2x1bW5FdmVudCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBncmlkRXZlbnQoZSk7XG5cdCAgICAgICAgY29sdW1uRXZlbnQoZSk7XG5cdCAgICAgIH07XG5cdCAgICB9LCBfdGhpcy5jcmVhdGVFdmVudERUTyA9IGZ1bmN0aW9uIChncmlkRXZlbnRzLCBjb2x1bW5FdmVudHMsIG9uQ29sdW1uRXZlbnQpIHtcblx0ICAgICAgdmFyIGFsbEV2ZW50cyA9IE9iamVjdC5hc3NpZ24oe30sIGdyaWRFdmVudHMpO1xuXG5cdCAgICAgIGZvciAodmFyIGV2ZW50S2V5IGluIGNvbHVtbkV2ZW50cykge1xuXHQgICAgICAgIGlmIChjb2x1bW5FdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnRLZXkpKSB7XG5cdCAgICAgICAgICB2YXIgZXZlbnQgPSBjb2x1bW5FdmVudHNbZXZlbnRdO1xuXHQgICAgICAgICAgdmFyIGV2ZW50SW5mbyA9IHsgaWR4OiBfdGhpcy5wcm9wcy5pZHgsIHJvd0lkeDogX3RoaXMucHJvcHMucm93SWR4LCByb3dJZDogX3RoaXMucHJvcHMucm93RGF0YVtfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEucm93S2V5XSwgbmFtZTogZXZlbnRLZXkgfTtcblx0ICAgICAgICAgIHZhciBldmVudENhbGxiYWNrID0gX3RoaXMuY3JlYXRlQ29sdW1FdmVudENhbGxCYWNrKG9uQ29sdW1uRXZlbnQsIGV2ZW50SW5mbyk7XG5cblx0ICAgICAgICAgIGlmIChhbGxFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnRLZXkpKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50RXZlbnQgPSBhbGxFdmVudHNbZXZlbnRLZXldO1xuXHQgICAgICAgICAgICBhbGxFdmVudHNbZXZlbnRLZXldID0gX3RoaXMuY3JlYXRlQ2VsbEV2ZW50Q2FsbEJhY2soY3VycmVudEV2ZW50LCBldmVudENhbGxiYWNrKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGFsbEV2ZW50c1tldmVudEtleV0gPSBldmVudENhbGxiYWNrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBhbGxFdmVudHM7XG5cdCAgICB9LCBfdGhpcy5nZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBjb2x1bW5FdmVudHMgPSBfdGhpcy5wcm9wcy5jb2x1bW4gPyBPYmplY3QuYXNzaWduKHt9LCBfdGhpcy5wcm9wcy5jb2x1bW4uZXZlbnRzKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgdmFyIG9uQ29sdW1uRXZlbnQgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEgPyBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEub25Db2x1bW5FdmVudCA6IHVuZGVmaW5lZDtcblx0ICAgICAgdmFyIGdyaWRFdmVudHMgPSB7XG5cdCAgICAgICAgb25DbGljazogX3RoaXMub25DZWxsQ2xpY2ssXG5cdCAgICAgICAgb25Gb2N1czogX3RoaXMub25DZWxsRm9jdXMsXG5cdCAgICAgICAgb25Eb3VibGVDbGljazogX3RoaXMub25DZWxsRG91YmxlQ2xpY2ssXG5cdCAgICAgICAgb25Db250ZXh0TWVudTogX3RoaXMub25DZWxsQ29udGV4dE1lbnUsXG5cdCAgICAgICAgb25EcmFnT3ZlcjogX3RoaXMub25EcmFnT3ZlclxuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmICghY29sdW1uRXZlbnRzIHx8ICFvbkNvbHVtbkV2ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGdyaWRFdmVudHM7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlRXZlbnREVE8oZ3JpZEV2ZW50cywgY29sdW1uRXZlbnRzLCBvbkNvbHVtbkV2ZW50KTtcblx0ICAgIH0sIF90aGlzLmdldEtub3duRGl2UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBjcmVhdGVPYmplY3RXaXRoUHJvcGVydGllcyhfdGhpcy5wcm9wcywga25vd25EaXZQcm9wZXJ0eUtleXMpO1xuXHQgICAgfSwgX3RoaXMucmVuZGVyQ2VsbENvbnRlbnQgPSBmdW5jdGlvbiAocHJvcHMpIHtcblx0ICAgICAgdmFyIENlbGxDb250ZW50ID0gdm9pZCAwO1xuXHQgICAgICB2YXIgRm9ybWF0dGVyID0gX3RoaXMuZ2V0Rm9ybWF0dGVyKCk7XG5cdCAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChGb3JtYXR0ZXIpKSB7XG5cdCAgICAgICAgcHJvcHMuZGVwZW5kZW50VmFsdWVzID0gX3RoaXMuZ2V0Rm9ybWF0dGVyRGVwZW5kZW5jaWVzKCk7XG5cdCAgICAgICAgQ2VsbENvbnRlbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoRm9ybWF0dGVyLCBwcm9wcyk7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihGb3JtYXR0ZXIpKSB7XG5cdCAgICAgICAgQ2VsbENvbnRlbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1hdHRlciwgeyB2YWx1ZTogX3RoaXMucHJvcHMudmFsdWUsIGRlcGVuZGVudFZhbHVlczogX3RoaXMuZ2V0Rm9ybWF0dGVyRGVwZW5kZW5jaWVzKCkgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgQ2VsbENvbnRlbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFNpbXBsZUNlbGxGb3JtYXR0ZXIsIHsgdmFsdWU6IF90aGlzLnByb3BzLnZhbHVlIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpc0V4cGFuZENlbGwgPSBfdGhpcy5wcm9wcy5leHBhbmRhYmxlT3B0aW9ucyA/IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zLmZpZWxkID09PSBfdGhpcy5wcm9wcy5jb2x1bW4ua2V5IDogZmFsc2U7XG5cdCAgICAgIHZhciB0cmVlRGVwdGggPSBfdGhpcy5wcm9wcy5leHBhbmRhYmxlT3B0aW9ucyA/IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zLnRyZWVEZXB0aCA6IDA7XG5cdCAgICAgIHZhciBtYXJnaW5MZWZ0ID0gX3RoaXMucHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMgJiYgaXNFeHBhbmRDZWxsID8gX3RoaXMucHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMudHJlZURlcHRoICogMzAgOiAwO1xuXHQgICAgICB2YXIgY2VsbEV4cGFuZGVyID0gdm9pZCAwO1xuXHQgICAgICB2YXIgY2VsbERlbGV0ZXIgPSB2b2lkIDA7XG5cdCAgICAgIGlmIChfdGhpcy5jYW5FeHBhbmQoKSkge1xuXHQgICAgICAgIGNlbGxFeHBhbmRlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoX0NlbGxFeHBhbmQyWydkZWZhdWx0J10sIHsgZXhwYW5kYWJsZU9wdGlvbnM6IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zLCBvbkNlbGxFeHBhbmQ6IF90aGlzLm9uQ2VsbEV4cGFuZCB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpc0RlbGV0ZVN1YlJvd0VuYWJsZWQgPSBfdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEub25EZWxldGVTdWJSb3cgPyB0cnVlIDogZmFsc2U7XG5cblx0ICAgICAgaWYgKHRyZWVEZXB0aCA+IDAgJiYgaXNFeHBhbmRDZWxsKSB7XG5cdCAgICAgICAgY2VsbERlbGV0ZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KF9DaGlsZFJvd0RlbGV0ZUJ1dHRvbjJbJ2RlZmF1bHQnXSwgeyB0cmVlRGVwdGg6IHRyZWVEZXB0aCwgY2VsbEhlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0LCBzaWJsaW5nSW5kZXg6IF90aGlzLnByb3BzLmV4cGFuZGFibGVPcHRpb25zLnN1YlJvd0RldGFpbHMuc2libGluZ0luZGV4LCBudW1iZXJTaWJsaW5nczogX3RoaXMucHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMuc3ViUm93RGV0YWlscy5udW1iZXJTaWJsaW5ncywgb25EZWxldGVTdWJSb3c6IF90aGlzLm9uRGVsZXRlU3ViUm93LCBpc0RlbGV0ZVN1YlJvd0VuYWJsZWQ6IGlzRGVsZXRlU3ViUm93RW5hYmxlZCB9KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAnZGl2Jyxcblx0ICAgICAgICB7IGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtQ2VsbF9fdmFsdWUnIH0sXG5cdCAgICAgICAgY2VsbERlbGV0ZXIsXG5cdCAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAgICdkaXYnLFxuXHQgICAgICAgICAgeyBzdHlsZTogeyBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0IH0gfSxcblx0ICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICAgICAgICdzcGFuJyxcblx0ICAgICAgICAgICAgbnVsbCxcblx0ICAgICAgICAgICAgQ2VsbENvbnRlbnRcblx0ICAgICAgICAgICksXG5cdCAgICAgICAgICAnICcsXG5cdCAgICAgICAgICBfdGhpcy5wcm9wcy5jZWxsQ29udHJvbHMsXG5cdCAgICAgICAgICAnICcsXG5cdCAgICAgICAgICBjZWxsRXhwYW5kZXJcblx0ICAgICAgICApXG5cdCAgICAgICk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBDZWxsLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHQgICAgdGhpcy5jaGVja0ZvY3VzKCk7XG5cdCAgfTtcblxuXHQgIENlbGwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXHQgICAgdGhpcy5zZXRTdGF0ZSh7XG5cdCAgICAgIGlzQ2VsbFZhbHVlQ2hhbmdpbmc6IHRoaXMucHJvcHMuaXNDZWxsVmFsdWVDaGFuZ2luZyh0aGlzLnByb3BzLnZhbHVlLCBuZXh0UHJvcHMudmFsdWUpLFxuXHQgICAgICBpc0xvY2tDaGFuZ2luZzogdGhpcy5wcm9wcy5jb2x1bW4ubG9ja2VkICE9PSBuZXh0UHJvcHMuY29sdW1uLmxvY2tlZFxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIENlbGwucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcblx0ICAgIHRoaXMuY2hlY2tGb2N1cygpO1xuXHQgICAgdmFyIGRyYWdnZWQgPSB0aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5kcmFnZ2VkO1xuXHQgICAgaWYgKGRyYWdnZWQgJiYgZHJhZ2dlZC5jb21wbGV0ZSA9PT0gdHJ1ZSkge1xuXHQgICAgICB0aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5oYW5kbGVUZXJtaW5hdGVEcmFnKCk7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5zdGF0ZS5pc0NlbGxWYWx1ZUNoYW5naW5nICYmIHRoaXMucHJvcHMuc2VsZWN0ZWRDb2x1bW4gIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLmFwcGx5VXBkYXRlQ2xhc3MoKTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnN0YXRlLmlzTG9ja0NoYW5naW5nICYmICF0aGlzLnByb3BzLmNvbHVtbi5sb2NrZWQpIHtcblx0ICAgICAgdGhpcy5yZW1vdmVTY3JvbGwoKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgQ2VsbC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuXHQgICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMuY29sdW1uLndpZHRoICE9PSBuZXh0UHJvcHMuY29sdW1uLndpZHRoIHx8IHRoaXMucHJvcHMuY29sdW1uLmxlZnQgIT09IG5leHRQcm9wcy5jb2x1bW4ubGVmdCB8fCB0aGlzLnByb3BzLmNvbHVtbi5jZWxsQ2xhc3MgIT09IG5leHRQcm9wcy5jb2x1bW4uY2VsbENsYXNzIHx8IHRoaXMucHJvcHMuaGVpZ2h0ICE9PSBuZXh0UHJvcHMuaGVpZ2h0IHx8IHRoaXMucHJvcHMucm93SWR4ICE9PSBuZXh0UHJvcHMucm93SWR4IHx8IHRoaXMuaXNDZWxsU2VsZWN0aW9uQ2hhbmdpbmcobmV4dFByb3BzKSB8fCB0aGlzLmlzRHJhZ2dlZENlbGxDaGFuZ2luZyhuZXh0UHJvcHMpIHx8IHRoaXMuaXNDb3B5Q2VsbENoYW5naW5nKG5leHRQcm9wcykgfHwgdGhpcy5wcm9wcy5pc1Jvd1NlbGVjdGVkICE9PSBuZXh0UHJvcHMuaXNSb3dTZWxlY3RlZCB8fCB0aGlzLmlzU2VsZWN0ZWQoKSB8fCB0aGlzLnByb3BzLmlzQ2VsbFZhbHVlQ2hhbmdpbmcodGhpcy5wcm9wcy52YWx1ZSwgbmV4dFByb3BzLnZhbHVlKSB8fCB0aGlzLnByb3BzLmZvcmNlVXBkYXRlID09PSB0cnVlIHx8IHRoaXMucHJvcHMuY2xhc3NOYW1lICE9PSBuZXh0UHJvcHMuY2xhc3NOYW1lIHx8IHRoaXMucHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMgIT09IG5leHRQcm9wcy5leHBhbmRhYmxlT3B0aW9ucyB8fCB0aGlzLmhhc0NoYW5nZWREZXBlbmRlbnRWYWx1ZXMobmV4dFByb3BzKSB8fCB0aGlzLnByb3BzLmNvbHVtbi5sb2NrZWQgIT09IG5leHRQcm9wcy5jb2x1bW4ubG9ja2VkO1xuXHQgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcblx0ICB9O1xuXG5cdCAgQ2VsbC5wcm90b3R5cGUuZ2V0Q2VsbEFjdGlvbnMgPSBmdW5jdGlvbiBnZXRDZWxsQWN0aW9ucygpIHtcblx0ICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuXHQgICAgICAgIGNlbGxNZXRhRGF0YSA9IF9wcm9wcy5jZWxsTWV0YURhdGEsXG5cdCAgICAgICAgY29sdW1uID0gX3Byb3BzLmNvbHVtbixcblx0ICAgICAgICByb3dEYXRhID0gX3Byb3BzLnJvd0RhdGE7XG5cblx0ICAgIGlmIChjZWxsTWV0YURhdGEgJiYgY2VsbE1ldGFEYXRhLmdldENlbGxBY3Rpb25zKSB7XG5cdCAgICAgIHZhciBjZWxsQWN0aW9ucyA9IGNlbGxNZXRhRGF0YS5nZXRDZWxsQWN0aW9ucyhjb2x1bW4sIHJvd0RhdGEpO1xuXHQgICAgICBpZiAoY2VsbEFjdGlvbnMgJiYgY2VsbEFjdGlvbnMubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIGNlbGxBY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uLCBpbmRleCkge1xuXHQgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX0NlbGxBY3Rpb24yWydkZWZhdWx0J10sIHsga2V5OiBpbmRleCwgYWN0aW9uOiBhY3Rpb24sIGlzRmlyc3Q6IGluZGV4ID09PSAwIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfTtcblxuXHQgIENlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICBpZiAodGhpcy5wcm9wcy5jb2x1bW4uaGlkZGVuKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG5cblx0ICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxDbGFzcygpO1xuXG5cdCAgICB2YXIgY2VsbEFjdGlvbnMgPSB0aGlzLmdldENlbGxBY3Rpb25zKCk7XG5cblx0ICAgIHZhciBjZWxsQ29udGVudCA9IHRoaXMucHJvcHMuY2hpbGRyZW4gfHwgdGhpcy5yZW5kZXJDZWxsQ29udGVudCh7XG5cdCAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuXHQgICAgICBjb2x1bW46IHRoaXMucHJvcHMuY29sdW1uLFxuXHQgICAgICByb3dJZHg6IHRoaXMucHJvcHMucm93SWR4LFxuXHQgICAgICBpc0V4cGFuZGVkOiB0aGlzLnByb3BzLmlzRXhwYW5kZWRcblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgZHJhZ0hhbmRsZSA9ICF0aGlzLmlzQWN0aXZlKCkgJiYgQ29sdW1uVXRpbHMuY2FuRWRpdCh0aGlzLnByb3BzLmNvbHVtbiwgdGhpcy5wcm9wcy5yb3dEYXRhLCB0aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5lbmFibGVDZWxsU2VsZWN0KSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IGNsYXNzTmFtZTogJ2RyYWctaGFuZGxlJywgZHJhZ2dhYmxlOiAndHJ1ZScsIG9uRG91YmxlQ2xpY2s6IHRoaXMub25EcmFnSGFuZGxlRG91YmxlQ2xpY2sgfSxcblx0ICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfSlcblx0ICAgICkgOiBudWxsO1xuXHQgICAgdmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdCAgICB2YXIgdG9vbHRpcCA9IHRoaXMucHJvcHMudG9vbHRpcCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdzcGFuJyxcblx0ICAgICAgeyBjbGFzc05hbWU6ICdjZWxsLXRvb2x0aXAtdGV4dCcgfSxcblx0ICAgICAgdGhpcy5wcm9wcy50b29sdGlwXG5cdCAgICApIDogbnVsbDtcblxuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICBfZXh0ZW5kcyh7fSwgdGhpcy5nZXRLbm93bkRpdlByb3BzKCksIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHN0eWxlOiBzdHlsZSB9LCBldmVudHMsIHsgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgX3RoaXMyLm5vZGUgPSBub2RlO1xuXHQgICAgICAgIH0gfSksXG5cdCAgICAgIGNlbGxBY3Rpb25zLFxuXHQgICAgICBjZWxsQ29udGVudCxcblx0ICAgICAgZHJhZ0hhbmRsZSxcblx0ICAgICAgdG9vbHRpcFxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENlbGw7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRDZWxsLnByb3BUeXBlcyA9IHtcblx0ICByb3dJZHg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgaWR4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIHNlbGVjdGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgIGlkeDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZFxuXHQgIH0pLFxuXHQgIHNlbGVjdGVkQ29sdW1uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHRhYkluZGV4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBjb2x1bW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoRXhjZWxDb2x1bW4pLmlzUmVxdWlyZWQsXG5cdCAgdmFsdWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xdKSxcblx0ICBpc0V4cGFuZGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgaXNSb3dTZWxlY3RlZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgIGNlbGxNZXRhRGF0YTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZShDZWxsTWV0YURhdGFTaGFwZSkuaXNSZXF1aXJlZCxcblx0ICBoYW5kbGVEcmFnU3RhcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIGNlbGxDb250cm9sczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hbnksXG5cdCAgcm93RGF0YTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QuaXNSZXF1aXJlZCxcblx0ICBmb3JjZVVwZGF0ZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgIGV4cGFuZGFibGVPcHRpb25zOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdC5pc1JlcXVpcmVkLFxuXHQgIGlzU2Nyb2xsaW5nOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wuaXNSZXF1aXJlZCxcblx0ICB0b29sdGlwOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBpc0NlbGxWYWx1ZUNoYW5naW5nOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgY2hpbGRyZW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5T2YoX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ub2RlKSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ub2RlXSlcblx0fTtcblx0Q2VsbC5kZWZhdWx0UHJvcHMgPSB7XG5cdCAgdGFiSW5kZXg6IDAsXG5cdCAgaXNFeHBhbmRlZDogZmFsc2UsXG5cdCAgdmFsdWU6ICcnLFxuXHQgIGlzQ2VsbFZhbHVlQ2hhbmdpbmc6IGZ1bmN0aW9uIGlzQ2VsbFZhbHVlQ2hhbmdpbmcodmFsdWUsIG5leHRWYWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlICE9PSBuZXh0VmFsdWU7XG5cdCAgfVxuXHR9O1xuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDZWxsO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBSZWFjdERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdHZhciBqb2luQ2xhc3NlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBFeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgUmVzaXplSGFuZGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXHRmdW5jdGlvbiBzaW1wbGVDZWxsUmVuZGVyZXIob2JqQXJncykge1xuXHQgIHZhciBoZWFkZXJUZXh0ID0gb2JqQXJncy5jb2x1bW4ucm93VHlwZSA9PT0gJ2hlYWRlcicgPyBvYmpBcmdzLmNvbHVtbi5uYW1lIDogJyc7XG5cdCAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAnZGl2Jyxcblx0ICAgIHsgY2xhc3NOYW1lOiAnd2lkZ2V0LUhlYWRlckNlbGxfX3ZhbHVlJyB9LFxuXHQgICAgaGVhZGVyVGV4dFxuXHQgICk7XG5cdH1cblxuXHR2YXIgSGVhZGVyQ2VsbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKEhlYWRlckNlbGwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gSGVhZGVyQ2VsbCgpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWFkZXJDZWxsKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0geyByZXNpemluZzogZmFsc2UgfSwgX3RoaXMub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHJlc2l6aW5nOiB0cnVlIH0pO1xuXHQgICAgICAvLyBuZWVkIHRvIHNldCBkdW1teSBkYXRhIGZvciBGRlxuXHQgICAgICBpZiAoZSAmJiBlLmRhdGFUcmFuc2ZlciAmJiBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKSBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0L3BsYWluJywgJ2R1bW15Jyk7XG5cdCAgICB9LCBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgcmVzaXplID0gX3RoaXMucHJvcHMub25SZXNpemUgfHwgbnVsbDsgLy8gZm9yIGZsb3dzIHNha2UsIGRvZXNudCByZWNvZ25pc2UgYSBudWxsIGNoZWNrIGRpcmVjdFxuXHQgICAgICBpZiAocmVzaXplKSB7XG5cdCAgICAgICAgdmFyIF93aWR0aCA9IF90aGlzLmdldFdpZHRoRnJvbU1vdXNlRXZlbnQoZSk7XG5cdCAgICAgICAgaWYgKF93aWR0aCA+IDApIHtcblx0ICAgICAgICAgIHJlc2l6ZShfdGhpcy5wcm9wcy5jb2x1bW4sIF93aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgd2lkdGggPSBfdGhpcy5nZXRXaWR0aEZyb21Nb3VzZUV2ZW50KGUpO1xuXHQgICAgICBfdGhpcy5wcm9wcy5vblJlc2l6ZUVuZChfdGhpcy5wcm9wcy5jb2x1bW4sIHdpZHRoKTtcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoeyByZXNpemluZzogZmFsc2UgfSk7XG5cdCAgICB9LCBfdGhpcy5nZXRXaWR0aEZyb21Nb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHJpZ2h0ID0gZS5wYWdlWCB8fCBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdICYmIGUudG91Y2hlc1swXS5wYWdlWCB8fCBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXNbZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggLSAxXS5wYWdlWDtcblx0ICAgICAgdmFyIGxlZnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShfdGhpcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0ICAgICAgcmV0dXJuIHJpZ2h0IC0gbGVmdDtcblx0ICAgIH0sIF90aGlzLmdldENlbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChfdGhpcy5wcm9wcy5yZW5kZXJlcikpIHtcblx0ICAgICAgICAvLyBpZiBpdCBpcyBhIHN0cmluZywgaXQncyBhbiBIVE1MIGVsZW1lbnQsIGFuZCBjb2x1bW4gaXMgbm90IGEgdmFsaWQgcHJvcGVydHksIHNvIG9ubHkgcGFzcyBoZWlnaHRcblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLnJlbmRlcmVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KF90aGlzLnByb3BzLnJlbmRlcmVyLCB7IGhlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KF90aGlzLnByb3BzLnJlbmRlcmVyLCB7IGNvbHVtbjogX3RoaXMucHJvcHMuY29sdW1uLCBoZWlnaHQ6IF90aGlzLnByb3BzLmhlaWdodCB9KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gX3RoaXMucHJvcHMucmVuZGVyZXIoeyBjb2x1bW46IF90aGlzLnByb3BzLmNvbHVtbiB9KTtcblx0ICAgIH0sIF90aGlzLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy5jb2x1bW4ud2lkdGgsXG5cdCAgICAgICAgbGVmdDogX3RoaXMucHJvcHMuY29sdW1uLmxlZnQsXG5cdCAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG5cdCAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdCAgICAgICAgaGVpZ2h0OiBfdGhpcy5wcm9wcy5oZWlnaHQsXG5cdCAgICAgICAgbWFyZ2luOiAwLFxuXHQgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcblx0ICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuXHQgICAgICB9O1xuXHQgICAgfSwgX3RoaXMuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChzY3JvbGxMZWZ0KSB7XG5cdCAgICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3RoaXMpO1xuXHQgICAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgc2Nyb2xsTGVmdCArICdweCwgMHB4LCAwcHgpJztcblx0ICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIHNjcm9sbExlZnQgKyAncHgsIDBweCwgMHB4KSc7XG5cdCAgICB9LCBfdGhpcy5yZW1vdmVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3RoaXMpO1xuXHQgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgIHZhciB0cmFuc2Zvcm0gPSAnbm9uZSc7XG5cdCAgICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdCAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdCAgICAgIH1cblx0ICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuXHQgIH1cblxuXHQgIEhlYWRlckNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciByZXNpemVIYW5kbGUgPSB2b2lkIDA7XG5cdCAgICBpZiAodGhpcy5wcm9wcy5jb2x1bW4ucmVzaXphYmxlKSB7XG5cdCAgICAgIHJlc2l6ZUhhbmRsZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXplSGFuZGxlLCB7XG5cdCAgICAgICAgb25EcmFnOiB0aGlzLm9uRHJhZyxcblx0ICAgICAgICBvbkRyYWdTdGFydDogdGhpcy5vbkRyYWdTdGFydCxcblx0ICAgICAgICBvbkRyYWdFbmQ6IHRoaXMub25EcmFnRW5kXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdmFyIGNsYXNzTmFtZSA9IGpvaW5DbGFzc2VzKHtcblx0ICAgICAgJ3JlYWN0LWdyaWQtSGVhZGVyQ2VsbCc6IHRydWUsXG5cdCAgICAgICdyZWFjdC1ncmlkLUhlYWRlckNlbGwtLXJlc2l6aW5nJzogdGhpcy5zdGF0ZS5yZXNpemluZyxcblx0ICAgICAgJ3JlYWN0LWdyaWQtSGVhZGVyQ2VsbC0tbG9ja2VkJzogdGhpcy5wcm9wcy5jb2x1bW4ubG9ja2VkXG5cdCAgICB9KTtcblx0ICAgIGNsYXNzTmFtZSA9IGpvaW5DbGFzc2VzKGNsYXNzTmFtZSwgdGhpcy5wcm9wcy5jbGFzc05hbWUsIHRoaXMucHJvcHMuY29sdW1uLmNlbGxDbGFzcyk7XG5cdCAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCgpO1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogdGhpcy5nZXRTdHlsZSgpIH0sXG5cdCAgICAgIGNlbGwsXG5cdCAgICAgIHJlc2l6ZUhhbmRsZVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEhlYWRlckNlbGw7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRIZWFkZXJDZWxsLnByb3BUeXBlcyA9IHtcblx0ICByZW5kZXJlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50XSkuaXNSZXF1aXJlZCxcblx0ICBjb2x1bW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoRXhjZWxDb2x1bW4pLmlzUmVxdWlyZWQsXG5cdCAgb25SZXNpemU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYy5pc1JlcXVpcmVkLFxuXHQgIGhlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBvblJlc2l6ZUVuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ1xuXHR9O1xuXHRIZWFkZXJDZWxsLmRlZmF1bHRQcm9wcyA9IHtcblx0ICByZW5kZXJlcjogc2ltcGxlQ2VsbFJlbmRlcmVyXG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEhlYWRlckNlbGw7XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuXHR2YXIgX092ZXJmbG93Q2VsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuXHR2YXIgX092ZXJmbG93Q2VsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PdmVyZmxvd0NlbGwpO1xuXG5cdHZhciBfUm93Q29tcGFyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuXHR2YXIgX1Jvd0NvbXBhcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jvd0NvbXBhcmVyKTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgam9pbkNsYXNzZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgQ2VsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXHR2YXIgY29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgY2VsbE1ldGFEYXRhU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIGNyZWF0ZU9iamVjdFdpdGhQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG5cdHZhciBDZWxsRXhwYW5kZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhDZWxsRXhwYW5kZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gQ2VsbEV4cGFuZGVyKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbGxFeHBhbmRlcik7XG5cblx0ICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIENlbGxFeHBhbmRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2VsbCwgdGhpcy5wcm9wcyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBDZWxsRXhwYW5kZXI7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHQvLyBUaGUgbGlzdCBvZiB0aGUgcHJvcFR5cGVzIHRoYXQgd2Ugd2FudCB0byBpbmNsdWRlIGluIHRoZSBSb3cgZGl2XG5cblxuXHR2YXIga25vd25EaXZQcm9wZXJ0eUtleXMgPSBbJ2hlaWdodCddO1xuXG5cdHZhciBSb3cgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcblx0ICBfaW5oZXJpdHMoUm93LCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cblx0ICBmdW5jdGlvbiBSb3coKSB7XG5cdCAgICB2YXIgX3RlbXAsIF90aGlzMiwgX3JldDtcblxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdyk7XG5cblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQyLmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudDIsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMyKSwgX3RoaXMyLmhhbmRsZURyYWdFbnRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGhhbmRsZURyYWdFbnRlclJvdyA9IF90aGlzMi5wcm9wcy5jZWxsTWV0YURhdGEuaGFuZGxlRHJhZ0VudGVyUm93O1xuXHQgICAgICBpZiAoaGFuZGxlRHJhZ0VudGVyUm93KSB7XG5cdCAgICAgICAgaGFuZGxlRHJhZ0VudGVyUm93KF90aGlzMi5wcm9wcy5pZHgpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpczIuZ2V0U2VsZWN0ZWRDb2x1bW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpczIucHJvcHMuY2VsbE1ldGFEYXRhKSB7XG5cdCAgICAgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMyLnByb3BzLmNlbGxNZXRhRGF0YS5zZWxlY3RlZDtcblx0ICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuaWR4KSB7XG5cdCAgICAgICAgICByZXR1cm4gY29sdW1uVXRpbHMuZ2V0Q29sdW1uKF90aGlzMi5wcm9wcy5jb2x1bW5zLCBzZWxlY3RlZC5pZHgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMyLmdldENlbGxSZW5kZXJlciA9IGZ1bmN0aW9uIChjb2x1bW5LZXkpIHtcblx0ICAgICAgdmFyIENlbGxSZW5kZXJlciA9IF90aGlzMi5wcm9wcy5jZWxsUmVuZGVyZXI7XG5cdCAgICAgIGlmIChfdGhpczIucHJvcHMuc3ViUm93RGV0YWlscyAmJiBfdGhpczIucHJvcHMuc3ViUm93RGV0YWlscy5maWVsZCA9PT0gY29sdW1uS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIENlbGxFeHBhbmRlcjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gQ2VsbFJlbmRlcmVyO1xuXHQgICAgfSwgX3RoaXMyLmdldENlbGwgPSBmdW5jdGlvbiAoY29sdW1uLCBpLCBzZWxlY3RlZENvbHVtbikge1xuXHQgICAgICB2YXIgQ2VsbFJlbmRlcmVyID0gX3RoaXMyLnByb3BzLmNlbGxSZW5kZXJlcjtcblx0ICAgICAgdmFyIF90aGlzMiRwcm9wcyA9IF90aGlzMi5wcm9wcyxcblx0ICAgICAgICAgIGNvbFZpc2libGVTdGFydCA9IF90aGlzMiRwcm9wcy5jb2xWaXNpYmxlU3RhcnQsXG5cdCAgICAgICAgICBjb2xWaXNpYmxlRW5kID0gX3RoaXMyJHByb3BzLmNvbFZpc2libGVFbmQsXG5cdCAgICAgICAgICBpZHggPSBfdGhpczIkcHJvcHMuaWR4LFxuXHQgICAgICAgICAgY2VsbE1ldGFEYXRhID0gX3RoaXMyJHByb3BzLmNlbGxNZXRhRGF0YTtcblx0ICAgICAgdmFyIGtleSA9IGNvbHVtbi5rZXksXG5cdCAgICAgICAgICBmb3JtYXR0ZXIgPSBjb2x1bW4uZm9ybWF0dGVyLFxuXHQgICAgICAgICAgbG9ja2VkID0gY29sdW1uLmxvY2tlZDtcblxuXHQgICAgICB2YXIgYmFzZUNlbGxQcm9wcyA9IHsga2V5OiBrZXkgKyAnLScgKyBpZHgsIGlkeDogaSwgcm93SWR4OiBpZHgsIGhlaWdodDogX3RoaXMyLmdldFJvd0hlaWdodCgpLCBjb2x1bW46IGNvbHVtbiwgY2VsbE1ldGFEYXRhOiBjZWxsTWV0YURhdGEgfTtcblxuXHQgICAgICBpZiAoKGkgPCBjb2xWaXNpYmxlU3RhcnQgfHwgaSA+IGNvbFZpc2libGVFbmQpICYmICFsb2NrZWQpIHtcblx0ICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChfT3ZlcmZsb3dDZWxsMlsnZGVmYXVsdCddLCBfZXh0ZW5kcyh7IHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzMltrZXldID0gbm9kZTtcblx0ICAgICAgICAgIH0gfSwgYmFzZUNlbGxQcm9wcykpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIF90aGlzMiRwcm9wczIgPSBfdGhpczIucHJvcHMsXG5cdCAgICAgICAgICByb3cgPSBfdGhpczIkcHJvcHMyLnJvdyxcblx0ICAgICAgICAgIGlzU2VsZWN0ZWQgPSBfdGhpczIkcHJvcHMyLmlzU2VsZWN0ZWQ7XG5cblx0ICAgICAgdmFyIGNlbGxQcm9wcyA9IHtcblx0ICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgICByZXR1cm4gX3RoaXMyW2tleV0gPSBub2RlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRDZWxsVmFsdWUoa2V5IHx8IGkpLFxuXHQgICAgICAgIHJvd0RhdGE6IHJvdyxcblx0ICAgICAgICBpc1Jvd1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuXHQgICAgICAgIGV4cGFuZGFibGVPcHRpb25zOiBfdGhpczIuZ2V0RXhwYW5kYWJsZU9wdGlvbnMoa2V5KSxcblx0ICAgICAgICBzZWxlY3RlZENvbHVtbjogc2VsZWN0ZWRDb2x1bW4sXG5cdCAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG5cdCAgICAgICAgaXNTY3JvbGxpbmc6IF90aGlzMi5wcm9wcy5pc1Njcm9sbGluZ1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENlbGxSZW5kZXJlciwgX2V4dGVuZHMoe30sIGJhc2VDZWxsUHJvcHMsIGNlbGxQcm9wcykpO1xuXHQgICAgfSwgX3RoaXMyLmdldENlbGxzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgY2VsbHMgPSBbXTtcblx0ICAgICAgdmFyIGxvY2tlZENlbGxzID0gW107XG5cdCAgICAgIHZhciBzZWxlY3RlZENvbHVtbiA9IF90aGlzMi5nZXRTZWxlY3RlZENvbHVtbigpO1xuXHQgICAgICB2YXIgbGFzdENvbHVtbklkeCA9IF90aGlzMi5wcm9wcy5jb2x1bW5zLnNpemUgLSAxO1xuXHQgICAgICBpZiAoX3RoaXMyLnByb3BzLmNvbHVtbnMpIHtcblx0ICAgICAgICBfdGhpczIucHJvcHMuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcblx0ICAgICAgICAgIGlmIChpID09PSBsYXN0Q29sdW1uSWR4KSB7XG5cdCAgICAgICAgICAgIGNvbHVtbi5pc0xhc3RDb2x1bW4gPSB0cnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIGNlbGwgPSBfdGhpczIuZ2V0Q2VsbChjb2x1bW4sIGksIHNlbGVjdGVkQ29sdW1uKTtcblx0ICAgICAgICAgIGlmIChjb2x1bW4ubG9ja2VkKSB7XG5cdCAgICAgICAgICAgIGxvY2tlZENlbGxzLnB1c2goY2VsbCk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGNlbGxzLmNvbmNhdChsb2NrZWRDZWxscyk7XG5cdCAgICB9LCBfdGhpczIuZ2V0Um93SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgcm93cyA9IF90aGlzMi5wcm9wcy5leHBhbmRlZFJvd3MgfHwgbnVsbDtcblx0ICAgICAgaWYgKHJvd3MgJiYgX3RoaXMyLnByb3BzLmlkeCkge1xuXHQgICAgICAgIHZhciByb3cgPSByb3dzW190aGlzMi5wcm9wcy5pZHhdIHx8IG51bGw7XG5cdCAgICAgICAgaWYgKHJvdykge1xuXHQgICAgICAgICAgcmV0dXJuIHJvdy5oZWlnaHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBfdGhpczIucHJvcHMuaGVpZ2h0O1xuXHQgICAgfSwgX3RoaXMyLmdldENlbGxWYWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgdmFyIHZhbCA9IHZvaWQgMDtcblx0ICAgICAgaWYgKGtleSA9PT0gJ3NlbGVjdC1yb3cnKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy5pc1NlbGVjdGVkO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpczIucHJvcHMucm93LmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHZhbCA9IF90aGlzMi5wcm9wcy5yb3cuZ2V0KGtleSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFsID0gX3RoaXMyLnByb3BzLnJvd1trZXldO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB2YWw7XG5cdCAgICB9LCBfdGhpczIuaXNDb250ZXh0TWVudURpc3BsYXllZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzMi5wcm9wcy5jZWxsTWV0YURhdGEpIHtcblx0ICAgICAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpczIucHJvcHMuY2VsbE1ldGFEYXRhLnNlbGVjdGVkO1xuXHQgICAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5jb250ZXh0TWVudURpc3BsYXllZCAmJiBzZWxlY3RlZC5yb3dJZHggPT09IF90aGlzMi5wcm9wcy5pZHgpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9LCBfdGhpczIuZ2V0RXhwYW5kYWJsZU9wdGlvbnMgPSBmdW5jdGlvbiAoY29sdW1uS2V5KSB7XG5cdCAgICAgIHZhciBzdWJSb3dEZXRhaWxzID0gX3RoaXMyLnByb3BzLnN1YlJvd0RldGFpbHM7XG5cdCAgICAgIGlmIChzdWJSb3dEZXRhaWxzKSB7XG5cdCAgICAgICAgcmV0dXJuIHsgY2FuRXhwYW5kOiBzdWJSb3dEZXRhaWxzICYmIHN1YlJvd0RldGFpbHMuZmllbGQgPT09IGNvbHVtbktleSAmJiAoc3ViUm93RGV0YWlscy5jaGlsZHJlbiAmJiBzdWJSb3dEZXRhaWxzLmNoaWxkcmVuLmxlbmd0aCA+IDAgfHwgc3ViUm93RGV0YWlscy5ncm91cCA9PT0gdHJ1ZSksIGZpZWxkOiBzdWJSb3dEZXRhaWxzLmZpZWxkLCBleHBhbmRlZDogc3ViUm93RGV0YWlscyAmJiBzdWJSb3dEZXRhaWxzLmV4cGFuZGVkLCBjaGlsZHJlbjogc3ViUm93RGV0YWlscyAmJiBzdWJSb3dEZXRhaWxzLmNoaWxkcmVuLCB0cmVlRGVwdGg6IHN1YlJvd0RldGFpbHMgPyBzdWJSb3dEZXRhaWxzLnRyZWVEZXB0aCA6IDAsIHN1YlJvd0RldGFpbHM6IHN1YlJvd0RldGFpbHMgfTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4ge307XG5cdCAgICB9LCBfdGhpczIuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChzY3JvbGxMZWZ0KSB7XG5cdCAgICAgIF90aGlzMi5wcm9wcy5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuXHQgICAgICAgIGlmIChjb2x1bW4ubG9ja2VkKSB7XG5cdCAgICAgICAgICBpZiAoIV90aGlzMltjb2x1bW4ua2V5XSkgcmV0dXJuO1xuXHQgICAgICAgICAgX3RoaXMyW2NvbHVtbi5rZXldLnNldFNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0sIF90aGlzMi5nZXRLbm93bkRpdlByb3BzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0V2l0aFByb3BlcnRpZXMoX3RoaXMyLnByb3BzLCBrbm93bkRpdlByb3BlcnR5S2V5cyk7XG5cdCAgICB9LCBfdGhpczIucmVuZGVyQ2VsbCA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHQgICAgICBpZiAodHlwZW9mIF90aGlzMi5wcm9wcy5jZWxsUmVuZGVyZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBfdGhpczIucHJvcHMuY2VsbFJlbmRlcmVyLmNhbGwoX3RoaXMyLCBwcm9wcyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KF90aGlzMi5wcm9wcy5jZWxsUmVuZGVyZXIpKSB7XG5cdCAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChfdGhpczIucHJvcHMuY2VsbFJlbmRlcmVyLCBwcm9wcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gX3RoaXMyLnByb3BzLmNlbGxSZW5kZXJlcihwcm9wcyk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzMiwgX3JldCk7XG5cdCAgfVxuXG5cdCAgUm93LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG5cdCAgICByZXR1cm4gKDAsIF9Sb3dDb21wYXJlcjJbJ2RlZmF1bHQnXSkobmV4dFByb3BzLCB0aGlzLnByb3BzKTtcblx0ICB9O1xuXG5cdCAgUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICB2YXIgY2xhc3NOYW1lID0gam9pbkNsYXNzZXMoJ3JlYWN0LWdyaWQtUm93JywgJ3JlYWN0LWdyaWQtUm93LS0nICsgKHRoaXMucHJvcHMuaWR4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnKSwge1xuXHQgICAgICAncm93LXNlbGVjdGVkJzogdGhpcy5wcm9wcy5pc1NlbGVjdGVkLFxuXHQgICAgICAncm93LWNvbnRleHQtbWVudSc6IHRoaXMuaXNDb250ZXh0TWVudURpc3BsYXllZCgpXG5cdCAgICB9LCB0aGlzLnByb3BzLmV4dHJhQ2xhc3Nlcyk7XG5cblx0ICAgIHZhciBzdHlsZSA9IHtcblx0ICAgICAgaGVpZ2h0OiB0aGlzLmdldFJvd0hlaWdodCh0aGlzLnByb3BzKSxcblx0ICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG5cdCAgICB9O1xuXG5cdCAgICB2YXIgY2VsbHMgPSB0aGlzLmdldENlbGxzKCk7XG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ2RpdicsXG5cdCAgICAgIF9leHRlbmRzKHt9LCB0aGlzLmdldEtub3duRGl2UHJvcHMoKSwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlLCBvbkRyYWdFbnRlcjogdGhpcy5oYW5kbGVEcmFnRW50ZXIgfSksXG5cdCAgICAgIFJlYWN0LmlzVmFsaWRFbGVtZW50KHRoaXMucHJvcHMucm93KSA/IHRoaXMucHJvcHMucm93IDogY2VsbHNcblx0ICAgICk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBSb3c7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRSb3cuZGlzcGxheU5hbWUgPSAnUm93Jztcblx0Um93LnByb3BUeXBlcyA9IHtcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5XSkuaXNSZXF1aXJlZCxcblx0ICByb3c6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYW55LmlzUmVxdWlyZWQsXG5cdCAgY2VsbFJlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgY2VsbE1ldGFEYXRhOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKGNlbGxNZXRhRGF0YVNoYXBlKSxcblx0ICBpc1NlbGVjdGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgaWR4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGV4cGFuZGVkUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheU9mKF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0KSxcblx0ICBleHRyYUNsYXNzZXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIGZvcmNlVXBkYXRlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgc3ViUm93RGV0YWlsczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgaXNSb3dIb3ZlcmVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgY29sVmlzaWJsZVN0YXJ0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGNvbFZpc2libGVFbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sRGlzcGxheVN0YXJ0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGNvbERpc3BsYXlFbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgaXNTY3JvbGxpbmc6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbC5pc1JlcXVpcmVkXG5cdH07XG5cdFJvdy5kZWZhdWx0UHJvcHMgPSB7XG5cdCAgY2VsbFJlbmRlcmVyOiBDZWxsLFxuXHQgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuXHQgIGhlaWdodDogMzVcblx0fTtcblxuXG5cdG1vZHVsZS5leHBvcnRzID0gUm93O1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHMuc2hvdWxkUm93VXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdHZhciBfQ29sdW1uTWV0cmljcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5cdHZhciBfQ29sdW1uTWV0cmljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2x1bW5NZXRyaWNzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gZG9lc1Jvd0NvbnRhaW5TZWxlY3RlZENlbGwocHJvcHMpIHtcblx0ICB2YXIgc2VsZWN0ZWQgPSBwcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQ7XG5cdCAgaWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLnJvd0lkeCA9PT0gcHJvcHMuaWR4KSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2lsbFJvd0JlRHJhZ2dlZE92ZXIocHJvcHMpIHtcblx0ICB2YXIgZHJhZ2dlZCA9IHByb3BzLmNlbGxNZXRhRGF0YS5kcmFnZ2VkO1xuXHQgIHJldHVybiBkcmFnZ2VkICE9IG51bGwgJiYgKGRyYWdnZWQucm93SWR4ID49IDAgfHwgZHJhZ2dlZC5jb21wbGV0ZSA9PT0gdHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNSb3dCZWVuQ29waWVkKHByb3BzKSB7XG5cdCAgdmFyIGNvcGllZCA9IHByb3BzLmNlbGxNZXRhRGF0YS5jb3BpZWQ7XG5cdCAgcmV0dXJuIGNvcGllZCAhPSBudWxsICYmIGNvcGllZC5yb3dJZHggPT09IHByb3BzLmlkeDtcblx0fVxuXG5cdHZhciBzaG91bGRSb3dVcGRhdGUgPSBleHBvcnRzLnNob3VsZFJvd1VwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZFJvd1VwZGF0ZShuZXh0UHJvcHMsIGN1cnJlbnRQcm9wcykge1xuXHQgIHJldHVybiAhX0NvbHVtbk1ldHJpY3MyWydkZWZhdWx0J10uc2FtZUNvbHVtbnMoY3VycmVudFByb3BzLmNvbHVtbnMsIG5leHRQcm9wcy5jb2x1bW5zLCBfQ29sdW1uTWV0cmljczJbJ2RlZmF1bHQnXS5zYW1lQ29sdW1uKSB8fCBkb2VzUm93Q29udGFpblNlbGVjdGVkQ2VsbChjdXJyZW50UHJvcHMpIHx8IGRvZXNSb3dDb250YWluU2VsZWN0ZWRDZWxsKG5leHRQcm9wcykgfHwgd2lsbFJvd0JlRHJhZ2dlZE92ZXIobmV4dFByb3BzKSB8fCBuZXh0UHJvcHMucm93ICE9PSBjdXJyZW50UHJvcHMucm93IHx8IGN1cnJlbnRQcm9wcy5jb2xEaXNwbGF5U3RhcnQgIT09IG5leHRQcm9wcy5jb2xEaXNwbGF5U3RhcnQgfHwgY3VycmVudFByb3BzLmNvbERpc3BsYXlFbmQgIT09IG5leHRQcm9wcy5jb2xEaXNwbGF5RW5kIHx8IGN1cnJlbnRQcm9wcy5jb2xWaXNpYmxlU3RhcnQgIT09IG5leHRQcm9wcy5jb2xWaXNpYmxlU3RhcnQgfHwgY3VycmVudFByb3BzLmNvbFZpc2libGVFbmQgIT09IG5leHRQcm9wcy5jb2xWaXNpYmxlRW5kIHx8IGhhc1Jvd0JlZW5Db3BpZWQoY3VycmVudFByb3BzKSB8fCBjdXJyZW50UHJvcHMuaXNTZWxlY3RlZCAhPT0gbmV4dFByb3BzLmlzU2VsZWN0ZWQgfHwgbmV4dFByb3BzLmhlaWdodCAhPT0gY3VycmVudFByb3BzLmhlaWdodCB8fCBjdXJyZW50UHJvcHMuaXNPdmVyICE9PSBuZXh0UHJvcHMuaXNPdmVyIHx8IGN1cnJlbnRQcm9wcy5leHBhbmRlZFJvd3MgIT09IG5leHRQcm9wcy5leHBhbmRlZFJvd3MgfHwgY3VycmVudFByb3BzLmNhbkRyb3AgIT09IG5leHRQcm9wcy5jYW5Ecm9wIHx8IGN1cnJlbnRQcm9wcy5mb3JjZVVwZGF0ZSA9PT0gdHJ1ZSB8fCBjdXJyZW50UHJvcHMuZXh0cmFDbGFzc2VzICE9PSBuZXh0UHJvcHMuZXh0cmFDbGFzc2VzO1xuXHR9O1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IHNob3VsZFJvd1VwZGF0ZTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgUm93VXRpbHMgPSB7XG5cdCAgZ2V0OiBmdW5jdGlvbiBnZXQocm93LCBwcm9wZXJ0eSkge1xuXHQgICAgaWYgKHR5cGVvZiByb3cuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybiByb3cuZ2V0KHByb3BlcnR5KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJvd1twcm9wZXJ0eV07XG5cdCAgfSxcblx0ICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbiBpc1Jvd1NlbGVjdGVkKGtleXMsIGluZGV4ZXMsIGlzU2VsZWN0ZWRLZXksIHJvd0RhdGEsIHJvd0lkeCkge1xuXHQgICAgaWYgKGluZGV4ZXMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGluZGV4ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdCAgICAgIHJldHVybiBpbmRleGVzLmluZGV4T2Yocm93SWR4KSA+IC0xO1xuXHQgICAgfSBlbHNlIGlmIChrZXlzICYmIGtleXMucm93S2V5ICYmIGtleXMudmFsdWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChrZXlzLnZhbHVlcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0ICAgICAgcmV0dXJuIGtleXMudmFsdWVzLmluZGV4T2Yocm93RGF0YVtrZXlzLnJvd0tleV0pID4gLTE7XG5cdCAgICB9IGVsc2UgaWYgKGlzU2VsZWN0ZWRLZXkgJiYgcm93RGF0YSAmJiB0eXBlb2YgaXNTZWxlY3RlZEtleSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuIHJvd0RhdGFbaXNTZWxlY3RlZEtleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUm93VXRpbHM7XG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0cy5TaW1wbGVSb3dzQ29udGFpbmVyID0gZXhwb3J0cy5nZXROZXdDb250ZXh0TWVudVByb3BzID0gZXhwb3J0cy5ERUZBVUxUX0NPTlRFWFRfTUVOVV9JRCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgREVGQVVMVF9DT05URVhUX01FTlVfSUQgPSBleHBvcnRzLkRFRkFVTFRfQ09OVEVYVF9NRU5VX0lEID0gJ3JnZENvbnRleHRNZW51JztcblxuXHR2YXIgU2ltcGxlUm93c0NvbnRhaW5lciA9IGZ1bmN0aW9uIFNpbXBsZVJvd3NDb250YWluZXIocHJvcHMpIHtcblx0ICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAnZGl2Jyxcblx0ICAgIHsga2V5OiAncm93cy1jb250YWluZXInIH0sXG5cdCAgICBwcm9wcy5yb3dzXG5cdCAgKTtcblx0fTtcblxuXHRTaW1wbGVSb3dzQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcblx0ICB3aWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgcm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheVxuXHR9O1xuXG5cdHZhciBnZXROZXdDb250ZXh0TWVudVByb3BzID0gZXhwb3J0cy5nZXROZXdDb250ZXh0TWVudVByb3BzID0gZnVuY3Rpb24gZ2V0TmV3Q29udGV4dE1lbnVQcm9wcyhfcmVmKSB7XG5cdCAgdmFyIGNvbnRleHRNZW51ID0gX3JlZi5jb250ZXh0TWVudSxcblx0ICAgICAgcm93SWR4ID0gX3JlZi5yb3dJZHgsXG5cdCAgICAgIGlkeCA9IF9yZWYuaWR4O1xuXHQgIHJldHVybiB7XG5cdCAgICByb3dJZHg6IHJvd0lkeCwgaWR4OiBpZHgsIGlkOiBjb250ZXh0TWVudS5wcm9wcy5pZCB8fCBERUZBVUxUX0NPTlRFWFRfTUVOVV9JRFxuXHQgIH07XG5cdH07XG5cblx0dmFyIFJvd3NDb250YWluZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhSb3dzQ29udGFpbmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIFJvd3NDb250YWluZXIocHJvcHMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3dzQ29udGFpbmVyKTtcblxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cblx0ICAgIF90aGlzLnBsdWdpbnMgPSBwcm9wcy53aW5kb3cgPyBwcm9wcy53aW5kb3cuUmVhY3REYXRhR3JpZFBsdWdpbnMgOiB3aW5kb3cuUmVhY3REYXRhR3JpZFBsdWdpbnM7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXG5cdCAgUm93c0NvbnRhaW5lci5wcm90b3R5cGUudmFsaWRhdGVQbHVnaW4gPSBmdW5jdGlvbiB2YWxpZGF0ZVBsdWdpbigpIHtcblx0ICAgIGlmICghdGhpcy5wbHVnaW5zKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5jbHVkZSBSZWFjdERhdGFHcmlkIFVpUGx1Z2lucyBpbiBvcmRlciB0byBpbml0aWFsaXNlIGNvbnRleHQgbWVudScpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBSb3dzQ29udGFpbmVyLnByb3RvdHlwZS5oYXNDb250ZXh0TWVudSA9IGZ1bmN0aW9uIGhhc0NvbnRleHRNZW51KCkge1xuXHQgICAgcmV0dXJuIHRoaXMucHJvcHMuY29udGV4dE1lbnUgJiYgX3JlYWN0MlsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KHRoaXMucHJvcHMuY29udGV4dE1lbnUpO1xuXHQgIH07XG5cblx0ICBSb3dzQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJSb3dzV2l0aENvbnRleHRNZW51ID0gZnVuY3Rpb24gcmVuZGVyUm93c1dpdGhDb250ZXh0TWVudSgpIHtcblx0ICAgIHZhciBDb250ZXh0TWVudVRyaWdnZXIgPSB0aGlzLnBsdWdpbnMuTWVudS5Db250ZXh0TWVudVRyaWdnZXI7XG5cblx0ICAgIHZhciBuZXdQcm9wcyA9IGdldE5ld0NvbnRleHRNZW51UHJvcHModGhpcy5wcm9wcyk7XG5cdCAgICB2YXIgY29udGV4dE1lbnUgPSBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY29udGV4dE1lbnUsIG5ld1Byb3BzKTtcblx0ICAgIC8vIEluaXRpYWxpc2UgdGhlIGNvbnRleHQgbWVudSBpZiBpdCBpcyBhdmFpbGFibGVcblx0ICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ2RpdicsXG5cdCAgICAgIG51bGwsXG5cdCAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgIENvbnRleHRNZW51VHJpZ2dlcixcblx0ICAgICAgICB7IGlkOiBuZXdQcm9wcy5pZCB9LFxuXHQgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFNpbXBsZVJvd3NDb250YWluZXIsIHRoaXMucHJvcHMpXG5cdCAgICAgICksXG5cdCAgICAgIGNvbnRleHRNZW51XG5cdCAgICApO1xuXHQgIH07XG5cblx0ICBSb3dzQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICBpZiAodGhpcy5oYXNDb250ZXh0TWVudSgpKSB7XG5cdCAgICAgIHRoaXMudmFsaWRhdGVQbHVnaW4oKTtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm93c1dpdGhDb250ZXh0TWVudSgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoU2ltcGxlUm93c0NvbnRhaW5lciwgdGhpcy5wcm9wcyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBSb3dzQ29udGFpbmVyO1xuXHR9KF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5cdFJvd3NDb250YWluZXIucHJvcFR5cGVzID0ge1xuXHQgIGNvbnRleHRNZW51OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmVsZW1lbnQsXG5cdCAgcm93SWR4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBpZHg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHdpbmRvdzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3Rcblx0fTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBSb3dzQ29udGFpbmVyO1xuXHRleHBvcnRzLlNpbXBsZVJvd3NDb250YWluZXIgPSBTaW1wbGVSb3dzQ29udGFpbmVyO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblx0dmFyIGpvaW5DbGFzc2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIERFRklORV9TT1JUID0ge1xuXHQgIEFTQzogJ0FTQycsXG5cdCAgREVTQzogJ0RFU0MnLFxuXHQgIE5PTkU6ICdOT05FJ1xuXHR9O1xuXG5cdHZhciBTb3J0YWJsZUhlYWRlckNlbGwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhTb3J0YWJsZUhlYWRlckNlbGwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gU29ydGFibGVIZWFkZXJDZWxsKCkge1xuXHQgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvcnRhYmxlSGVhZGVyQ2VsbCk7XG5cblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZGlyZWN0aW9uID0gdm9pZCAwO1xuXHQgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcblx0ICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBfdGhpcyRwcm9wcy5zb3J0RGlyZWN0aW9uLFxuXHQgICAgICAgICAgc29ydERlc2NlbmRpbmdGaXJzdCA9IF90aGlzJHByb3BzLnNvcnREZXNjZW5kaW5nRmlyc3Q7XG5cblx0ICAgICAgc3dpdGNoIChzb3J0RGlyZWN0aW9uKSB7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICBjYXNlIG51bGw6XG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgY2FzZSBERUZJTkVfU09SVC5OT05FOlxuXHQgICAgICAgICAgZGlyZWN0aW9uID0gc29ydERlc2NlbmRpbmdGaXJzdCA/IERFRklORV9TT1JULkRFU0MgOiBERUZJTkVfU09SVC5BU0M7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIERFRklORV9TT1JULkFTQzpcblx0ICAgICAgICAgIGRpcmVjdGlvbiA9IHNvcnREZXNjZW5kaW5nRmlyc3QgPyBERUZJTkVfU09SVC5OT05FIDogREVGSU5FX1NPUlQuREVTQztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgREVGSU5FX1NPUlQuREVTQzpcblx0ICAgICAgICAgIGRpcmVjdGlvbiA9IHNvcnREZXNjZW5kaW5nRmlyc3QgPyBERUZJTkVfU09SVC5BU0MgOiBERUZJTkVfU09SVC5OT05FO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgX3RoaXMucHJvcHMub25Tb3J0KF90aGlzLnByb3BzLmNvbHVtbktleSwgZGlyZWN0aW9uKTtcblx0ICAgIH0sIF90aGlzLmdldFNvcnRCeVRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciB1bmljb2RlS2V5cyA9IHtcblx0ICAgICAgICBBU0M6ICc5NjUwJyxcblx0ICAgICAgICBERVNDOiAnOTY2MCdcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnNvcnREaXJlY3Rpb24gPT09ICdOT05FJyA/ICcnIDogU3RyaW5nLmZyb21DaGFyQ29kZSh1bmljb2RlS2V5c1tfdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uXSk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBTb3J0YWJsZUhlYWRlckNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciBjbGFzc05hbWUgPSBqb2luQ2xhc3Nlcyh7XG5cdCAgICAgICdyZWFjdC1ncmlkLUhlYWRlckNlbGwtc29ydGFibGUnOiB0cnVlLFxuXHQgICAgICAncmVhY3QtZ3JpZC1IZWFkZXJDZWxsLXNvcnRhYmxlLS1hc2NlbmRpbmcnOiB0aGlzLnByb3BzLnNvcnREaXJlY3Rpb24gPT09ICdBU0MnLFxuXHQgICAgICAncmVhY3QtZ3JpZC1IZWFkZXJDZWxsLXNvcnRhYmxlLS1kZXNjZW5kaW5nJzogdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uID09PSAnREVTQydcblx0ICAgIH0pO1xuXHQgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnByb3BzLmhlYWRlclJlbmRlcmVyID8gdGhpcy5wcm9wcy5oZWFkZXJSZW5kZXJlciA6IHRoaXMucHJvcHMuY29sdW1uLm5hbWU7XG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ2RpdicsXG5cdCAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG5cdCAgICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrLFxuXHQgICAgICAgIHN0eWxlOiB7IGN1cnNvcjogJ3BvaW50ZXInIH0gfSxcblx0ICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAnc3BhbicsXG5cdCAgICAgICAgeyBjbGFzc05hbWU6ICdwdWxsLXJpZ2h0JyB9LFxuXHQgICAgICAgIHRoaXMuZ2V0U29ydEJ5VGV4dCgpXG5cdCAgICAgICksXG5cdCAgICAgIGNvbnRlbnRcblx0ICAgICk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBTb3J0YWJsZUhlYWRlckNlbGw7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRTb3J0YWJsZUhlYWRlckNlbGwucHJvcFR5cGVzID0ge1xuXHQgIGNvbHVtbktleTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICBjb2x1bW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoeyBuYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm5vZGUgfSksXG5cdCAgb25Tb3J0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBzb3J0RGlyZWN0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKE9iamVjdC5rZXlzKERFRklORV9TT1JUKSksXG5cdCAgaGVhZGVyUmVuZGVyZXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubm9kZSxcblx0ICBzb3J0RGVzY2VuZGluZ0ZpcnN0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xcblx0fTtcblxuXG5cdG1vZHVsZS5leHBvcnRzID0gU29ydGFibGVIZWFkZXJDZWxsO1xuXHRtb2R1bGUuZXhwb3J0cy5ERUZJTkVfU09SVCA9IERFRklORV9TT1JUO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cblx0dmFyIENoZWNrYm94RWRpdG9yID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoQ2hlY2tib3hFZGl0b3IsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gQ2hlY2tib3hFZGl0b3IoKSB7XG5cdCAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hFZGl0b3IpO1xuXG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMucHJvcHMuY29sdW1uLm9uQ2VsbENoYW5nZShfdGhpcy5wcm9wcy5yb3dJZHgsIF90aGlzLnByb3BzLmNvbHVtbi5rZXksIF90aGlzLnByb3BzLmRlcGVuZGVudFZhbHVlcywgZSk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBDaGVja2JveEVkaXRvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgdmFyIGNoZWNrZWQgPSB0aGlzLnByb3BzLnZhbHVlICE9IG51bGwgPyB0aGlzLnByb3BzLnZhbHVlIDogZmFsc2U7XG5cdCAgICB2YXIgY2hlY2tib3hOYW1lID0gJ2NoZWNrYm94JyArIHRoaXMucHJvcHMucm93SWR4O1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtY2hlY2tib3gtY29udGFpbmVyIGNoZWNrYm94LWFsaWduJywgb25DbGljazogdGhpcy5oYW5kbGVDaGFuZ2UgfSxcblx0ICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtY2hlY2tib3gnLCB0eXBlOiAnY2hlY2tib3gnLCBuYW1lOiBjaGVja2JveE5hbWUsIGNoZWNrZWQ6IGNoZWNrZWQgfSksXG5cdCAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJywgeyBodG1sRm9yOiBjaGVja2JveE5hbWUsIGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtY2hlY2tib3gtbGFiZWwnIH0pXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ2hlY2tib3hFZGl0b3I7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRDaGVja2JveEVkaXRvci5wcm9wVHlwZXMgPSB7XG5cdCAgdmFsdWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCxcblx0ICByb3dJZHg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGNvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBrZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgICAgb25DZWxsQ2hhbmdlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0ICB9KSxcblx0ICBkZXBlbmRlbnRWYWx1ZXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0XG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94RWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBSZWFjdERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdHZhciBFeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cdHZhciBFZGl0b3JCYXNlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoRWRpdG9yQmFzZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBFZGl0b3JCYXNlKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvckJhc2UpO1xuXG5cdCAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBFZGl0b3JCYXNlLnByb3RvdHlwZS5nZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgd2lkdGg6ICcxMDAlJ1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcblx0ICAgIHZhciB1cGRhdGVkID0ge307XG5cdCAgICB1cGRhdGVkW3RoaXMucHJvcHMuY29sdW1uLmtleV0gPSB0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlO1xuXHQgICAgcmV0dXJuIHVwZGF0ZWQ7XG5cdCAgfTtcblxuXHQgIEVkaXRvckJhc2UucHJvdG90eXBlLmdldElucHV0Tm9kZSA9IGZ1bmN0aW9uIGdldElucHV0Tm9kZSgpIHtcblx0ICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cdCAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnSU5QVVQnKSB7XG5cdCAgICAgIHJldHVybiBkb21Ob2RlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZG9tTm9kZS5xdWVyeVNlbGVjdG9yKCdpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSknKTtcblx0ICB9O1xuXG5cdCAgRWRpdG9yQmFzZS5wcm90b3R5cGUuaW5oZXJpdENvbnRhaW5lclN0eWxlcyA9IGZ1bmN0aW9uIGluaGVyaXRDb250YWluZXJTdHlsZXMoKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVkaXRvckJhc2U7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRFZGl0b3JCYXNlLnByb3BUeXBlcyA9IHtcblx0ICBvbktleURvd246IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYy5pc1JlcXVpcmVkLFxuXHQgIHZhbHVlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFueS5pc1JlcXVpcmVkLFxuXHQgIG9uQmx1cjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKEV4Y2VsQ29sdW1uKS5pc1JlcXVpcmVkLFxuXHQgIGNvbW1pdDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWRcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEVkaXRvckJhc2U7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgRWRpdG9yQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG5cdHZhciBTaW1wbGVUZXh0RWRpdG9yID0gZnVuY3Rpb24gKF9FZGl0b3JCYXNlKSB7XG5cdCAgX2luaGVyaXRzKFNpbXBsZVRleHRFZGl0b3IsIF9FZGl0b3JCYXNlKTtcblxuXHQgIGZ1bmN0aW9uIFNpbXBsZVRleHRFZGl0b3IoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlVGV4dEVkaXRvcik7XG5cblx0ICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRWRpdG9yQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBTaW1wbGVUZXh0RWRpdG9yLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzMi5pbnB1dCA9IG5vZGU7XG5cdCAgICAgIH0sIHR5cGU6ICd0ZXh0Jywgb25CbHVyOiB0aGlzLnByb3BzLm9uQmx1ciwgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgZGVmYXVsdFZhbHVlOiB0aGlzLnByb3BzLnZhbHVlIH0pO1xuXHQgIH07XG5cblx0ICByZXR1cm4gU2ltcGxlVGV4dEVkaXRvcjtcblx0fShFZGl0b3JCYXNlKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZVRleHRFZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0dmFyIFNlbGVjdEFsbCA9IGZ1bmN0aW9uIFNlbGVjdEFsbChwcm9wcykge1xuXHQgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0ICAgICdkaXYnLFxuXHQgICAgeyBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLWNoZWNrYm94LWNvbnRhaW5lciBjaGVja2JveC1hbGlnbicgfSxcblx0ICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcblx0ICAgICAgY2xhc3NOYW1lOiAncmVhY3QtZ3JpZC1jaGVja2JveCcsXG5cdCAgICAgIHR5cGU6ICdjaGVja2JveCcsXG5cdCAgICAgIG5hbWU6ICdzZWxlY3QtYWxsLWNoZWNrYm94Jyxcblx0ICAgICAgaWQ6ICdzZWxlY3QtYWxsLWNoZWNrYm94Jyxcblx0ICAgICAgcmVmOiBwcm9wcy5pbnB1dFJlZixcblx0ICAgICAgb25DaGFuZ2U6IHByb3BzLm9uQ2hhbmdlXG5cdCAgICB9KSxcblx0ICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdsYWJlbCcsIHsgaHRtbEZvcjogJ3NlbGVjdC1hbGwtY2hlY2tib3gnLCBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLWNoZWNrYm94LWxhYmVsJyB9KVxuXHQgICk7XG5cdH07XG5cblx0U2VsZWN0QWxsLnByb3BUeXBlcyA9IHtcblx0ICBvbkNoYW5nZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGlucHV0UmVmOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0fTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBTZWxlY3RBbGw7XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgU2ltcGxlQ2VsbEZvcm1hdHRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKFNpbXBsZUNlbGxGb3JtYXR0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gU2ltcGxlQ2VsbEZvcm1hdHRlcigpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVDZWxsRm9ybWF0dGVyKTtcblxuXHQgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgU2ltcGxlQ2VsbEZvcm1hdHRlci5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuXHQgICAgcmV0dXJuIG5leHRQcm9wcy52YWx1ZSAhPT0gdGhpcy5wcm9wcy52YWx1ZTtcblx0ICB9O1xuXG5cdCAgU2ltcGxlQ2VsbEZvcm1hdHRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IHRpdGxlOiB0aGlzLnByb3BzLnZhbHVlIH0sXG5cdCAgICAgIHRoaXMucHJvcHMudmFsdWVcblx0ICAgICk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBTaW1wbGVDZWxsRm9ybWF0dGVyO1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0U2ltcGxlQ2VsbEZvcm1hdHRlci5wcm9wVHlwZXMgPSB7XG5cdCAgdmFsdWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xdKS5pc1JlcXVpcmVkXG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUNlbGxGb3JtYXR0ZXI7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBzaGFsbG93Q2xvbmVPYmplY3Qob2JqKSB7XG5cdCAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgIGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG5cdCAgICAgIHJlc3VsdFtrXSA9IG9ialtrXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0Nsb25lT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHR2YXIgX2ltbXV0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGlzRW1wdHlBcnJheTogX193ZWJwYWNrX3JlcXVpcmVfXygxMzEpLFxuXHQgIGlzRW1wdHlPYmplY3Q6IF9fd2VicGFja19yZXF1aXJlX18oMTMyKSxcblx0ICBpc0Z1bmN0aW9uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSxcblx0ICBpc0ltbXV0YWJsZUNvbGxlY3Rpb246IF9fd2VicGFja19yZXF1aXJlX18oMTMzKSxcblx0ICBnZXRNaXhlZFR5cGVWYWx1ZVJldHJpZXZlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpLFxuXHQgIGlzQ29sdW1uc0ltbXV0YWJsZTogX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG5cdCAgaXNJbW11dGFibGVNYXA6IF9fd2VicGFja19yZXF1aXJlX18oMTM0KSxcblx0ICBsYXN0OiBmdW5jdGlvbiBsYXN0KGFycmF5T3JMaXN0KSB7XG5cdCAgICBpZiAoYXJyYXlPckxpc3QgPT0gbnVsbCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5T3JDb2xsZWN0aW9uIGlzIG51bGwnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKF9pbW11dGFibGUuTGlzdC5pc0xpc3QoYXJyYXlPckxpc3QpKSB7XG5cdCAgICAgIHJldHVybiBhcnJheU9yTGlzdC5sYXN0KCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5T3JMaXN0KSkge1xuXHQgICAgICByZXR1cm4gYXJyYXlPckxpc3RbYXJyYXlPckxpc3QubGVuZ3RoIC0gMV07XG5cdCAgICB9XG5cblx0ICAgIHRocm93IG5ldyBFcnJvcignQ2FudCBnZXQgbGFzdCBvZjogJyArICh0eXBlb2YgYXJyYXlPckxpc3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFycmF5T3JMaXN0KSkpO1xuXHQgIH1cblx0fTtcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ29sdW1uc0ltbXV0YWJsZShjb2x1bW5zKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBJbW11dGFibGUgIT09ICd1bmRlZmluZWQnICYmIGNvbHVtbnMgaW5zdGFuY2VvZiBJbW11dGFibGUuTGlzdDtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRmdW5jdGlvbiBpc0tleVByaW50YWJsZShrZXljb2RlKSB7XG5cdCAgdmFyIHZhbGlkID0ga2V5Y29kZSA+IDQ3ICYmIGtleWNvZGUgPCA1OCB8fCAvLyBudW1iZXIga2V5c1xuXHQgIGtleWNvZGUgPT09IDMyIHx8IGtleWNvZGUgPT09IDEzIHx8IC8vIHNwYWNlYmFyICYgcmV0dXJuIGtleShzKSAoaWYgeW91IHdhbnQgdG8gYWxsb3cgY2FycmlhZ2UgcmV0dXJucylcblx0ICBrZXljb2RlID4gNjQgJiYga2V5Y29kZSA8IDkxIHx8IC8vIGxldHRlciBrZXlzXG5cdCAga2V5Y29kZSA+IDk1ICYmIGtleWNvZGUgPCAxMTIgfHwgLy8gbnVtcGFkIGtleXNcblx0ICBrZXljb2RlID4gMTg1ICYmIGtleWNvZGUgPCAxOTMgfHwgLy8gOz0sLS4vYCAoaW4gb3JkZXIpXG5cdCAga2V5Y29kZSA+IDIxOCAmJiBrZXljb2RlIDwgMjIzOyAvLyBbXFxdJyAoaW4gb3JkZXIpXG5cblx0ICByZXR1cm4gdmFsaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0N0cmxLZXlIZWxkRG93bihlKSB7XG5cdCAgcmV0dXJuIChlLmN0cmxLZXkgPT09IHRydWUgfHwgZS5tZXRhS2V5ID09PSB0cnVlKSAmJiBlLmtleSAhPT0gJ0NvbnRyb2wnO1xuXHR9XG5cblx0ZXhwb3J0cy5pc0tleVByaW50YWJsZSA9IGlzS2V5UHJpbnRhYmxlO1xuXHRleHBvcnRzLmlzQ3RybEtleUhlbGREb3duID0gaXNDdHJsS2V5SGVsZERvd247XG5cbi8qKiovIH0pLFxuLyogNTYgKi8sXG4vKiA1NyAqLyxcbi8qIDU4ICovLFxuLyogNTkgKi8sXG4vKiA2MCAqLyxcbi8qIDYxICovLFxuLyogNjIgKi8sXG4vKiA2MyAqLyxcbi8qIDY0ICovLFxuLyogNjUgKi8sXG4vKiA2NiAqLyxcbi8qIDY3ICovLFxuLyogNjggKi8sXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG5cblx0ICAgIHZhciByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcblxuXHQgICAgaWYocmV0ICE9PSB2b2lkIDApIHtcblx0ICAgICAgICByZXR1cm4gISFyZXQ7XG5cdCAgICB9XG5cblx0ICAgIGlmKG9iakEgPT09IG9iakIpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8ICFvYmpBIHx8XG5cdCAgICAgICB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgIW9iakIpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuXHQgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cblx0ICAgIGlmKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG5cdCAgICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuXHQgICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCBrZXlzQS5sZW5ndGg7IGlkeCsrKSB7XG5cblx0ICAgICAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuXHQgICAgICAgIGlmKCFiSGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcblx0ICAgICAgICB2YXIgdmFsdWVCID0gb2JqQltrZXldO1xuXG5cdCAgICAgICAgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgdmFsdWVBLCB2YWx1ZUIsIGtleSkgOiB2b2lkIDA7XG5cblx0ICAgICAgICBpZihyZXQgPT09IGZhbHNlIHx8XG5cdCAgICAgICAgICAgcmV0ID09PSB2b2lkIDAgJiYgdmFsdWVBICE9PSB2YWx1ZUIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG5cdC8vIGxvYWQgdGhlIHN0eWxlc1xuXHR2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KTtcblx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cdC8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cblx0dmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoY29udGVudCwge30pO1xuXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcblx0Ly8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuXHRpZihmYWxzZSkge1xuXHRcdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdFx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9yZWFjdC1kYXRhLWdyaWQtY2hlY2tib3guY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZGF0YS1ncmlkLWNoZWNrYm94LmNzc1wiKTtcblx0XHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdFx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG5cdH1cblxuLyoqKi8gfSksXG4vKiA3MSAqLyxcbi8qIDcyICovLFxuLyogNzMgKi8sXG4vKiA3NCAqLyxcbi8qIDc1ICovLFxuLyogNzYgKi8sXG4vKiA3NyAqLyxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG5cdC8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuXHQvLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuXHQvLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuXHQoZnVuY3Rpb24oKSB7XG5cblx0ICAvLyBCYXNlbGluZSBzZXR1cFxuXHQgIC8vIC0tLS0tLS0tLS0tLS0tXG5cblx0ICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG5cdCAgdmFyIHJvb3QgPSB0aGlzO1xuXG5cdCAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cblx0ICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG5cdCAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcblx0ICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cblx0ICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cblx0ICB2YXJcblx0ICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG5cdCAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcblx0ICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcblx0ICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuXHQgIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuXHQgIHZhclxuXHQgICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcblx0ICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuXHQgICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG5cdCAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG5cdCAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuXHQgIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG5cdCAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG5cdCAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuXHQgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcblx0ICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG5cdCAgfTtcblxuXHQgIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG5cdCAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuXHQgIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cblx0ICBpZiAodHJ1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdCAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG5cdCAgICB9XG5cdCAgICBleHBvcnRzLl8gPSBfO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByb290Ll8gPSBfO1xuXHQgIH1cblxuXHQgIC8vIEN1cnJlbnQgdmVyc2lvbi5cblx0ICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG5cdCAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuXHQgIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG5cdCAgLy8gZnVuY3Rpb25zLlxuXHQgIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcblx0ICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuXHQgICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG5cdCAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG5cdCAgICAgIH07XG5cdCAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuXHQgICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcblx0ICAgICAgfTtcblx0ICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuXHQgICAgICB9O1xuXHQgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG5cdCAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG5cdCAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuXHQgIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuXHQgICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG5cdCAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuXHQgICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuXHQgIH07XG5cdCAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG5cdCAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcblx0ICB9O1xuXG5cdCAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cblx0ICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG5cdCAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcblx0ICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcblx0ICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG5cdCAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG5cdCAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcblx0ICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG5cdCAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG5cdCAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgQ3Rvcjtcblx0ICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIHZhciBwcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuXHQgIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3Rcblx0ICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuXHQgIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG5cdCAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cdCAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcblx0ICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuXHQgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcblx0ICB9O1xuXG5cdCAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcblx0ICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdCAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG5cdCAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuXHQgIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG5cdCAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcblx0ICAgIHZhciBpLCBsZW5ndGg7XG5cdCAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuXHQgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG5cdCAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuXHQgIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG5cdCAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuXHQgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuXHQgICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuXHQgICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cblx0ICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cblx0ICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG5cdCAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuXHQgICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuXHQgICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuXHQgICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcblx0ICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtZW1vO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuXHQgICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuXHQgICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuXHQgICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG5cdCAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcblx0ICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG5cdCAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuXHQgICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuXHQgICAgICAgIGluZGV4ICs9IGRpcjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcblx0ICAvLyBvciBgZm9sZGxgLlxuXHQgIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG5cdCAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG5cdCAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG5cdCAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuXHQgIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBrZXk7XG5cdCAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuXHQgICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cblx0ICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuXHQgIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgdmFyIHJlc3VsdHMgPSBbXTtcblx0ICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG5cdCAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcblx0ICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cblx0ICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG5cdCAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG5cdCAgfTtcblxuXHQgIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuXHQgIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG5cdCAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG5cdCAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuXHQgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuXHQgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuXHQgICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH07XG5cblx0ICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cblx0ICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuXHQgIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcblx0ICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG5cdCAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuXHQgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuXHQgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuXHQgICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfTtcblxuXHQgIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuXHQgIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuXHQgIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG5cdCAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG5cdCAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcblx0ICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG5cdCAgfTtcblxuXHQgIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuXHQgIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcblx0ICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuXHQgICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuXHQgICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG5cdCAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG5cdCAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuXHQgIH07XG5cblx0ICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG5cdCAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cblx0ICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuXHQgICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG5cdCAgfTtcblxuXHQgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3Rcblx0ICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuXHQgIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuXHQgICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG5cdCAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG5cdCAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuXHQgICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcblx0ICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YWx1ZSA9IG9ialtpXTtcblx0ICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG5cdCAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuXHQgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcblx0ICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuXHQgIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcblx0ICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG5cdCAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuXHQgICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhbHVlID0gb2JqW2ldO1xuXHQgICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcblx0ICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG5cdCAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuXHQgICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcblx0ICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG5cdCAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG5cdCAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcblx0ICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdCAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG5cdCAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG5cdCAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzaHVmZmxlZDtcblx0ICB9O1xuXG5cdCAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG5cdCAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cblx0ICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuXHQgIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuXHQgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuXHQgICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG5cdCAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG5cdCAgfTtcblxuXHQgIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cblx0ICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcblx0ICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuXHQgICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG5cdCAgICAgIH07XG5cdCAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG5cdCAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcblx0ICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcblx0ICAgICAgaWYgKGEgIT09IGIpIHtcblx0ICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcblx0ICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcblx0ICAgIH0pLCAndmFsdWUnKTtcblx0ICB9O1xuXG5cdCAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuXHQgIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuXHQgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0ICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuXHQgICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuXHQgIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuXHQgIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuXHQgICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuXHQgIH0pO1xuXG5cdCAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuXHQgIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cblx0ICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcblx0ICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdCAgfSk7XG5cblx0ICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3Ncblx0ICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcblx0ICAvLyBjcml0ZXJpb24uXG5cdCAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG5cdCAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcblx0ICB9KTtcblxuXHQgIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG5cdCAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuXHQgICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuXHQgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuXHQgICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cblx0ICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG5cdCAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG5cdCAgfTtcblxuXHQgIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cblx0ICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG5cdCAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcblx0ICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcblx0ICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuXHQgICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBbcGFzcywgZmFpbF07XG5cdCAgfTtcblxuXHQgIC8vIEFycmF5IEZ1bmN0aW9uc1xuXHQgIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG5cdCAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG5cdCAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuXHQgIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cblx0ICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG5cdCAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcblx0ICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcblx0ICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cblx0ICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuXHQgIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG5cdCAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG5cdCAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuXHQgIH07XG5cblx0ICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG5cdCAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cblx0ICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcblx0ICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuXHQgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuXHQgICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG5cdCAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cblx0ICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG5cdCAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG5cdCAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuXHQgIH07XG5cblx0ICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG5cdCAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0ICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG5cdCAgfTtcblxuXHQgIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cblx0ICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcblx0ICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcblx0ICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcblx0ICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG5cdCAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG5cdCAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG5cdCAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcblx0ICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG5cdCAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3V0cHV0O1xuXHQgIH07XG5cblx0ICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG5cdCAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcblx0ICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuXHQgIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdCAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHQgIH07XG5cblx0ICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuXHQgIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cblx0ICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuXHQgIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcblx0ICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuXHQgICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuXHQgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgdmFyIHNlZW4gPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG5cdCAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuXHQgICAgICBpZiAoaXNTb3J0ZWQpIHtcblx0ICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0ICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcblx0ICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG5cdCAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuXHQgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG5cdCAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG5cdCAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuXHQgIH07XG5cblx0ICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG5cdCAgLy8gcGFzc2VkLWluIGFycmF5cy5cblx0ICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG5cdCAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuXHQgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuXHQgICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG5cdCAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cblx0ICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuXHQgICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG5cdCAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG5cdCAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG5cdCAgXy56aXAgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG5cdCAgfTtcblxuXHQgIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcblx0ICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcblx0ICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0ICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcblx0ICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG5cdCAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdCAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG5cdCAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG5cdCAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuXHQgIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHZhbHVlcykge1xuXHQgICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG5cdCAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuXHQgICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuXHQgICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcblx0ICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuXHQgICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gLTE7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuXHQgIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG5cdCAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG5cdCAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuXHQgIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cblx0ICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcblx0ICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuXHQgICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcblx0ICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcblx0ICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdCAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuXHQgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvdztcblx0ICB9O1xuXG5cdCAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG5cdCAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcblx0ICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuXHQgICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuXHQgICAgICAgIGlmIChkaXIgPiAwKSB7XG5cdCAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuXHQgICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcblx0ICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG5cdCAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcblx0ICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuXHQgICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAtMTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuXHQgIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG5cdCAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG5cdCAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cblx0ICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG5cdCAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG5cdCAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuXHQgIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG5cdCAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cblx0ICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcblx0ICAgIGlmIChzdG9wID09IG51bGwpIHtcblx0ICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG5cdCAgICAgIHN0YXJ0ID0gMDtcblx0ICAgIH1cblx0ICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cblx0ICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG5cdCAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG5cdCAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG5cdCAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH07XG5cblx0ICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG5cdCAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0ICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3Jcblx0ICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcblx0ICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuXHQgICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcblx0ICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG5cdCAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcblx0ICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG5cdCAgICByZXR1cm4gc2VsZjtcblx0ICB9O1xuXG5cdCAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG5cdCAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuXHQgIC8vIGF2YWlsYWJsZS5cblx0ICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG5cdCAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdCAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG5cdCAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0ICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gYm91bmQ7XG5cdCAgfTtcblxuXHQgIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcblx0ICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG5cdCAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuXHQgIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcblx0ICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcblx0ICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcblx0ICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGJvdW5kO1xuXHQgIH07XG5cblx0ICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcblx0ICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3Ncblx0ICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG5cdCAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuXHQgICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcblx0ICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9O1xuXG5cdCAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cblx0ICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcblx0ICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG5cdCAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuXHQgICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcblx0ICAgIH07XG5cdCAgICBtZW1vaXplLmNhY2hlID0ge307XG5cdCAgICByZXR1cm4gbWVtb2l6ZTtcblx0ICB9O1xuXG5cdCAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuXHQgIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cblx0ICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuXHQgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdCAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHQgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcblx0ICAgIH0sIHdhaXQpO1xuXHQgIH07XG5cblx0ICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcblx0ICAvLyBjbGVhcmVkLlxuXHQgIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cblx0ICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2Vcblx0ICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cblx0ICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG5cdCAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3Ncblx0ICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cblx0ICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuXHQgICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcblx0ICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblx0ICAgIHZhciBwcmV2aW91cyA9IDA7XG5cdCAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblx0ICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcblx0ICAgICAgdGltZW91dCA9IG51bGw7XG5cdCAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdCAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG5cdCAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG5cdCAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcblx0ICAgICAgY29udGV4dCA9IHRoaXM7XG5cdCAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG5cdCAgICAgICAgaWYgKHRpbWVvdXQpIHtcblx0ICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwcmV2aW91cyA9IG5vdztcblx0ICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHQgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHQgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcblx0ICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG5cdCAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG5cdCAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cblx0ICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG5cdCAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cblx0ICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cblx0ICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuXHQgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGltZW91dCA9IG51bGw7XG5cdCAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdCAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgY29udGV4dCA9IHRoaXM7XG5cdCAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG5cdCAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuXHQgICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblx0ICAgICAgaWYgKGNhbGxOb3cpIHtcblx0ICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHQgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcblx0ICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG5cdCAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cblx0ICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG5cdCAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuXHQgIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuXHQgIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG5cdCAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGkgPSBzdGFydDtcblx0ICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG5cdCAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuXHQgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cblx0ICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG5cdCAgICB2YXIgbWVtbztcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG5cdCAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG5cdCAgICAgIHJldHVybiBtZW1vO1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG5cdCAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cblx0ICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG5cdCAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuXHQgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuXHQgIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG5cdCAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcblx0ICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cblx0ICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuXHQgICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuXHQgICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuXHQgICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuXHQgICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG5cdCAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG5cdCAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG5cdCAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG5cdCAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG5cdCAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG5cdCAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuXHQgIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2Bcblx0ICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG5cdCAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcblx0ICAgIHZhciBrZXlzID0gW107XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcblx0ICAgIC8vIEFoZW0sIElFIDwgOS5cblx0ICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG5cdCAgICByZXR1cm4ga2V5cztcblx0ICB9O1xuXG5cdCAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG5cdCAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuXHQgICAgdmFyIGtleXMgPSBbXTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuXHQgICAgLy8gQWhlbSwgSUUgPCA5LlxuXHQgICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcblx0ICAgIHJldHVybiBrZXlzO1xuXHQgIH07XG5cblx0ICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG5cdCAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG5cdCAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdCAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlcztcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3Rcblx0ICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuXHQgIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuXHQgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG5cdCAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuXHQgICAgICAgICAgcmVzdWx0cyA9IHt9LFxuXHQgICAgICAgICAgY3VycmVudEtleTtcblx0ICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcblx0ICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cblx0ICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cblx0ICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuXHQgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHQgICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYWlycztcblx0ICB9O1xuXG5cdCAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuXHQgIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuXHQgIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG5cdCAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBuYW1lcyA9IFtdO1xuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcblx0ICB9O1xuXG5cdCAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG5cdCAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG5cdCAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3Qocylcblx0ICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcblx0ICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuXHQgIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuXHQgIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG5cdCAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuXHQgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuXHQgIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG5cdCAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG5cdCAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcblx0ICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuXHQgICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcblx0ICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG5cdCAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXHQgICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cblx0ICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG5cdCAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuXHQgICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG5cdCAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHQgICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcblx0ICB9O1xuXG5cdCAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuXHQgIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cblx0ICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuXHQgIC8vIGNyZWF0ZWQgb2JqZWN0LlxuXHQgIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuXHQgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcblx0ICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG5cdCAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG5cdCAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuXHQgIH07XG5cblx0ICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG5cdCAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG5cdCAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG5cdCAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG5cdCAgICBpbnRlcmNlcHRvcihvYmopO1xuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG5cdCAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuXHQgICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG5cdCAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXHQgICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfTtcblxuXG5cdCAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cblx0ICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuXHQgICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuXHQgICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG5cdCAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuXHQgICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuXHQgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuXHQgICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG5cdCAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuXHQgICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcblx0ICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG5cdCAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcblx0ICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcblx0ICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG5cdCAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuXHQgICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuXHQgICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuXHQgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuXHQgICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG5cdCAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuXHQgICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcblx0ICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcblx0ICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuXHQgICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG5cdCAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcblx0ICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuXHQgICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG5cdCAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuXHQgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcblx0ICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG5cdCAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuXHQgICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cblx0ICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuXHQgICAgaWYgKCFhcmVBcnJheXMpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG5cdCAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG5cdCAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuXHQgICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cblx0ICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblx0ICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cblx0ICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcblx0ICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcblx0ICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuXHQgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuXHQgICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG5cdCAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cdCAgICBhU3RhY2sucHVzaChhKTtcblx0ICAgIGJTdGFjay5wdXNoKGIpO1xuXG5cdCAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cblx0ICAgIGlmIChhcmVBcnJheXMpIHtcblx0ICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG5cdCAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuXHQgICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG5cdCAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG5cdCAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHQgICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG5cdCAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcblx0ICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG5cdCAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuXHQgICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cdCAgICBhU3RhY2sucG9wKCk7XG5cdCAgICBiU3RhY2sucG9wKCk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG5cdCAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGVxKGEsIGIpO1xuXHQgIH07XG5cblx0ICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cblx0ICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuXHQgIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblx0ICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG5cdCAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuXHQgIH07XG5cblx0ICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG5cdCAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcblx0ICB9O1xuXG5cdCAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cblx0ICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuXHQgIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdCAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHQgIH07XG5cblx0ICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cblx0ICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG5cdCAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcblx0ICB9O1xuXG5cdCAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG5cdCAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuXHQgICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG5cdCAgICB9O1xuXHQgIH0pO1xuXG5cdCAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuXHQgIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG5cdCAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcblx0ICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuXHQgIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuXHQgIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuXHQgICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cblx0ICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcblx0ICB9O1xuXG5cdCAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuXHQgIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuXHQgIH07XG5cblx0ICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cblx0ICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXHQgIH07XG5cblx0ICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG5cdCAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHJldHVybiBvYmogPT09IG51bGw7XG5cdCAgfTtcblxuXHQgIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuXHQgIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcblx0ICB9O1xuXG5cdCAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuXHQgIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG5cdCAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuXHQgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuXHQgIH07XG5cblx0ICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuXHQgIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cblx0ICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG5cdCAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuXHQgIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG5cdCAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblxuXHQgIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cblx0ICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG5cdCAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG5cdCAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuXHQgIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgIHJldHVybiBvYmpba2V5XTtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuXHQgIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuXHQgIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG5cdCAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cblx0ICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcblx0ICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcblx0ICAgIHJldHVybiBhY2N1bTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cblx0ICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cdCAgICBpZiAobWF4ID09IG51bGwpIHtcblx0ICAgICAgbWF4ID0gbWluO1xuXHQgICAgICBtaW4gPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG5cdCAgfTtcblxuXHQgIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cblx0ICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHQgIH07XG5cblx0ICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cblx0ICB2YXIgZXNjYXBlTWFwID0ge1xuXHQgICAgJyYnOiAnJmFtcDsnLFxuXHQgICAgJzwnOiAnJmx0OycsXG5cdCAgICAnPic6ICcmZ3Q7Jyxcblx0ICAgICdcIic6ICcmcXVvdDsnLFxuXHQgICAgXCInXCI6ICcmI3gyNzsnLFxuXHQgICAgJ2AnOiAnJiN4NjA7J1xuXHQgIH07XG5cdCAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuXHQgIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cblx0ICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuXHQgICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuXHQgICAgICByZXR1cm4gbWFwW21hdGNoXTtcblx0ICAgIH07XG5cdCAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcblx0ICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcblx0ICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG5cdCAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcblx0ICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG5cdCAgICB9O1xuXHQgIH07XG5cdCAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG5cdCAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG5cdCAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcblx0ICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cblx0ICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG5cdCAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG5cdCAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuXHQgICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcblx0ICB9O1xuXG5cdCAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cblx0ICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuXHQgIHZhciBpZENvdW50ZXIgPSAwO1xuXHQgIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcblx0ICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG5cdCAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcblx0ICB9O1xuXG5cdCAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG5cdCAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuXHQgIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcblx0ICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcblx0ICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG5cdCAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG5cdCAgfTtcblxuXHQgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cblx0ICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG5cdCAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG5cdCAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cblx0ICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuXHQgIC8vIHN0cmluZyBsaXRlcmFsLlxuXHQgIHZhciBlc2NhcGVzID0ge1xuXHQgICAgXCInXCI6ICAgICAgXCInXCIsXG5cdCAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG5cdCAgICAnXFxyJzogICAgICdyJyxcblx0ICAgICdcXG4nOiAgICAgJ24nLFxuXHQgICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuXHQgICAgJ1xcdTIwMjknOiAndTIwMjknXG5cdCAgfTtcblxuXHQgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5cdCAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuXHQgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuXHQgIH07XG5cblx0ICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuXHQgIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcblx0ICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cblx0ICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdCAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuXHQgICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcblx0ICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cblx0ICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuXHQgICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuXHQgICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcblx0ICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcblx0ICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuXHQgICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG5cdCAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuXHQgICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG5cdCAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG5cdCAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG5cdCAgICAgIGlmIChlc2NhcGUpIHtcblx0ICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuXHQgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG5cdCAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcblx0ICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuXHQgICAgICByZXR1cm4gbWF0Y2g7XG5cdCAgICB9KTtcblx0ICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cblx0ICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG5cdCAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG5cdCAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG5cdCAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG5cdCAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG5cdCAgICAgIHRocm93IGU7XG5cdCAgICB9XG5cblx0ICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuXHQgICAgfTtcblxuXHQgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuXHQgICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG5cdCAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuXHQgICAgcmV0dXJuIHRlbXBsYXRlO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cblx0ICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG5cdCAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuXHQgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgIH07XG5cblx0ICAvLyBPT1Bcblx0ICAvLyAtLS0tLS0tLS0tLS0tLS1cblx0ICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuXHQgIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG5cdCAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuXHQgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cblx0ICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuXHQgICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG5cdCAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuXHQgICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuXHQgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cblx0ICBfLm1peGluKF8pO1xuXG5cdCAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cblx0ICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuXHQgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG5cdCAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcblx0ICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0ICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuXHQgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG5cdCAgICB9O1xuXHQgIH0pO1xuXG5cdCAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG5cdCAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuXHQgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG5cdCAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcblx0ICAgIH07XG5cdCAgfSk7XG5cblx0ICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cblx0ICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG5cdCAgfTtcblxuXHQgIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcblx0ICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuXHQgIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuXHQgIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuXHQgIH07XG5cblx0ICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG5cdCAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG5cdCAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuXHQgIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG5cdCAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG5cdCAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuXHQgIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuXHQgIGlmICh0cnVlKSB7XG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIF87XG5cdCAgICB9LmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdCAgfVxuXHR9LmNhbGwodGhpcykpO1xuXG5cbi8qKiovIH0pLFxuLyogNzkgKi8sXG4vKiA4MCAqLyxcbi8qIDgxICovLFxuLyogODIgKi8sXG4vKiA4MyAqLyxcbi8qIDg0ICovLFxuLyogODUgKi8sXG4vKiA4NiAqLyxcbi8qIDg3ICovLFxuLyogODggKi8sXG4vKiA4OSAqLyxcbi8qIDkwICovLFxuLyogOTEgKi8sXG4vKiA5MiAqLyxcbi8qIDkzICovLFxuLyogOTQgKi8sXG4vKiA5NSAqLyxcbi8qIDk2ICovLFxuLyogOTcgKi8sXG4vKiA5OCAqLyxcbi8qIDk5ICovLFxuLyogMTAwICovLFxuLyogMTAxICovLFxuLyogMTAyICovLFxuLyogMTAzICovLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0dmFyIF9zY3JvbGxVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KTtcblxuXHR2YXIgX3NoYWxsb3dlcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG5cdHZhciBfc2hhbGxvd2VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dlcXVhbCk7XG5cblx0dmFyIF9Sb3dzQ29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cblx0dmFyIF9Sb3dzQ29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jvd3NDb250YWluZXIpO1xuXG5cdHZhciBfUm93R3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMSk7XG5cblx0dmFyIF9Sb3dHcm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3dHcm91cCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIGpvaW5DbGFzc2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHR2YXIgUm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cdHZhciBjZWxsTWV0YURhdGFTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgUm93VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHR2YXIgQ2FudmFzID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoQ2FudmFzLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIENhbnZhcygpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXMpO1xuXG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG5cdCAgICAgIGRpc3BsYXlTdGFydDogX3RoaXMucHJvcHMuZGlzcGxheVN0YXJ0LFxuXHQgICAgICBkaXNwbGF5RW5kOiBfdGhpcy5wcm9wcy5kaXNwbGF5RW5kLFxuXHQgICAgICBzY3JvbGxpbmdUaW1lb3V0OiBudWxsXG5cdCAgICB9LCBfdGhpcy5fY3VycmVudFJvd3NMZW5ndGggPSAwLCBfdGhpcy5fY3VycmVudFJvd3NSYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9LCBfdGhpcy5fc2Nyb2xsID0geyBzY3JvbGxUb3A6IDAsIHNjcm9sbExlZnQ6IDAgfSwgX3RoaXMuYXBwZW5kU2Nyb2xsU2hpbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFfdGhpcy5fc2Nyb2xsU2hpbSkge1xuXHQgICAgICAgIHZhciBzaXplID0gX3RoaXMuX3Njcm9sbFNoaW1TaXplKCk7XG5cdCAgICAgICAgdmFyIHNoaW0gPSAoMCwgX3Njcm9sbFV0aWxzLmNyZWF0ZVNjcm9sbFNoaW0pKHNpemUpO1xuXHQgICAgICAgIF90aGlzLmNhbnZhcy5hcHBlbmRDaGlsZChzaGltKTtcblx0ICAgICAgICBfdGhpcy5fc2Nyb2xsU2hpbSA9IHNoaW07XG5cdCAgICAgIH1cblx0ICAgICAgX3RoaXMuX3NjaGVkdWxlUmVtb3ZlU2Nyb2xsU2hpbSgpO1xuXHQgICAgfSwgX3RoaXMuX3Njcm9sbFNoaW1TaXplID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy53aWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IF90aGlzLnByb3BzLmxlbmd0aCAqIF90aGlzLnByb3BzLnJvd0hlaWdodFxuXHQgICAgICB9O1xuXHQgICAgfSwgX3RoaXMuX3NjaGVkdWxlUmVtb3ZlU2Nyb2xsU2hpbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzLl9zY2hlZHVsZVJlbW92ZVNjcm9sbFNoaW1UaW1lcikge1xuXHQgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fc2NoZWR1bGVSZW1vdmVTY3JvbGxTaGltVGltZXIpO1xuXHQgICAgICB9XG5cdCAgICAgIF90aGlzLl9zY2hlZHVsZVJlbW92ZVNjcm9sbFNoaW1UaW1lciA9IHNldFRpbWVvdXQoX3RoaXMuX3JlbW92ZVNjcm9sbFNoaW0sIDIwMCk7XG5cdCAgICB9LCBfdGhpcy5fcmVtb3ZlU2Nyb2xsU2hpbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzLl9zY3JvbGxTaGltKSB7XG5cdCAgICAgICAgX3RoaXMuX3Njcm9sbFNoaW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5fc2Nyb2xsU2hpbSk7XG5cdCAgICAgICAgX3RoaXMuX3Njcm9sbFNoaW0gPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLm9uUm93cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzLl9jdXJyZW50Um93c1JhbmdlICE9PSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfSkge1xuXHQgICAgICAgIF90aGlzLnByb3BzLm9uUm93cyhfdGhpcy5fY3VycmVudFJvd3NSYW5nZSk7XG5cdCAgICAgICAgX3RoaXMuX2N1cnJlbnRSb3dzUmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25TY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoX3RoaXMuY2FudmFzICE9PSBlLnRhcmdldCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBfdGhpcy5hcHBlbmRTY3JvbGxTaGltKCk7XG5cdCAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZS50YXJnZXQuc2Nyb2xsTGVmdDtcblx0ICAgICAgdmFyIHNjcm9sbFRvcCA9IGUudGFyZ2V0LnNjcm9sbFRvcDtcblx0ICAgICAgdmFyIHNjcm9sbCA9IHsgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQgfTtcblx0ICAgICAgX3RoaXMuX3Njcm9sbCA9IHNjcm9sbDtcblx0ICAgICAgX3RoaXMucHJvcHMub25TY3JvbGwoc2Nyb2xsKTtcblx0ICAgIH0sIF90aGlzLmdldFJvd3MgPSBmdW5jdGlvbiAoZGlzcGxheVN0YXJ0LCBkaXNwbGF5RW5kKSB7XG5cdCAgICAgIF90aGlzLl9jdXJyZW50Um93c1JhbmdlID0geyBzdGFydDogZGlzcGxheVN0YXJ0LCBlbmQ6IGRpc3BsYXlFbmQgfTtcblx0ICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMucm93R2V0dGVyKSkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5yb3dHZXR0ZXIuc2xpY2UoZGlzcGxheVN0YXJ0LCBkaXNwbGF5RW5kKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcm93cyA9IFtdO1xuXHQgICAgICB2YXIgaSA9IGRpc3BsYXlTdGFydDtcblx0ICAgICAgd2hpbGUgKGkgPCBkaXNwbGF5RW5kKSB7XG5cdCAgICAgICAgdmFyIHJvdyA9IF90aGlzLnByb3BzLnJvd0dldHRlcihpKTtcblx0ICAgICAgICB2YXIgc3ViUm93RGV0YWlscyA9IHt9O1xuXHQgICAgICAgIGlmIChfdGhpcy5wcm9wcy5nZXRTdWJSb3dEZXRhaWxzKSB7XG5cdCAgICAgICAgICBzdWJSb3dEZXRhaWxzID0gX3RoaXMucHJvcHMuZ2V0U3ViUm93RGV0YWlscyhyb3cpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByb3dzLnB1c2goeyByb3c6IHJvdywgc3ViUm93RGV0YWlsczogc3ViUm93RGV0YWlscyB9KTtcblx0ICAgICAgICBpKys7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJvd3M7XG5cdCAgICB9LCBfdGhpcy5nZXRTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgLy8gR2V0IHRoZSBzY3JvbGxiYXIgd2lkdGhcblx0ICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gX3RoaXMuY2FudmFzLm9mZnNldFdpZHRoIC0gX3RoaXMuY2FudmFzLmNsaWVudFdpZHRoO1xuXHQgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG5cdCAgICB9LCBfdGhpcy5nZXRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBfdGhpcyRjYW52YXMgPSBfdGhpcy5jYW52YXMsXG5cdCAgICAgICAgICBzY3JvbGxUb3AgPSBfdGhpcyRjYW52YXMuc2Nyb2xsVG9wLFxuXHQgICAgICAgICAgc2Nyb2xsTGVmdCA9IF90aGlzJGNhbnZhcy5zY3JvbGxMZWZ0O1xuXG5cdCAgICAgIHJldHVybiB7IHNjcm9sbFRvcDogc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0IH07XG5cdCAgICB9LCBfdGhpcy5pc1Jvd1NlbGVjdGVkID0gZnVuY3Rpb24gKGlkeCwgcm93KSB7XG5cdCAgICAgIC8vIFVzZSBzZWxlY3RlZFJvd3MgaWYgc2V0XG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RlZFJvd3MgIT09IG51bGwpIHtcblx0ICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRSb3dzLmZpbHRlcihmdW5jdGlvbiAocikge1xuXHQgICAgICAgICAgdmFyIHJvd0tleVZhbHVlID0gcm93LmdldCA/IHJvdy5nZXQoX3RoaXMucHJvcHMucm93S2V5KSA6IHJvd1tfdGhpcy5wcm9wcy5yb3dLZXldO1xuXHQgICAgICAgICAgcmV0dXJuIHJbX3RoaXMucHJvcHMucm93S2V5XSA9PT0gcm93S2V5VmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93cy5sZW5ndGggPiAwICYmIHNlbGVjdGVkUm93c1swXS5pc1NlbGVjdGVkO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gRWxzZSB1c2UgbmV3IHJvd1NlbGVjdGlvbiBwcm9wc1xuXHQgICAgICBpZiAoX3RoaXMucHJvcHMucm93U2VsZWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzJHByb3BzJHJvd1NlbGVjdCA9IF90aGlzLnByb3BzLnJvd1NlbGVjdGlvbixcblx0ICAgICAgICAgICAga2V5cyA9IF90aGlzJHByb3BzJHJvd1NlbGVjdC5rZXlzLFxuXHQgICAgICAgICAgICBpbmRleGVzID0gX3RoaXMkcHJvcHMkcm93U2VsZWN0LmluZGV4ZXMsXG5cdCAgICAgICAgICAgIGlzU2VsZWN0ZWRLZXkgPSBfdGhpcyRwcm9wcyRyb3dTZWxlY3QuaXNTZWxlY3RlZEtleTtcblxuXHQgICAgICAgIHJldHVybiBSb3dVdGlscy5pc1Jvd1NlbGVjdGVkKGtleXMsIGluZGV4ZXMsIGlzU2VsZWN0ZWRLZXksIHJvdywgaWR4KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0sIF90aGlzLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoc2Nyb2xsTGVmdCkge1xuXHQgICAgICBpZiAoX3RoaXMuX2N1cnJlbnRSb3dzTGVuZ3RoICE9PSAwKSB7XG5cdCAgICAgICAgaWYgKCFfdGhpcy5yb3dzKSByZXR1cm47XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IF90aGlzLl9jdXJyZW50Um93c0xlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoX3RoaXMucm93c1tpXSkge1xuXHQgICAgICAgICAgICB2YXIgcm93ID0gX3RoaXMuZ2V0Um93QnlSZWYoaSk7XG5cdCAgICAgICAgICAgIGlmIChyb3cgJiYgcm93LnNldFNjcm9sbExlZnQpIHtcblx0ICAgICAgICAgICAgICByb3cuc2V0U2Nyb2xsTGVmdChzY3JvbGxMZWZ0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMuZ2V0Um93QnlSZWYgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAvLyBjaGVjayBpZiB3cmFwcGVkIHdpdGggUmVhY3QgRE5EIGRyb3AgdGFyZ2V0XG5cdCAgICAgIHZhciB3cmFwcGVkUm93ID0gX3RoaXMucm93c1tpXS5nZXREZWNvcmF0ZWRDb21wb25lbnRJbnN0YW5jZSA/IF90aGlzLnJvd3NbaV0uZ2V0RGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UoaSkgOiBudWxsO1xuXHQgICAgICBpZiAod3JhcHBlZFJvdykge1xuXHQgICAgICAgIHJldHVybiB3cmFwcGVkUm93LnJvdztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gX3RoaXMucm93c1tpXTtcblx0ICAgIH0sIF90aGlzLnJlbmRlclJvdyA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHQgICAgICB2YXIgcm93ID0gcHJvcHMucm93O1xuXHQgICAgICBpZiAocm93Ll9fbWV0YURhdGEgJiYgcm93Ll9fbWV0YURhdGEuZ2V0Um93UmVuZGVyZXIpIHtcblx0ICAgICAgICByZXR1cm4gcm93Ll9fbWV0YURhdGEuZ2V0Um93UmVuZGVyZXIoX3RoaXMucHJvcHMsIHByb3BzLmlkeCk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJvdy5fX21ldGFEYXRhICYmIHJvdy5fX21ldGFEYXRhLmlzR3JvdXApIHtcblx0ICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChfUm93R3JvdXAyWydkZWZhdWx0J10sIF9leHRlbmRzKHt9LCBwcm9wcywgcm93Ll9fbWV0YURhdGEsIHtcblx0ICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuXHQgICAgICAgICAgcmVuZGVyZXI6IF90aGlzLnByb3BzLnJvd0dyb3VwUmVuZGVyZXIgfSkpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBSb3dzUmVuZGVyZXIgPSBfdGhpcy5wcm9wcy5yb3dSZW5kZXJlcjtcblx0ICAgICAgaWYgKHR5cGVvZiBSb3dzUmVuZGVyZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3dzUmVuZGVyZXIsIHByb3BzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChfdGhpcy5wcm9wcy5yb3dSZW5kZXJlcikpIHtcblx0ICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KF90aGlzLnByb3BzLnJvd1JlbmRlcmVyLCBwcm9wcyk7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLnJlbmRlclBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGtleSwgaGVpZ2h0KSB7XG5cdCAgICAgIC8vIGp1c3QgcmVuZGVycyBlbXB0eSBjZWxsc1xuXHQgICAgICAvLyBpZiB3ZSB3YW50ZWQgdG8gc2hvdyBncmlkbGluZXMsIHdlJ2QgbmVlZCBjbGFzc2VzIGFuZCBwb3NpdGlvbiBhcyB3aXRoIHJlbmRlclNjcm9sbGluZ1BsYWNlaG9sZGVyXG5cdCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsga2V5OiBrZXksIHN0eWxlOiB7IGhlaWdodDogaGVpZ2h0IH0gfSxcblx0ICAgICAgICBfdGhpcy5wcm9wcy5jb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcblx0ICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IHN0eWxlOiB7IHdpZHRoOiBjb2x1bW4ud2lkdGggfSwga2V5OiBpZHggfSk7XG5cdCAgICAgICAgfSlcblx0ICAgICAgKTtcblx0ICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuXHQgIH1cblxuXHQgIENhbnZhcy5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuXHQgICAgdGhpcy5yb3dzID0gW107XG5cdCAgICB0aGlzLl9jdXJyZW50Um93c0xlbmd0aCA9IDA7XG5cdCAgICB0aGlzLl9jdXJyZW50Um93c1JhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG5cdCAgICB0aGlzLl9zY3JvbGwgPSB7IHNjcm9sbFRvcDogMCwgc2Nyb2xsTGVmdDogMCB9O1xuXHQgIH07XG5cblx0ICBDYW52YXMucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG5cdCAgICB0aGlzLm9uUm93cygpO1xuXHQgIH07XG5cblx0ICBDYW52YXMucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXHQgICAgaWYgKG5leHRQcm9wcy5kaXNwbGF5U3RhcnQgIT09IHRoaXMuc3RhdGUuZGlzcGxheVN0YXJ0IHx8IG5leHRQcm9wcy5kaXNwbGF5RW5kICE9PSB0aGlzLnN0YXRlLmRpc3BsYXlFbmQpIHtcblx0ICAgICAgdGhpcy5zZXRTdGF0ZSh7XG5cdCAgICAgICAgZGlzcGxheVN0YXJ0OiBuZXh0UHJvcHMuZGlzcGxheVN0YXJ0LFxuXHQgICAgICAgIGRpc3BsYXlFbmQ6IG5leHRQcm9wcy5kaXNwbGF5RW5kXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBDYW52YXMucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHQgICAgdmFyIHNob3VsZFVwZGF0ZSA9IG5leHRTdGF0ZS5kaXNwbGF5U3RhcnQgIT09IHRoaXMuc3RhdGUuZGlzcGxheVN0YXJ0IHx8IG5leHRTdGF0ZS5kaXNwbGF5RW5kICE9PSB0aGlzLnN0YXRlLmRpc3BsYXlFbmQgfHwgbmV4dFN0YXRlLnNjcm9sbGluZ1RpbWVvdXQgIT09IHRoaXMuc3RhdGUuc2Nyb2xsaW5nVGltZW91dCB8fCB0aGlzLnByb3BzLnNjcm9sbFRvUm93SW5kZXggIT09IG5leHRQcm9wcy5zY3JvbGxUb1Jvd0luZGV4IHx8IG5leHRQcm9wcy5yb3dzQ291bnQgIT09IHRoaXMucHJvcHMucm93c0NvdW50IHx8IG5leHRQcm9wcy5yb3dIZWlnaHQgIT09IHRoaXMucHJvcHMucm93SGVpZ2h0IHx8IG5leHRQcm9wcy5jb2x1bW5zICE9PSB0aGlzLnByb3BzLmNvbHVtbnMgfHwgbmV4dFByb3BzLndpZHRoICE9PSB0aGlzLnByb3BzLndpZHRoIHx8IG5leHRQcm9wcy5oZWlnaHQgIT09IHRoaXMucHJvcHMuaGVpZ2h0IHx8IG5leHRQcm9wcy5jZWxsTWV0YURhdGEgIT09IHRoaXMucHJvcHMuY2VsbE1ldGFEYXRhIHx8IHRoaXMucHJvcHMuY29sRGlzcGxheVN0YXJ0ICE9PSBuZXh0UHJvcHMuY29sRGlzcGxheVN0YXJ0IHx8IHRoaXMucHJvcHMuY29sRGlzcGxheUVuZCAhPT0gbmV4dFByb3BzLmNvbERpc3BsYXlFbmQgfHwgdGhpcy5wcm9wcy5jb2xWaXNpYmxlU3RhcnQgIT09IG5leHRQcm9wcy5jb2xWaXNpYmxlU3RhcnQgfHwgdGhpcy5wcm9wcy5jb2xWaXNpYmxlRW5kICE9PSBuZXh0UHJvcHMuY29sVmlzaWJsZUVuZCB8fCAhKDAsIF9zaGFsbG93ZXF1YWwyWydkZWZhdWx0J10pKG5leHRQcm9wcy5zdHlsZSwgdGhpcy5wcm9wcy5zdHlsZSkgfHwgdGhpcy5wcm9wcy5pc1Njcm9sbGluZyAhPT0gbmV4dFByb3BzLmlzU2Nyb2xsaW5nO1xuXHQgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcblx0ICB9O1xuXG5cdCAgQ2FudmFzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgdGhpcy5fY3VycmVudFJvd3NMZW5ndGggPSAwO1xuXHQgICAgdGhpcy5fY3VycmVudFJvd3NSYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuXHQgICAgdGhpcy5fc2Nyb2xsID0geyBzY3JvbGxUb3A6IDAsIHNjcm9sbExlZnQ6IDAgfTtcblx0ICB9O1xuXG5cdCAgQ2FudmFzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdCAgICBpZiAodGhpcy5fc2Nyb2xsLnNjcm9sbFRvcCAhPT0gMCAmJiB0aGlzLl9zY3JvbGwuc2Nyb2xsTGVmdCAhPT0gMCkge1xuXHQgICAgICB0aGlzLnNldFNjcm9sbExlZnQodGhpcy5fc2Nyb2xsLnNjcm9sbExlZnQpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9Sb3dJbmRleCAhPT0gMCkge1xuXHQgICAgICB0aGlzLmNhbnZhcy5zY3JvbGxUb3AgPSBNYXRoLm1pbih0aGlzLnByb3BzLnNjcm9sbFRvUm93SW5kZXggKiB0aGlzLnByb3BzLnJvd0hlaWdodCwgdGhpcy5wcm9wcy5yb3dzQ291bnQgKiB0aGlzLnByb3BzLnJvd0hlaWdodCAtIHRoaXMucHJvcHMuaGVpZ2h0KTtcblx0ICAgIH1cblx0ICAgIHRoaXMub25Sb3dzKCk7XG5cdCAgfTtcblxuXHQgIENhbnZhcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlLFxuXHQgICAgICAgIGRpc3BsYXlTdGFydCA9IF9zdGF0ZS5kaXNwbGF5U3RhcnQsXG5cdCAgICAgICAgZGlzcGxheUVuZCA9IF9zdGF0ZS5kaXNwbGF5RW5kO1xuXHQgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG5cdCAgICAgICAgcm93SGVpZ2h0ID0gX3Byb3BzLnJvd0hlaWdodCxcblx0ICAgICAgICByb3dzQ291bnQgPSBfcHJvcHMucm93c0NvdW50O1xuXG5cblx0ICAgIHZhciByb3dzID0gdGhpcy5nZXRSb3dzKGRpc3BsYXlTdGFydCwgZGlzcGxheUVuZCkubWFwKGZ1bmN0aW9uIChyLCBpZHgpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXJSb3coe1xuXHQgICAgICAgIGtleTogJ3Jvdy0nICsgKGRpc3BsYXlTdGFydCArIGlkeCksXG5cdCAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgcmV0dXJuIF90aGlzMi5yb3dzW2lkeF0gPSBub2RlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaWR4OiBkaXNwbGF5U3RhcnQgKyBpZHgsXG5cdCAgICAgICAgdmlzaWJsZVN0YXJ0OiBfdGhpczIucHJvcHMudmlzaWJsZVN0YXJ0LFxuXHQgICAgICAgIHZpc2libGVFbmQ6IF90aGlzMi5wcm9wcy52aXNpYmxlRW5kLFxuXHQgICAgICAgIHJvdzogci5yb3csXG5cdCAgICAgICAgaGVpZ2h0OiByb3dIZWlnaHQsXG5cdCAgICAgICAgb25Nb3VzZU92ZXI6IF90aGlzMi5vbk1vdXNlT3Zlcixcblx0ICAgICAgICBjb2x1bW5zOiBfdGhpczIucHJvcHMuY29sdW1ucyxcblx0ICAgICAgICBpc1NlbGVjdGVkOiBfdGhpczIuaXNSb3dTZWxlY3RlZChkaXNwbGF5U3RhcnQgKyBpZHgsIHIucm93LCBkaXNwbGF5U3RhcnQsIGRpc3BsYXlFbmQpLFxuXHQgICAgICAgIGV4cGFuZGVkUm93czogX3RoaXMyLnByb3BzLmV4cGFuZGVkUm93cyxcblx0ICAgICAgICBjZWxsTWV0YURhdGE6IF90aGlzMi5wcm9wcy5jZWxsTWV0YURhdGEsXG5cdCAgICAgICAgc3ViUm93RGV0YWlsczogci5zdWJSb3dEZXRhaWxzLFxuXHQgICAgICAgIGNvbFZpc2libGVTdGFydDogX3RoaXMyLnByb3BzLmNvbFZpc2libGVTdGFydCxcblx0ICAgICAgICBjb2xWaXNpYmxlRW5kOiBfdGhpczIucHJvcHMuY29sVmlzaWJsZUVuZCxcblx0ICAgICAgICBjb2xEaXNwbGF5U3RhcnQ6IF90aGlzMi5wcm9wcy5jb2xEaXNwbGF5U3RhcnQsXG5cdCAgICAgICAgY29sRGlzcGxheUVuZDogX3RoaXMyLnByb3BzLmNvbERpc3BsYXlFbmQsXG5cdCAgICAgICAgaXNTY3JvbGxpbmc6IF90aGlzMi5wcm9wcy5pc1Njcm9sbGluZ1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXG5cdCAgICB0aGlzLl9jdXJyZW50Um93c0xlbmd0aCA9IHJvd3MubGVuZ3RoO1xuXG5cdCAgICBpZiAoZGlzcGxheVN0YXJ0ID4gMCkge1xuXHQgICAgICByb3dzLnVuc2hpZnQodGhpcy5yZW5kZXJQbGFjZWhvbGRlcigndG9wJywgZGlzcGxheVN0YXJ0ICogcm93SGVpZ2h0KSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyb3dzQ291bnQgLSBkaXNwbGF5RW5kID4gMCkge1xuXHQgICAgICByb3dzLnB1c2godGhpcy5yZW5kZXJQbGFjZWhvbGRlcignYm90dG9tJywgKHJvd3NDb3VudCAtIGRpc3BsYXlFbmQpICogcm93SGVpZ2h0KSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdHlsZSA9IHtcblx0ICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdCAgICAgIHRvcDogMCxcblx0ICAgICAgbGVmdDogMCxcblx0ICAgICAgb3ZlcmZsb3dYOiAnYXV0bycsXG5cdCAgICAgIG92ZXJmbG93WTogJ3Njcm9sbCcsXG5cdCAgICAgIHdpZHRoOiB0aGlzLnByb3BzLnRvdGFsV2lkdGgsXG5cdCAgICAgIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHRcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAnZGl2Jyxcblx0ICAgICAge1xuXHQgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGRpdikge1xuXHQgICAgICAgICAgX3RoaXMyLmNhbnZhcyA9IGRpdjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN0eWxlOiBzdHlsZSxcblx0ICAgICAgICBvblNjcm9sbDogdGhpcy5vblNjcm9sbCxcblx0ICAgICAgICBjbGFzc05hbWU6IGpvaW5DbGFzc2VzKCdyZWFjdC1ncmlkLUNhbnZhcycsIHRoaXMucHJvcHMuY2xhc3NOYW1lLCB7IG9wYXF1ZTogdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQgJiYgdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQuYWN0aXZlIH0pIH0sXG5cdCAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX1Jvd3NDb250YWluZXIyWydkZWZhdWx0J10sIHtcblx0ICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCxcblx0ICAgICAgICByb3dzOiByb3dzLFxuXHQgICAgICAgIGNvbnRleHRNZW51OiB0aGlzLnByb3BzLmNvbnRleHRNZW51LFxuXHQgICAgICAgIHJvd0lkeDogdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQucm93SWR4LFxuXHQgICAgICAgIGlkeDogdGhpcy5wcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQuaWR4IH0pXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ2FudmFzO1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0Q2FudmFzLmRpc3BsYXlOYW1lID0gJ0NhbnZhcyc7XG5cdENhbnZhcy5wcm9wVHlwZXMgPSB7XG5cdCAgcm93UmVuZGVyZXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZWxlbWVudF0pLFxuXHQgIHJvd0hlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgd2lkdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHRvdGFsV2lkdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlciwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmddKSxcblx0ICBzdHlsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBkaXNwbGF5U3RhcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgZGlzcGxheUVuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICB2aXNpYmxlU3RhcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgdmlzaWJsZUVuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBjb2xWaXNpYmxlU3RhcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sVmlzaWJsZUVuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBjb2xEaXNwbGF5U3RhcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sRGlzcGxheUVuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICByb3dzQ291bnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgcm93R2V0dGVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXkuaXNSZXF1aXJlZF0pLFxuXHQgIGV4cGFuZGVkUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheSxcblx0ICBvblJvd3M6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvblNjcm9sbDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGNvbHVtbnM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheV0pLmlzUmVxdWlyZWQsXG5cdCAgY2VsbE1ldGFEYXRhOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKGNlbGxNZXRhRGF0YVNoYXBlKS5pc1JlcXVpcmVkLFxuXHQgIHNlbGVjdGVkUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheSxcblx0ICByb3dLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIHJvd1Njcm9sbFRpbWVvdXQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHNjcm9sbFRvUm93SW5kZXg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGNvbnRleHRNZW51OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmVsZW1lbnQsXG5cdCAgZ2V0U3ViUm93RGV0YWlsczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIHJvd1NlbGVjdGlvbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoe1xuXHQgICAgaW5kZXhlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheU9mKF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyKS5pc1JlcXVpcmVkXG5cdCAgfSksIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoe1xuXHQgICAgaXNTZWxlY3RlZEtleTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZFxuXHQgIH0pLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgIGtleXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoe1xuXHQgICAgICB2YWx1ZXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXkuaXNSZXF1aXJlZCxcblx0ICAgICAgcm93S2V5OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkXG5cdCAgICB9KS5pc1JlcXVpcmVkXG5cdCAgfSldKSxcblx0ICByb3dHcm91cFJlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgaXNTY3JvbGxpbmc6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCxcblx0ICBsZW5ndGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyXG5cdH07XG5cdENhbnZhcy5kZWZhdWx0UHJvcHMgPSB7XG5cdCAgcm93UmVuZGVyZXI6IFJvdyxcblx0ICBvblJvd3M6IGZ1bmN0aW9uIG9uUm93cygpIHt9LFxuXHQgIHNlbGVjdGVkUm93czogW10sXG5cdCAgcm93U2Nyb2xsVGltZW91dDogMFxuXHR9O1xuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG5cbi8qKiovIH0pLFxuLyogMTA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc25hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHR2YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cblx0dmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblx0dmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0dmFyIF9DZWxsQWN0aW9uU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cblx0dmFyIF9DZWxsQWN0aW9uU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2VsbEFjdGlvblNoYXBlKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgQ2VsbEFjdGlvbiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKENlbGxBY3Rpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gQ2VsbEFjdGlvbigpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsQWN0aW9uKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0geyBpc01lbnVPcGVuOiBmYWxzZSB9LCBfdGhpcy5vblRvZ2dsZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcblx0ICAgICAgICByZXR1cm4geyBpc01lbnVPcGVuOiAhcHJldlN0YXRlLmlzTWVudU9wZW4gfTtcblx0ICAgICAgfSk7XG5cdCAgICB9LCBfdGhpcy5vbkhpZGVNZW51ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzTWVudU9wZW46IGZhbHNlIH0pO1xuXHQgICAgfSwgX3RoaXMub25HZXRNZW51T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmFjdGlvbi5hY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uLCBpbmRleCkge1xuXHQgICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAgICdzcGFuJyxcblx0ICAgICAgICAgIHsga2V5OiBpbmRleCwgb25DbGljazogYWN0aW9uLmNhbGxiYWNrIH0sXG5cdCAgICAgICAgICBhY3Rpb24udGV4dFxuXHQgICAgICAgICk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgX3RoaXMuaXNBY3Rpb25NZW51ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gIV90aGlzLnByb3BzLmFjdGlvbi5jYWxsYmFjayAmJiBfdGhpcy5wcm9wcy5hY3Rpb24uYWN0aW9ucyAmJiBfdGhpcy5wcm9wcy5hY3Rpb24uYWN0aW9ucy5sZW5ndGg7XG5cdCAgICB9LCBfdGhpcy5vbkFjdGlvbkJ1dHRvbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpcy5pc0FjdGlvbk1lbnUoKSkge1xuXHQgICAgICAgIF90aGlzLm9uSGlkZU1lbnUoKTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25BY3Rpb25JY29uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghX3RoaXMuaXNBY3Rpb25NZW51KCkpIHtcblx0ICAgICAgICBfdGhpcy5wcm9wcy5hY3Rpb24uY2FsbGJhY2soKTtcblx0ICAgICAgfSBlbHNlIGlmIChfdGhpcy5wcm9wcy5hY3Rpb24uYWN0aW9ucyAmJiBfdGhpcy5wcm9wcy5hY3Rpb24uYWN0aW9ucy5sZW5ndGgpIHtcblx0ICAgICAgICBfdGhpcy5vblRvZ2dsZU1lbnUoKTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG5cdCAgfVxuXG5cdCAgQ2VsbEFjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgdmFyIGlzQWN0aW9uTWVudSA9IHRoaXMuaXNBY3Rpb25NZW51KCk7XG5cblx0ICAgIHZhciBjZWxsQWN0aW9uQ2xhc3NlcyA9ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoJ3JkZy1jZWxsLWFjdGlvbicsIHtcblx0ICAgICAgJ3JkZy1jZWxsLWFjdGlvbi1sYXN0JzogdGhpcy5wcm9wcy5pc0ZpcnN0XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIGFjdGlvbkJ1dHRvbkNsYXNzZXMgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKCdyZGctY2VsbC1hY3Rpb24tYnV0dG9uJywge1xuXHQgICAgICAncmRnLWNlbGwtYWN0aW9uLWJ1dHRvbi10b2dnbGVkJzogdGhpcy5zdGF0ZS5pc01lbnVPcGVuXG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAnZGl2Jyxcblx0ICAgICAgeyBjbGFzc05hbWU6IGNlbGxBY3Rpb25DbGFzc2VzLCBvbk1vdXNlTGVhdmU6IHRoaXMub25BY3Rpb25CdXR0b25CbHVyIH0sXG5cdCAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsgY2xhc3NOYW1lOiBhY3Rpb25CdXR0b25DbGFzc2VzLCBvbkNsaWNrOiB0aGlzLm9uQWN0aW9uSWNvbkNsaWNrIH0sXG5cdCAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5hY3Rpb24uaWNvbiB9KVxuXHQgICAgICApLFxuXHQgICAgICBpc0FjdGlvbk1lbnUgJiYgdGhpcy5zdGF0ZS5pc01lbnVPcGVuICYmIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsgY2xhc3NOYW1lOiAncmRnLWNlbGwtYWN0aW9uLW1lbnUnIH0sXG5cdCAgICAgICAgdGhpcy5vbkdldE1lbnVPcHRpb25zKClcblx0ICAgICAgKVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENlbGxBY3Rpb247XG5cdH0oX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cblx0Q2VsbEFjdGlvbi5wcm9wVHlwZXMgPSB7XG5cdCAgYWN0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKF9DZWxsQWN0aW9uU2hhcGUyWydkZWZhdWx0J10pLmlzUmVxdWlyZWQsXG5cdCAgaXNGaXJzdDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLmlzUmVxdWlyZWRcblx0fTtcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gQ2VsbEFjdGlvbjtcblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHR2YXIgX0FwcENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuXG5cdHZhciBfQXBwQ29uc3RhbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwcENvbnN0YW50cyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIENlbGxFeHBhbmQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhDZWxsRXhwYW5kLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIENlbGxFeHBhbmQocHJvcHMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsRXhwYW5kKTtcblxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cblx0ICAgIF90aGlzLm9uQ2VsbEV4cGFuZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHsgZXhwYW5kZWQ6ICFfdGhpcy5zdGF0ZS5leHBhbmRlZCB9KTtcblx0ICAgICAgX3RoaXMucHJvcHMub25DZWxsRXhwYW5kKGUpO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMgJiYgcHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMuZXhwYW5kZWQ7XG5cdCAgICBfdGhpcy5zdGF0ZSA9IHsgZXhwYW5kZWQ6IGV4cGFuZGVkIH07XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXG5cdCAgQ2VsbEV4cGFuZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG5cdCAgICB2YXIgZXhwYW5kZWQgPSBuZXh0UHJvcHMuZXhwYW5kYWJsZU9wdGlvbnMgJiYgbmV4dFByb3BzLmV4cGFuZGFibGVPcHRpb25zLmV4cGFuZGVkO1xuXHQgICAgaWYgKHRoaXMuc3RhdGUuZXhwYW5kZWQgIT09IGV4cGFuZGVkKSB7XG5cdCAgICAgIHRoaXMuc2V0U3RhdGUoeyBleHBhbmRlZDogZXhwYW5kZWQgfSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIENlbGxFeHBhbmQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ3NwYW4nLFxuXHQgICAgICB7IGNsYXNzTmFtZTogJ3JkZy1jZWxsLWV4cGFuZCcsIG9uQ2xpY2s6IHRoaXMub25DZWxsRXhwYW5kIH0sXG5cdCAgICAgIHRoaXMuc3RhdGUuZXhwYW5kZWQgPyBfQXBwQ29uc3RhbnRzMlsnZGVmYXVsdCddLkNlbGxFeHBhbmQuRE9XTl9UUklBTkdMRSA6IF9BcHBDb25zdGFudHMyWydkZWZhdWx0J10uQ2VsbEV4cGFuZC5SSUdIVF9UUklBTkdMRVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENlbGxFeHBhbmQ7XG5cdH0oX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cblx0Q2VsbEV4cGFuZC5wcm9wVHlwZXMgPSB7XG5cdCAgZXhwYW5kYWJsZU9wdGlvbnM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LmlzUmVxdWlyZWQsXG5cdCAgb25DZWxsRXhwYW5kOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZFxuXHR9O1xuXHRleHBvcnRzWydkZWZhdWx0J10gPSBDZWxsRXhwYW5kO1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5cdHZhciBfY2xhc3NuYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0dmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHR2YXIgQ2hpbGRSb3dEZWxldGVCdXR0b24gPSBmdW5jdGlvbiBDaGlsZFJvd0RlbGV0ZUJ1dHRvbihfcmVmKSB7XG5cdCAgdmFyIHRyZWVEZXB0aCA9IF9yZWYudHJlZURlcHRoLFxuXHQgICAgICBjZWxsSGVpZ2h0ID0gX3JlZi5jZWxsSGVpZ2h0LFxuXHQgICAgICBzaWJsaW5nSW5kZXggPSBfcmVmLnNpYmxpbmdJbmRleCxcblx0ICAgICAgbnVtYmVyU2libGluZ3MgPSBfcmVmLm51bWJlclNpYmxpbmdzLFxuXHQgICAgICBvbkRlbGV0ZVN1YlJvdyA9IF9yZWYub25EZWxldGVTdWJSb3csXG5cdCAgICAgIGlzRGVsZXRlU3ViUm93RW5hYmxlZCA9IF9yZWYuaXNEZWxldGVTdWJSb3dFbmFibGVkLFxuXHQgICAgICBfcmVmJGFsbG93QWRkQ2hpbGRSb3cgPSBfcmVmLmFsbG93QWRkQ2hpbGRSb3csXG5cdCAgICAgIGFsbG93QWRkQ2hpbGRSb3cgPSBfcmVmJGFsbG93QWRkQ2hpbGRSb3cgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJGFsbG93QWRkQ2hpbGRSb3c7XG5cblx0ICB2YXIgbGFzdFNpYmxpbmcgPSBzaWJsaW5nSW5kZXggPT09IG51bWJlclNpYmxpbmdzIC0gMTtcblx0ICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKSh7ICdyZGctY2hpbGQtcm93LWFjdGlvbi1jcm9zcyc6IGFsbG93QWRkQ2hpbGRSb3cgPT09IHRydWUgfHwgIWxhc3RTaWJsaW5nIH0sIHsgJ3JkZy1jaGlsZC1yb3ctYWN0aW9uLWNyb3NzLWxhc3QnOiBhbGxvd0FkZENoaWxkUm93ID09PSBmYWxzZSAmJiAobGFzdFNpYmxpbmcgfHwgbnVtYmVyU2libGluZ3MgPT09IDEpIH0pO1xuXHQgIHZhciBoZWlnaHQgPSAxMjtcblx0ICB2YXIgd2lkdGggPSAxMjtcblx0ICB2YXIgbGVmdCA9IHRyZWVEZXB0aCAqIDE1O1xuXHQgIHZhciB0b3AgPSAoY2VsbEhlaWdodCAtIDEyKSAvIDI7XG5cdCAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgJ2RpdicsXG5cdCAgICBudWxsLFxuXHQgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSksXG5cdCAgICBpc0RlbGV0ZVN1YlJvd0VuYWJsZWQgJiYgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IHN0eWxlOiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIGNsYXNzTmFtZTogJ3JkZy1jaGlsZC1yb3ctYnRuJywgb25DbGljazogb25EZWxldGVTdWJSb3cgfSxcblx0ICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUtc2lnbicgfSlcblx0ICAgIClcblx0ICApO1xuXHR9O1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IENoaWxkUm93RGVsZXRlQnV0dG9uO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaXNWYWxpZEVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLmlzVmFsaWRFbGVtZW50O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FtZUNvbHVtbihhLCBiKSB7XG5cdCAgdmFyIGsgPSB2b2lkIDA7XG5cblx0ICBmb3IgKGsgaW4gYSkge1xuXHQgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoaykpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBhW2tdID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiW2tdID09PSAnZnVuY3Rpb24nIHx8IGlzVmFsaWRFbGVtZW50KGFba10pICYmIGlzVmFsaWRFbGVtZW50KGJba10pKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGspIHx8IGFba10gIT09IGJba10pIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBmb3IgKGsgaW4gYikge1xuXHQgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaykgJiYgIWEuaGFzT3duUHJvcGVydHkoaykpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblx0dmFyIGNyZWF0ZU9iamVjdFdpdGhQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5cdC8vIFRoZSBsaXN0IG9mIHRoZSBwcm9wVHlwZXMgdGhhdCB3ZSB3YW50IHRvIGluY2x1ZGUgaW4gdGhlIERyYWdnYWJsZSBkaXZcblx0dmFyIGtub3duRGl2UHJvcGVydHlLZXlzID0gWydvbkRyYWdTdGFydCcsICdvbkRyYWdFbmQnLCAnb25EcmFnJywgJ3N0eWxlJ107XG5cblx0dmFyIERyYWdnYWJsZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKERyYWdnYWJsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cdCAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ2dhYmxlKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICBkcmFnOiBudWxsXG5cdCAgICB9LCBfdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBkcmFnID0gX3RoaXMucHJvcHMub25EcmFnU3RhcnQoZSk7XG5cdCAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG5cdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGRyYWcgPT09IG51bGwgJiYgZS5idXR0b24gIT09IDApIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLm9uTW91c2VVcCk7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5vbk1vdXNlTW92ZSk7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLm9uTW91c2VVcCk7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5vbk1vdXNlTW92ZSk7XG5cblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoeyBkcmFnOiBkcmFnIH0pO1xuXHQgICAgfSwgX3RoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoX3RoaXMuc3RhdGUuZHJhZyA9PT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG5cdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMucHJvcHMub25EcmFnKGUpO1xuXHQgICAgfSwgX3RoaXMub25Nb3VzZVVwID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMuY2xlYW5VcCgpO1xuXHQgICAgICBfdGhpcy5wcm9wcy5vbkRyYWdFbmQoZSwgX3RoaXMuc3RhdGUuZHJhZyk7XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZzogbnVsbCB9KTtcblx0ICAgIH0sIF90aGlzLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMub25Nb3VzZVVwKTtcblx0ICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLm9uTW91c2VNb3ZlKTtcblx0ICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMub25Nb3VzZVVwKTtcblx0ICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLm9uTW91c2VNb3ZlKTtcblx0ICAgIH0sIF90aGlzLmdldEtub3duRGl2UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBjcmVhdGVPYmplY3RXaXRoUHJvcGVydGllcyhfdGhpcy5wcm9wcywga25vd25EaXZQcm9wZXJ0eUtleXMpO1xuXHQgICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG5cdCAgfVxuXG5cdCAgRHJhZ2dhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgdGhpcy5jbGVhblVwKCk7XG5cdCAgfTtcblxuXHQgIERyYWdnYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIF9leHRlbmRzKHt9LCB0aGlzLmdldEtub3duRGl2UHJvcHMoKSwge1xuXHQgICAgICBvbk1vdXNlRG93bjogdGhpcy5vbk1vdXNlRG93bixcblx0ICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLm9uTW91c2VEb3duLFxuXHQgICAgICBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLUhlYWRlckNlbGxfX2RyYWdnYWJsZScgfSkpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gRHJhZ2dhYmxlO1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0RHJhZ2dhYmxlLnByb3BUeXBlcyA9IHtcblx0ICBvbkRyYWdTdGFydDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uRHJhZ0VuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uRHJhZzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGNvbXBvbmVudDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5jb25zdHJ1Y3Rvcl0pLFxuXHQgIHN0eWxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdFxuXHR9O1xuXHREcmFnZ2FibGUuZGVmYXVsdFByb3BzID0ge1xuXHQgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgb25EcmFnRW5kOiBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7fSxcblx0ICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9XG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHR2YXIgX0NvbHVtblV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHR2YXIgX0NvbHVtblV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbHVtblV0aWxzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgRW1wdHlDaGlsZFJvdyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKEVtcHR5Q2hpbGRSb3csIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gRW1wdHlDaGlsZFJvdygpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbXB0eUNoaWxkUm93KTtcblxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMpKTtcblxuXHQgICAgX3RoaXMub25BZGRTdWJSb3cgPSBfdGhpcy5vbkFkZFN1YlJvdy5iaW5kKF90aGlzKTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICBFbXB0eUNoaWxkUm93LnByb3RvdHlwZS5vbkFkZFN1YlJvdyA9IGZ1bmN0aW9uIG9uQWRkU3ViUm93KCkge1xuXHQgICAgdGhpcy5wcm9wcy5vbkFkZFN1YlJvdyh0aGlzLnByb3BzLnBhcmVudFJvd0lkKTtcblx0ICB9O1xuXG5cdCAgRW1wdHlDaGlsZFJvdy5wcm90b3R5cGUuZ2V0Rml4ZWRDb2x1bW5zV2lkdGggPSBmdW5jdGlvbiBnZXRGaXhlZENvbHVtbnNXaWR0aCgpIHtcblx0ICAgIHZhciBmaXhlZFdpZHRoID0gMDtcblx0ICAgIHZhciBzaXplID0gX0NvbHVtblV0aWxzMlsnZGVmYXVsdCddLmdldFNpemUodGhpcy5wcm9wcy5jb2x1bW5zKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG5cdCAgICAgIHZhciBjb2x1bW4gPSBfQ29sdW1uVXRpbHMyWydkZWZhdWx0J10uZ2V0Q29sdW1uKHRoaXMucHJvcHMuY29sdW1ucywgaSk7XG5cdCAgICAgIGlmIChjb2x1bW4pIHtcblx0ICAgICAgICBpZiAoX0NvbHVtblV0aWxzMlsnZGVmYXVsdCddLmdldFZhbHVlKGNvbHVtbiwgJ2xvY2tlZCcpKSB7XG5cdCAgICAgICAgICBmaXhlZFdpZHRoICs9IF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRWYWx1ZShjb2x1bW4sICd3aWR0aCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZpeGVkV2lkdGg7XG5cdCAgfTtcblxuXHQgIEVtcHR5Q2hpbGRSb3cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcblx0ICAgICAgICBjZWxsSGVpZ2h0ID0gX3Byb3BzLmNlbGxIZWlnaHQsXG5cdCAgICAgICAgdHJlZURlcHRoID0gX3Byb3BzLnRyZWVEZXB0aDtcblxuXHQgICAgdmFyIGhlaWdodCA9IDEyO1xuXHQgICAgdmFyIHdpZHRoID0gMTI7XG5cdCAgICB2YXIgbGVmdCA9IHRyZWVEZXB0aCAqIDE1O1xuXHQgICAgdmFyIHRvcCA9IChjZWxsSGVpZ2h0IC0gMTIpIC8gMjtcblx0ICAgIHZhciBzdHlsZSA9IHtcblx0ICAgICAgaGVpZ2h0OiBjZWxsSGVpZ2h0LFxuXHQgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgI2RkZGRkZCdcblx0ICAgIH07XG5cdCAgICB2YXIgZXhwYW5kQ29sdW1uID0gX0NvbHVtblV0aWxzMlsnZGVmYXVsdCddLmdldENvbHVtbih0aGlzLnByb3BzLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgIHJldHVybiBjLmtleSA9PT0gX3RoaXMyLnByb3BzLmV4cGFuZENvbHVtbktleTtcblx0ICAgIH0pLCAwKTtcblxuXHQgICAgdmFyIGNlbGxMZWZ0ID0gZXhwYW5kQ29sdW1uID8gZXhwYW5kQ29sdW1uLmxlZnQgOiAwO1xuXHQgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAnZGl2Jyxcblx0ICAgICAgeyBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLVJvdyByZGctYWRkLWNoaWxkLXJvdy1jb250YWluZXInLCBzdHlsZTogc3R5bGUgfSxcblx0ICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICAgJ2RpdicsXG5cdCAgICAgICAgeyBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLUNlbGwnLCBzdHlsZTogeyBwb3NpdGlvbjogJ2Fic29sdXRlJywgaGVpZ2h0OiBjZWxsSGVpZ2h0LCB3aWR0aDogJzEwMCUnLCBsZWZ0OiBjZWxsTGVmdCB9IH0sXG5cdCAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICAgICAnZGl2Jyxcblx0ICAgICAgICAgIHsgY2xhc3NOYW1lOiAncmRnLWVtcHR5LWNoaWxkLXJvdycsIHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICczMHB4JywgbGluZUhlaWdodDogY2VsbEhlaWdodCArICdweCcgfSB9LFxuXHQgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnXFwncmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3MgcmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3MtbGFzdCcgfSksXG5cdCAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAgICAgJ2RpdicsXG5cdCAgICAgICAgICAgIHsgc3R5bGU6IHsgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgY2xhc3NOYW1lOiAncmRnLWNoaWxkLXJvdy1idG4nLCBvbkNsaWNrOiB0aGlzLm9uQWRkU3ViUm93IH0sXG5cdCAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2dseXBoaWNvbiBnbHlwaGljb24tcGx1cy1zaWduJyB9KVxuXHQgICAgICAgICAgKVxuXHQgICAgICAgIClcblx0ICAgICAgKVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVtcHR5Q2hpbGRSb3c7XG5cdH0oX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cblx0RW1wdHlDaGlsZFJvdy5wcm9wVHlwZXMgPSB7XG5cdCAgdHJlZURlcHRoOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGNlbGxIZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgb25BZGRTdWJSb3c6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYy5pc1JlcXVpcmVkLFxuXHQgIHBhcmVudFJvd0lkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBjb2x1bW5zOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LmlzUmVxdWlyZWQsXG5cdCAgZXhwYW5kQ29sdW1uS2V5OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkXG5cdH07XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gRW1wdHlDaGlsZFJvdztcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIFJlYWN0RE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHR2YXIgSGVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTIpO1xuXHR2YXIgVmlld3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMik7XG5cdHZhciBjZWxsTWV0YURhdGFTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHR2YXIgR3JpZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKEdyaWQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gR3JpZCgpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcblx0ICAgICAgICBvdXRsaW5lOiAwLFxuXHQgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHQgICAgICAgIG1pbkhlaWdodDogX3RoaXMucHJvcHMubWluSGVpZ2h0XG5cdCAgICAgIH07XG5cdCAgICB9LCBfdGhpcy5fb25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpcy5fc2Nyb2xsTGVmdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgX3RoaXMuaGVhZGVyLnNldFNjcm9sbExlZnQoX3RoaXMuX3Njcm9sbExlZnQpO1xuXHQgICAgICAgIGlmIChfdGhpcy52aWV3cG9ydCkge1xuXHQgICAgICAgICAgX3RoaXMudmlld3BvcnQuc2V0U2Nyb2xsTGVmdChfdGhpcy5fc2Nyb2xsTGVmdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHQgICAgICBpZiAoX3RoaXMuX3Njcm9sbExlZnQgIT09IHByb3BzLnNjcm9sbExlZnQpIHtcblx0ICAgICAgICBfdGhpcy5fc2Nyb2xsTGVmdCA9IHByb3BzLnNjcm9sbExlZnQ7XG5cdCAgICAgICAgX3RoaXMuX29uU2Nyb2xsKCk7XG5cdCAgICAgIH1cblx0ICAgIH0sIF90aGlzLm9uSGVhZGVyU2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHNjcm9sbExlZnQgPSBlLnRhcmdldC5zY3JvbGxMZWZ0O1xuXHQgICAgICBpZiAoX3RoaXMuX3Njcm9sbExlZnQgIT09IHNjcm9sbExlZnQpIHtcblx0ICAgICAgICBfdGhpcy5fc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdCAgICAgICAgX3RoaXMuaGVhZGVyLnNldFNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG5cdCAgICAgICAgdmFyIGNhbnZhcyA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKF90aGlzLnZpZXdwb3J0LmNhbnZhcyk7XG5cdCAgICAgICAgY2FudmFzLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHQgICAgICAgIF90aGlzLnZpZXdwb3J0LmNhbnZhcy5zZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBHcmlkLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHQgICAgdGhpcy5fc2Nyb2xsTGVmdCA9IHRoaXMudmlld3BvcnQgPyB0aGlzLnZpZXdwb3J0LmdldFNjcm9sbCgpLnNjcm9sbExlZnQgOiAwO1xuXHQgICAgdGhpcy5fb25TY3JvbGwoKTtcblx0ICB9O1xuXG5cdCAgR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuXHQgICAgdGhpcy5fb25TY3JvbGwoKTtcblx0ICB9O1xuXG5cdCAgR3JpZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuXHQgICAgdGhpcy5fc2Nyb2xsTGVmdCA9IHVuZGVmaW5lZDtcblx0ICB9O1xuXG5cdCAgR3JpZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0ICAgIHRoaXMuX3Njcm9sbExlZnQgPSB1bmRlZmluZWQ7XG5cdCAgfTtcblxuXHQgIEdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMucHJvcHMuaGVhZGVyUm93cyB8fCBbeyByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzMi5yb3cgPSBub2RlO1xuXHQgICAgICB9IH1dO1xuXHQgICAgdmFyIEVtcHR5Um93c1ZpZXcgPSB0aGlzLnByb3BzLmVtcHR5Um93c1ZpZXc7XG5cblx0ICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAnZGl2Jyxcblx0ICAgICAgeyBzdHlsZTogdGhpcy5nZXRTdHlsZSgpLCBjbGFzc05hbWU6ICdyZWFjdC1ncmlkLUdyaWQnIH0sXG5cdCAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyLCB7XG5cdCAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoaW5wdXQpIHtcblx0ICAgICAgICAgIF90aGlzMi5oZWFkZXIgPSBpbnB1dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNvbHVtbk1ldHJpY3M6IHRoaXMucHJvcHMuY29sdW1uTWV0cmljcyxcblx0ICAgICAgICBvbkNvbHVtblJlc2l6ZTogdGhpcy5wcm9wcy5vbkNvbHVtblJlc2l6ZSxcblx0ICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMucm93SGVpZ2h0LFxuXHQgICAgICAgIHRvdGFsV2lkdGg6IHRoaXMucHJvcHMudG90YWxXaWR0aCxcblx0ICAgICAgICBoZWFkZXJSb3dzOiBoZWFkZXJSb3dzLFxuXHQgICAgICAgIHNvcnRDb2x1bW46IHRoaXMucHJvcHMuc29ydENvbHVtbixcblx0ICAgICAgICBzb3J0RGlyZWN0aW9uOiB0aGlzLnByb3BzLnNvcnREaXJlY3Rpb24sXG5cdCAgICAgICAgZHJhZ2dhYmxlSGVhZGVyQ2VsbDogdGhpcy5wcm9wcy5kcmFnZ2FibGVIZWFkZXJDZWxsLFxuXHQgICAgICAgIG9uU29ydDogdGhpcy5wcm9wcy5vblNvcnQsXG5cdCAgICAgICAgb25IZWFkZXJEcm9wOiB0aGlzLnByb3BzLm9uSGVhZGVyRHJvcCxcblx0ICAgICAgICBvblNjcm9sbDogdGhpcy5vbkhlYWRlclNjcm9sbCxcblx0ICAgICAgICBnZXRWYWxpZEZpbHRlclZhbHVlczogdGhpcy5wcm9wcy5nZXRWYWxpZEZpbHRlclZhbHVlcyxcblx0ICAgICAgICBjZWxsTWV0YURhdGE6IHRoaXMucHJvcHMuY2VsbE1ldGFEYXRhXG5cdCAgICAgIH0pLFxuXHQgICAgICB0aGlzLnByb3BzLnJvd3NDb3VudCA+PSAxIHx8IHRoaXMucHJvcHMucm93c0NvdW50ID09PSAwICYmICF0aGlzLnByb3BzLmVtcHR5Um93c1ZpZXcgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcblx0ICAgICAgICAgICAgX3RoaXMyLnZpZXdQb3J0Q29udGFpbmVyID0gbm9kZTtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICB0YWJJbmRleDogdGhpcy5wcm9wcy50YWJJbmRleCxcblx0ICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5wcm9wcy5vblZpZXdwb3J0S2V5ZG93bixcblx0ICAgICAgICAgIG9uS2V5VXA6IHRoaXMucHJvcHMub25WaWV3cG9ydEtleXVwLFxuXHQgICAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy5vblZpZXdwb3J0Q2xpY2ssXG5cdCAgICAgICAgICBvbkRvdWJsZUNsaWNrOiB0aGlzLnByb3BzLm9uVmlld3BvcnREb3VibGVDbGljayxcblx0ICAgICAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLnByb3BzLm9uVmlld3BvcnREcmFnU3RhcnQsXG5cdCAgICAgICAgICBvbkRyYWdFbmQ6IHRoaXMucHJvcHMub25WaWV3cG9ydERyYWdFbmQgfSxcblx0ICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdwb3J0LCB7XG5cdCAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgICAgIF90aGlzMi52aWV3cG9ydCA9IG5vZGU7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgcm93S2V5OiB0aGlzLnByb3BzLnJvd0tleSxcblx0ICAgICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLmNvbHVtbk1ldHJpY3Mud2lkdGgsXG5cdCAgICAgICAgICByb3dIZWlnaHQ6IHRoaXMucHJvcHMucm93SGVpZ2h0LFxuXHQgICAgICAgICAgcm93UmVuZGVyZXI6IHRoaXMucHJvcHMucm93UmVuZGVyZXIsXG5cdCAgICAgICAgICByb3dHZXR0ZXI6IHRoaXMucHJvcHMucm93R2V0dGVyLFxuXHQgICAgICAgICAgcm93c0NvdW50OiB0aGlzLnByb3BzLnJvd3NDb3VudCxcblx0ICAgICAgICAgIHNlbGVjdGVkUm93czogdGhpcy5wcm9wcy5zZWxlY3RlZFJvd3MsXG5cdCAgICAgICAgICBleHBhbmRlZFJvd3M6IHRoaXMucHJvcHMuZXhwYW5kZWRSb3dzLFxuXHQgICAgICAgICAgY29sdW1uTWV0cmljczogdGhpcy5wcm9wcy5jb2x1bW5NZXRyaWNzLFxuXHQgICAgICAgICAgdG90YWxXaWR0aDogdGhpcy5wcm9wcy50b3RhbFdpZHRoLFxuXHQgICAgICAgICAgb25TY3JvbGw6IHRoaXMub25TY3JvbGwsXG5cdCAgICAgICAgICBvblJvd3M6IHRoaXMucHJvcHMub25Sb3dzLFxuXHQgICAgICAgICAgY2VsbE1ldGFEYXRhOiB0aGlzLnByb3BzLmNlbGxNZXRhRGF0YSxcblx0ICAgICAgICAgIHJvd09mZnNldEhlaWdodDogdGhpcy5wcm9wcy5yb3dPZmZzZXRIZWlnaHQgfHwgdGhpcy5wcm9wcy5yb3dIZWlnaHQgKiBoZWFkZXJSb3dzLmxlbmd0aCxcblx0ICAgICAgICAgIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsXG5cdCAgICAgICAgICByb3dTY3JvbGxUaW1lb3V0OiB0aGlzLnByb3BzLnJvd1Njcm9sbFRpbWVvdXQsXG5cdCAgICAgICAgICBzY3JvbGxUb1Jvd0luZGV4OiB0aGlzLnByb3BzLnNjcm9sbFRvUm93SW5kZXgsXG5cdCAgICAgICAgICBjb250ZXh0TWVudTogdGhpcy5wcm9wcy5jb250ZXh0TWVudSxcblx0ICAgICAgICAgIHJvd1NlbGVjdGlvbjogdGhpcy5wcm9wcy5yb3dTZWxlY3Rpb24sXG5cdCAgICAgICAgICBnZXRTdWJSb3dEZXRhaWxzOiB0aGlzLnByb3BzLmdldFN1YlJvd0RldGFpbHMsXG5cdCAgICAgICAgICByb3dHcm91cFJlbmRlcmVyOiB0aGlzLnByb3BzLnJvd0dyb3VwUmVuZGVyZXIsXG5cdCAgICAgICAgICBvdmVyU2NhbjogdGhpcy5wcm9wcy5vdmVyU2NhblxuXHQgICAgICAgIH0pXG5cdCAgICAgICkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgICBfdGhpczIuZW1wdHlWaWV3ID0gbm9kZTtcblx0ICAgICAgICAgIH0sIGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtRW1wdHknIH0sXG5cdCAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFbXB0eVJvd3NWaWV3LCBudWxsKVxuXHQgICAgICApXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gR3JpZDtcblx0fShSZWFjdC5Db21wb25lbnQpO1xuXG5cdEdyaWQuZGlzcGxheU5hbWUgPSAnR3JpZCc7XG5cdEdyaWQucHJvcFR5cGVzID0ge1xuXHQgIHJvd0dldHRlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXksIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuY10pLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXksIF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0XSksXG5cdCAgdGFiSW5kZXg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGNvbHVtbk1ldHJpY3M6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LFxuXHQgIG1pbkhlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgdG90YWxXaWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIGhlYWRlclJvd3M6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNdKSxcblx0ICByb3dIZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHJvd1JlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNdKSxcblx0ICBlbXB0eVJvd3NWaWV3OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgZXhwYW5kZWRSb3dzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXSksXG5cdCAgc2VsZWN0ZWRSb3dzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXSksXG5cdCAgcm93U2VsZWN0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBpbmRleGVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5T2YoX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIpLmlzUmVxdWlyZWRcblx0ICB9KSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBpc1NlbGVjdGVkS2V5OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkXG5cdCAgfSksIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoe1xuXHQgICAga2V5czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICAgIHZhbHVlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheS5pc1JlcXVpcmVkLFxuXHQgICAgICByb3dLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWRcblx0ICAgIH0pLmlzUmVxdWlyZWRcblx0ICB9KV0pLFxuXHQgIHJvd3NDb3VudDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgb25Sb3dzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgc29ydENvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgc29ydERpcmVjdGlvbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZihbJ0FTQycsICdERVNDJywgJ05PTkUnXSksXG5cdCAgcm93T2Zmc2V0SGVpZ2h0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIG9uVmlld3BvcnRLZXlkb3duOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBvblZpZXdwb3J0S2V5dXA6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvblZpZXdwb3J0RHJhZ1N0YXJ0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBvblZpZXdwb3J0RHJhZ0VuZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgb25WaWV3cG9ydENsaWNrOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBvblZpZXdwb3J0RG91YmxlQ2xpY2s6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYy5pc1JlcXVpcmVkLFxuXHQgIG9uQ29sdW1uUmVzaXplOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25Tb3J0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25IZWFkZXJEcm9wOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgY2VsbE1ldGFEYXRhOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKGNlbGxNZXRhRGF0YVNoYXBlKSxcblx0ICByb3dLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWQsXG5cdCAgcm93U2Nyb2xsVGltZW91dDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgc2Nyb2xsVG9Sb3dJbmRleDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgY29udGV4dE1lbnU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZWxlbWVudCxcblx0ICBnZXRTdWJSb3dEZXRhaWxzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgZHJhZ2dhYmxlSGVhZGVyQ2VsbDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGdldFZhbGlkRmlsdGVyVmFsdWVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgcm93R3JvdXBSZW5kZXJlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG92ZXJTY2FuOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdFxuXHR9O1xuXHRHcmlkLmRlZmF1bHRQcm9wcyA9IHtcblx0ICByb3dIZWlnaHQ6IDM1LFxuXHQgIG1pbkhlaWdodDogMzUwLFxuXHQgIHRhYkluZGV4OiAwXG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIFJlYWN0RE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIGpvaW5DbGFzc2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHNoYWxsb3dDbG9uZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXHR2YXIgQ29sdW1uTWV0cmljcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXHR2YXIgQ29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgSGVhZGVyUm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTQpO1xuXHR2YXIgZ2V0U2Nyb2xsYmFyU2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG5cdHZhciBjcmVhdGVPYmplY3RXaXRoUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR2YXIgY2VsbE1ldGFEYXRhU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cblx0Ly8gVGhlIGxpc3Qgb2YgdGhlIHByb3BUeXBlcyB0aGF0IHdlIHdhbnQgdG8gaW5jbHVkZSBpbiB0aGUgSGVhZGVyIGRpdlxuXHR2YXIga25vd25EaXZQcm9wZXJ0eUtleXMgPSBbJ2hlaWdodCcsICdvblNjcm9sbCddO1xuXG5cdHZhciBIZWFkZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhIZWFkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gSGVhZGVyKCkge1xuXHQgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlcik7XG5cblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHsgcmVzaXppbmc6IG51bGwgfSwgX3RoaXMub25Db2x1bW5SZXNpemUgPSBmdW5jdGlvbiAoY29sdW1uLCB3aWR0aCkge1xuXHQgICAgICB2YXIgc3RhdGUgPSBfdGhpcy5zdGF0ZS5yZXNpemluZyB8fCBfdGhpcy5wcm9wcztcblxuXHQgICAgICB2YXIgcG9zID0gX3RoaXMuZ2V0Q29sdW1uUG9zaXRpb24oY29sdW1uKTtcblxuXHQgICAgICBpZiAocG9zICE9IG51bGwpIHtcblx0ICAgICAgICB2YXIgX3Jlc2l6aW5nID0ge1xuXHQgICAgICAgICAgY29sdW1uTWV0cmljczogc2hhbGxvd0Nsb25lT2JqZWN0KHN0YXRlLmNvbHVtbk1ldHJpY3MpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfcmVzaXppbmcuY29sdW1uTWV0cmljcyA9IENvbHVtbk1ldHJpY3MucmVzaXplQ29sdW1uKF9yZXNpemluZy5jb2x1bW5NZXRyaWNzLCBwb3MsIHdpZHRoKTtcblxuXHQgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gaW5mbHVlbmNlIHNjcm9sbExlZnQgd2hpbGUgcmVzaXppbmdcblx0ICAgICAgICBpZiAoX3Jlc2l6aW5nLmNvbHVtbk1ldHJpY3MudG90YWxXaWR0aCA8IHN0YXRlLmNvbHVtbk1ldHJpY3MudG90YWxXaWR0aCkge1xuXHQgICAgICAgICAgX3Jlc2l6aW5nLmNvbHVtbk1ldHJpY3MudG90YWxXaWR0aCA9IHN0YXRlLmNvbHVtbk1ldHJpY3MudG90YWxXaWR0aDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBfcmVzaXppbmcuY29sdW1uID0gQ29sdW1uVXRpbHMuZ2V0Q29sdW1uKF9yZXNpemluZy5jb2x1bW5NZXRyaWNzLmNvbHVtbnMsIHBvcyk7XG5cdCAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyByZXNpemluZzogX3Jlc2l6aW5nIH0pO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5vbkNvbHVtblJlc2l6ZUVuZCA9IGZ1bmN0aW9uIChjb2x1bW4sIHdpZHRoKSB7XG5cdCAgICAgIHZhciBwb3MgPSBfdGhpcy5nZXRDb2x1bW5Qb3NpdGlvbihjb2x1bW4pO1xuXHQgICAgICBpZiAocG9zICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uQ29sdW1uUmVzaXplKSB7XG5cdCAgICAgICAgX3RoaXMucHJvcHMub25Db2x1bW5SZXNpemUocG9zLCB3aWR0aCB8fCBjb2x1bW4ud2lkdGgpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5nZXRIZWFkZXJSb3dzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgY29sdW1uTWV0cmljcyA9IF90aGlzLmdldENvbHVtbk1ldHJpY3MoKTtcblx0ICAgICAgdmFyIHJlc2l6ZUNvbHVtbiA9IHZvaWQgMDtcblx0ICAgICAgaWYgKF90aGlzLnN0YXRlLnJlc2l6aW5nKSB7XG5cdCAgICAgICAgcmVzaXplQ29sdW1uID0gX3RoaXMuc3RhdGUucmVzaXppbmcuY29sdW1uO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBoZWFkZXJSb3dzID0gW107XG5cdCAgICAgIF90aGlzLnByb3BzLmhlYWRlclJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuXHQgICAgICAgIC8vIFRvIGFsbG93IGhlYWRlciBmaWx0ZXJzIHRvIGJlIHZpc2libGVcblx0ICAgICAgICB2YXIgcm93SGVpZ2h0ID0gJ2F1dG8nO1xuXHQgICAgICAgIGlmIChyb3cucm93VHlwZSA9PT0gJ2ZpbHRlcicpIHtcblx0ICAgICAgICAgIHJvd0hlaWdodCA9ICc1MDBweCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gZ2V0U2Nyb2xsYmFyU2l6ZSgpID4gMCA/IGdldFNjcm9sbGJhclNpemUoKSA6IDA7XG5cdCAgICAgICAgdmFyIHVwZGF0ZWRXaWR0aCA9IGlzTmFOKF90aGlzLnByb3BzLnRvdGFsV2lkdGggLSBzY3JvbGxiYXJTaXplKSA/IF90aGlzLnByb3BzLnRvdGFsV2lkdGggOiBfdGhpcy5wcm9wcy50b3RhbFdpZHRoIC0gc2Nyb2xsYmFyU2l6ZTtcblx0ICAgICAgICB2YXIgaGVhZGVyUm93U3R5bGUgPSB7XG5cdCAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0ICAgICAgICAgIHRvcDogX3RoaXMuZ2V0Q29tYmluZWRIZWFkZXJIZWlnaHRzKGluZGV4KSxcblx0ICAgICAgICAgIGxlZnQ6IDAsXG5cdCAgICAgICAgICB3aWR0aDogdXBkYXRlZFdpZHRoLFxuXHQgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0ICAgICAgICAgIG1pbkhlaWdodDogcm93SGVpZ2h0XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIGhlYWRlclJvd3MucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlclJvdywge1xuXHQgICAgICAgICAga2V5OiByb3cucmVmLFxuXHQgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gcm93LnJvd1R5cGUgPT09ICdmaWx0ZXInID8gX3RoaXMuZmlsdGVyUm93ID0gbm9kZSA6IF90aGlzLnJvdyA9IG5vZGU7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgcm93VHlwZTogcm93LnJvd1R5cGUsXG5cdCAgICAgICAgICBzdHlsZTogaGVhZGVyUm93U3R5bGUsXG5cdCAgICAgICAgICBvbkNvbHVtblJlc2l6ZTogX3RoaXMub25Db2x1bW5SZXNpemUsXG5cdCAgICAgICAgICBvbkNvbHVtblJlc2l6ZUVuZDogX3RoaXMub25Db2x1bW5SZXNpemVFbmQsXG5cdCAgICAgICAgICB3aWR0aDogY29sdW1uTWV0cmljcy53aWR0aCxcblx0ICAgICAgICAgIGhlaWdodDogcm93LmhlaWdodCB8fCBfdGhpcy5wcm9wcy5oZWlnaHQsXG5cdCAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5NZXRyaWNzLmNvbHVtbnMsXG5cdCAgICAgICAgICByZXNpemluZzogcmVzaXplQ29sdW1uLFxuXHQgICAgICAgICAgZHJhZ2dhYmxlSGVhZGVyQ2VsbDogX3RoaXMucHJvcHMuZHJhZ2dhYmxlSGVhZGVyQ2VsbCxcblx0ICAgICAgICAgIGZpbHRlcmFibGU6IHJvdy5maWx0ZXJhYmxlLFxuXHQgICAgICAgICAgb25GaWx0ZXJDaGFuZ2U6IHJvdy5vbkZpbHRlckNoYW5nZSxcblx0ICAgICAgICAgIG9uSGVhZGVyRHJvcDogX3RoaXMucHJvcHMub25IZWFkZXJEcm9wLFxuXHQgICAgICAgICAgc29ydENvbHVtbjogX3RoaXMucHJvcHMuc29ydENvbHVtbixcblx0ICAgICAgICAgIHNvcnREaXJlY3Rpb246IF90aGlzLnByb3BzLnNvcnREaXJlY3Rpb24sXG5cdCAgICAgICAgICBvblNvcnQ6IF90aGlzLnByb3BzLm9uU29ydCxcblx0ICAgICAgICAgIG9uU2Nyb2xsOiBfdGhpcy5wcm9wcy5vblNjcm9sbCxcblx0ICAgICAgICAgIGdldFZhbGlkRmlsdGVyVmFsdWVzOiBfdGhpcy5wcm9wcy5nZXRWYWxpZEZpbHRlclZhbHVlc1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBoZWFkZXJSb3dzO1xuXHQgICAgfSwgX3RoaXMuZ2V0Q29sdW1uTWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGNvbHVtbk1ldHJpY3MgPSB2b2lkIDA7XG5cdCAgICAgIGlmIChfdGhpcy5zdGF0ZS5yZXNpemluZykge1xuXHQgICAgICAgIGNvbHVtbk1ldHJpY3MgPSBfdGhpcy5zdGF0ZS5yZXNpemluZy5jb2x1bW5NZXRyaWNzO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNvbHVtbk1ldHJpY3MgPSBfdGhpcy5wcm9wcy5jb2x1bW5NZXRyaWNzO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjb2x1bW5NZXRyaWNzO1xuXHQgICAgfSwgX3RoaXMuZ2V0Q29sdW1uUG9zaXRpb24gPSBmdW5jdGlvbiAoY29sdW1uKSB7XG5cdCAgICAgIHZhciBjb2x1bW5NZXRyaWNzID0gX3RoaXMuZ2V0Q29sdW1uTWV0cmljcygpO1xuXHQgICAgICB2YXIgcG9zID0gLTE7XG5cdCAgICAgIGNvbHVtbk1ldHJpY3MuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpZHgpIHtcblx0ICAgICAgICBpZiAoYy5rZXkgPT09IGNvbHVtbi5rZXkpIHtcblx0ICAgICAgICAgIHBvcyA9IGlkeDtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcG9zID09PSAtMSA/IG51bGwgOiBwb3M7XG5cdCAgICB9LCBfdGhpcy5nZXRDb21iaW5lZEhlYWRlckhlaWdodHMgPSBmdW5jdGlvbiAodW50aWwpIHtcblx0ICAgICAgdmFyIHN0b3BBdCA9IF90aGlzLnByb3BzLmhlYWRlclJvd3MubGVuZ3RoO1xuXHQgICAgICBpZiAodHlwZW9mIHVudGlsICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHN0b3BBdCA9IHVudGlsO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGhlaWdodCA9IDA7XG5cdCAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdG9wQXQ7IGluZGV4KyspIHtcblx0ICAgICAgICBoZWlnaHQgKz0gX3RoaXMucHJvcHMuaGVhZGVyUm93c1tpbmRleF0uaGVpZ2h0IHx8IF90aGlzLnByb3BzLmhlaWdodDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaGVpZ2h0O1xuXHQgICAgfSwgX3RoaXMuZ2V0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdCAgICAgICAgaGVpZ2h0OiBfdGhpcy5nZXRDb21iaW5lZEhlYWRlckhlaWdodHMoKVxuXHQgICAgICB9O1xuXHQgICAgfSwgX3RoaXMuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChzY3JvbGxMZWZ0KSB7XG5cdCAgICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3RoaXMucm93KTtcblx0ICAgICAgbm9kZS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0ICAgICAgX3RoaXMucm93LnNldFNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG5cdCAgICAgIGlmIChfdGhpcy5maWx0ZXJSb3cpIHtcblx0ICAgICAgICB2YXIgbm9kZUZpbHRlcnMgPSBSZWFjdERPTS5maW5kRE9NTm9kZShfdGhpcy5maWx0ZXJSb3cpO1xuXHQgICAgICAgIG5vZGVGaWx0ZXJzLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHQgICAgICAgIF90aGlzLmZpbHRlclJvdy5zZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5nZXRLbm93bkRpdlByb3BzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0V2l0aFByb3BlcnRpZXMoX3RoaXMucHJvcHMsIGtub3duRGl2UHJvcGVydHlLZXlzKTtcblx0ICAgIH0sIF90aGlzLm9uSGVhZGVyQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLnByb3BzLmNlbGxNZXRhRGF0YS5vbkNlbGxDbGljayh7IHJvd0lkeDogLTEsIGlkeDogLTEgfSk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBIZWFkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuXHQgICAgdGhpcy5zZXRTdGF0ZSh7IHJlc2l6aW5nOiBudWxsIH0pO1xuXHQgIH07XG5cblx0ICBIZWFkZXIucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHQgICAgdmFyIHVwZGF0ZSA9ICFDb2x1bW5NZXRyaWNzLnNhbWVDb2x1bW5zKHRoaXMucHJvcHMuY29sdW1uTWV0cmljcy5jb2x1bW5zLCBuZXh0UHJvcHMuY29sdW1uTWV0cmljcy5jb2x1bW5zLCBDb2x1bW5NZXRyaWNzLnNhbWVDb2x1bW4pIHx8IHRoaXMucHJvcHMudG90YWxXaWR0aCAhPT0gbmV4dFByb3BzLnRvdGFsV2lkdGggfHwgdGhpcy5wcm9wcy5oZWFkZXJSb3dzLmxlbmd0aCAhPT0gbmV4dFByb3BzLmhlYWRlclJvd3MubGVuZ3RoIHx8IHRoaXMuc3RhdGUucmVzaXppbmcgIT09IG5leHRTdGF0ZS5yZXNpemluZyB8fCB0aGlzLnByb3BzLnNvcnRDb2x1bW4gIT09IG5leHRQcm9wcy5zb3J0Q29sdW1uIHx8IHRoaXMucHJvcHMuc29ydERpcmVjdGlvbiAhPT0gbmV4dFByb3BzLnNvcnREaXJlY3Rpb247XG5cdCAgICByZXR1cm4gdXBkYXRlO1xuXHQgIH07XG5cblx0ICAvLyBTZXQgdGhlIGNlbGwgc2VsZWN0aW9uIHRvIC0xIHggLTEgd2hlbiBjbGlja2luZyBvbiB0aGUgaGVhZGVyXG5cblxuXHQgIEhlYWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgdmFyIGNsYXNzTmFtZSA9IGpvaW5DbGFzc2VzKHtcblx0ICAgICAgJ3JlYWN0LWdyaWQtSGVhZGVyJzogdHJ1ZSxcblx0ICAgICAgJ3JlYWN0LWdyaWQtSGVhZGVyLS1yZXNpemluZyc6ICEhdGhpcy5zdGF0ZS5yZXNpemluZ1xuXHQgICAgfSk7XG5cdCAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ2V0SGVhZGVyUm93cygpO1xuXG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ2RpdicsXG5cdCAgICAgIF9leHRlbmRzKHt9LCB0aGlzLmdldEtub3duRGl2UHJvcHMoKSwgeyBzdHlsZTogdGhpcy5nZXRTdHlsZSgpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgb25DbGljazogdGhpcy5vbkhlYWRlckNsaWNrIH0pLFxuXHQgICAgICBoZWFkZXJSb3dzXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gSGVhZGVyO1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0SGVhZGVyLnByb3BUeXBlcyA9IHtcblx0ICBjb2x1bW5NZXRyaWNzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHsgd2lkdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsIGNvbHVtbnM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYW55IH0pLmlzUmVxdWlyZWQsXG5cdCAgdG90YWxXaWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIGhlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBoZWFkZXJSb3dzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LmlzUmVxdWlyZWQsXG5cdCAgc29ydENvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgc29ydERpcmVjdGlvbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZihbJ0FTQycsICdERVNDJywgJ05PTkUnXSksXG5cdCAgb25Tb3J0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25Db2x1bW5SZXNpemU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvblNjcm9sbDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uSGVhZGVyRHJvcDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGRyYWdnYWJsZUhlYWRlckNlbGw6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBnZXRWYWxpZEZpbHRlclZhbHVlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGNlbGxNZXRhRGF0YTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZShjZWxsTWV0YURhdGFTaGFwZSlcblx0fTtcblxuXG5cdG1vZHVsZS5leHBvcnRzID0gSGVhZGVyO1xuXG4vKioqLyB9KSxcbi8qIDExMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBIZWFkZXJDZWxsVHlwZSA9IHtcblx0ICBTT1JUQUJMRTogMCxcblx0ICBGSUxURVJBQkxFOiAxLFxuXHQgIE5PTkU6IDIsXG5cdCAgQ0hFQ0tCT1g6IDNcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IEhlYWRlckNlbGxUeXBlO1xuXG4vKioqLyB9KSxcbi8qIDExNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBzaGFsbG93RXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblx0dmFyIEJhc2VIZWFkZXJDZWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cdHZhciBnZXRTY3JvbGxiYXJTaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5cdHZhciBFeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgY29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgU29ydGFibGVIZWFkZXJDZWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cdHZhciBGaWx0ZXJhYmxlSGVhZGVyQ2VsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIzKTtcblx0dmFyIEhlYWRlckNlbGxUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTMpO1xuXHR2YXIgY3JlYXRlT2JqZWN0V2l0aFByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cblx0dmFyIEhlYWRlclJvd1N0eWxlID0ge1xuXHQgIG92ZXJmbG93OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICB3aWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIGhlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgcG9zaXRpb246IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nXG5cdH07XG5cblx0Ly8gVGhlIGxpc3Qgb2YgdGhlIHByb3BUeXBlcyB0aGF0IHdlIHdhbnQgdG8gaW5jbHVkZSBpbiB0aGUgSGVhZGVyUm93IGRpdlxuXHR2YXIga25vd25EaXZQcm9wZXJ0eUtleXMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdzdHlsZScsICdvblNjcm9sbCddO1xuXG5cdHZhciBIZWFkZXJSb3cgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhIZWFkZXJSb3csIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gSGVhZGVyUm93KCkge1xuXHQgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlclJvdyk7XG5cblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5nZXRIZWFkZXJDZWxsVHlwZSA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcblx0ICAgICAgaWYgKGNvbHVtbi5maWx0ZXJhYmxlKSB7XG5cdCAgICAgICAgaWYgKF90aGlzLnByb3BzLmZpbHRlcmFibGUpIHJldHVybiBIZWFkZXJDZWxsVHlwZS5GSUxURVJBQkxFO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNvbHVtbi5zb3J0YWJsZSAmJiBjb2x1bW4ucm93VHlwZSAhPT0gJ2ZpbHRlcicpIHJldHVybiBIZWFkZXJDZWxsVHlwZS5TT1JUQUJMRTtcblxuXHQgICAgICByZXR1cm4gSGVhZGVyQ2VsbFR5cGUuTk9ORTtcblx0ICAgIH0sIF90aGlzLmdldEZpbHRlcmFibGVIZWFkZXJDZWxsID0gZnVuY3Rpb24gKGNvbHVtbikge1xuXHQgICAgICB2YXIgRmlsdGVyUmVuZGVyZXIgPSBGaWx0ZXJhYmxlSGVhZGVyQ2VsbDtcblx0ICAgICAgaWYgKGNvbHVtbi5maWx0ZXJSZW5kZXJlciAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgRmlsdGVyUmVuZGVyZXIgPSBjb2x1bW4uZmlsdGVyUmVuZGVyZXI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmlsdGVyUmVuZGVyZXIsIF9leHRlbmRzKHt9LCBfdGhpcy5wcm9wcywgeyBvbkNoYW5nZTogX3RoaXMucHJvcHMub25GaWx0ZXJDaGFuZ2UgfSkpO1xuXHQgICAgfSwgX3RoaXMuZ2V0U29ydGFibGVIZWFkZXJDZWxsID0gZnVuY3Rpb24gKGNvbHVtbikge1xuXHQgICAgICB2YXIgc29ydERpcmVjdGlvbiA9IF90aGlzLnByb3BzLnNvcnRDb2x1bW4gPT09IGNvbHVtbi5rZXkgPyBfdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uIDogU29ydGFibGVIZWFkZXJDZWxsLkRFRklORV9TT1JULk5PTkU7XG5cdCAgICAgIHZhciBzb3J0RGVzY2VuZGluZ0ZpcnN0ID0gY29sdW1uLnNvcnREZXNjZW5kaW5nRmlyc3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogY29sdW1uLnNvcnREZXNjZW5kaW5nRmlyc3Q7XG5cdCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFNvcnRhYmxlSGVhZGVyQ2VsbCwgeyBjb2x1bW5LZXk6IGNvbHVtbi5rZXksIG9uU29ydDogX3RoaXMucHJvcHMub25Tb3J0LCBzb3J0RGlyZWN0aW9uOiBzb3J0RGlyZWN0aW9uLCBzb3J0RGVzY2VuZGluZ0ZpcnN0OiBzb3J0RGVzY2VuZGluZ0ZpcnN0LCBoZWFkZXJSZW5kZXJlcjogY29sdW1uLmhlYWRlclJlbmRlcmVyIH0pO1xuXHQgICAgfSwgX3RoaXMuZ2V0SGVhZGVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoY29sdW1uKSB7XG5cdCAgICAgIHZhciByZW5kZXJlciA9IHZvaWQgMDtcblx0ICAgICAgaWYgKGNvbHVtbi5oZWFkZXJSZW5kZXJlciAmJiAhY29sdW1uLnNvcnRhYmxlICYmICFfdGhpcy5wcm9wcy5maWx0ZXJhYmxlKSB7XG5cdCAgICAgICAgcmVuZGVyZXIgPSBjb2x1bW4uaGVhZGVyUmVuZGVyZXI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGhlYWRlckNlbGxUeXBlID0gX3RoaXMuZ2V0SGVhZGVyQ2VsbFR5cGUoY29sdW1uKTtcblx0ICAgICAgICBzd2l0Y2ggKGhlYWRlckNlbGxUeXBlKSB7XG5cdCAgICAgICAgICBjYXNlIEhlYWRlckNlbGxUeXBlLlNPUlRBQkxFOlxuXHQgICAgICAgICAgICByZW5kZXJlciA9IF90aGlzLmdldFNvcnRhYmxlSGVhZGVyQ2VsbChjb2x1bW4pO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIGNhc2UgSGVhZGVyQ2VsbFR5cGUuRklMVEVSQUJMRTpcblx0ICAgICAgICAgICAgcmVuZGVyZXIgPSBfdGhpcy5nZXRGaWx0ZXJhYmxlSGVhZGVyQ2VsbChjb2x1bW4pO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVuZGVyZXI7XG5cdCAgICB9LCBfdGhpcy5nZXRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG5cdCAgICAgICAgd2lkdGg6ICcxMDAlJyxcblx0ICAgICAgICBoZWlnaHQ6IF90aGlzLnByb3BzLmhlaWdodCxcblx0ICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuXHQgICAgICB9O1xuXHQgICAgfSwgX3RoaXMuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBjZWxscyA9IFtdO1xuXHQgICAgICB2YXIgbG9ja2VkQ2VsbHMgPSBbXTtcblxuXHQgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpLCBsZW4pIHtcblx0ICAgICAgICB2YXIgY29sdW1uID0gT2JqZWN0LmFzc2lnbih7IHJvd1R5cGU6IF90aGlzLnByb3BzLnJvd1R5cGUgfSwgY29sdW1uVXRpbHMuZ2V0Q29sdW1uKF90aGlzLnByb3BzLmNvbHVtbnMsIGkpKTtcblx0ICAgICAgICB2YXIgX3JlbmRlcmVyID0gX3RoaXMuZ2V0SGVhZGVyUmVuZGVyZXIoY29sdW1uKTtcblx0ICAgICAgICBpZiAoY29sdW1uLmtleSA9PT0gJ3NlbGVjdC1yb3cnICYmIF90aGlzLnByb3BzLnJvd1R5cGUgPT09ICdmaWx0ZXInKSB7XG5cdCAgICAgICAgICBfcmVuZGVyZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIEhlYWRlckNlbGwgPSBjb2x1bW4uZHJhZ2dhYmxlID8gX3RoaXMucHJvcHMuZHJhZ2dhYmxlSGVhZGVyQ2VsbCA6IEJhc2VIZWFkZXJDZWxsO1xuXHQgICAgICAgIHZhciBjZWxsID0gUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXJDZWxsLCB7XG5cdCAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5jZWxsc1tpXSA9IG5vZGU7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAga2V5OiBpLFxuXHQgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5wcm9wcy5oZWlnaHQsXG5cdCAgICAgICAgICBjb2x1bW46IGNvbHVtbixcblx0ICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXIsXG5cdCAgICAgICAgICByZXNpemluZzogX3RoaXMucHJvcHMucmVzaXppbmcgPT09IGNvbHVtbixcblx0ICAgICAgICAgIG9uUmVzaXplOiBfdGhpcy5wcm9wcy5vbkNvbHVtblJlc2l6ZSxcblx0ICAgICAgICAgIG9uUmVzaXplRW5kOiBfdGhpcy5wcm9wcy5vbkNvbHVtblJlc2l6ZUVuZCxcblx0ICAgICAgICAgIG9uSGVhZGVyRHJvcDogX3RoaXMucHJvcHMub25IZWFkZXJEcm9wXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKGNvbHVtbi5sb2NrZWQpIHtcblx0ICAgICAgICAgIGxvY2tlZENlbGxzLnB1c2goY2VsbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2x1bW5VdGlscy5nZXRTaXplKF90aGlzLnByb3BzLmNvbHVtbnMpOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICBfbG9vcChpLCBsZW4pO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGNlbGxzLmNvbmNhdChsb2NrZWRDZWxscyk7XG5cdCAgICB9LCBfdGhpcy5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcblx0ICAgICAgX3RoaXMucHJvcHMuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcblx0ICAgICAgICBpZiAoY29sdW1uLmxvY2tlZCkge1xuXHQgICAgICAgICAgX3RoaXMuY2VsbHNbaV0uc2V0U2Nyb2xsTGVmdChzY3JvbGxMZWZ0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKF90aGlzLmNlbGxzW2ldICYmIF90aGlzLmNlbGxzW2ldLnJlbW92ZVNjcm9sbCkge1xuXHQgICAgICAgICAgICBfdGhpcy5jZWxsc1tpXS5yZW1vdmVTY3JvbGwoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgX3RoaXMuZ2V0S25vd25EaXZQcm9wcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdFdpdGhQcm9wZXJ0aWVzKF90aGlzLnByb3BzLCBrbm93bkRpdlByb3BlcnR5S2V5cyk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBIZWFkZXJSb3cucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0ICAgIHRoaXMuY2VsbHMgPSBbXTtcblx0ICB9O1xuXG5cdCAgSGVhZGVyUm93LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG5cdCAgICByZXR1cm4gbmV4dFByb3BzLndpZHRoICE9PSB0aGlzLnByb3BzLndpZHRoIHx8IG5leHRQcm9wcy5oZWlnaHQgIT09IHRoaXMucHJvcHMuaGVpZ2h0IHx8IG5leHRQcm9wcy5jb2x1bW5zICE9PSB0aGlzLnByb3BzLmNvbHVtbnMgfHwgIXNoYWxsb3dFcXVhbChuZXh0UHJvcHMuc3R5bGUsIHRoaXMucHJvcHMuc3R5bGUpIHx8IHRoaXMucHJvcHMuc29ydENvbHVtbiAhPT0gbmV4dFByb3BzLnNvcnRDb2x1bW4gfHwgdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uICE9PSBuZXh0UHJvcHMuc29ydERpcmVjdGlvbjtcblx0ICB9O1xuXG5cdCAgSGVhZGVyUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICB2YXIgY2VsbHNTdHlsZSA9IHtcblx0ICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGggPyB0aGlzLnByb3BzLndpZHRoICsgZ2V0U2Nyb2xsYmFyU2l6ZSgpIDogJzEwMCUnLFxuXHQgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuXHQgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcblx0ICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0ICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJ1xuXHQgICAgfTtcblxuXHQgICAgdmFyIGNlbGxzID0gdGhpcy5nZXRDZWxscygpO1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICBfZXh0ZW5kcyh7fSwgdGhpcy5nZXRLbm93bkRpdlByb3BzKCksIHsgY2xhc3NOYW1lOiAncmVhY3QtZ3JpZC1IZWFkZXJSb3cnIH0pLFxuXHQgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsgc3R5bGU6IGNlbGxzU3R5bGUgfSxcblx0ICAgICAgICBjZWxsc1xuXHQgICAgICApXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gSGVhZGVyUm93O1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0SGVhZGVyUm93LmRpc3BsYXlOYW1lID0gJ0hlYWRlclJvdyc7XG5cdEhlYWRlclJvdy5wcm9wVHlwZXMgPSB7XG5cdCAgd2lkdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlciwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmddKSxcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXksIF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0XSkuaXNSZXF1aXJlZCxcblx0ICBvbkNvbHVtblJlc2l6ZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uU29ydDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgb25Db2x1bW5SZXNpemVFbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBzdHlsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZShIZWFkZXJSb3dTdHlsZSksXG5cdCAgc29ydENvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgc29ydERpcmVjdGlvbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZihPYmplY3Qua2V5cyhTb3J0YWJsZUhlYWRlckNlbGwuREVGSU5FX1NPUlQpKSxcblx0ICBjZWxsUmVuZGVyZXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBoZWFkZXJDZWxsUmVuZGVyZXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBmaWx0ZXJhYmxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgb25GaWx0ZXJDaGFuZ2U6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICByZXNpemluZzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgb25TY3JvbGw6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICByb3dUeXBlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBkcmFnZ2FibGVIZWFkZXJDZWxsOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25IZWFkZXJEcm9wOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0fTtcblxuXG5cdG1vZHVsZS5leHBvcnRzID0gSGVhZGVyUm93O1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIEJhY2tzcGFjZTogOCxcblx0ICBUYWI6IDksXG5cdCAgRW50ZXI6IDEzLFxuXHQgIFNoaWZ0OiAxNixcblx0ICBDdHJsOiAxNyxcblx0ICBBbHQ6IDE4LFxuXHQgIFBhdXNlQnJlYWs6IDE5LFxuXHQgIENhcHNMb2NrOiAyMCxcblx0ICBFc2NhcGU6IDI3LFxuXHQgIFBhZ2VVcDogMzMsXG5cdCAgUGFnZURvd246IDM0LFxuXHQgIEVuZDogMzUsXG5cdCAgSG9tZTogMzYsXG5cdCAgTGVmdEFycm93OiAzNyxcblx0ICBVcEFycm93OiAzOCxcblx0ICBSaWdodEFycm93OiAzOSxcblx0ICBEb3duQXJyb3c6IDQwLFxuXHQgIEluc2VydDogNDUsXG5cdCAgRGVsZXRlOiA0Nixcblx0ICAwOiA0OCxcblx0ICAxOiA0OSxcblx0ICAyOiA1MCxcblx0ICAzOiA1MSxcblx0ICA0OiA1Mixcblx0ICA1OiA1Myxcblx0ICA2OiA1NCxcblx0ICA3OiA1NSxcblx0ICA4OiA1Nixcblx0ICA5OiA1Nyxcblx0ICBhOiA2NSxcblx0ICBiOiA2Nixcblx0ICBjOiA2Nyxcblx0ICBkOiA2OCxcblx0ICBlOiA2OSxcblx0ICBmOiA3MCxcblx0ICBnOiA3MSxcblx0ICBoOiA3Mixcblx0ICBpOiA3Myxcblx0ICBqOiA3NCxcblx0ICBrOiA3NSxcblx0ICBsOiA3Nixcblx0ICBtOiA3Nyxcblx0ICBuOiA3OCxcblx0ICBvOiA3OSxcblx0ICBwOiA4MCxcblx0ICBxOiA4MSxcblx0ICByOiA4Mixcblx0ICBzOiA4Myxcblx0ICB0OiA4NCxcblx0ICB1OiA4NSxcblx0ICB2OiA4Nixcblx0ICB3OiA4Nyxcblx0ICB4OiA4OCxcblx0ICB5OiA4OSxcblx0ICB6OiA5MCxcblx0ICBMZWZ0V2luZG93S2V5OiA5MSxcblx0ICBSaWdodFdpbmRvd0tleTogOTIsXG5cdCAgU2VsZWN0S2V5OiA5Myxcblx0ICBOdW1QYWQwOiA5Nixcblx0ICBOdW1QYWQxOiA5Nyxcblx0ICBOdW1QYWQyOiA5OCxcblx0ICBOdW1QYWQzOiA5OSxcblx0ICBOdW1QYWQ0OiAxMDAsXG5cdCAgTnVtUGFkNTogMTAxLFxuXHQgIE51bVBhZDY6IDEwMixcblx0ICBOdW1QYWQ3OiAxMDMsXG5cdCAgTnVtUGFkODogMTA0LFxuXHQgIE51bVBhZDk6IDEwNSxcblx0ICBNdWx0aXBseTogMTA2LFxuXHQgIEFkZDogMTA3LFxuXHQgIFN1YnRyYWN0OiAxMDksXG5cdCAgRGVjaW1hbFBvaW50OiAxMTAsXG5cdCAgRGl2aWRlOiAxMTEsXG5cdCAgRjE6IDExMixcblx0ICBGMjogMTEzLFxuXHQgIEYzOiAxMTQsXG5cdCAgRjQ6IDExNSxcblx0ICBGNTogMTE2LFxuXHQgIEY2OiAxMTcsXG5cdCAgRjc6IDExOCxcblx0ICBGODogMTE5LFxuXHQgIEY5OiAxMjAsXG5cdCAgRjEwOiAxMjEsXG5cdCAgRjEyOiAxMjMsXG5cdCAgTnVtTG9jazogMTQ0LFxuXHQgIFNjcm9sbExvY2s6IDE0NSxcblx0ICBTZW1pQ29sb246IDE4Nixcblx0ICBFcXVhbFNpZ246IDE4Nyxcblx0ICBDb21tYTogMTg4LFxuXHQgIERhc2g6IDE4OSxcblx0ICBQZXJpb2Q6IDE5MCxcblx0ICBGb3J3YXJkU2xhc2g6IDE5MSxcblx0ICBHcmF2ZUFjY2VudDogMTkyLFxuXHQgIE9wZW5CcmFja2V0OiAyMTksXG5cdCAgQmFja1NsYXNoOiAyMjAsXG5cdCAgQ2xvc2VCcmFja2V0OiAyMjEsXG5cdCAgU2luZ2xlUXVvdGU6IDIyMlxuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzLk92ZXJmbG93Q2VsbENvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHR2YXIgX2ZvY3VzYWJsZUNvbXBvbmVudFdyYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG5cblx0dmFyIF9mb2N1c2FibGVDb21wb25lbnRXcmFwcGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZUNvbXBvbmVudFdyYXBwZXIpO1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBPdmVyZmxvd0NlbGwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhPdmVyZmxvd0NlbGwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdCAgZnVuY3Rpb24gT3ZlcmZsb3dDZWxsKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJmbG93Q2VsbCk7XG5cblx0ICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIE92ZXJmbG93Q2VsbC5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcblx0ICAgIHZhciBzdHlsZSA9IHtcblx0ICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdCAgICAgIHdpZHRoOiB0aGlzLnByb3BzLmNvbHVtbi53aWR0aCxcblx0ICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodCxcblx0ICAgICAgbGVmdDogdGhpcy5wcm9wcy5jb2x1bW4ubGVmdCxcblx0ICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNlZWUnXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHN0eWxlO1xuXHQgIH07XG5cblx0ICBPdmVyZmxvd0NlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2JywgeyB0YWJJbmRleDogJy0xJywgc3R5bGU6IHRoaXMuZ2V0U3R5bGUoKSwgd2lkdGg6ICcxMDAlJywgY2xhc3NOYW1lOiAncmVhY3QtZ3JpZC1DZWxsJyB9KTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIE92ZXJmbG93Q2VsbDtcblx0fShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuXHRPdmVyZmxvd0NlbGwuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHQgIHZhciBjZWxsTWV0YURhdGEgPSBwcm9wcy5jZWxsTWV0YURhdGEsXG5cdCAgICAgIHJvd0lkeCA9IHByb3BzLnJvd0lkeCxcblx0ICAgICAgaWR4ID0gcHJvcHMuaWR4O1xuXG5cdCAgaWYgKGNlbGxNZXRhRGF0YSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgdmFyIHNlbGVjdGVkID0gY2VsbE1ldGFEYXRhLnNlbGVjdGVkO1xuXG5cblx0ICByZXR1cm4gc2VsZWN0ZWQgJiYgc2VsZWN0ZWQucm93SWR4ID09PSByb3dJZHggJiYgc2VsZWN0ZWQuaWR4ID09PSBpZHg7XG5cdH07XG5cblx0T3ZlcmZsb3dDZWxsLmlzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdCAgcmV0dXJuIHByb3BzLmNlbGxNZXRhRGF0YS5pc1Njcm9sbGluZ0hvcml6b250YWxseVdpdGhLZXlib2FyZDtcblx0fTtcblxuXHRPdmVyZmxvd0NlbGwucHJvcFR5cGVzID0ge1xuXHQgIHJvd0lkeDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgaWR4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGNvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgY2VsbE1ldGFEYXRhOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdFxuXHR9O1xuXG5cdE92ZXJmbG93Q2VsbC5kaXNwbGF5TmFtZSA9ICdDZWxsJztcblxuXHR2YXIgT3ZlcmZsb3dDZWxsQ29tcG9uZW50ID0gT3ZlcmZsb3dDZWxsO1xuXHRleHBvcnRzWydkZWZhdWx0J10gPSAoMCwgX2ZvY3VzYWJsZUNvbXBvbmVudFdyYXBwZXIyWydkZWZhdWx0J10pKE92ZXJmbG93Q2VsbCk7XG5cdGV4cG9ydHMuT3ZlcmZsb3dDZWxsQ29tcG9uZW50ID0gT3ZlcmZsb3dDZWxsQ29tcG9uZW50O1xuXG4vKioqLyB9KSxcbi8qIDExNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHR2YXIgQ2VsbEFjdGlvblNoYXBlID0ge1xuXHQgIGljb246IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWQsXG5cdCAgY2FsbGJhY2s6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBhY3Rpb25zOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5T2YoX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICB0ZXh0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICAgIGNhbGxiYWNrOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0ICB9KSlcblx0fTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBDZWxsQWN0aW9uU2hhcGU7XG5cbi8qKiovIH0pLFxuLyogMTE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9FeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cdHZhciBfRXhjZWxDb2x1bW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXhjZWxDb2x1bW4pO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSB7IEV4Y2VsQ29sdW1uOiBfRXhjZWxDb2x1bW4yWydkZWZhdWx0J10gfTtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuXHR2YXIgX1NlbGVjdEFsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXG5cdHZhciBfU2VsZWN0QWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbGVjdEFsbCk7XG5cblx0dmFyIF9BcHBDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuXHR2YXIgX0FwcENvbnN0YW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcHBDb25zdGFudHMpO1xuXG5cdHZhciBfU29ydGFibGVIZWFkZXJDZWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cblx0dmFyIF9rZXlib2FyZFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgQmFzZUdyaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XG5cdHZhciBDaGVja2JveEVkaXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXHR2YXIgUm93VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0dmFyIENvbHVtblV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIEtleUNvZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpO1xuXHR2YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBDb2x1bW5NZXRyaWNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0ICBPYmplY3QuYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDYpO1xuXHR9XG5cblx0dmFyIFJlYWN0RGF0YUdyaWQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhSZWFjdERhdGFHcmlkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIFJlYWN0RGF0YUdyaWQocHJvcHMsIGNvbnRleHQpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdERhdGFHcmlkKTtcblxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cblx0ICAgIF9pbml0aWFsaXNlUHJvcHMuY2FsbChfdGhpcyk7XG5cblx0ICAgIHZhciBjb2x1bW5NZXRyaWNzID0gX3RoaXMuY3JlYXRlQ29sdW1uTWV0cmljcygpO1xuXHQgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHsgY29sdW1uTWV0cmljczogY29sdW1uTWV0cmljcywgc2VsZWN0ZWRSb3dzOiBbXSwgY29waWVkOiBudWxsLCBleHBhbmRlZFJvd3M6IFtdLCBjYW5GaWx0ZXI6IGZhbHNlLCBjb2x1bW5GaWx0ZXJzOiB7fSwgc29ydERpcmVjdGlvbjogbnVsbCwgc29ydENvbHVtbjogbnVsbCwgZHJhZ2dlZDogbnVsbCwgc2Nyb2xsT2Zmc2V0OiAwLCBsYXN0Um93SWR4VWlTZWxlY3RlZDogLTEgfTtcblx0ICAgIGlmIChwcm9wcy5lbmFibGVDZWxsU2VsZWN0KSB7XG5cdCAgICAgIGluaXRpYWxTdGF0ZS5zZWxlY3RlZCA9IHsgcm93SWR4OiAwLCBpZHg6IDAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGluaXRpYWxTdGF0ZS5zZWxlY3RlZCA9IHsgcm93SWR4OiAtMSwgaWR4OiAtMSB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoX3RoaXMucHJvcHMuc29ydENvbHVtbiAmJiBfdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uKSB7XG5cdCAgICAgIGluaXRpYWxTdGF0ZS5zb3J0Q29sdW1uID0gX3RoaXMucHJvcHMuc29ydENvbHVtbjtcblx0ICAgICAgaW5pdGlhbFN0YXRlLnNvcnREaXJlY3Rpb24gPSBfdGhpcy5wcm9wcy5zb3J0RGlyZWN0aW9uO1xuXHQgICAgfVxuXG5cdCAgICBfdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICBSZWFjdERhdGFHcmlkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdCAgICB0aGlzLl9tb3VudGVkID0gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgUmVhY3REYXRhR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcblx0ICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5tZXRyaWNzVXBkYXRlZCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ3Jlc2l6ZScsIHRoaXMubWV0cmljc1VwZGF0ZWQpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5tZXRyaWNzVXBkYXRlZCgpO1xuXHQgIH07XG5cblx0ICBSZWFjdERhdGFHcmlkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgdGhpcy5fbW91bnRlZCA9IGZhbHNlO1xuXHQgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMubWV0cmljc1VwZGF0ZWQpO1xuXHQgIH07XG5cblx0ICBSZWFjdERhdGFHcmlkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0ICAgIGlmIChuZXh0UHJvcHMuY29sdW1ucykge1xuXHQgICAgICBpZiAoIUNvbHVtbk1ldHJpY3Muc2FtZUNvbHVtbnModGhpcy5wcm9wcy5jb2x1bW5zLCBuZXh0UHJvcHMuY29sdW1ucywgdGhpcy5wcm9wcy5jb2x1bW5FcXVhbGl0eSkgfHwgbmV4dFByb3BzLm1pbldpZHRoICE9PSB0aGlzLnByb3BzLm1pbldpZHRoKSB7XG5cdCAgICAgICAgdmFyIGNvbHVtbk1ldHJpY3MgPSB0aGlzLmNyZWF0ZUNvbHVtbk1ldHJpY3MobmV4dFByb3BzKTtcblx0ICAgICAgICB0aGlzLnNldFN0YXRlKHsgY29sdW1uTWV0cmljczogY29sdW1uTWV0cmljcyB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvLyByZXR1cm4gZmFsc2UgaWYgbm90IGEgc2hpZnQgc2VsZWN0IHNvIGNhbiBiZSBoYW5kbGVkIGFzIG5vcm1hbCByb3cgc2VsZWN0aW9uXG5cblxuXHQgIC8vIGNvbHVtbktleSBub3QgdXNlZCBoZXJlIGFzIHRoaXMgZnVuY3Rpb24gd2lsbCBzZWxlY3QgdGhlIHdob2xlIHJvdyxcblx0ICAvLyBidXQgbmVlZGVkIHRvIG1hdGNoIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgaW4gdGhlIENoZWNrYm94RWRpdG9yXG5cblxuXHQgIFJlYWN0RGF0YUdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgY2VsbE1ldGFEYXRhID0ge1xuXHQgICAgICByb3dLZXk6IHRoaXMucHJvcHMucm93S2V5LFxuXHQgICAgICBzZWxlY3RlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCxcblx0ICAgICAgZHJhZ2dlZDogdGhpcy5zdGF0ZS5kcmFnZ2VkLFxuXHQgICAgICBob3ZlcmVkUm93SWR4OiB0aGlzLnN0YXRlLmhvdmVyZWRSb3dJZHgsXG5cdCAgICAgIG9uQ2VsbENsaWNrOiB0aGlzLm9uQ2VsbENsaWNrLFxuXHQgICAgICBvbkNlbGxGb2N1czogdGhpcy5vbkNlbGxGb2N1cyxcblx0ICAgICAgb25DZWxsQ29udGV4dE1lbnU6IHRoaXMub25DZWxsQ29udGV4dE1lbnUsXG5cdCAgICAgIG9uQ2VsbERvdWJsZUNsaWNrOiB0aGlzLm9uQ2VsbERvdWJsZUNsaWNrLFxuXHQgICAgICBvbkNvbW1pdDogdGhpcy5vbkNlbGxDb21taXQsXG5cdCAgICAgIG9uQ29tbWl0Q2FuY2VsOiB0aGlzLnNldEluYWN0aXZlLFxuXHQgICAgICBjb3BpZWQ6IHRoaXMuc3RhdGUuY29waWVkLFxuXHQgICAgICBoYW5kbGVEcmFnRW50ZXJSb3c6IHRoaXMuaGFuZGxlRHJhZ0VudGVyLFxuXHQgICAgICBoYW5kbGVUZXJtaW5hdGVEcmFnOiB0aGlzLmhhbmRsZVRlcm1pbmF0ZURyYWcsXG5cdCAgICAgIGVuYWJsZUNlbGxTZWxlY3Q6IHRoaXMucHJvcHMuZW5hYmxlQ2VsbFNlbGVjdCxcblx0ICAgICAgb25Db2x1bW5FdmVudDogdGhpcy5vbkNvbHVtbkV2ZW50LFxuXHQgICAgICBvcGVuQ2VsbEVkaXRvcjogdGhpcy5vcGVuQ2VsbEVkaXRvcixcblx0ICAgICAgb25EcmFnSGFuZGxlRG91YmxlQ2xpY2s6IHRoaXMub25EcmFnSGFuZGxlRG91YmxlQ2xpY2ssXG5cdCAgICAgIG9uQ2VsbEV4cGFuZDogdGhpcy5vbkNlbGxFeHBhbmQsXG5cdCAgICAgIG9uUm93RXhwYW5kVG9nZ2xlOiB0aGlzLm9uUm93RXhwYW5kVG9nZ2xlLFxuXHQgICAgICBvblJvd0hvdmVyOiB0aGlzLm9uUm93SG92ZXIsXG5cdCAgICAgIGdldERhdGFHcmlkRE9NTm9kZTogdGhpcy5nZXREYXRhR3JpZERPTU5vZGUsXG5cdCAgICAgIGdldENlbGxBY3Rpb25zOiB0aGlzLnByb3BzLmdldENlbGxBY3Rpb25zLFxuXHQgICAgICBvbkRlbGV0ZVN1YlJvdzogdGhpcy5wcm9wcy5vbkRlbGV0ZVN1YlJvdyxcblx0ICAgICAgb25BZGRTdWJSb3c6IHRoaXMucHJvcHMub25BZGRTdWJSb3csXG5cdCAgICAgIGlzU2Nyb2xsaW5nVmVydGljYWxseVdpdGhLZXlib2FyZDogdGhpcy5pc0tleURvd24oS2V5Q29kZXMuRG93bkFycm93KSB8fCB0aGlzLmlzS2V5RG93bihLZXlDb2Rlcy5VcEFycm93KSxcblx0ICAgICAgaXNTY3JvbGxpbmdIb3Jpem9udGFsbHlXaXRoS2V5Ym9hcmQ6IHRoaXMuaXNLZXlEb3duKEtleUNvZGVzLkxlZnRBcnJvdykgfHwgdGhpcy5pc0tleURvd24oS2V5Q29kZXMuUmlnaHRBcnJvdykgfHwgdGhpcy5pc0tleURvd24oS2V5Q29kZXMuVGFiKSxcblx0ICAgICAgZW5hYmxlQ2VsbEF1dG9Gb2N1czogdGhpcy5wcm9wcy5lbmFibGVDZWxsQXV0b0ZvY3VzXG5cdCAgICB9O1xuXG5cdCAgICB2YXIgdG9vbGJhciA9IHRoaXMucmVuZGVyVG9vbGJhcigpO1xuXHQgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5wcm9wcy5taW5XaWR0aCB8fCB0aGlzLmdyaWRXaWR0aCgpO1xuXHQgICAgdmFyIGdyaWRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gdGhpcy5zdGF0ZS5zY3JvbGxPZmZzZXQ7XG5cblx0ICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBsaWZlY3ljbGUgc3RhZ2UsIGdyaWRXaWR0aCgpIG1heSBub3QgaW5pdGlhbGl6ZSBjb3JyZWN0bHlcblx0ICAgIC8vIHRoaXMgYWxzbyBoYW5kbGVzIGNhc2VzIHdoZXJlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCAtLSBzdWNoIGFzIHdoZW4gaW5zaWRlIGEgZGl2IHdpdGggZGlzcGxheTpub25lXG5cdCAgICAvLyBlZyBCb290c3RyYXAgdGFicyBhbmQgY29sbGFwc2VzXG5cdCAgICBpZiAodHlwZW9mIGNvbnRhaW5lcldpZHRoID09PSAndW5kZWZpbmVkJyB8fCBpc05hTihjb250YWluZXJXaWR0aCkgfHwgY29udGFpbmVyV2lkdGggPT09IDApIHtcblx0ICAgICAgY29udGFpbmVyV2lkdGggPSAnMTAwJSc7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIGdyaWRXaWR0aCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNOYU4oZ3JpZFdpZHRoKSB8fCBncmlkV2lkdGggPT09IDApIHtcblx0ICAgICAgZ3JpZFdpZHRoID0gJzEwMCUnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtQ29udGFpbmVyJywgc3R5bGU6IHsgd2lkdGg6IGNvbnRhaW5lcldpZHRoIH0sXG5cdCAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgX3RoaXMyLmdyaWQgPSBub2RlO1xuXHQgICAgICAgIH0gfSxcblx0ICAgICAgdG9vbGJhcixcblx0ICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgICAnZGl2Jyxcblx0ICAgICAgICB7IGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtTWFpbicgfSxcblx0ICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VHcmlkLCBfZXh0ZW5kcyh7XG5cdCAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpczIuYmFzZSA9IG5vZGU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSwgdGhpcy5wcm9wcywge1xuXHQgICAgICAgICAgcm93S2V5OiB0aGlzLnByb3BzLnJvd0tleSxcblx0ICAgICAgICAgIGhlYWRlclJvd3M6IHRoaXMuZ2V0SGVhZGVyUm93cygpLFxuXHQgICAgICAgICAgY29sdW1uTWV0cmljczogdGhpcy5zdGF0ZS5jb2x1bW5NZXRyaWNzLFxuXHQgICAgICAgICAgcm93R2V0dGVyOiB0aGlzLnByb3BzLnJvd0dldHRlcixcblx0ICAgICAgICAgIHJvd3NDb3VudDogdGhpcy5wcm9wcy5yb3dzQ291bnQsXG5cdCAgICAgICAgICByb3dIZWlnaHQ6IHRoaXMucHJvcHMucm93SGVpZ2h0LFxuXHQgICAgICAgICAgY2VsbE1ldGFEYXRhOiBjZWxsTWV0YURhdGEsXG5cdCAgICAgICAgICBzZWxlY3RlZFJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG5cdCAgICAgICAgICByb3dTZWxlY3Rpb246IHRoaXMuZ2V0Um93U2VsZWN0aW9uUHJvcHMoKSxcblx0ICAgICAgICAgIGV4cGFuZGVkUm93czogdGhpcy5zdGF0ZS5leHBhbmRlZFJvd3MsXG5cdCAgICAgICAgICByb3dPZmZzZXRIZWlnaHQ6IHRoaXMuZ2V0Um93T2Zmc2V0SGVpZ2h0KCksXG5cdCAgICAgICAgICBzb3J0Q29sdW1uOiB0aGlzLnN0YXRlLnNvcnRDb2x1bW4sXG5cdCAgICAgICAgICBzb3J0RGlyZWN0aW9uOiB0aGlzLnN0YXRlLnNvcnREaXJlY3Rpb24sXG5cdCAgICAgICAgICBvblNvcnQ6IHRoaXMuaGFuZGxlU29ydCxcblx0ICAgICAgICAgIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsXG5cdCAgICAgICAgICB0b3RhbFdpZHRoOiBncmlkV2lkdGgsXG5cdCAgICAgICAgICBvblZpZXdwb3J0S2V5ZG93bjogdGhpcy5vbktleURvd24sXG5cdCAgICAgICAgICBvblZpZXdwb3J0S2V5dXA6IHRoaXMub25LZXlVcCxcblx0ICAgICAgICAgIG9uVmlld3BvcnREcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG5cdCAgICAgICAgICBvblZpZXdwb3J0RHJhZ0VuZDogdGhpcy5oYW5kbGVEcmFnRW5kLFxuXHQgICAgICAgICAgb25WaWV3cG9ydENsaWNrOiB0aGlzLmRlc2VsZWN0LFxuXHQgICAgICAgICAgb25WaWV3cG9ydERvdWJsZUNsaWNrOiB0aGlzLmRlc2VsZWN0LFxuXHQgICAgICAgICAgb25Db2x1bW5SZXNpemU6IHRoaXMub25Db2x1bW5SZXNpemUsXG5cdCAgICAgICAgICByb3dTY3JvbGxUaW1lb3V0OiB0aGlzLnByb3BzLnJvd1Njcm9sbFRpbWVvdXQsXG5cdCAgICAgICAgICBzY3JvbGxUb1Jvd0luZGV4OiB0aGlzLnByb3BzLnNjcm9sbFRvUm93SW5kZXgsXG5cdCAgICAgICAgICBjb250ZXh0TWVudTogdGhpcy5wcm9wcy5jb250ZXh0TWVudSxcblx0ICAgICAgICAgIG92ZXJTY2FuOiB0aGlzLnByb3BzLm92ZXJTY2FuIH0pKVxuXHQgICAgICApXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUmVhY3REYXRhR3JpZDtcblx0fShSZWFjdC5Db21wb25lbnQpO1xuXG5cdFJlYWN0RGF0YUdyaWQuZGlzcGxheU5hbWUgPSAnUmVhY3REYXRhR3JpZCc7XG5cdFJlYWN0RGF0YUdyaWQucHJvcFR5cGVzID0ge1xuXHQgIHJvd0hlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBoZWFkZXJSb3dIZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGhlYWRlckZpbHRlcnNIZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIG1pbkhlaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIuaXNSZXF1aXJlZCxcblx0ICBtaW5XaWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgZW5hYmxlUm93U2VsZWN0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIG9uUm93VXBkYXRlZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIHJvd0dldHRlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgcm93c0NvdW50OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIHRvb2xiYXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZWxlbWVudCxcblx0ICBlbmFibGVDZWxsU2VsZWN0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgY29sdW1uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5XSkuaXNSZXF1aXJlZCxcblx0ICBvbkZpbHRlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uQ2VsbENvcHlQYXN0ZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uQ2VsbHNEcmFnZ2VkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgZ2V0Q2VsbEFjdGlvbnM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvbkFkZEZpbHRlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uR3JpZFNvcnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBzb3J0Q29sdW1uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBzb3J0RGlyZWN0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKE9iamVjdC5rZXlzKF9Tb3J0YWJsZUhlYWRlckNlbGwuREVGSU5FX1NPUlQpKSxcblx0ICBvbkRyYWdIYW5kbGVEb3VibGVDbGljazogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uR3JpZFJvd3NVcGRhdGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25Sb3dTZWxlY3Q6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICByb3dLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIHJvd1Njcm9sbFRpbWVvdXQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHNjcm9sbFRvUm93SW5kZXg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIG9uQ2xlYXJGaWx0ZXJzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgY29udGV4dE1lbnU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZWxlbWVudCxcblx0ICBjZWxsTmF2aWdhdGlvbk1vZGU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2YoWydub25lJywgJ2xvb3BPdmVyUm93JywgJ2NoYW5nZVJvdyddKSxcblx0ICBvbkNlbGxTZWxlY3RlZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uQ2VsbERlU2VsZWN0ZWQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvbkNlbGxFeHBhbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBlbmFibGVEcmFnQW5kRHJvcDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgIHRhYkluZGV4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBvblJvd0V4cGFuZFRvZ2dsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGRyYWdnYWJsZUhlYWRlckNlbGw6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBnZXRWYWxpZEZpbHRlclZhbHVlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIHJvd1NlbGVjdGlvbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBlbmFibGVTaGlmdFNlbGVjdDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgICAgb25Sb3dzU2VsZWN0ZWQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICAgIG9uUm93c0Rlc2VsZWN0ZWQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICAgIHNob3dDaGVja2JveDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgICAgc2VsZWN0Qnk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgICAgaW5kZXhlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheU9mKF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyKS5pc1JlcXVpcmVkXG5cdCAgICB9KSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICAgIGlzU2VsZWN0ZWRLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWRcblx0ICAgIH0pLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgICAga2V5czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICAgICAgdmFsdWVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LmlzUmVxdWlyZWQsXG5cdCAgICAgICAgcm93S2V5OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkXG5cdCAgICAgIH0pLmlzUmVxdWlyZWRcblx0ICAgIH0pXSkuaXNSZXF1aXJlZFxuXHQgIH0pLFxuXHQgIG9uUm93Q2xpY2s6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvblJvd0RvdWJsZUNsaWNrOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25HcmlkS2V5VXA6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvbkdyaWRLZXlEb3duOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgcm93R3JvdXBSZW5kZXJlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIHJvd0FjdGlvbnNDZWxsOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25DaGVja0NlbGxJc0VkaXRhYmxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgLyogY2FsbGVkIGJlZm9yZSBjZWxsIGlzIHNldCBhY3RpdmUsIHJldHVybnMgYSBib29sZWFuIHRvIGRldGVybWluZSB3aGV0aGVyIGNlbGwgaXMgZWRpdGFibGUgKi9cblx0ICBvdmVyU2NhbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgb25EZWxldGVTdWJSb3c6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBvbkFkZFN1YlJvdzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGVuYWJsZUNlbGxBdXRvRm9jdXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCxcblx0ICBvbkJlZm9yZUVkaXQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBzZWxlY3RBbGxSZW5kZXJlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgbWluQ29sdW1uV2lkdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGNvbHVtbkVxdWFsaXR5OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgb25Db2x1bW5SZXNpemU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuY1xuXHR9O1xuXHRSZWFjdERhdGFHcmlkLmRlZmF1bHRQcm9wcyA9IHtcblx0ICBlbmFibGVDZWxsU2VsZWN0OiBmYWxzZSxcblx0ICB0YWJJbmRleDogLTEsXG5cdCAgcm93SGVpZ2h0OiAzNSxcblx0ICBoZWFkZXJGaWx0ZXJzSGVpZ2h0OiA0NSxcblx0ICBlbmFibGVSb3dTZWxlY3Q6IGZhbHNlLFxuXHQgIG1pbkhlaWdodDogMzUwLFxuXHQgIHJvd0tleTogJ2lkJyxcblx0ICByb3dTY3JvbGxUaW1lb3V0OiAwLFxuXHQgIHNjcm9sbFRvUm93SW5kZXg6IDAsXG5cdCAgY2VsbE5hdmlnYXRpb25Nb2RlOiAnbm9uZScsXG5cdCAgb3ZlclNjYW46IHtcblx0ICAgIGNvbHNTdGFydDogNSxcblx0ICAgIGNvbHNFbmQ6IDUsXG5cdCAgICByb3dzU3RhcnQ6IDUsXG5cdCAgICByb3dzRW5kOiA1XG5cdCAgfSxcblx0ICBlbmFibGVDZWxsQXV0b0ZvY3VzOiB0cnVlLFxuXHQgIG9uQmVmb3JlRWRpdDogZnVuY3Rpb24gb25CZWZvcmVFZGl0KCkge30sXG5cdCAgbWluQ29sdW1uV2lkdGg6IDgwLFxuXHQgIGNvbHVtbkVxdWFsaXR5OiBDb2x1bW5NZXRyaWNzLnNhbWVDb2x1bW5cblx0fTtcblxuXHR2YXIgX2luaXRpYWxpc2VQcm9wcyA9IGZ1bmN0aW9uIF9pbml0aWFsaXNlUHJvcHMoKSB7XG5cdCAgdmFyIF90aGlzMyA9IHRoaXM7XG5cblx0ICB0aGlzLmdyaWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfdGhpczMuZ3JpZCA/IF90aGlzMy5ncmlkLnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGggOiAwO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldFRvdGFsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdG90YWxXaWR0aCA9IDA7XG5cdCAgICBpZiAoX3RoaXMzLl9tb3VudGVkKSB7XG5cdCAgICAgIHRvdGFsV2lkdGggPSBfdGhpczMuZ3JpZFdpZHRoKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0b3RhbFdpZHRoID0gQ29sdW1uVXRpbHMuZ2V0U2l6ZShfdGhpczMucHJvcHMuY29sdW1ucykgKiBfdGhpczMucHJvcHMubWluQ29sdW1uV2lkdGg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG90YWxXaWR0aDtcblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRDb2x1bW5NZXRyaWNzVHlwZSA9IGZ1bmN0aW9uIChtZXRyaWNzKSB7XG5cdCAgICB2YXIgdG90YWxXaWR0aCA9IG1ldHJpY3MudG90YWxXaWR0aCB8fCBfdGhpczMuZ2V0VG90YWxXaWR0aCgpO1xuXHQgICAgdmFyIGN1cnJlbnRNZXRyaWNzID0ge1xuXHQgICAgICBjb2x1bW5zOiBtZXRyaWNzLmNvbHVtbnMsXG5cdCAgICAgIHRvdGFsV2lkdGg6IHRvdGFsV2lkdGgsXG5cdCAgICAgIG1pbkNvbHVtbldpZHRoOiBtZXRyaWNzLm1pbkNvbHVtbldpZHRoXG5cdCAgICB9O1xuXHQgICAgdmFyIHVwZGF0ZWRNZXRyaWNzID0gQ29sdW1uTWV0cmljcy5yZWNhbGN1bGF0ZShjdXJyZW50TWV0cmljcyk7XG5cdCAgICByZXR1cm4gdXBkYXRlZE1ldHJpY3M7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgdmFyIGNvbHVtbnMgPSBfdGhpczMuc3RhdGUuY29sdW1uTWV0cmljcy5jb2x1bW5zO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1ucykpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnNbaWR4XTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIEltbXV0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnMuZ2V0KGlkeCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb2x1bW5zID0gX3RoaXMzLnN0YXRlLmNvbHVtbk1ldHJpY3MuY29sdW1ucztcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbnMpKSB7XG5cdCAgICAgIHJldHVybiBjb2x1bW5zLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIEltbXV0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIGNvbHVtbnMuc2l6ZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5tZXRyaWNzVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb2x1bW5NZXRyaWNzID0gX3RoaXMzLmNyZWF0ZUNvbHVtbk1ldHJpY3MoKTtcblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IGNvbHVtbk1ldHJpY3M6IGNvbHVtbk1ldHJpY3MgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMuY3JlYXRlQ29sdW1uTWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3RoaXMzLnByb3BzO1xuXG5cdCAgICB2YXIgZ3JpZENvbHVtbnMgPSBfdGhpczMuc2V0dXBHcmlkQ29sdW1ucyhwcm9wcyk7XG5cdCAgICByZXR1cm4gX3RoaXMzLmdldENvbHVtbk1ldHJpY3NUeXBlKHtcblx0ICAgICAgY29sdW1uczogZ3JpZENvbHVtbnMsXG5cdCAgICAgIG1pbkNvbHVtbldpZHRoOiBfdGhpczMucHJvcHMubWluQ29sdW1uV2lkdGgsXG5cdCAgICAgIHRvdGFsV2lkdGg6IHByb3BzLm1pbldpZHRoXG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vbkNvbHVtblJlc2l6ZSA9IGZ1bmN0aW9uIChpbmRleCwgd2lkdGgpIHtcblx0ICAgIHZhciBjb2x1bW5NZXRyaWNzID0gQ29sdW1uTWV0cmljcy5yZXNpemVDb2x1bW4oX3RoaXMzLnN0YXRlLmNvbHVtbk1ldHJpY3MsIGluZGV4LCB3aWR0aCk7XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyBjb2x1bW5NZXRyaWNzOiBjb2x1bW5NZXRyaWNzIH0pO1xuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5vbkNvbHVtblJlc2l6ZSkge1xuXHQgICAgICBfdGhpczMucHJvcHMub25Db2x1bW5SZXNpemUoaW5kZXgsIHdpZHRoKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKCgwLCBfa2V5Ym9hcmRVdGlscy5pc0N0cmxLZXlIZWxkRG93bikoZSkpIHtcblx0ICAgICAgX3RoaXMzLmNoZWNrQW5kQ2FsbCgnb25QcmVzc0tleVdpdGhDdHJsJywgZSk7XG5cdCAgICB9IGVsc2UgaWYgKF90aGlzMy5pc0tleUV4cGxpY2l0bHlIYW5kbGVkKGUua2V5KSkge1xuXHQgICAgICAvLyBicmVhayB1cCBpbmRpdmlkdWFsIGtleVByZXNzIGV2ZW50cyB0byBoYXZlIHRoZWlyIG93biBzcGVjaWZpYyBjYWxsYmFja3Ncblx0ICAgICAgdmFyIGNhbGxCYWNrID0gJ29uUHJlc3MnICsgZS5rZXk7XG5cdCAgICAgIF90aGlzMy5jaGVja0FuZENhbGwoY2FsbEJhY2ssIGUpO1xuXHQgICAgfSBlbHNlIGlmICgoMCwgX2tleWJvYXJkVXRpbHMuaXNLZXlQcmludGFibGUpKGUua2V5Q29kZSkpIHtcblx0ICAgICAgX3RoaXMzLmNoZWNrQW5kQ2FsbCgnb25QcmVzc0NoYXInLCBlKTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJhY2sgd2hpY2gga2V5cyBhcmUgY3VycmVudGx5IGRvd24gZm9yIHNoaWZ0IGNsaWNraW5nIGV0Y1xuXHQgICAgX3RoaXMzLl9rZXlzRG93biA9IF90aGlzMy5fa2V5c0Rvd24gfHwge307XG5cdCAgICBfdGhpczMuX2tleXNEb3duW2Uua2V5Q29kZV0gPSB0cnVlO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMzLnByb3BzLm9uR3JpZEtleURvd24pKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5vbkdyaWRLZXlEb3duKGUpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgLy8gVHJhY2sgd2hpY2gga2V5cyBhcmUgY3VycmVudGx5IGRvd24gZm9yIHNoaWZ0IGNsaWNraW5nIGV0Y1xuXHQgICAgX3RoaXMzLl9rZXlzRG93biA9IF90aGlzMy5fa2V5c0Rvd24gfHwge307XG5cdCAgICBkZWxldGUgX3RoaXMzLl9rZXlzRG93bltlLmtleUNvZGVdO1xuXG5cdCAgICBpZiAoaXNGdW5jdGlvbihfdGhpczMucHJvcHMub25HcmlkS2V5VXApKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5vbkdyaWRLZXlVcChlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5pc0tleURvd24gPSBmdW5jdGlvbiAoa2V5Q29kZSkge1xuXHQgICAgaWYgKCFfdGhpczMuX2tleXNEb3duKSByZXR1cm4gZmFsc2U7XG5cdCAgICByZXR1cm4ga2V5Q29kZSBpbiBfdGhpczMuX2tleXNEb3duO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzU2luZ2xlS2V5RG93biA9IGZ1bmN0aW9uIChrZXlDb2RlKSB7XG5cdCAgICBpZiAoIV90aGlzMy5fa2V5c0Rvd24pIHJldHVybiBmYWxzZTtcblx0ICAgIHJldHVybiBrZXlDb2RlIGluIF90aGlzMy5fa2V5c0Rvd24gJiYgT2JqZWN0LmtleXMoX3RoaXMzLl9rZXlzRG93bikubGVuZ3RoID09PSAxO1xuXHQgIH07XG5cblx0ICB0aGlzLmNoZWNrQW5kQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmdzKSB7XG5cdCAgICBpZiAodHlwZW9mIF90aGlzM1ttZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBfdGhpczNbbWV0aG9kTmFtZV0oYXJncyk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMuaXNLZXlFeHBsaWNpdGx5SGFuZGxlZCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgX3RoaXMzWydvblByZXNzJyArIGtleV0gPT09ICdmdW5jdGlvbic7XG5cdCAgfTtcblxuXHQgIHRoaXMuaGFzU2VsZWN0ZWRDZWxsQ2hhbmdlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuXHQgICAgdmFyIHByZXZpb3VzbHlTZWxlY3RlZCA9IE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5zdGF0ZS5zZWxlY3RlZCk7XG5cdCAgICByZXR1cm4gcHJldmlvdXNseVNlbGVjdGVkLnJvd0lkeCAhPT0gc2VsZWN0ZWQucm93SWR4IHx8IHByZXZpb3VzbHlTZWxlY3RlZC5pZHggIT09IHNlbGVjdGVkLmlkeCB8fCBwcmV2aW91c2x5U2VsZWN0ZWQuYWN0aXZlID09PSBmYWxzZTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vbkNvbnRleHRNZW51SGlkZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMzLm9uQ29udGV4dE1lbnVIaWRlKTtcblx0ICAgIHZhciBuZXdTZWxlY3RlZCA9IE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5zdGF0ZS5zZWxlY3RlZCwgeyBjb250ZXh0TWVudURpc3BsYXllZDogZmFsc2UgfSk7XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyBzZWxlY3RlZDogbmV3U2VsZWN0ZWQgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25Db2x1bW5FdmVudCA9IGZ1bmN0aW9uIChldiwgY29sdW1uRXZlbnQpIHtcblx0ICAgIHZhciBpZHggPSBjb2x1bW5FdmVudC5pZHgsXG5cdCAgICAgICAgbmFtZSA9IGNvbHVtbkV2ZW50Lm5hbWU7XG5cblxuXHQgICAgaWYgKG5hbWUgJiYgdHlwZW9mIGlkeCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgdmFyIGNvbHVtbiA9IF90aGlzMy5nZXRDb2x1bW4oaWR4KTtcblxuXHQgICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5ldmVudHMgJiYgY29sdW1uLmV2ZW50c1tuYW1lXSAmJiB0eXBlb2YgY29sdW1uLmV2ZW50c1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHZhciBldmVudEFyZ3MgPSB7XG5cdCAgICAgICAgICBpZHg6IGlkeCxcblx0ICAgICAgICAgIHJvd0lkeDogY29sdW1uRXZlbnQucm93SWR4LFxuXHQgICAgICAgICAgcm93SWQ6IGNvbHVtbkV2ZW50LnJvd0lkLFxuXHQgICAgICAgICAgY29sdW1uOiBjb2x1bW5cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgY29sdW1uLmV2ZW50c1tuYW1lXShldiwgZXZlbnRBcmdzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG5cdCAgICBpZiAoX3RoaXMzLnN0YXRlLnNlbGVjdGVkLnJvd0lkeCAhPT0gc2VsZWN0ZWQucm93SWR4IHx8IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5pZHggIT09IHNlbGVjdGVkLmlkeCB8fCBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuYWN0aXZlID09PSBmYWxzZSkge1xuXHQgICAgICB2YXIgX2lkeCA9IHNlbGVjdGVkLmlkeDtcblx0ICAgICAgdmFyIF9yb3dJZHggPSBzZWxlY3RlZC5yb3dJZHg7XG5cdCAgICAgIGlmIChfdGhpczMuaXNDZWxsV2l0aGluQm91bmRzKHNlbGVjdGVkKSkge1xuXHQgICAgICAgIHZhciBvbGRTZWxlY3Rpb24gPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQ7XG5cdCAgICAgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMzLnByb3BzLm9uQ2VsbERlU2VsZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgX3RoaXMzLnByb3BzLm9uQ2VsbERlU2VsZWN0ZWQob2xkU2VsZWN0aW9uKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMzLnByb3BzLm9uQ2VsbFNlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkNlbGxTZWxlY3RlZChzZWxlY3RlZCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3Jvd0lkeCA9PT0gLTEgJiYgX2lkeCA9PT0gLTEpIHtcblx0ICAgICAgICAvLyBXaGVuIGl0J3Mgb3V0c2lkZSBvZiB0aGUgZ3JpZCwgc2V0IHJvd0lkeCBhbnl3YXlcblx0ICAgICAgICBfdGhpczMuc2V0U3RhdGUoeyBzZWxlY3RlZDogeyBpZHg6IF9pZHgsIHJvd0lkeDogX3Jvd0lkeCB9IH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25DZWxsQ2xpY2sgPSBmdW5jdGlvbiAoY2VsbCwgZSkge1xuXHQgICAgX3RoaXMzLm9uU2VsZWN0KHsgcm93SWR4OiBjZWxsLnJvd0lkeCwgaWR4OiBjZWxsLmlkeCB9KTtcblxuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5vblJvd0NsaWNrICYmIHR5cGVvZiBfdGhpczMucHJvcHMub25Sb3dDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBfdGhpczMucHJvcHMub25Sb3dDbGljayhjZWxsLnJvd0lkeCwgX3RoaXMzLnByb3BzLnJvd0dldHRlcihjZWxsLnJvd0lkeCksIF90aGlzMy5nZXRDb2x1bW4oY2VsbC5pZHgpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGUpIHtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vbkNlbGxGb2N1cyA9IGZ1bmN0aW9uIChjZWxsKSB7XG5cdCAgICBfdGhpczMub25TZWxlY3QoY2VsbCk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25DZWxsQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoY2VsbCkge1xuXHQgICAgX3RoaXMzLm9uU2VsZWN0KHsgcm93SWR4OiBjZWxsLnJvd0lkeCwgaWR4OiBjZWxsLmlkeCwgY29udGV4dE1lbnVEaXNwbGF5ZWQ6IF90aGlzMy5wcm9wcy5jb250ZXh0TWVudSB9KTtcblx0ICAgIGlmIChfdGhpczMucHJvcHMuY29udGV4dE1lbnUpIHtcblx0ICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpczMub25Db250ZXh0TWVudUhpZGUpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLm9uQ2VsbERvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGNlbGwsIGUpIHtcblx0ICAgIF90aGlzMy5vblNlbGVjdCh7IHJvd0lkeDogY2VsbC5yb3dJZHgsIGlkeDogY2VsbC5pZHggfSk7XG5cdCAgICBpZiAoX3RoaXMzLnByb3BzLm9uUm93RG91YmxlQ2xpY2sgJiYgdHlwZW9mIF90aGlzMy5wcm9wcy5vblJvd0RvdWJsZUNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5vblJvd0RvdWJsZUNsaWNrKGNlbGwucm93SWR4LCBfdGhpczMucHJvcHMucm93R2V0dGVyKGNlbGwucm93SWR4KSwgX3RoaXMzLmdldENvbHVtbihjZWxsLmlkeCkpO1xuXHQgICAgfVxuXHQgICAgX3RoaXMzLnNldEFjdGl2ZSgpO1xuXHQgICAgaWYgKGUpIHtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzQXJyb3dVcCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBfdGhpczMubW92ZVNlbGVjdGVkQ2VsbChlLCAtMSwgMCk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0Fycm93RG93biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBfdGhpczMubW92ZVNlbGVjdGVkQ2VsbChlLCAxLCAwKTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzQXJyb3dMZWZ0ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIF90aGlzMy5tb3ZlU2VsZWN0ZWRDZWxsKGUsIDAsIC0xKTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzQXJyb3dSaWdodCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBfdGhpczMubW92ZVNlbGVjdGVkQ2VsbChlLCAwLCAxKTtcblx0ICB9O1xuXG5cdCAgdGhpcy5pc0ZvY3VzZWRPbkNlbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncmVhY3QtZ3JpZC1DZWxsJyk7XG5cdCAgfTtcblxuXHQgIHRoaXMuaXNGb2N1c2VkT25UYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBkb21Ob2RlID0gX3RoaXMzLmdldERhdGFHcmlkRE9NTm9kZSgpO1xuXHQgICAgcmV0dXJuIGRvbU5vZGUgJiYgZG9tTm9kZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5leGl0R3JpZCA9IGZ1bmN0aW9uIChvbGRTZWxlY3RlZENlbGwsIG5ld1NlbGVjdGVkVmFsdWUpIHtcblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiBuZXdTZWxlY3RlZFZhbHVlIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBfdGhpczMucHJvcHMub25DZWxsRGVTZWxlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIF90aGlzMy5wcm9wcy5vbkNlbGxEZVNlbGVjdGVkKG9sZFNlbGVjdGVkQ2VsbCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICB0aGlzLmVudGVyR3JpZCA9IGZ1bmN0aW9uIChuZXdTZWxlY3RlZFZhbHVlKSB7XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyBzZWxlY3RlZDogbmV3U2VsZWN0ZWRWYWx1ZSB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgX3RoaXMzLnByb3BzLm9uQ2VsbFNlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgX3RoaXMzLnByb3BzLm9uQ2VsbFNlbGVjdGVkKG5ld1NlbGVjdGVkVmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzVGFiID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIC8vIFNjZW5hcmlvIDBhOiBXaGVuIHRoZXJlIGFyZSBubyByb3dzIGluIHRoZSBncmlkLCBwcmVzc2luZyB0YWIgbmVlZHMgdG8gYWxsb3cgdGhlIGJyb3dzZXIgdG8gaGFuZGxlIGl0XG5cdCAgICBpZiAoX3RoaXMzLnByb3BzLnJvd3NDb3VudCA9PT0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBTY2VuYXJpbyAwYjogV2hlbiB3ZSdyZSBlZGl0aW5nIGEgY2VsbFxuXHQgICAgdmFyIGlkeCA9IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5pZHg7XG5cdCAgICB2YXIgcm93SWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLnJvd0lkeDtcblx0ICAgIGlmIChfdGhpczMuc3RhdGUuc2VsZWN0ZWQuYWN0aXZlID09PSB0cnVlKSB7XG5cdCAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIHBvc2l0aW9uIHRvIGxlYXZlIHRoZSBncmlkLCBzdG9wIGVkaXRpbmcgYnV0IHN0YXkgaW4gdGhhdCBjZWxsXG5cdCAgICAgIGlmIChfdGhpczMuY2FuRXhpdEdyaWQoZSkpIHtcblx0ICAgICAgICBfdGhpczMubW92ZVNlbGVjdGVkQ2VsbChlLCAwLCAwKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgLy8gb3RoZXJ3aXNlIG1vdmUgbGVmdCBvciByaWdodCBhcyBhcHByb3ByaWF0ZVxuXHQgICAgICBfdGhpczMubW92ZVNlbGVjdGVkQ2VsbChlLCAwLCBlLnNoaWZ0S2V5ID8gLTEgOiAxKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHNoaWZ0ID0gZS5zaGlmdEtleSA9PT0gdHJ1ZTtcblx0ICAgIC8vIFNjZW5hcmlvIDE6IHdlJ3JlIGF0IGEgY2VsbCB3aGVyZSB3ZSBjYW4gZXhpdCB0aGUgZ3JpZFxuXHQgICAgaWYgKF90aGlzMy5jYW5FeGl0R3JpZChlKSAmJiBfdGhpczMuaXNGb2N1c2VkT25DZWxsKCkpIHtcblx0ICAgICAgaWYgKHNoaWZ0ICYmIGlkeCA+PSAwKSB7XG5cdCAgICAgICAgX3RoaXMzLmV4aXRHcmlkKHsgaWR4OiBpZHgsIHJvd0lkeDogcm93SWR4IH0sIHsgaWR4OiAtMSwgcm93SWR4OiByb3dJZHgsIGV4aXRlZExlZnQ6IHRydWUgfSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9IGVsc2UgaWYgKCFzaGlmdCAmJiBpZHggPj0gMCkge1xuXHQgICAgICAgIF90aGlzMy5leGl0R3JpZCh7IGlkeDogaWR4LCByb3dJZHg6IHJvd0lkeCB9LCB7IGlkeDogLTEsIHJvd0lkeDogcm93SWR4IH0pO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gU2NlbmFyaW8gMjogd2UncmUgb24gdGhlIGRpdiBzdXJyb3VuZGluZyB0aGUgZ3JpZCBhbmQgcHJlc3Mgc2hpZnQrVGFiXG5cdCAgICAvLyBhbmQgd2UganVzdCBleGl0ZWQgbGVmdCwgc28gd2Ugd2FudCB0byBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIGl0XG5cdCAgICAvLyBLTk9XTiBJU1NVRTogRm9jdXMgb24gdGhlIHRhYmxlIGNhbiBjb21lIGZyb20gZWl0aGVyIHNpZGUgYW5kIGF0IHRoaXMgcG9pbnQgd2UgY2FuJ3Qga25vdyBob3dcblx0ICAgIC8vIHRoZXkgdXNlciBhcnJpdmVkLCBzbyBpdCBpcyBwb3NzaWJsZSB0aGF0IGV4aXRMZWZ0IGdldHMgc2V0IGFuZCB0aGVuIHRoZSB1c2VyIGNsaWNrcyBvdXQgb2YgdGhlIHRhYmxlXG5cdCAgICAvLyBhbmQgdGhleSB3b24ndCBiZSBhYmxlIHRvIFNoaWZ0K1RhYiBhcm91bmQgdGhlIHNpdGUgdG8gcmUtZW50ZXIgdGhlIHRhYmxlIGZyb20gdGhlIHJpZ2h0LlxuXHQgICAgaWYgKF90aGlzMy5pc0ZvY3VzZWRPblRhYmxlKCkgJiYgIV90aGlzMy5pc0ZvY3VzZWRPbkNlbGwoKSAmJiBzaGlmdCAmJiBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuZXhpdGVkTGVmdCkge1xuXHQgICAgICBfdGhpczMuZW50ZXJHcmlkKHsgaWR4OiBpZHgsIHJvd0lkeDogcm93SWR4IH0pO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBTY2VuYXJpbyAzOiB3ZSdyZSBvbiB0aGUgZGl2IHN1cnJvdW5kaW5nIHRoZSBncmlkIGFuZCB3ZSB3YW50IHRvIGVudGVyIHRoZSBncmlkXG5cdCAgICBpZiAoIV90aGlzMy5pc0ZvY3VzZWRPbkNlbGwoKSkge1xuXHQgICAgICAvLyBTY2VuYXJpbyAzQTogaWR4IGhhcyBiZWVuIHNldCB0byAtMSAoZWcgY2FuIGhhcHBlbiB3aGVuIGNsaWNraW5nIGludG8gdGhlIGZpbHRlciBib3gpXG5cdCAgICAgIC8vIHdlIHdhbnQgdG8gZ28gdG8gdGhlIGZpcnN0IGNlbGwgaW4gdGhlIHJvdyBpZiB3ZSBwcmVzcyBUYWJcblx0ICAgICAgLy8gd2Ugd2FudCB0byBnbyB0byB0aGUgbGFzdCBjZWxsIGluIHRoZSByb3cgaWYgd2UgcHJlc3MgU2hpZnQrVGFiXG5cdCAgICAgIGlmIChpZHggPT09IC0xKSB7XG5cdCAgICAgICAgX3RoaXMzLm1vdmVTZWxlY3RlZENlbGwoZSwgcm93SWR4ID09PSAtMSA/IDEgOiAwLCBzaGlmdCA/IF90aGlzMy5nZXROYnJDb2x1bW5zKCkgOiAxKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgLy8gb3RoZXJ3aXNlLCB0aGVyZSBpcyBhIHNlbGVjdGVkIGNlbGwgaW4gdGhlIHRhYmxlIGFscmVhZHksIGFuZFxuXHQgICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgaXQgdG8gZm9jdXMgLSBzZXR0aW5nIHNlbGVjdGVkIGluIHN0YXRlIHdpbGwgdXBkYXRlXG5cdCAgICAgIC8vIHRoZSBjZWxsIHByb3BzLCBhbmQgY2hlY2tGb2N1cyB3aWxsIGJlIGNhbGxlZFxuXHQgICAgICBfdGhpczMuZW50ZXJHcmlkKHsgaWR4OiBpZHgsIHJvd0lkeDogcm93SWR4LCBjaGFuZ2VTb21ldGhpbmc6IHRydWUgfSk7XG5cdCAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGhhbmRsZSBpdFxuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIF90aGlzMy5tb3ZlU2VsZWN0ZWRDZWxsKGUsIDAsIGUuc2hpZnRLZXkgPyAtMSA6IDEpO1xuXHQgIH07XG5cblx0ICB0aGlzLm9uUHJlc3NFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBfdGhpczMuc2V0QWN0aXZlKGUua2V5KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzRGVsZXRlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIF90aGlzMy5zZXRBY3RpdmUoZS5rZXkpO1xuXHQgIH07XG5cblx0ICB0aGlzLm9uUHJlc3NFc2NhcGUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgX3RoaXMzLnNldEluYWN0aXZlKGUua2V5KTtcblx0ICAgIF90aGlzMy5oYW5kbGVDYW5jZWxDb3B5KCk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0JhY2tzcGFjZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBfdGhpczMuc2V0QWN0aXZlKGUua2V5KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzQ2hhciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoKDAsIF9rZXlib2FyZFV0aWxzLmlzS2V5UHJpbnRhYmxlKShlLmtleUNvZGUpKSB7XG5cdCAgICAgIF90aGlzMy5zZXRBY3RpdmUoZS5rZXlDb2RlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzS2V5V2l0aEN0cmwgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIGtleXMgPSB7XG5cdCAgICAgIEtleUNvZGVfYzogOTksXG5cdCAgICAgIEtleUNvZGVfQzogNjcsXG5cdCAgICAgIEtleUNvZGVfVjogODYsXG5cdCAgICAgIEtleUNvZGVfdjogMTE4XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgcm93SWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLnJvd0lkeDtcblx0ICAgIHZhciByb3cgPSBfdGhpczMucHJvcHMucm93R2V0dGVyKHJvd0lkeCk7XG5cblx0ICAgIHZhciBpZHggPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuaWR4O1xuXHQgICAgdmFyIGNvbCA9IF90aGlzMy5nZXRDb2x1bW4oaWR4KTtcblxuXHQgICAgaWYgKENvbHVtblV0aWxzLmNhbkVkaXQoY29sLCByb3csIF90aGlzMy5wcm9wcy5lbmFibGVDZWxsU2VsZWN0KSkge1xuXHQgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzLktleUNvZGVfYyB8fCBlLmtleUNvZGUgPT09IGtleXMuS2V5Q29kZV9DKSB7XG5cdCAgICAgICAgdmFyIF92YWx1ZSA9IF90aGlzMy5nZXRTZWxlY3RlZFZhbHVlKCk7XG5cdCAgICAgICAgX3RoaXMzLmhhbmRsZUNvcHkoeyB2YWx1ZTogX3ZhbHVlIH0pO1xuXHQgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0ga2V5cy5LZXlDb2RlX3YgfHwgZS5rZXlDb2RlID09PSBrZXlzLktleUNvZGVfVikge1xuXHQgICAgICAgIF90aGlzMy5oYW5kbGVQYXN0ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25HcmlkUm93c1VwZGF0ZWQgPSBmdW5jdGlvbiAoY2VsbEtleSwgZnJvbVJvdywgdG9Sb3csIHVwZGF0ZWQsIGFjdGlvbiwgb3JpZ2luUm93KSB7XG5cdCAgICB2YXIgcm93SWRzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSBmcm9tUm93OyBpIDw9IHRvUm93OyBpKyspIHtcblx0ICAgICAgcm93SWRzLnB1c2goX3RoaXMzLnByb3BzLnJvd0dldHRlcihpKVtfdGhpczMucHJvcHMucm93S2V5XSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBmcm9tUm93RGF0YSA9IF90aGlzMy5wcm9wcy5yb3dHZXR0ZXIoYWN0aW9uID09PSAnQ09QWV9QQVNURScgPyBvcmlnaW5Sb3cgOiBmcm9tUm93KTtcblx0ICAgIHZhciBmcm9tUm93SWQgPSBmcm9tUm93RGF0YVtfdGhpczMucHJvcHMucm93S2V5XTtcblx0ICAgIHZhciB0b1Jvd0lkID0gX3RoaXMzLnByb3BzLnJvd0dldHRlcih0b1JvdylbX3RoaXMzLnByb3BzLnJvd0tleV07XG5cdCAgICBfdGhpczMucHJvcHMub25HcmlkUm93c1VwZGF0ZWQoeyBjZWxsS2V5OiBjZWxsS2V5LCBmcm9tUm93OiBmcm9tUm93LCB0b1JvdzogdG9Sb3csIGZyb21Sb3dJZDogZnJvbVJvd0lkLCB0b1Jvd0lkOiB0b1Jvd0lkLCByb3dJZHM6IHJvd0lkcywgdXBkYXRlZDogdXBkYXRlZCwgYWN0aW9uOiBhY3Rpb24sIGZyb21Sb3dEYXRhOiBmcm9tUm93RGF0YSB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vbkNlbGxDb21taXQgPSBmdW5jdGlvbiAoY29tbWl0KSB7XG5cdCAgICB2YXIgc2VsZWN0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpczMuc3RhdGUuc2VsZWN0ZWQpO1xuXHQgICAgc2VsZWN0ZWQuYWN0aXZlID0gZmFsc2U7XG5cdCAgICB2YXIgZXhwYW5kZWRSb3dzID0gX3RoaXMzLnN0YXRlLmV4cGFuZGVkUm93cztcblx0ICAgIC8vIGlmKGNvbW1pdC5jaGFuZ2VkICYmIGNvbW1pdC5jaGFuZ2VkLmV4cGFuZGVkSGVpZ2h0KXtcblx0ICAgIC8vICAgZXhwYW5kZWRSb3dzID0gdGhpcy5leHBhbmRSb3coY29tbWl0LnJvd0lkeCwgY29tbWl0LmNoYW5nZWQuZXhwYW5kZWRIZWlnaHQpO1xuXHQgICAgLy8gfVxuXHQgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWQ6IHNlbGVjdGVkLCBleHBhbmRlZFJvd3M6IGV4cGFuZGVkUm93cyB9KTtcblxuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5vblJvd1VwZGF0ZWQpIHtcblx0ICAgICAgX3RoaXMzLnByb3BzLm9uUm93VXBkYXRlZChjb21taXQpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdGFyZ2V0Um93ID0gY29tbWl0LnJvd0lkeDtcblxuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5vbkdyaWRSb3dzVXBkYXRlZCkge1xuXHQgICAgICBfdGhpczMub25HcmlkUm93c1VwZGF0ZWQoY29tbWl0LmNlbGxLZXksIHRhcmdldFJvdywgdGFyZ2V0Um93LCBjb21taXQudXBkYXRlZCwgX0FwcENvbnN0YW50czJbJ2RlZmF1bHQnXS5VcGRhdGVBY3Rpb25zLkNFTExfVVBEQVRFKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgaWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLmlkeDtcblx0ICAgIC8vIFRvIHByZXZlbnQgZHJhZ2dpbmcgZG93bi91cCB3aGVuIHJlb3JkZXJpbmcgcm93cy5cblx0ICAgIHZhciBpc1ZpZXdwb3J0RHJhZ2dpbmcgPSBlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LmNsYXNzTmFtZTtcblx0ICAgIGlmIChpZHggPiAtMSAmJiBpc1ZpZXdwb3J0RHJhZ2dpbmcpIHtcblx0ICAgICAgdmFyIF92YWx1ZTIgPSBfdGhpczMuZ2V0U2VsZWN0ZWRWYWx1ZSgpO1xuXHQgICAgICBfdGhpczMuaGFuZGxlRHJhZ1N0YXJ0KHsgaWR4OiBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuaWR4LCByb3dJZHg6IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5yb3dJZHgsIHZhbHVlOiBfdmFsdWUyIH0pO1xuXHQgICAgICAvLyBuZWVkIHRvIHNldCBkdW1teSBkYXRhIGZvciBGRlxuXHQgICAgICBpZiAoZSAmJiBlLmRhdGFUcmFuc2Zlcikge1xuXHQgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREYXRhKSB7XG5cdCAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuXHQgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcblx0ICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQvcGxhaW4nLCAnJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25Ub2dnbGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBzZXRTdGF0ZSgpIGRvZXMgbm90IGltbWVkaWF0ZWx5IG11dGF0ZSB0aGlzLnN0YXRlIGJ1dCBjcmVhdGVzIGEgcGVuZGluZyBzdGF0ZSB0cmFuc2l0aW9uLlxuXHQgICAgLy8gVGhlcmVmb3JlIGlmIHlvdSB3YW50IHRvIGRvIHNvbWV0aGluZyBhZnRlciB0aGUgc3RhdGUgY2hhbmdlIG9jY3VycywgcGFzcyBpdCBpbiBhcyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgICAgX3RoaXMzLnNldFN0YXRlKHsgY2FuRmlsdGVyOiAhX3RoaXMzLnN0YXRlLmNhbkZpbHRlciB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpczMuc3RhdGUuY2FuRmlsdGVyID09PSBmYWxzZSAmJiBfdGhpczMucHJvcHMub25DbGVhckZpbHRlcnMpIHtcblx0ICAgICAgICBfdGhpczMucHJvcHMub25DbGVhckZpbHRlcnMoKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25EcmFnSGFuZGxlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5vbkRyYWdIYW5kbGVEb3VibGVDbGljaykge1xuXHQgICAgICBfdGhpczMucHJvcHMub25EcmFnSGFuZGxlRG91YmxlQ2xpY2soZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChfdGhpczMucHJvcHMub25HcmlkUm93c1VwZGF0ZWQpIHtcblx0ICAgICAgdmFyIF90aGlzMyRvbkdyaWRSb3dzVXBkYTtcblxuXHQgICAgICB2YXIgY2VsbEtleSA9IF90aGlzMy5nZXRDb2x1bW4oZS5pZHgpLmtleTtcblx0ICAgICAgX3RoaXMzLm9uR3JpZFJvd3NVcGRhdGVkKGNlbGxLZXksIGUucm93SWR4LCBfdGhpczMucHJvcHMucm93c0NvdW50IC0gMSwgKF90aGlzMyRvbkdyaWRSb3dzVXBkYSA9IHt9LCBfdGhpczMkb25HcmlkUm93c1VwZGFbY2VsbEtleV0gPSBlLnJvd0RhdGFbY2VsbEtleV0sIF90aGlzMyRvbkdyaWRSb3dzVXBkYSksIF9BcHBDb25zdGFudHMyWydkZWZhdWx0J10uVXBkYXRlQWN0aW9ucy5DT0xVTU5fRklMTCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25DZWxsRXhwYW5kID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgIGlmIChfdGhpczMucHJvcHMub25DZWxsRXhwYW5kKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5vbkNlbGxFeHBhbmQoYXJncyk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25Sb3dFeHBhbmRUb2dnbGUgPSBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgaWYgKHR5cGVvZiBfdGhpczMucHJvcHMub25Sb3dFeHBhbmRUb2dnbGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgX3RoaXMzLnByb3BzLm9uUm93RXhwYW5kVG9nZ2xlKGFyZ3MpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLmlzQ2VsbFdpdGhpbkJvdW5kcyA9IGZ1bmN0aW9uIChfcmVmKSB7XG5cdCAgICB2YXIgaWR4ID0gX3JlZi5pZHgsXG5cdCAgICAgICAgcm93SWR4ID0gX3JlZi5yb3dJZHg7XG5cblx0ICAgIHJldHVybiBpZHggPj0gMCAmJiByb3dJZHggPj0gMCAmJiBpZHggPCBDb2x1bW5VdGlscy5nZXRTaXplKF90aGlzMy5zdGF0ZS5jb2x1bW5NZXRyaWNzLmNvbHVtbnMpICYmIHJvd0lkeCA8IF90aGlzMy5wcm9wcy5yb3dzQ291bnQ7XG5cdCAgfTtcblxuXHQgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGRyYWdnZWQpIHtcblx0ICAgIGlmICghX3RoaXMzLmRyYWdFbmFibGVkKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKF90aGlzMy5pc0NlbGxXaXRoaW5Cb3VuZHMoZHJhZ2dlZCkpIHtcblx0ICAgICAgX3RoaXMzLnNldFN0YXRlKHsgZHJhZ2dlZDogZHJhZ2dlZCB9KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFfdGhpczMuZHJhZ0VuYWJsZWQoKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgX3N0YXRlID0gX3RoaXMzLnN0YXRlLFxuXHQgICAgICAgIHNlbGVjdGVkID0gX3N0YXRlLnNlbGVjdGVkLFxuXHQgICAgICAgIGRyYWdnZWQgPSBfc3RhdGUuZHJhZ2dlZDtcblxuXHQgICAgdmFyIGNvbHVtbiA9IF90aGlzMy5nZXRDb2x1bW4oX3RoaXMzLnN0YXRlLnNlbGVjdGVkLmlkeCk7XG5cdCAgICBpZiAoc2VsZWN0ZWQgJiYgZHJhZ2dlZCAmJiBjb2x1bW4pIHtcblx0ICAgICAgdmFyIGNlbGxLZXkgPSBjb2x1bW4ua2V5O1xuXHQgICAgICB2YXIgZnJvbVJvdyA9IHNlbGVjdGVkLnJvd0lkeCA8IGRyYWdnZWQub3ZlclJvd0lkeCA/IHNlbGVjdGVkLnJvd0lkeCA6IGRyYWdnZWQub3ZlclJvd0lkeDtcblx0ICAgICAgdmFyIHRvUm93ID0gc2VsZWN0ZWQucm93SWR4ID4gZHJhZ2dlZC5vdmVyUm93SWR4ID8gc2VsZWN0ZWQucm93SWR4IDogZHJhZ2dlZC5vdmVyUm93SWR4O1xuXHQgICAgICBpZiAoX3RoaXMzLnByb3BzLm9uQ2VsbHNEcmFnZ2VkKSB7XG5cdCAgICAgICAgX3RoaXMzLnByb3BzLm9uQ2VsbHNEcmFnZ2VkKHsgY2VsbEtleTogY2VsbEtleSwgZnJvbVJvdzogZnJvbVJvdywgdG9Sb3c6IHRvUm93LCB2YWx1ZTogZHJhZ2dlZC52YWx1ZSB9KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoX3RoaXMzLnByb3BzLm9uR3JpZFJvd3NVcGRhdGVkKSB7XG5cdCAgICAgICAgdmFyIF90aGlzMyRvbkdyaWRSb3dzVXBkYTI7XG5cblx0ICAgICAgICBfdGhpczMub25HcmlkUm93c1VwZGF0ZWQoY2VsbEtleSwgZnJvbVJvdywgdG9Sb3csIChfdGhpczMkb25HcmlkUm93c1VwZGEyID0ge30sIF90aGlzMyRvbkdyaWRSb3dzVXBkYTJbY2VsbEtleV0gPSBkcmFnZ2VkLnZhbHVlLCBfdGhpczMkb25HcmlkUm93c1VwZGEyKSwgX0FwcENvbnN0YW50czJbJ2RlZmF1bHQnXS5VcGRhdGVBY3Rpb25zLkNFTExfRFJBRyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IGRyYWdnZWQ6IHsgY29tcGxldGU6IHRydWUgfSB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVEcmFnRW50ZXIgPSBmdW5jdGlvbiAocm93KSB7XG5cdCAgICBpZiAoIV90aGlzMy5kcmFnRW5hYmxlZCgpIHx8IF90aGlzMy5zdGF0ZS5kcmFnZ2VkID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIGRyYWdnZWQgPSBfdGhpczMuc3RhdGUuZHJhZ2dlZDtcblx0ICAgIGRyYWdnZWQub3ZlclJvd0lkeCA9IHJvdztcblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IGRyYWdnZWQ6IGRyYWdnZWQgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMuaGFuZGxlVGVybWluYXRlRHJhZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghX3RoaXMzLmRyYWdFbmFibGVkKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgX3RoaXMzLnNldFN0YXRlKHsgZHJhZ2dlZDogbnVsbCB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVQYXN0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghX3RoaXMzLmNvcHlQYXN0ZUVuYWJsZWQoKSB8fCAhX3RoaXMzLnN0YXRlLmNvcGllZCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQ7XG5cdCAgICB2YXIgY2VsbEtleSA9IF90aGlzMy5nZXRDb2x1bW4oX3RoaXMzLnN0YXRlLnNlbGVjdGVkLmlkeCkua2V5O1xuXHQgICAgdmFyIHRleHRUb0NvcHkgPSBfdGhpczMuc3RhdGUudGV4dFRvQ29weTtcblx0ICAgIHZhciBmcm9tUm93ID0gX3RoaXMzLnN0YXRlLmNvcGllZC5yb3dJZHg7XG5cdCAgICB2YXIgdG9Sb3cgPSBzZWxlY3RlZC5yb3dJZHg7XG5cblx0ICAgIGlmIChfdGhpczMucHJvcHMub25DZWxsQ29weVBhc3RlKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5vbkNlbGxDb3B5UGFzdGUoeyBjZWxsS2V5OiBjZWxsS2V5LCByb3dJZHg6IHRvUm93LCB2YWx1ZTogdGV4dFRvQ29weSwgZnJvbVJvdzogZnJvbVJvdywgdG9Sb3c6IHRvUm93IH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoX3RoaXMzLnByb3BzLm9uR3JpZFJvd3NVcGRhdGVkKSB7XG5cdCAgICAgIHZhciBfdGhpczMkb25HcmlkUm93c1VwZGEzO1xuXG5cdCAgICAgIF90aGlzMy5vbkdyaWRSb3dzVXBkYXRlZChjZWxsS2V5LCB0b1JvdywgdG9Sb3csIChfdGhpczMkb25HcmlkUm93c1VwZGEzID0ge30sIF90aGlzMyRvbkdyaWRSb3dzVXBkYTNbY2VsbEtleV0gPSB0ZXh0VG9Db3B5LCBfdGhpczMkb25HcmlkUm93c1VwZGEzKSwgX0FwcENvbnN0YW50czJbJ2RlZmF1bHQnXS5VcGRhdGVBY3Rpb25zLkNPUFlfUEFTVEUsIGZyb21Sb3cpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLmhhbmRsZUNhbmNlbENvcHkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyBjb3BpZWQ6IG51bGwgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMuaGFuZGxlQ29weSA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICBpZiAoIV90aGlzMy5jb3B5UGFzdGVFbmFibGVkKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHRleHRUb0NvcHkgPSBhcmdzLnZhbHVlO1xuXHQgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkO1xuXHQgICAgdmFyIGNvcGllZCA9IHsgaWR4OiBzZWxlY3RlZC5pZHgsIHJvd0lkeDogc2VsZWN0ZWQucm93SWR4IH07XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyB0ZXh0VG9Db3B5OiB0ZXh0VG9Db3B5LCBjb3BpZWQ6IGNvcGllZCB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVTb3J0ID0gZnVuY3Rpb24gKGNvbHVtbktleSwgZGlyZWN0aW9uKSB7XG5cdCAgICBfdGhpczMuc2V0U3RhdGUoeyBzb3J0RGlyZWN0aW9uOiBkaXJlY3Rpb24sIHNvcnRDb2x1bW46IGNvbHVtbktleSB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMucHJvcHMub25HcmlkU29ydChjb2x1bW5LZXksIGRpcmVjdGlvbik7XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRTZWxlY3RlZFJvdyA9IGZ1bmN0aW9uIChyb3dzLCBrZXkpIHtcblx0ICAgIHZhciBzZWxlY3RlZFJvdyA9IHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG5cdCAgICAgIGlmIChyW190aGlzMy5wcm9wcy5yb3dLZXldID09PSBrZXkpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9KTtcblx0ICAgIGlmIChzZWxlY3RlZFJvdy5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHJldHVybiBzZWxlY3RlZFJvd1swXTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy51c2VOZXdSb3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbiAmJiBfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLnNlbGVjdEJ5O1xuXHQgIH07XG5cblx0ICB0aGlzLmhhbmRsZVNoaWZ0U2VsZWN0ID0gZnVuY3Rpb24gKHJvd0lkeCkge1xuXHQgICAgaWYgKF90aGlzMy5zdGF0ZS5sYXN0Um93SWR4VWlTZWxlY3RlZCA+IC0xICYmIF90aGlzMy5pc1NpbmdsZUtleURvd24oS2V5Q29kZXMuU2hpZnQpKSB7XG5cdCAgICAgIHZhciBfcHJvcHMkcm93U2VsZWN0aW9uJHMgPSBfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLnNlbGVjdEJ5LFxuXHQgICAgICAgICAga2V5cyA9IF9wcm9wcyRyb3dTZWxlY3Rpb24kcy5rZXlzLFxuXHQgICAgICAgICAgaW5kZXhlcyA9IF9wcm9wcyRyb3dTZWxlY3Rpb24kcy5pbmRleGVzLFxuXHQgICAgICAgICAgaXNTZWxlY3RlZEtleSA9IF9wcm9wcyRyb3dTZWxlY3Rpb24kcy5pc1NlbGVjdGVkS2V5O1xuXG5cdCAgICAgIHZhciBpc1ByZXZpb3VzbHlTZWxlY3RlZCA9IFJvd1V0aWxzLmlzUm93U2VsZWN0ZWQoa2V5cywgaW5kZXhlcywgaXNTZWxlY3RlZEtleSwgX3RoaXMzLnByb3BzLnJvd0dldHRlcihyb3dJZHgpLCByb3dJZHgpO1xuXG5cdCAgICAgIGlmIChpc1ByZXZpb3VzbHlTZWxlY3RlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIHZhciBoYW5kbGVkID0gZmFsc2U7XG5cblx0ICAgICAgaWYgKHJvd0lkeCA+IF90aGlzMy5zdGF0ZS5sYXN0Um93SWR4VWlTZWxlY3RlZCkge1xuXHQgICAgICAgIHZhciByb3dzU2VsZWN0ZWQgPSBbXTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSBfdGhpczMuc3RhdGUubGFzdFJvd0lkeFVpU2VsZWN0ZWQgKyAxOyBpIDw9IHJvd0lkeDsgaSsrKSB7XG5cdCAgICAgICAgICByb3dzU2VsZWN0ZWQucHVzaCh7IHJvd0lkeDogaSwgcm93OiBfdGhpczMucHJvcHMucm93R2V0dGVyKGkpIH0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5vblJvd3NTZWxlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5vblJvd3NTZWxlY3RlZChyb3dzU2VsZWN0ZWQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKHJvd0lkeCA8IF90aGlzMy5zdGF0ZS5sYXN0Um93SWR4VWlTZWxlY3RlZCkge1xuXHQgICAgICAgIHZhciBfcm93c1NlbGVjdGVkID0gW107XG5cblx0ICAgICAgICBmb3IgKHZhciBfaSA9IHJvd0lkeDsgX2kgPD0gX3RoaXMzLnN0YXRlLmxhc3RSb3dJZHhVaVNlbGVjdGVkIC0gMTsgX2krKykge1xuXHQgICAgICAgICAgX3Jvd3NTZWxlY3RlZC5wdXNoKHsgcm93SWR4OiBfaSwgcm93OiBfdGhpczMucHJvcHMucm93R2V0dGVyKF9pKSB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24ub25Sb3dzU2VsZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24ub25Sb3dzU2VsZWN0ZWQoX3Jvd3NTZWxlY3RlZCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaGFuZGxlZCA9IHRydWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaGFuZGxlZCkge1xuXHQgICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7IGxhc3RSb3dJZHhVaVNlbGVjdGVkOiByb3dJZHggfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gaGFuZGxlZDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07XG5cblx0ICB0aGlzLmhhbmRsZU5ld1Jvd1NlbGVjdCA9IGZ1bmN0aW9uIChyb3dJZHgsIHJvd0RhdGEpIHtcblx0ICAgIGlmIChfdGhpczMuc2VsZWN0QWxsQ2hlY2tib3ggJiYgX3RoaXMzLnNlbGVjdEFsbENoZWNrYm94LmNoZWNrZWQgPT09IHRydWUpIHtcblx0ICAgICAgX3RoaXMzLnNlbGVjdEFsbENoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIF9wcm9wcyRyb3dTZWxlY3Rpb24kczIgPSBfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLnNlbGVjdEJ5LFxuXHQgICAgICAgIGtleXMgPSBfcHJvcHMkcm93U2VsZWN0aW9uJHMyLmtleXMsXG5cdCAgICAgICAgaW5kZXhlcyA9IF9wcm9wcyRyb3dTZWxlY3Rpb24kczIuaW5kZXhlcyxcblx0ICAgICAgICBpc1NlbGVjdGVkS2V5ID0gX3Byb3BzJHJvd1NlbGVjdGlvbiRzMi5pc1NlbGVjdGVkS2V5O1xuXG5cdCAgICB2YXIgaXNQcmV2aW91c2x5U2VsZWN0ZWQgPSBSb3dVdGlscy5pc1Jvd1NlbGVjdGVkKGtleXMsIGluZGV4ZXMsIGlzU2VsZWN0ZWRLZXksIHJvd0RhdGEsIHJvd0lkeCk7XG5cblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IGxhc3RSb3dJZHhVaVNlbGVjdGVkOiBpc1ByZXZpb3VzbHlTZWxlY3RlZCA/IC0xIDogcm93SWR4LCBzZWxlY3RlZDogeyByb3dJZHg6IHJvd0lkeCwgaWR4OiAwIH0gfSk7XG5cblx0ICAgIGlmIChpc1ByZXZpb3VzbHlTZWxlY3RlZCAmJiB0eXBlb2YgX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5vblJvd3NEZXNlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24ub25Sb3dzRGVzZWxlY3RlZChbeyByb3dJZHg6IHJvd0lkeCwgcm93OiByb3dEYXRhIH1dKTtcblx0ICAgIH0gZWxzZSBpZiAoIWlzUHJldmlvdXNseVNlbGVjdGVkICYmIHR5cGVvZiBfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLm9uUm93c1NlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24ub25Sb3dzU2VsZWN0ZWQoW3sgcm93SWR4OiByb3dJZHgsIHJvdzogcm93RGF0YSB9XSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMuaGFuZGxlUm93U2VsZWN0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sdW1uS2V5LCByb3dEYXRhLCBlKSB7XG5cdCAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdCAgICBpZiAoX3RoaXMzLnVzZU5ld1Jvd1NlbGVjdGlvbigpKSB7XG5cdCAgICAgIGlmIChfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLmVuYWJsZVNoaWZ0U2VsZWN0ID09PSB0cnVlKSB7XG5cdCAgICAgICAgaWYgKCFfdGhpczMuaGFuZGxlU2hpZnRTZWxlY3Qocm93SWR4KSkge1xuXHQgICAgICAgICAgX3RoaXMzLmhhbmRsZU5ld1Jvd1NlbGVjdChyb3dJZHgsIHJvd0RhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBfdGhpczMuaGFuZGxlTmV3Um93U2VsZWN0KHJvd0lkeCwgcm93RGF0YSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIEZhbGxiYWNrIHRvIG9sZCBvblJvd1NlbGVjdCBoYW5kbGVyXG5cdCAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBfdGhpczMucHJvcHMuZW5hYmxlUm93U2VsZWN0ID09PSAnc2luZ2xlJyA/IFtdIDogX3RoaXMzLnN0YXRlLnNlbGVjdGVkUm93cy5zbGljZSgwKTtcblx0ICAgICAgdmFyIHNlbGVjdGVkUm93ID0gX3RoaXMzLmdldFNlbGVjdGVkUm93KHNlbGVjdGVkUm93cywgcm93RGF0YVtfdGhpczMucHJvcHMucm93S2V5XSk7XG5cdCAgICAgIGlmIChzZWxlY3RlZFJvdykge1xuXHQgICAgICAgIHNlbGVjdGVkUm93LmlzU2VsZWN0ZWQgPSAhc2VsZWN0ZWRSb3cuaXNTZWxlY3RlZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByb3dEYXRhLmlzU2VsZWN0ZWQgPSB0cnVlO1xuXHQgICAgICAgIHNlbGVjdGVkUm93cy5wdXNoKHJvd0RhdGEpO1xuXHQgICAgICB9XG5cdCAgICAgIF90aGlzMy5zZXRTdGF0ZSh7IHNlbGVjdGVkUm93czogc2VsZWN0ZWRSb3dzLCBzZWxlY3RlZDogeyByb3dJZHg6IHJvd0lkeCwgaWR4OiAwIH0gfSk7XG5cdCAgICAgIGlmIChfdGhpczMucHJvcHMub25Sb3dTZWxlY3QpIHtcblx0ICAgICAgICBfdGhpczMucHJvcHMub25Sb3dTZWxlY3Qoc2VsZWN0ZWRSb3dzLmZpbHRlcihmdW5jdGlvbiAocikge1xuXHQgICAgICAgICAgcmV0dXJuIHIuaXNTZWxlY3RlZCA9PT0gdHJ1ZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVDaGVja2JveENoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgYWxsUm93c1NlbGVjdGVkID0gdm9pZCAwO1xuXHQgICAgaWYgKGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQgPT09IHRydWUpIHtcblx0ICAgICAgYWxsUm93c1NlbGVjdGVkID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKF90aGlzMy51c2VOZXdSb3dTZWxlY3Rpb24oKSkge1xuXHQgICAgICB2YXIgX3Byb3BzJHJvd1NlbGVjdGlvbiRzMyA9IF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24uc2VsZWN0QnksXG5cdCAgICAgICAgICBrZXlzID0gX3Byb3BzJHJvd1NlbGVjdGlvbiRzMy5rZXlzLFxuXHQgICAgICAgICAgaW5kZXhlcyA9IF9wcm9wcyRyb3dTZWxlY3Rpb24kczMuaW5kZXhlcyxcblx0ICAgICAgICAgIGlzU2VsZWN0ZWRLZXkgPSBfcHJvcHMkcm93U2VsZWN0aW9uJHMzLmlzU2VsZWN0ZWRLZXk7XG5cblxuXHQgICAgICBpZiAoYWxsUm93c1NlbGVjdGVkICYmIHR5cGVvZiBfdGhpczMucHJvcHMucm93U2VsZWN0aW9uLm9uUm93c1NlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLnByb3BzLnJvd3NDb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgcm93RGF0YSA9IF90aGlzMy5wcm9wcy5yb3dHZXR0ZXIoaSk7XG5cdCAgICAgICAgICBpZiAoIVJvd1V0aWxzLmlzUm93U2VsZWN0ZWQoa2V5cywgaW5kZXhlcywgaXNTZWxlY3RlZEtleSwgcm93RGF0YSwgaSkpIHtcblx0ICAgICAgICAgICAgc2VsZWN0ZWRSb3dzLnB1c2goeyByb3dJZHg6IGksIHJvdzogcm93RGF0YSB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgIF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24ub25Sb3dzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dzKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoIWFsbFJvd3NTZWxlY3RlZCAmJiB0eXBlb2YgX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5vblJvd3NEZXNlbGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdmFyIGRlc2VsZWN0ZWRSb3dzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX3RoaXMzLnByb3BzLnJvd3NDb3VudDsgX2kyKyspIHtcblx0ICAgICAgICAgIHZhciBfcm93RGF0YSA9IF90aGlzMy5wcm9wcy5yb3dHZXR0ZXIoX2kyKTtcblx0ICAgICAgICAgIGlmIChSb3dVdGlscy5pc1Jvd1NlbGVjdGVkKGtleXMsIGluZGV4ZXMsIGlzU2VsZWN0ZWRLZXksIF9yb3dEYXRhLCBfaTIpKSB7XG5cdCAgICAgICAgICAgIGRlc2VsZWN0ZWRSb3dzLnB1c2goeyByb3dJZHg6IF9pMiwgcm93OiBfcm93RGF0YSB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZGVzZWxlY3RlZFJvd3MubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5vblJvd3NEZXNlbGVjdGVkKGRlc2VsZWN0ZWRSb3dzKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBfc2VsZWN0ZWRSb3dzID0gW107XG5cdCAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF90aGlzMy5wcm9wcy5yb3dzQ291bnQ7IF9pMysrKSB7XG5cdCAgICAgICAgdmFyIHJvdyA9IE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5wcm9wcy5yb3dHZXR0ZXIoX2kzKSwgeyBpc1NlbGVjdGVkOiBhbGxSb3dzU2VsZWN0ZWQgfSk7XG5cdCAgICAgICAgX3NlbGVjdGVkUm93cy5wdXNoKHJvdyk7XG5cdCAgICAgIH1cblx0ICAgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWRSb3dzOiBfc2VsZWN0ZWRSb3dzIH0pO1xuXHQgICAgICBpZiAodHlwZW9mIF90aGlzMy5wcm9wcy5vblJvd1NlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIF90aGlzMy5wcm9wcy5vblJvd1NlbGVjdChfc2VsZWN0ZWRSb3dzLmZpbHRlcihmdW5jdGlvbiAocikge1xuXHQgICAgICAgICAgcmV0dXJuIHIuaXNTZWxlY3RlZCA9PT0gdHJ1ZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRTY3JvbGxPZmZTZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgc2Nyb2xsT2Zmc2V0ID0gMDtcblx0ICAgIGlmIChfdGhpczMuZ3JpZCkge1xuXHQgICAgICB2YXIgY2FudmFzID0gX3RoaXMzLmdyaWQucXVlcnlTZWxlY3RvcignLnJlYWN0LWdyaWQtQ2FudmFzJyk7XG5cdCAgICAgIGlmIChjYW52YXMpIHtcblx0ICAgICAgICBzY3JvbGxPZmZzZXQgPSBjYW52YXMub2Zmc2V0V2lkdGggLSBjYW52YXMuY2xpZW50V2lkdGg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIF90aGlzMy5zZXRTdGF0ZSh7IHNjcm9sbE9mZnNldDogc2Nyb2xsT2Zmc2V0IH0pO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldFJvd09mZnNldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBvZmZzZXRIZWlnaHQgPSAwO1xuXHQgICAgX3RoaXMzLmdldEhlYWRlclJvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcblx0ICAgICAgcmV0dXJuIG9mZnNldEhlaWdodCArPSBwYXJzZUZsb2F0KHJvdy5oZWlnaHQsIDEwKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIG9mZnNldEhlaWdodDtcblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRIZWFkZXJSb3dzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJvd3MgPSBbeyByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzMy5yb3cgPSBub2RlO1xuXHQgICAgICB9LCBoZWlnaHQ6IF90aGlzMy5wcm9wcy5oZWFkZXJSb3dIZWlnaHQgfHwgX3RoaXMzLnByb3BzLnJvd0hlaWdodCwgcm93VHlwZTogJ2hlYWRlcicgfV07XG5cdCAgICBpZiAoX3RoaXMzLnN0YXRlLmNhbkZpbHRlciA9PT0gdHJ1ZSkge1xuXHQgICAgICByb3dzLnB1c2goe1xuXHQgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcblx0ICAgICAgICAgIHJldHVybiBfdGhpczMuZmlsdGVyUm93ID0gbm9kZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZpbHRlcmFibGU6IHRydWUsXG5cdCAgICAgICAgb25GaWx0ZXJDaGFuZ2U6IF90aGlzMy5wcm9wcy5vbkFkZEZpbHRlcixcblx0ICAgICAgICBoZWlnaHQ6IF90aGlzMy5wcm9wcy5oZWFkZXJGaWx0ZXJzSGVpZ2h0LFxuXHQgICAgICAgIHJvd1R5cGU6ICdmaWx0ZXInXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJvd3M7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0SW5pdGlhbFNlbGVjdGVkUm93cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBzZWxlY3RlZFJvd3MgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLnByb3BzLnJvd3NDb3VudDsgaSsrKSB7XG5cdCAgICAgIHNlbGVjdGVkUm93cy5wdXNoKGZhbHNlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzZWxlY3RlZFJvd3M7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0Um93U2VsZWN0aW9uUHJvcHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbikge1xuXHQgICAgICByZXR1cm4gX3RoaXMzLnByb3BzLnJvd1NlbGVjdGlvbi5zZWxlY3RCeTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0U2VsZWN0ZWRSb3dzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24pIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfdGhpczMuc3RhdGUuc2VsZWN0ZWRSb3dzLmZpbHRlcihmdW5jdGlvbiAocikge1xuXHQgICAgICByZXR1cm4gci5pc1NlbGVjdGVkID09PSB0cnVlO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0U2VsZWN0ZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByb3dJZHggPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQucm93SWR4O1xuXHQgICAgdmFyIGlkeCA9IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5pZHg7XG5cdCAgICB2YXIgY2VsbEtleSA9IF90aGlzMy5nZXRDb2x1bW4oaWR4KS5rZXk7XG5cdCAgICB2YXIgcm93ID0gX3RoaXMzLnByb3BzLnJvd0dldHRlcihyb3dJZHgpO1xuXHQgICAgcmV0dXJuIFJvd1V0aWxzLmdldChyb3csIGNlbGxLZXkpO1xuXHQgIH07XG5cblx0ICB0aGlzLmNhbkV4aXRHcmlkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIC8vIFdoZW4gdGhlIGNlbGxOYXZpZ2F0aW9uTW9kZSBpcyAnbm9uZScsIHlvdSBjYW4gZXhpdCB0aGUgZ3JpZCBpZiB5b3UncmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgcm93XG5cdCAgICAvLyBXaGVuIHRoZSBjZWxsTmF2aWdhdGlvbk1vZGUgaXMgJ2NoYW5nZVJvdycsIHlvdSBjYW4gZXhpdCB0aGUgZ3JpZCBpZiB5b3UncmUgYXQgdGhlIGZpcnN0IG9yIGxhc3QgY2VsbCBvZiB0aGUgZ3JpZFxuXHQgICAgLy8gV2hlbiB0aGUgY2VsbE5hdmlnYXRpb25Nb2RlIGlzICdsb29wT3ZlclJvdycsIHRoZXJlIGlzIG5vIGxvZ2ljYWwgZXhpdCBwb2ludCBzbyB5b3UgY2FuJ3QgZXhpdCB0aGUgZ3JpZFxuXHQgICAgdmFyIGF0TGFzdENlbGxJblJvdyA9IF90aGlzMy5pc0F0TGFzdENlbGxJblJvdyhfdGhpczMuZ2V0TmJyQ29sdW1ucygpKTtcblx0ICAgIHZhciBhdEZpcnN0Q2VsbEluUm93ID0gX3RoaXMzLmlzQXRGaXJzdENlbGxJblJvdygpO1xuXHQgICAgdmFyIGF0TGFzdFJvdyA9IF90aGlzMy5pc0F0TGFzdFJvdygpO1xuXHQgICAgdmFyIGF0Rmlyc3RSb3cgPSBfdGhpczMuaXNBdEZpcnN0Um93KCk7XG5cdCAgICB2YXIgc2hpZnQgPSBlLnNoaWZ0S2V5ID09PSB0cnVlO1xuXHQgICAgdmFyIGNlbGxOYXZpZ2F0aW9uTW9kZSA9IF90aGlzMy5wcm9wcy5jZWxsTmF2aWdhdGlvbk1vZGU7XG5cblx0ICAgIGlmIChzaGlmdCkge1xuXHQgICAgICBpZiAoY2VsbE5hdmlnYXRpb25Nb2RlID09PSAnbm9uZScpIHtcblx0ICAgICAgICBpZiAoYXRGaXJzdENlbGxJblJvdykge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGNlbGxOYXZpZ2F0aW9uTW9kZSA9PT0gJ2NoYW5nZVJvdycpIHtcblx0ICAgICAgICBpZiAoYXRGaXJzdENlbGxJblJvdyAmJiBhdEZpcnN0Um93KSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChjZWxsTmF2aWdhdGlvbk1vZGUgPT09ICdub25lJykge1xuXHQgICAgICAgIGlmIChhdExhc3RDZWxsSW5Sb3cpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChjZWxsTmF2aWdhdGlvbk1vZGUgPT09ICdjaGFuZ2VSb3cnKSB7XG5cdCAgICAgICAgaWYgKGF0TGFzdENlbGxJblJvdyAmJiBhdExhc3RSb3cpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07XG5cblx0ICB0aGlzLm1vdmVTZWxlY3RlZENlbGwgPSBmdW5jdGlvbiAoZSwgcm93RGVsdGEsIGNlbGxEZWx0YSkge1xuXHQgICAgLy8gd2UgbmVlZCB0byBwcmV2ZW50IGRlZmF1bHQgYXMgd2UgY29udHJvbCBncmlkIHNjcm9sbFxuXHQgICAgLy8gb3RoZXJ3aXNlIGl0IG1vdmVzIGV2ZXJ5IHRpbWUgeW91IGxlZnQvcmlnaHQgd2hpY2ggaXMgamFua3lcblx0ICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgIHZhciByb3dJZHggPSB2b2lkIDA7XG5cdCAgICB2YXIgaWR4ID0gdm9pZCAwO1xuXHQgICAgdmFyIGNlbGxOYXZpZ2F0aW9uTW9kZSA9IF90aGlzMy5wcm9wcy5jZWxsTmF2aWdhdGlvbk1vZGU7XG5cblx0ICAgIGlmIChjZWxsTmF2aWdhdGlvbk1vZGUgIT09ICdub25lJykge1xuXHQgICAgICB2YXIgX2NhbGN1bGF0ZU5leHRTZWxlY3RpID0gX3RoaXMzLmNhbGN1bGF0ZU5leHRTZWxlY3Rpb25Qb3NpdGlvbihjZWxsTmF2aWdhdGlvbk1vZGUsIGNlbGxEZWx0YSwgcm93RGVsdGEpO1xuXG5cdCAgICAgIGlkeCA9IF9jYWxjdWxhdGVOZXh0U2VsZWN0aS5pZHg7XG5cdCAgICAgIHJvd0lkeCA9IF9jYWxjdWxhdGVOZXh0U2VsZWN0aS5yb3dJZHg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByb3dJZHggPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQucm93SWR4ICsgcm93RGVsdGE7XG5cdCAgICAgIGlkeCA9IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5pZHggKyBjZWxsRGVsdGE7XG5cdCAgICB9XG5cdCAgICBfdGhpczMuc2Nyb2xsVG9Db2x1bW4oaWR4KTtcblx0ICAgIF90aGlzMy5vblNlbGVjdCh7IGlkeDogaWR4LCByb3dJZHg6IHJvd0lkeCB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5nZXROYnJDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIF9wcm9wcyA9IF90aGlzMy5wcm9wcyxcblx0ICAgICAgICBjb2x1bW5zID0gX3Byb3BzLmNvbHVtbnMsXG5cdCAgICAgICAgZW5hYmxlUm93U2VsZWN0ID0gX3Byb3BzLmVuYWJsZVJvd1NlbGVjdDtcblxuXHQgICAgcmV0dXJuIGVuYWJsZVJvd1NlbGVjdCA/IGNvbHVtbnMubGVuZ3RoICsgMSA6IGNvbHVtbnMubGVuZ3RoO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldERhdGFHcmlkRE9NTm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfdGhpczMuZ3JpZDtcblx0ICB9O1xuXG5cdCAgdGhpcy5jYWxjdWxhdGVOZXh0U2VsZWN0aW9uUG9zaXRpb24gPSBmdW5jdGlvbiAoY2VsbE5hdmlnYXRpb25Nb2RlLCBjZWxsRGVsdGEsIHJvd0RlbHRhKSB7XG5cdCAgICB2YXIgX3Jvd0RlbHRhID0gcm93RGVsdGE7XG5cdCAgICB2YXIgaWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLmlkeCArIGNlbGxEZWx0YTtcblx0ICAgIHZhciBuYnJDb2x1bW5zID0gX3RoaXMzLmdldE5ickNvbHVtbnMoKTtcblx0ICAgIGlmIChjZWxsRGVsdGEgPiAwKSB7XG5cdCAgICAgIGlmIChfdGhpczMuaXNBdExhc3RDZWxsSW5Sb3cobmJyQ29sdW1ucykpIHtcblx0ICAgICAgICBpZiAoY2VsbE5hdmlnYXRpb25Nb2RlID09PSAnY2hhbmdlUm93Jykge1xuXHQgICAgICAgICAgX3Jvd0RlbHRhID0gX3RoaXMzLmlzQXRMYXN0Um93KCkgPyByb3dEZWx0YSA6IHJvd0RlbHRhICsgMTtcblx0ICAgICAgICAgIGlkeCA9IF90aGlzMy5pc0F0TGFzdFJvdygpID8gaWR4IDogMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWR4ID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoY2VsbERlbHRhIDwgMCkge1xuXHQgICAgICBpZiAoX3RoaXMzLmlzQXRGaXJzdENlbGxJblJvdygpKSB7XG5cdCAgICAgICAgaWYgKGNlbGxOYXZpZ2F0aW9uTW9kZSA9PT0gJ2NoYW5nZVJvdycpIHtcblx0ICAgICAgICAgIF9yb3dEZWx0YSA9IF90aGlzMy5pc0F0Rmlyc3RSb3coKSA/IHJvd0RlbHRhIDogcm93RGVsdGEgLSAxO1xuXHQgICAgICAgICAgaWR4ID0gX3RoaXMzLmlzQXRGaXJzdFJvdygpID8gMCA6IG5ickNvbHVtbnMgLSAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZHggPSBuYnJDb2x1bW5zIC0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciByb3dJZHggPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQucm93SWR4ICsgX3Jvd0RlbHRhO1xuXHQgICAgcmV0dXJuIHsgaWR4OiBpZHgsIHJvd0lkeDogcm93SWR4IH07XG5cdCAgfTtcblxuXHQgIHRoaXMuaXNBdExhc3RDZWxsSW5Sb3cgPSBmdW5jdGlvbiAobmJyQ29sdW1ucykge1xuXHQgICAgcmV0dXJuIF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5pZHggPT09IG5ickNvbHVtbnMgLSAxO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzQXRMYXN0Um93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5yb3dJZHggPT09IF90aGlzMy5wcm9wcy5yb3dzQ291bnQgLSAxO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzQXRGaXJzdENlbGxJblJvdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuaWR4ID09PSAwO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzQXRGaXJzdFJvdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfdGhpczMuc3RhdGUuc2VsZWN0ZWQucm93SWR4ID09PSAwO1xuXHQgIH07XG5cblx0ICB0aGlzLm9wZW5DZWxsRWRpdG9yID0gZnVuY3Rpb24gKHJvd0lkeCwgaWR4KSB7XG5cdCAgICB2YXIgcm93ID0gX3RoaXMzLnByb3BzLnJvd0dldHRlcihyb3dJZHgpO1xuXHQgICAgdmFyIGNvbCA9IF90aGlzMy5nZXRDb2x1bW4oaWR4KTtcblxuXHQgICAgaWYgKCFDb2x1bW5VdGlscy5jYW5FZGl0KGNvbCwgcm93LCBfdGhpczMucHJvcHMuZW5hYmxlQ2VsbFNlbGVjdCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2VsZWN0ZWQgPSB7IHJvd0lkeDogcm93SWR4LCBpZHg6IGlkeCB9O1xuXHQgICAgaWYgKF90aGlzMy5oYXNTZWxlY3RlZENlbGxDaGFuZ2VkKHNlbGVjdGVkKSkge1xuXHQgICAgICBfdGhpczMuc2V0U3RhdGUoeyBzZWxlY3RlZDogc2VsZWN0ZWQgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIF90aGlzMy5zZXRBY3RpdmUoJ0VudGVyJyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgX3RoaXMzLnNldEFjdGl2ZSgnRW50ZXInKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5zY3JvbGxUb0NvbHVtbiA9IGZ1bmN0aW9uIChjb2xJZHgpIHtcblx0ICAgIGlmIChfdGhpczMuZ3JpZCkge1xuXHQgICAgICB2YXIgY2FudmFzID0gX3RoaXMzLmdyaWQucXVlcnlTZWxlY3RvcignLnJlYWN0LWdyaWQtQ2FudmFzJyk7XG5cdCAgICAgIGlmIChjYW52YXMpIHtcblx0ICAgICAgICB2YXIgbGVmdCA9IDA7XG5cdCAgICAgICAgdmFyIGxvY2tlZCA9IDA7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbElkeDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgY29sdW1uID0gX3RoaXMzLmdldENvbHVtbihpKTtcblx0ICAgICAgICAgIGlmIChjb2x1bW4pIHtcblx0ICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuXHQgICAgICAgICAgICAgIGxlZnQgKz0gY29sdW1uLndpZHRoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjb2x1bW4ubG9ja2VkKSB7XG5cdCAgICAgICAgICAgICAgbG9ja2VkICs9IGNvbHVtbi53aWR0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBzZWxlY3RlZENvbHVtbiA9IF90aGlzMy5nZXRDb2x1bW4oY29sSWR4KTtcblx0ICAgICAgICBpZiAoc2VsZWN0ZWRDb2x1bW4pIHtcblx0ICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gbGVmdCAtIGxvY2tlZCAtIGNhbnZhcy5zY3JvbGxMZWZ0O1xuXHQgICAgICAgICAgdmFyIHNjcm9sbFJpZ2h0ID0gbGVmdCArIHNlbGVjdGVkQ29sdW1uLndpZHRoIC0gY2FudmFzLnNjcm9sbExlZnQ7XG5cblx0ICAgICAgICAgIGlmIChzY3JvbGxMZWZ0IDwgMCkge1xuXHQgICAgICAgICAgICBjYW52YXMuc2Nyb2xsTGVmdCArPSBzY3JvbGxMZWZ0O1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxSaWdodCA+IGNhbnZhcy5jbGllbnRXaWR0aCkge1xuXHQgICAgICAgICAgICB2YXIgc2Nyb2xsQW1vdW50ID0gc2Nyb2xsUmlnaHQgLSBjYW52YXMuY2xpZW50V2lkdGg7XG5cdCAgICAgICAgICAgIGNhbnZhcy5zY3JvbGxMZWZ0ICs9IHNjcm9sbEFtb3VudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBzZWxlY3RlZCA9IHsgcm93SWR4OiAtMSwgaWR4OiAtMSB9O1xuXHQgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0pO1xuXHQgIH07XG5cblx0ICB0aGlzLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIChrZXlQcmVzc2VkKSB7XG5cdCAgICB2YXIgcm93SWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLnJvd0lkeDtcblx0ICAgIHZhciByb3cgPSBfdGhpczMucHJvcHMucm93R2V0dGVyKHJvd0lkeCk7XG5cblx0ICAgIHZhciBpZHggPSBfdGhpczMuc3RhdGUuc2VsZWN0ZWQuaWR4O1xuXHQgICAgdmFyIGNvbHVtbiA9IF90aGlzMy5nZXRDb2x1bW4oaWR4KTtcblxuXHQgICAgaWYgKENvbHVtblV0aWxzLmNhbkVkaXQoY29sdW1uLCByb3csIF90aGlzMy5wcm9wcy5lbmFibGVDZWxsU2VsZWN0KSAmJiAhX3RoaXMzLmlzQWN0aXZlKCkpIHtcblx0ICAgICAgdmFyIHNlbGVjdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLnN0YXRlLnNlbGVjdGVkLCB7IGlkeDogaWR4LCByb3dJZHg6IHJvd0lkeCwgYWN0aXZlOiB0cnVlLCBpbml0aWFsS2V5Q29kZToga2V5UHJlc3NlZCB9KTtcblx0ICAgICAgdmFyIHNob3dFZGl0b3IgPSB0cnVlO1xuXHQgICAgICBpZiAodHlwZW9mIF90aGlzMy5wcm9wcy5vbkNoZWNrQ2VsbElzRWRpdGFibGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IE9iamVjdC5hc3NpZ24oe30sIHsgcm93OiByb3csIGNvbHVtbjogY29sdW1uIH0sIHNlbGVjdGVkKTtcblx0ICAgICAgICBzaG93RWRpdG9yID0gX3RoaXMzLnByb3BzLm9uQ2hlY2tDZWxsSXNFZGl0YWJsZShhcmdzKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoc2hvd0VkaXRvciAhPT0gZmFsc2UpIHtcblx0ICAgICAgICBpZiAoY29sdW1uLmxvY2tlZCkge1xuXHQgICAgICAgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBfdGhpczMuc2V0U3RhdGUoeyBzZWxlY3RlZDogc2VsZWN0ZWQgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBfdGhpczMuc2Nyb2xsVG9Db2x1bW4oaWR4KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpczMucHJvcHMub25CZWZvcmVFZGl0KCk7XG5cdCAgICAgICAgX3RoaXMzLmhhbmRsZUNhbmNlbENvcHkoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLnNldEluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJvd0lkeCA9IF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5yb3dJZHg7XG5cdCAgICB2YXIgcm93ID0gX3RoaXMzLnByb3BzLnJvd0dldHRlcihyb3dJZHgpO1xuXG5cdCAgICB2YXIgaWR4ID0gX3RoaXMzLnN0YXRlLnNlbGVjdGVkLmlkeDtcblx0ICAgIHZhciBjb2wgPSBfdGhpczMuZ2V0Q29sdW1uKGlkeCk7XG5cblx0ICAgIGlmIChDb2x1bW5VdGlscy5jYW5FZGl0KGNvbCwgcm93LCBfdGhpczMucHJvcHMuZW5hYmxlQ2VsbFNlbGVjdCkgJiYgX3RoaXMzLmlzQWN0aXZlKCkpIHtcblx0ICAgICAgdmFyIHNlbGVjdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLnN0YXRlLnNlbGVjdGVkLCB7IGlkeDogaWR4LCByb3dJZHg6IHJvd0lkeCwgYWN0aXZlOiBmYWxzZSB9KTtcblx0ICAgICAgX3RoaXMzLnNldFN0YXRlKHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIF90aGlzMy5zdGF0ZS5zZWxlY3RlZC5hY3RpdmUgPT09IHRydWU7XG5cdCAgfTtcblxuXHQgIHRoaXMuc2V0dXBHcmlkQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3RoaXMzLnByb3BzO1xuXHQgICAgdmFyIGNvbHVtbnMgPSBwcm9wcy5jb2x1bW5zO1xuXG5cdCAgICBpZiAoX3RoaXMzLl9jYWNoZWRDb2x1bW5zID09PSBjb2x1bW5zKSB7XG5cdCAgICAgIHJldHVybiBfdGhpczMuX2NhY2hlZENvbXB1dGVkQ29sdW1ucztcblx0ICAgIH1cblxuXHQgICAgX3RoaXMzLl9jYWNoZWRDb2x1bW5zID0gY29sdW1ucztcblxuXHQgICAgdmFyIGNvbHMgPSBjb2x1bW5zLnNsaWNlKDApO1xuXHQgICAgdmFyIHVuc2hpZnRlZENvbHMgPSB7fTtcblx0ICAgIGlmIChfdGhpczMucHJvcHMucm93QWN0aW9uc0NlbGwgfHwgcHJvcHMuZW5hYmxlUm93U2VsZWN0ICYmICFfdGhpczMucHJvcHMucm93U2VsZWN0aW9uIHx8IHByb3BzLnJvd1NlbGVjdGlvbiAmJiBwcm9wcy5yb3dTZWxlY3Rpb24uc2hvd0NoZWNrYm94ICE9PSBmYWxzZSkge1xuXHQgICAgICB2YXIgU2VsZWN0QWxsQ29tcG9uZW50ID0gX3RoaXMzLnByb3BzLnNlbGVjdEFsbFJlbmRlcmVyIHx8IF9TZWxlY3RBbGwyWydkZWZhdWx0J107XG5cdCAgICAgIHZhciBTZWxlY3RBbGxSZW5kZXJlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0QWxsQ29tcG9uZW50LCB7IG9uQ2hhbmdlOiBfdGhpczMuaGFuZGxlQ2hlY2tib3hDaGFuZ2UsIGlucHV0UmVmOiBmdW5jdGlvbiBpbnB1dFJlZihncmlkKSB7XG5cdCAgICAgICAgICByZXR1cm4gX3RoaXMzLnNlbGVjdEFsbENoZWNrYm94ID0gZ3JpZDtcblx0ICAgICAgICB9IH0pO1xuXHQgICAgICB2YXIgaGVhZGVyUmVuZGVyZXIgPSBwcm9wcy5lbmFibGVSb3dTZWxlY3QgPT09ICdzaW5nbGUnID8gbnVsbCA6IFNlbGVjdEFsbFJlbmRlcmVyO1xuXHQgICAgICB2YXIgRm9ybWF0dGVyID0gX3RoaXMzLnByb3BzLnJvd0FjdGlvbnNDZWxsID8gX3RoaXMzLnByb3BzLnJvd0FjdGlvbnNDZWxsIDogQ2hlY2tib3hFZGl0b3I7XG5cdCAgICAgIHZhciBzZWxlY3RDb2x1bW4gPSB7XG5cdCAgICAgICAga2V5OiAnc2VsZWN0LXJvdycsXG5cdCAgICAgICAgbmFtZTogJycsXG5cdCAgICAgICAgZm9ybWF0dGVyOiBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1hdHRlciwgeyByb3dTZWxlY3Rpb246IF90aGlzMy5wcm9wcy5yb3dTZWxlY3Rpb24gfSksXG5cdCAgICAgICAgb25DZWxsQ2hhbmdlOiBfdGhpczMuaGFuZGxlUm93U2VsZWN0LFxuXHQgICAgICAgIGZpbHRlcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGhlYWRlclJlbmRlcmVyOiBoZWFkZXJSZW5kZXJlcixcblx0ICAgICAgICB3aWR0aDogNjAsXG5cdCAgICAgICAgbG9ja2VkOiB0cnVlLFxuXHQgICAgICAgIGdldFJvd01ldGFEYXRhOiBmdW5jdGlvbiBnZXRSb3dNZXRhRGF0YShyb3dEYXRhKSB7XG5cdCAgICAgICAgICByZXR1cm4gcm93RGF0YTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNlbGxDbGFzczogX3RoaXMzLnByb3BzLnJvd0FjdGlvbnNDZWxsID8gJ3JkZy1yb3ctYWN0aW9ucy1jZWxsJyA6ICcnXG5cdCAgICAgIH07XG5cdCAgICAgIHVuc2hpZnRlZENvbHMgPSBjb2xzLnVuc2hpZnQoc2VsZWN0Q29sdW1uKTtcblx0ICAgICAgY29scyA9IHVuc2hpZnRlZENvbHMgPiAwID8gY29scyA6IHVuc2hpZnRlZENvbHM7XG5cdCAgICB9XG5cdCAgICBfdGhpczMuX2NhY2hlZENvbXB1dGVkQ29sdW1ucyA9IGNvbHM7XG5cblx0ICAgIHJldHVybiBfdGhpczMuX2NhY2hlZENvbXB1dGVkQ29sdW1ucztcblx0ICB9O1xuXG5cdCAgdGhpcy5jb3B5UGFzdGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIF90aGlzMy5wcm9wcy5vbkNlbGxDb3B5UGFzdGUgIT09IG51bGw7XG5cdCAgfTtcblxuXHQgIHRoaXMuZHJhZ0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gX3RoaXMzLnByb3BzLm9uR3JpZFJvd3NVcGRhdGVkICE9PSB1bmRlZmluZWQgfHwgX3RoaXMzLnByb3BzLm9uQ2VsbHNEcmFnZ2VkICE9PSB1bmRlZmluZWQ7XG5cdCAgfTtcblxuXHQgIHRoaXMucmVuZGVyVG9vbGJhciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBUb29sYmFyID0gX3RoaXMzLnByb3BzLnRvb2xiYXI7XG5cdCAgICB2YXIgdG9vbEJhclByb3BzID0geyBjb2x1bW5zOiBfdGhpczMucHJvcHMuY29sdW1ucywgb25Ub2dnbGVGaWx0ZXI6IF90aGlzMy5vblRvZ2dsZUZpbHRlciwgbnVtYmVyT2ZSb3dzOiBfdGhpczMucHJvcHMucm93c0NvdW50IH07XG5cdCAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoVG9vbGJhcikpIHtcblx0ICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChUb29sYmFyLCB0b29sQmFyUHJvcHMpO1xuXHQgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKFRvb2xiYXIpKSB7XG5cdCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2xiYXIsIHRvb2xCYXJQcm9wcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGF0YUdyaWQ7XG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXHR2YXIgc3R5bGUgPSB7XG5cdCAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdCAgdG9wOiAwLFxuXHQgIHJpZ2h0OiAwLFxuXHQgIHdpZHRoOiA2LFxuXHQgIGhlaWdodDogJzEwMCUnXG5cdH07XG5cblx0dmFyIFJlc2l6ZUhhbmRsZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKFJlc2l6ZUhhbmRsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBSZXNpemVIYW5kbGUoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzaXplSGFuZGxlKTtcblxuXHQgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgUmVzaXplSGFuZGxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcmFnZ2FibGUsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7XG5cdCAgICAgIGNsYXNzTmFtZTogJ3JlYWN0LWdyaWQtSGVhZGVyQ2VsbF9fcmVzaXplSGFuZGxlJyxcblx0ICAgICAgc3R5bGU6IHN0eWxlXG5cdCAgICB9KSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBSZXNpemVIYW5kbGU7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZUhhbmRsZTtcblxuLyoqKi8gfSksXG4vKiAxMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxuXHR2YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgY2VsbE1ldGFEYXRhU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHR2YXIgUm93R3JvdXAgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhSb3dHcm91cCwgX0NvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBSb3dHcm91cChwcm9wcykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvd0dyb3VwKTtcblxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cblx0ICAgIF90aGlzLm9uUm93RXhwYW5kVG9nZ2xlID0gX3RoaXMub25Sb3dFeHBhbmRUb2dnbGUuYmluZChfdGhpcyk7XG5cdCAgICBfdGhpcy5vblJvd0V4cGFuZENsaWNrID0gX3RoaXMub25Sb3dFeHBhbmRDbGljay5iaW5kKF90aGlzKTtcblx0ICAgIF90aGlzLnNldFNjcm9sbExlZnQgPSBfdGhpcy5zZXRTY3JvbGxMZWZ0LmJpbmQoX3RoaXMpO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIFJvd0dyb3VwLnByb3RvdHlwZS5vblJvd0V4cGFuZFRvZ2dsZSA9IGZ1bmN0aW9uIG9uUm93RXhwYW5kVG9nZ2xlKGV4cGFuZCkge1xuXHQgICAgdmFyIHNob3VsZEV4cGFuZCA9IGV4cGFuZCA9PSBudWxsID8gIXRoaXMucHJvcHMuaXNFeHBhbmRlZCA6IGV4cGFuZDtcblx0ICAgIHZhciBtZXRhID0gdGhpcy5wcm9wcy5jZWxsTWV0YURhdGE7XG5cdCAgICBpZiAobWV0YSAhPSBudWxsICYmIG1ldGEub25Sb3dFeHBhbmRUb2dnbGUgJiYgdHlwZW9mIG1ldGEub25Sb3dFeHBhbmRUb2dnbGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgbWV0YS5vblJvd0V4cGFuZFRvZ2dsZSh7IHJvd0lkeDogdGhpcy5wcm9wcy5pZHgsIHNob3VsZEV4cGFuZDogc2hvdWxkRXhwYW5kLCBjb2x1bW5Hcm91cE5hbWU6IHRoaXMucHJvcHMuY29sdW1uR3JvdXBOYW1lLCBuYW1lOiB0aGlzLnByb3BzLm5hbWUgfSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFJvd0dyb3VwLnByb3RvdHlwZS5vblJvd0V4cGFuZENsaWNrID0gZnVuY3Rpb24gb25Sb3dFeHBhbmRDbGljaygpIHtcblx0ICAgIHRoaXMub25Sb3dFeHBhbmRUb2dnbGUoIXRoaXMucHJvcHMuaXNFeHBhbmRlZCk7XG5cdCAgfTtcblxuXHQgIFJvd0dyb3VwLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gc2V0U2Nyb2xsTGVmdChzY3JvbGxMZWZ0KSB7XG5cdCAgICBpZiAodGhpcy5yb3dHcm91cFJlbmRlcmVyKSB7XG5cdCAgICAgIHRoaXMucm93R3JvdXBSZW5kZXJlci5zZXRTY3JvbGxMZWZ0ID8gdGhpcy5yb3dHcm91cFJlbmRlcmVyLnNldFNjcm9sbExlZnQoc2Nyb2xsTGVmdCkgOiBudWxsO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBSb3dHcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHZhciBsYXN0Q29sdW1uID0gX3V0aWxzMlsnZGVmYXVsdCddLmxhc3QodGhpcy5wcm9wcy5jb2x1bW5zKTtcblxuXHQgICAgdmFyIHN0eWxlID0geyB3aWR0aDogbGFzdENvbHVtbi5sZWZ0ICsgbGFzdENvbHVtbi53aWR0aCB9O1xuXG5cdCAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7IHN0eWxlOiBzdHlsZSwgY2xhc3NOYW1lOiAncmVhY3QtZ3JpZC1yb3ctZ3JvdXAnIH0sXG5cdCAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMucmVuZGVyZXIsIF9leHRlbmRzKHsgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuXHQgICAgICAgICAgX3RoaXMyLnJvd0dyb3VwUmVuZGVyZXIgPSBub2RlO1xuXHQgICAgICAgIH0gfSwgdGhpcy5wcm9wcywgeyBvblJvd0V4cGFuZENsaWNrOiB0aGlzLm9uUm93RXhwYW5kQ2xpY2ssIG9uUm93RXhwYW5kVG9nZ2xlOiB0aGlzLm9uUm93RXhwYW5kVG9nZ2xlIH0pKVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFJvd0dyb3VwO1xuXHR9KF9yZWFjdC5Db21wb25lbnQpO1xuXG5cdFJvd0dyb3VwLnByb3BUeXBlcyA9IHtcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5XSkuaXNSZXF1aXJlZCxcblx0ICByb3c6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYW55LmlzUmVxdWlyZWQsXG5cdCAgY2VsbFJlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgY2VsbE1ldGFEYXRhOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKGNlbGxNZXRhRGF0YVNoYXBlKSxcblx0ICBpc1NlbGVjdGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgaWR4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGV4cGFuZGVkUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheU9mKF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0KSxcblx0ICBleHRyYUNsYXNzZXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIGZvcmNlVXBkYXRlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgc3ViUm93RGV0YWlsczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgaXNSb3dIb3ZlcmVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgY29sVmlzaWJsZVN0YXJ0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGNvbFZpc2libGVFbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgY29sRGlzcGxheVN0YXJ0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIGNvbERpc3BsYXlFbmQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgaXNTY3JvbGxpbmc6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbC5pc1JlcXVpcmVkLFxuXHQgIGNvbHVtbkdyb3VwTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICBpc0V4cGFuZGVkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wuaXNSZXF1aXJlZCxcblx0ICB0cmVlRGVwdGg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgbmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICByZW5kZXJlcjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXG5cdH07XG5cblx0dmFyIERlZmF1bHRSb3dHcm91cFJlbmRlcmVyID0gZnVuY3Rpb24gRGVmYXVsdFJvd0dyb3VwUmVuZGVyZXIocHJvcHMpIHtcblx0ICB2YXIgdHJlZURlcHRoID0gcHJvcHMudHJlZURlcHRoIHx8IDA7XG5cdCAgdmFyIG1hcmdpbkxlZnQgPSB0cmVlRGVwdGggKiAyMDtcblxuXHQgIHZhciBzdHlsZSA9IHtcblx0ICAgIGhlaWdodDogJzUwcHgnLFxuXHQgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNkZGRkZGQnLFxuXHQgICAgcGFkZGluZ1RvcDogJzE1cHgnLFxuXHQgICAgcGFkZGluZ0xlZnQ6ICc1cHgnXG5cdCAgfTtcblxuXHQgIHZhciBvbktleURvd24gPSBmdW5jdGlvbiBvbktleURvd24oZSkge1xuXHQgICAgaWYgKGUua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuXHQgICAgICBwcm9wcy5vblJvd0V4cGFuZFRvZ2dsZShmYWxzZSk7XG5cdCAgICB9XG5cdCAgICBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuXHQgICAgICBwcm9wcy5vblJvd0V4cGFuZFRvZ2dsZSh0cnVlKTtcblx0ICAgIH1cblx0ICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuXHQgICAgICBwcm9wcy5vblJvd0V4cGFuZFRvZ2dsZSghcHJvcHMuaXNFeHBhbmRlZCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAnZGl2Jyxcblx0ICAgIHsgc3R5bGU6IHN0eWxlLCBvbktleURvd246IG9uS2V5RG93biwgdGFiSW5kZXg6IDAgfSxcblx0ICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAnc3BhbicsXG5cdCAgICAgIHsgY2xhc3NOYW1lOiAncm93LWV4cGFuZC1pY29uJywgc3R5bGU6IHsgZmxvYXQ6ICdsZWZ0JywgbWFyZ2luTGVmdDogbWFyZ2luTGVmdCwgY3Vyc29yOiAncG9pbnRlcicgfSwgb25DbGljazogcHJvcHMub25Sb3dFeHBhbmRDbGljayB9LFxuXHQgICAgICBwcm9wcy5pc0V4cGFuZGVkID8gU3RyaW5nLmZyb21DaGFyQ29kZSgnOTY2MCcpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgnOTY1OCcpXG5cdCAgICApLFxuXHQgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdzdHJvbmcnLFxuXHQgICAgICBudWxsLFxuXHQgICAgICBwcm9wcy5jb2x1bW5Hcm91cE5hbWUsXG5cdCAgICAgICc6ICcsXG5cdCAgICAgIHByb3BzLm5hbWVcblx0ICAgIClcblx0ICApO1xuXHR9O1xuXG5cdERlZmF1bHRSb3dHcm91cFJlbmRlcmVyLnByb3BUeXBlcyA9IHtcblx0ICBvblJvd0V4cGFuZENsaWNrOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBvblJvd0V4cGFuZFRvZ2dsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLmlzUmVxdWlyZWQsXG5cdCAgaXNFeHBhbmRlZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLmlzUmVxdWlyZWQsXG5cdCAgdHJlZURlcHRoOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIG5hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uR3JvdXBOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkLFxuXHQgIGhpZGVDb2x1bW5OYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xcblx0fTtcblxuXHRSb3dHcm91cC5kZWZhdWx0UHJvcHMgPSB7XG5cdCAgcmVuZGVyZXI6IERlZmF1bHRSb3dHcm91cFJlbmRlcmVyXG5cdH07XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gUm93R3JvdXA7XG5cbi8qKiovIH0pLFxuLyogMTIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdHZhciBfQ29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cdHZhciBfQ29sdW1uVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sdW1uVXRpbHMpO1xuXG5cdHZhciBfdmlld3BvcnRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM3KTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgQ2FudmFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xuXHR2YXIgY2VsbE1ldGFEYXRhU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHR2YXIgVmlld3BvcnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhWaWV3cG9ydCwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydCk7XG5cblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9ICgwLCBfdmlld3BvcnRVdGlscy5nZXRHcmlkU3RhdGUpKF90aGlzLnByb3BzKSwgX3RoaXMub25TY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XG5cdCAgICAgIF90aGlzLnVwZGF0ZVNjcm9sbChzY3JvbGwuc2Nyb2xsVG9wLCBzY3JvbGwuc2Nyb2xsTGVmdCwgX3RoaXMuc3RhdGUuaGVpZ2h0LCBfdGhpcy5wcm9wcy5yb3dIZWlnaHQsIF90aGlzLnByb3BzLnJvd3NDb3VudCk7XG5cblx0ICAgICAgaWYgKF90aGlzLnByb3BzLm9uU2Nyb2xsKSB7XG5cdCAgICAgICAgX3RoaXMucHJvcHMub25TY3JvbGwoeyBzY3JvbGxUb3A6IHNjcm9sbC5zY3JvbGxUb3AsIHNjcm9sbExlZnQ6IHNjcm9sbC5zY3JvbGxMZWZ0IH0pO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5nZXRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcy5jYW52YXMuZ2V0U2Nyb2xsKCk7XG5cdCAgICB9LCBfdGhpcy5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcblx0ICAgICAgX3RoaXMuY2FudmFzLnNldFNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG5cdCAgICB9LCBfdGhpcy5nZXRET01Ob2RlT2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcy52aWV3cG9ydCA/IF90aGlzLnZpZXdwb3J0Lm9mZnNldFdpZHRoIDogMDtcblx0ICAgIH0sIF90aGlzLmNsZWFyU2Nyb2xsVGltZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpcy5yZXNldFNjcm9sbFN0YXRlVGltZW91dElkKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlc2V0U2Nyb2xsU3RhdGVUaW1lb3V0SWQpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy5yZXNldFNjcm9sbFN0YXRlQWZ0ZXJEZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3RoaXMuY2xlYXJTY3JvbGxUaW1lcigpO1xuXHQgICAgICBfdGhpcy5yZXNldFNjcm9sbFN0YXRlVGltZW91dElkID0gc2V0VGltZW91dChfdGhpcy5yZXNldFNjcm9sbFN0YXRlQWZ0ZXJEZWxheUNhbGxiYWNrLCA1MDApO1xuXHQgICAgfSwgX3RoaXMucmVzZXRTY3JvbGxTdGF0ZUFmdGVyRGVsYXlDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3RoaXMucmVzZXRTY3JvbGxTdGF0ZVRpbWVvdXRJZCA9IG51bGw7XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHtcblx0ICAgICAgICBpc1Njcm9sbGluZzogZmFsc2Vcblx0ICAgICAgfSk7XG5cdCAgICB9LCBfdGhpcy51cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCBoZWlnaHQsIHJvd0hlaWdodCwgbGVuZ3RoLCB3aWR0aCkge1xuXHQgICAgICBfdGhpcy5yZXNldFNjcm9sbFN0YXRlQWZ0ZXJEZWxheSgpO1xuXHQgICAgICB2YXIgbmV4dFNjcm9sbFN0YXRlID0gKDAsIF92aWV3cG9ydFV0aWxzLmdldE5leHRTY3JvbGxTdGF0ZSkoX3RoaXMucHJvcHMsIF90aGlzLmdldERPTU5vZGVPZmZzZXRXaWR0aCwgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCBoZWlnaHQsIHJvd0hlaWdodCwgbGVuZ3RoLCB3aWR0aCk7XG5cblx0ICAgICAgX3RoaXMuc2V0U3RhdGUobmV4dFNjcm9sbFN0YXRlKTtcblx0ICAgIH0sIF90aGlzLm1ldHJpY3NVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMudmlld3BvcnRIZWlnaHQoKTtcblx0ICAgICAgdmFyIHdpZHRoID0gX3RoaXMudmlld3BvcnRXaWR0aCgpO1xuXHQgICAgICBpZiAoaGVpZ2h0KSB7XG5cdCAgICAgICAgX3RoaXMudXBkYXRlU2Nyb2xsKF90aGlzLnN0YXRlLnNjcm9sbFRvcCwgX3RoaXMuc3RhdGUuc2Nyb2xsTGVmdCwgaGVpZ2h0LCBfdGhpcy5wcm9wcy5yb3dIZWlnaHQsIF90aGlzLnByb3BzLnJvd3NDb3VudCwgd2lkdGgpO1xuXHQgICAgICB9XG5cdCAgICB9LCBfdGhpcy52aWV3cG9ydEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzLnZpZXdwb3J0ID8gX3RoaXMudmlld3BvcnQub2Zmc2V0SGVpZ2h0IDogMDtcblx0ICAgIH0sIF90aGlzLnZpZXdwb3J0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcy52aWV3cG9ydCA/IF90aGlzLnZpZXdwb3J0Lm9mZnNldFdpZHRoIDogMDtcblx0ICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuXHQgIH1cblxuXHQgIFZpZXdwb3J0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0ICAgIGlmICh0aGlzLnByb3BzLnJvd0hlaWdodCAhPT0gbmV4dFByb3BzLnJvd0hlaWdodCB8fCB0aGlzLnByb3BzLm1pbkhlaWdodCAhPT0gbmV4dFByb3BzLm1pbkhlaWdodCkge1xuXHQgICAgICB2YXIgbmV3U3RhdGUgPSAoMCwgX3ZpZXdwb3J0VXRpbHMuZ2V0R3JpZFN0YXRlKShuZXh0UHJvcHMpO1xuXHQgICAgICB0aGlzLnVwZGF0ZVNjcm9sbChuZXdTdGF0ZS5zY3JvbGxUb3AsIG5ld1N0YXRlLnNjcm9sbExlZnQsIG5ld1N0YXRlLmhlaWdodCwgbmV4dFByb3BzLnJvd0hlaWdodCwgbmV4dFByb3BzLnJvd3NDb3VudCk7XG5cdCAgICB9IGVsc2UgaWYgKF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRTaXplKHRoaXMucHJvcHMuY29sdW1uTWV0cmljcy5jb2x1bW5zKSAhPT0gX0NvbHVtblV0aWxzMlsnZGVmYXVsdCddLmdldFNpemUobmV4dFByb3BzLmNvbHVtbk1ldHJpY3MuY29sdW1ucykpIHtcblx0ICAgICAgdGhpcy5zZXRTdGF0ZSgoMCwgX3ZpZXdwb3J0VXRpbHMuZ2V0R3JpZFN0YXRlKShuZXh0UHJvcHMpKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5yb3dzQ291bnQgIT09IG5leHRQcm9wcy5yb3dzQ291bnQpIHtcblx0ICAgICAgdGhpcy51cGRhdGVTY3JvbGwodGhpcy5zdGF0ZS5zY3JvbGxUb3AsIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCwgdGhpcy5zdGF0ZS5oZWlnaHQsIG5leHRQcm9wcy5yb3dIZWlnaHQsIG5leHRQcm9wcy5yb3dzQ291bnQpO1xuXHQgICAgICAvLyBBZGRlZCB0byBmaXggdGhlIGhpZGluZyBvZiB0aGUgYm90dG9tIHNjcm9sbGJhciB3aGVuIHNob3dpbmcgdGhlIGZpbHRlcnMuXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMucm93T2Zmc2V0SGVpZ2h0ICE9PSBuZXh0UHJvcHMucm93T2Zmc2V0SGVpZ2h0KSB7XG5cdCAgICAgIC8vIFRoZSB2YWx1ZSBvZiBoZWlnaHQgY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFuZCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IGhlaWdodCB0byBjYXRlciBmb3IgY2hhbmdlcyBpbiB0aGUgaGVhZGVyIGhlaWdodCAoZHVlIHRvIHRoZSBmaWxlcilcblx0ICAgICAgdmFyIGhlaWdodCA9IHRoaXMucHJvcHMucm93T2Zmc2V0SGVpZ2h0IC0gbmV4dFByb3BzLnJvd09mZnNldEhlaWdodDtcblxuXHQgICAgICB0aGlzLnVwZGF0ZVNjcm9sbCh0aGlzLnN0YXRlLnNjcm9sbFRvcCwgdGhpcy5zdGF0ZS5zY3JvbGxMZWZ0LCB0aGlzLnN0YXRlLmhlaWdodCArIGhlaWdodCwgbmV4dFByb3BzLnJvd0hlaWdodCwgbmV4dFByb3BzLnJvd3NDb3VudCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFZpZXdwb3J0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHQgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm1ldHJpY3NVcGRhdGVkKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgncmVzaXplJywgdGhpcy5tZXRyaWNzVXBkYXRlZCk7XG5cdCAgICB9XG5cdCAgICB0aGlzLm1ldHJpY3NVcGRhdGVkKCk7XG5cdCAgfTtcblxuXHQgIFZpZXdwb3J0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMubWV0cmljc1VwZGF0ZWQpO1xuXHQgICAgdGhpcy5jbGVhclNjcm9sbFRpbWVyKCk7XG5cdCAgfTtcblxuXHQgIFZpZXdwb3J0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgdmFyIHN0eWxlID0ge1xuXHQgICAgICBwYWRkaW5nOiAwLFxuXHQgICAgICBib3R0b206IDAsXG5cdCAgICAgIGxlZnQ6IDAsXG5cdCAgICAgIHJpZ2h0OiAwLFxuXHQgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG5cdCAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQgICAgICB0b3A6IHRoaXMucHJvcHMucm93T2Zmc2V0SGVpZ2h0XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICB7XG5cdCAgICAgICAgY2xhc3NOYW1lOiAncmVhY3QtZ3JpZC1WaWV3cG9ydCcsXG5cdCAgICAgICAgc3R5bGU6IHN0eWxlLFxuXHQgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcblx0ICAgICAgICAgIF90aGlzMi52aWV3cG9ydCA9IG5vZGU7XG5cdCAgICAgICAgfSB9LFxuXHQgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhcywge1xuXHQgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcblx0ICAgICAgICAgIHJldHVybiBfdGhpczIuY2FudmFzID0gbm9kZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJvd0tleTogdGhpcy5wcm9wcy5yb3dLZXksXG5cdCAgICAgICAgdG90YWxXaWR0aDogdGhpcy5wcm9wcy50b3RhbFdpZHRoLFxuXHQgICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLmNvbHVtbk1ldHJpY3Mud2lkdGgsXG5cdCAgICAgICAgcm93R2V0dGVyOiB0aGlzLnByb3BzLnJvd0dldHRlcixcblx0ICAgICAgICByb3dzQ291bnQ6IHRoaXMucHJvcHMucm93c0NvdW50LFxuXHQgICAgICAgIHNlbGVjdGVkUm93czogdGhpcy5wcm9wcy5zZWxlY3RlZFJvd3MsXG5cdCAgICAgICAgZXhwYW5kZWRSb3dzOiB0aGlzLnByb3BzLmV4cGFuZGVkUm93cyxcblx0ICAgICAgICBjb2x1bW5zOiB0aGlzLnByb3BzLmNvbHVtbk1ldHJpY3MuY29sdW1ucyxcblx0ICAgICAgICByb3dSZW5kZXJlcjogdGhpcy5wcm9wcy5yb3dSZW5kZXJlcixcblx0ICAgICAgICBkaXNwbGF5U3RhcnQ6IHRoaXMuc3RhdGUuZGlzcGxheVN0YXJ0LFxuXHQgICAgICAgIGRpc3BsYXlFbmQ6IHRoaXMuc3RhdGUuZGlzcGxheUVuZCxcblx0ICAgICAgICB2aXNpYmxlU3RhcnQ6IHRoaXMuc3RhdGUudmlzaWJsZVN0YXJ0LFxuXHQgICAgICAgIHZpc2libGVFbmQ6IHRoaXMuc3RhdGUudmlzaWJsZUVuZCxcblx0ICAgICAgICBjb2xWaXNpYmxlU3RhcnQ6IHRoaXMuc3RhdGUuY29sVmlzaWJsZVN0YXJ0LFxuXHQgICAgICAgIGNvbFZpc2libGVFbmQ6IHRoaXMuc3RhdGUuY29sVmlzaWJsZUVuZCxcblx0ICAgICAgICBjb2xEaXNwbGF5U3RhcnQ6IHRoaXMuc3RhdGUuY29sRGlzcGxheVN0YXJ0LFxuXHQgICAgICAgIGNvbERpc3BsYXlFbmQ6IHRoaXMuc3RhdGUuY29sRGlzcGxheUVuZCxcblx0ICAgICAgICBjZWxsTWV0YURhdGE6IHRoaXMucHJvcHMuY2VsbE1ldGFEYXRhLFxuXHQgICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQsXG5cdCAgICAgICAgcm93SGVpZ2h0OiB0aGlzLnByb3BzLnJvd0hlaWdodCxcblx0ICAgICAgICBvblNjcm9sbDogdGhpcy5vblNjcm9sbCxcblx0ICAgICAgICBvblJvd3M6IHRoaXMucHJvcHMub25Sb3dzLFxuXHQgICAgICAgIHJvd1Njcm9sbFRpbWVvdXQ6IHRoaXMucHJvcHMucm93U2Nyb2xsVGltZW91dCxcblx0ICAgICAgICBzY3JvbGxUb1Jvd0luZGV4OiB0aGlzLnByb3BzLnNjcm9sbFRvUm93SW5kZXgsXG5cdCAgICAgICAgY29udGV4dE1lbnU6IHRoaXMucHJvcHMuY29udGV4dE1lbnUsXG5cdCAgICAgICAgcm93U2VsZWN0aW9uOiB0aGlzLnByb3BzLnJvd1NlbGVjdGlvbixcblx0ICAgICAgICBnZXRTdWJSb3dEZXRhaWxzOiB0aGlzLnByb3BzLmdldFN1YlJvd0RldGFpbHMsXG5cdCAgICAgICAgcm93R3JvdXBSZW5kZXJlcjogdGhpcy5wcm9wcy5yb3dHcm91cFJlbmRlcmVyLFxuXHQgICAgICAgIGlzU2Nyb2xsaW5nOiB0aGlzLnN0YXRlLmlzU2Nyb2xsaW5nIHx8IGZhbHNlXG5cdCAgICAgIH0pXG5cdCAgICApO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVmlld3BvcnQ7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRWaWV3cG9ydC5kaXNwbGF5TmFtZSA9ICdWaWV3cG9ydCc7XG5cdFZpZXdwb3J0LnByb3BUeXBlcyA9IHtcblx0ICByb3dPZmZzZXRIZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgdG90YWxXaWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLmlzUmVxdWlyZWQsXG5cdCAgY29sdW1uTWV0cmljczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QuaXNSZXF1aXJlZCxcblx0ICByb3dHZXR0ZXI6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNdKS5pc1JlcXVpcmVkLFxuXHQgIHNlbGVjdGVkUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheSxcblx0ICByb3dTZWxlY3Rpb246IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgIGluZGV4ZXM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXlPZihfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcikuaXNSZXF1aXJlZFxuXHQgIH0pLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgIGlzU2VsZWN0ZWRLZXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWRcblx0ICB9KSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBrZXlzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnNoYXBlKHtcblx0ICAgICAgdmFsdWVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LmlzUmVxdWlyZWQsXG5cdCAgICAgIHJvd0tleTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZFxuXHQgICAgfSkuaXNSZXF1aXJlZFxuXHQgIH0pXSksXG5cdCAgZXhwYW5kZWRSb3dzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5LFxuXHQgIHJvd1JlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNdKSxcblx0ICByb3dzQ291bnQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgcm93SGVpZ2h0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlci5pc1JlcXVpcmVkLFxuXHQgIG9uUm93czogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIG9uU2Nyb2xsOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgbWluSGVpZ2h0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBjZWxsTWV0YURhdGE6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoY2VsbE1ldGFEYXRhU2hhcGUpLFxuXHQgIHJvd0tleTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICByb3dTY3JvbGxUaW1lb3V0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBzY3JvbGxUb1Jvd0luZGV4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBjb250ZXh0TWVudTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LFxuXHQgIGdldFN1YlJvd0RldGFpbHM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICByb3dHcm91cFJlbmRlcmVyOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0fTtcblx0Vmlld3BvcnQuZGVmYXVsdFByb3BzID0ge1xuXHQgIHJvd0hlaWdodDogMzBcblx0fTtcblxuXG5cdG1vZHVsZS5leHBvcnRzID0gVmlld3BvcnQ7XG5cbi8qKiovIH0pLFxuLyogMTIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBFeGNlbENvbHVtbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cdHZhciBGaWx0ZXJhYmxlSGVhZGVyQ2VsbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgX2luaGVyaXRzKEZpbHRlcmFibGVIZWFkZXJDZWxsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIEZpbHRlcmFibGVIZWFkZXJDZWxsKCkge1xuXHQgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlcmFibGVIZWFkZXJDZWxsKTtcblxuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0geyBmaWx0ZXJUZXJtOiAnJyB9LCBfdGhpcy5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdmFsID0gZS50YXJnZXQudmFsdWU7XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHsgZmlsdGVyVGVybTogdmFsIH0pO1xuXHQgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZSh7IGZpbHRlclRlcm06IHZhbCwgY29sdW1uOiBfdGhpcy5wcm9wcy5jb2x1bW4gfSk7XG5cdCAgICB9LCBfdGhpcy5yZW5kZXJJbnB1dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKF90aGlzLnByb3BzLmNvbHVtbi5maWx0ZXJhYmxlID09PSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaW5wdXRLZXkgPSAnaGVhZGVyLWZpbHRlci0nICsgX3RoaXMucHJvcHMuY29sdW1uLmtleTtcblx0ICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyBrZXk6IGlucHV0S2V5LCB0eXBlOiAndGV4dCcsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCBpbnB1dC1zbScsIHBsYWNlaG9sZGVyOiAnU2VhcmNoJywgdmFsdWU6IF90aGlzLnN0YXRlLmZpbHRlclRlcm0sIG9uQ2hhbmdlOiBfdGhpcy5oYW5kbGVDaGFuZ2UgfSk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cblx0ICBGaWx0ZXJhYmxlSGVhZGVyQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICdkaXYnLFxuXHQgICAgICBudWxsLFxuXHQgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgICdkaXYnLFxuXHQgICAgICAgIHsgY2xhc3NOYW1lOiAnZm9ybS1ncm91cCcgfSxcblx0ICAgICAgICB0aGlzLnJlbmRlcklucHV0KClcblx0ICAgICAgKVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEZpbHRlcmFibGVIZWFkZXJDZWxsO1xuXHR9KFJlYWN0LkNvbXBvbmVudCk7XG5cblx0RmlsdGVyYWJsZUhlYWRlckNlbGwucHJvcFR5cGVzID0ge1xuXHQgIG9uQ2hhbmdlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMuaXNSZXF1aXJlZCxcblx0ICBjb2x1bW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc2hhcGUoRXhjZWxDb2x1bW4pXG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEZpbHRlcmFibGVIZWFkZXJDZWxsO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5cdHZhciBfa2V5Ym9hcmRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBqb2luQ2xhc3NlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBTaW1wbGVUZXh0RWRpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cdHZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHR2YXIgRWRpdG9yQ29udGFpbmVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoRWRpdG9yQ29udGFpbmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHQgIGZ1bmN0aW9uIEVkaXRvckNvbnRhaW5lcigpIHtcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3JDb250YWluZXIpO1xuXG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX2luaXRpYWxpc2VQcm9wcy5jYWxsKF90aGlzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG5cdCAgfVxuXG5cdCAgRWRpdG9yQ29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHQgICAgdmFyIGlucHV0Tm9kZSA9IHRoaXMuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICBpZiAoaW5wdXROb2RlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhpcy5zZXRUZXh0SW5wdXRGb2N1cygpO1xuXHQgICAgICBpZiAoIXRoaXMuZ2V0RWRpdG9yKCkuZGlzYWJsZUNvbnRhaW5lclN0eWxlcykge1xuXHQgICAgICAgIGlucHV0Tm9kZS5jbGFzc05hbWUgKz0gJyBlZGl0b3ItbWFpbic7XG5cdCAgICAgICAgaW5wdXROb2RlLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0IC0gMSArICdweCc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWRpdG9yQ29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgaWYgKCF0aGlzLmNoYW5nZUNvbW1pdHRlZCAmJiAhdGhpcy5jaGFuZ2VDYW5jZWxlZCkge1xuXHQgICAgICB0aGlzLmNvbW1pdCh7IGtleTogJ0VudGVyJyB9KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWRpdG9yQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgJ2RpdicsXG5cdCAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLmdldENvbnRhaW5lckNsYXNzKCksIG9uQmx1cjogdGhpcy5oYW5kbGVCbHVyLCBvbktleURvd246IHRoaXMub25LZXlEb3duLCBvbkNvbnRleHRNZW51OiB0aGlzLmhhbmRsZVJpZ2h0Q2xpY2sgfSxcblx0ICAgICAgdGhpcy5jcmVhdGVFZGl0b3IoKSxcblx0ICAgICAgdGhpcy5yZW5kZXJTdGF0dXNJY29uKClcblx0ICAgICk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBFZGl0b3JDb250YWluZXI7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHRFZGl0b3JDb250YWluZXIuZGlzcGxheU5hbWUgPSAnRWRpdG9yQ29udGFpbmVyJztcblx0RWRpdG9yQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcblx0ICByb3dJZHg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIHJvd0RhdGE6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LmlzUmVxdWlyZWQsXG5cdCAgdmFsdWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2xdKS5pc1JlcXVpcmVkLFxuXHQgIGNlbGxNZXRhRGF0YTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zaGFwZSh7XG5cdCAgICBzZWxlY3RlZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QuaXNSZXF1aXJlZCxcblx0ICAgIGNvcGllZDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgICBkcmFnZ2VkOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICAgIG9uQ2VsbENsaWNrOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgICBvbkNlbGxEb3VibGVDbGljazogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgICAgb25Db21taXRDYW5jZWw6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICAgIG9uQ29tbWl0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmNcblx0ICB9KS5pc1JlcXVpcmVkLFxuXHQgIGNvbHVtbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QuaXNSZXF1aXJlZCxcblx0ICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLmlzUmVxdWlyZWQsXG5cdCAgb25HcmlkS2V5RG93bjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXG5cdH07XG5cblx0dmFyIF9pbml0aWFsaXNlUHJvcHMgPSBmdW5jdGlvbiBfaW5pdGlhbGlzZVByb3BzKCkge1xuXHQgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgdGhpcy5zdGF0ZSA9IHsgaXNJbnZhbGlkOiBmYWxzZSB9O1xuXHQgIHRoaXMuY2hhbmdlQ29tbWl0dGVkID0gZmFsc2U7XG5cdCAgdGhpcy5jaGFuZ2VDYW5jZWxlZCA9IGZhbHNlO1xuXG5cdCAgdGhpcy5pc0tleUV4cGxpY2l0bHlIYW5kbGVkID0gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgcmV0dXJuIGlzRnVuY3Rpb24oX3RoaXMyWydvblByZXNzJyArIGtleV0pO1xuXHQgIH07XG5cblx0ICB0aGlzLmNoZWNrQW5kQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmdzKSB7XG5cdCAgICBpZiAoaXNGdW5jdGlvbihfdGhpczJbbWV0aG9kTmFtZV0pKSB7XG5cdCAgICAgIF90aGlzMlttZXRob2ROYW1lXShhcmdzKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKCgwLCBfa2V5Ym9hcmRVdGlscy5pc0N0cmxLZXlIZWxkRG93bikoZSkpIHtcblx0ICAgICAgX3RoaXMyLmNoZWNrQW5kQ2FsbCgnb25QcmVzc0tleVdpdGhDdHJsJywgZSk7XG5cdCAgICB9IGVsc2UgaWYgKF90aGlzMi5pc0tleUV4cGxpY2l0bHlIYW5kbGVkKGUua2V5KSkge1xuXHQgICAgICAvLyBicmVhayB1cCBpbmRpdmlkdWFsIGtleVByZXNzIGV2ZW50cyB0byBoYXZlIHRoZWlyIG93biBzcGVjaWZpYyBjYWxsYmFja3Ncblx0ICAgICAgdmFyIGNhbGxCYWNrID0gJ29uUHJlc3MnICsgZS5rZXk7XG5cdCAgICAgIF90aGlzMi5jaGVja0FuZENhbGwoY2FsbEJhY2ssIGUpO1xuXHQgICAgfSBlbHNlIGlmICgoMCwgX2tleWJvYXJkVXRpbHMuaXNLZXlQcmludGFibGUpKGUua2V5Q29kZSkpIHtcblx0ICAgICAgX3RoaXMyLmNoZWNrQW5kQ2FsbCgnb25QcmVzc0NoYXInLCBlKTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJhY2sgd2hpY2gga2V5cyBhcmUgY3VycmVudGx5IGRvd24gZm9yIHNoaWZ0IGNsaWNraW5nIGV0Y1xuXHQgICAgX3RoaXMyLl9rZXlzRG93biA9IF90aGlzMi5fa2V5c0Rvd24gfHwge307XG5cdCAgICBfdGhpczIuX2tleXNEb3duW2Uua2V5Q29kZV0gPSB0cnVlO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMyLnByb3BzLm9uR3JpZEtleURvd24pKSB7XG5cdCAgICAgIF90aGlzMi5wcm9wcy5vbkdyaWRLZXlEb3duKGUpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLmNyZWF0ZUVkaXRvclJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcblx0ICAgIF90aGlzMi5lZGl0b3IgPSByZWY7XG5cdCAgfTtcblxuXHQgIHRoaXMuY3JlYXRlRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGVkaXRvclByb3BzID0ge1xuXHQgICAgICByZWY6IF90aGlzMi5jcmVhdGVFZGl0b3JSZWYsXG5cdCAgICAgIGNvbHVtbjogX3RoaXMyLnByb3BzLmNvbHVtbixcblx0ICAgICAgdmFsdWU6IF90aGlzMi5nZXRJbml0aWFsVmFsdWUoKSxcblx0ICAgICAgb25Db21taXQ6IF90aGlzMi5jb21taXQsXG5cdCAgICAgIG9uQ29tbWl0Q2FuY2VsOiBfdGhpczIuY29tbWl0Q2FuY2VsLFxuXHQgICAgICByb3dNZXRhRGF0YTogX3RoaXMyLmdldFJvd01ldGFEYXRhKCksXG5cdCAgICAgIHJvd0RhdGE6IF90aGlzMi5wcm9wcy5yb3dEYXRhLFxuXHQgICAgICBoZWlnaHQ6IF90aGlzMi5wcm9wcy5oZWlnaHQsXG5cdCAgICAgIG9uQmx1cjogX3RoaXMyLmNvbW1pdCxcblx0ICAgICAgb25PdmVycmlkZUtleURvd246IF90aGlzMi5vbktleURvd25cblx0ICAgIH07XG5cblx0ICAgIHZhciBDdXN0b21FZGl0b3IgPSBfdGhpczIucHJvcHMuY29sdW1uLmVkaXRvcjtcblx0ICAgIC8vIHJldHVybiBjdXN0b20gY29sdW1uIGVkaXRvciBvciBTaW1wbGVFZGl0b3IgaWYgbm9uZSBzcGVjaWZpZWRcblx0ICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChDdXN0b21FZGl0b3IpKSB7XG5cdCAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoQ3VzdG9tRWRpdG9yLCBlZGl0b3JQcm9wcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNGdW5jdGlvbihDdXN0b21FZGl0b3IpKSB7XG5cdCAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbUVkaXRvciwgX2V4dGVuZHMoeyByZWY6IF90aGlzMi5jcmVhdGVFZGl0b3JSZWYgfSwgZWRpdG9yUHJvcHMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2ltcGxlVGV4dEVkaXRvciwgeyByZWY6IF90aGlzMi5jcmVhdGVFZGl0b3JSZWYsIGNvbHVtbjogX3RoaXMyLnByb3BzLmNvbHVtbiwgdmFsdWU6IF90aGlzMi5nZXRJbml0aWFsVmFsdWUoKSwgb25CbHVyOiBfdGhpczIuY29tbWl0LCByb3dNZXRhRGF0YTogX3RoaXMyLmdldFJvd01ldGFEYXRhKCksIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKCkge30sIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KCkge30gfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0VudGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgX3RoaXMyLmNvbW1pdCh7IGtleTogJ0VudGVyJyB9KTtcblx0ICB9O1xuXG5cdCAgdGhpcy5vblByZXNzVGFiID0gZnVuY3Rpb24gKCkge1xuXHQgICAgX3RoaXMyLmNvbW1pdCh7IGtleTogJ1RhYicgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0VzY2FwZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoIV90aGlzMi5lZGl0b3JJc1NlbGVjdE9wZW4oKSkge1xuXHQgICAgICBfdGhpczIuY29tbWl0Q2FuY2VsKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBwcmV2ZW50IGV2ZW50IGZyb20gYnViYmxpbmcgaWYgZWRpdG9yIGhhcyByZXN1bHRzIHRvIHNlbGVjdFxuXHQgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLm9uUHJlc3NBcnJvd0Rvd24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKF90aGlzMi5lZGl0b3JIYXNSZXN1bHRzKCkpIHtcblx0ICAgICAgLy8gZG9udCB3YW50IHRvIHByb3BvZ2F0ZSBhcyB0aGF0IHRoZW4gbW92ZXMgdXMgcm91bmQgdGhlIGdyaWRcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF90aGlzMi5jb21taXQoZSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0Fycm93VXAgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKF90aGlzMi5lZGl0b3JIYXNSZXN1bHRzKCkpIHtcblx0ICAgICAgLy8gZG9udCB3YW50IHRvIHByb3BvZ2F0ZSBhcyB0aGF0IHRoZW4gbW92ZXMgdXMgcm91bmQgdGhlIGdyaWRcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF90aGlzMi5jb21taXQoZSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0Fycm93TGVmdCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAvLyBwcmV2ZW50IGV2ZW50IHByb3BvZ2F0aW9uLiB0aGlzIGRpc2FibGVzIGxlZnQgY2VsbCBuYXZpZ2F0aW9uXG5cdCAgICBpZiAoIV90aGlzMi5pc0NhcmV0QXRCZWdpbm5pbmdPZklucHV0KCkpIHtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF90aGlzMi5jb21taXQoZSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRoaXMub25QcmVzc0Fycm93UmlnaHQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgLy8gcHJldmVudCBldmVudCBwcm9wb2dhdGlvbi4gdGhpcyBkaXNhYmxlcyByaWdodCBjZWxsIG5hdmlnYXRpb25cblx0ICAgIGlmICghX3RoaXMyLmlzQ2FyZXRBdEVuZE9mSW5wdXQoKSkge1xuXHQgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgX3RoaXMyLmNvbW1pdChlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5lZGl0b3JIYXNSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMyLmdldEVkaXRvcigpLmhhc1Jlc3VsdHMpKSB7XG5cdCAgICAgIHJldHVybiBfdGhpczIuZ2V0RWRpdG9yKCkuaGFzUmVzdWx0cygpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfTtcblxuXHQgIHRoaXMuZWRpdG9ySXNTZWxlY3RPcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMyLmdldEVkaXRvcigpLmlzU2VsZWN0T3BlbikpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzMi5nZXRFZGl0b3IoKS5pc1NlbGVjdE9wZW4oKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldFJvd01ldGFEYXRhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gY2xvbmUgcm93IGRhdGEgc28gZWRpdG9yIGNhbm5vdCBhY3R1YWxseSBjaGFuZ2UgdGhpc1xuXHQgICAgLy8gY29udmVudGlvbiBiYXNlZCBtZXRob2QgdG8gZ2V0IGNvcnJlc3BvbmRpbmcgSWQgb3IgTmFtZSBvZiBhbnkgTmFtZSBvciBJZCBwcm9wZXJ0eVxuXHQgICAgaWYgKHR5cGVvZiBfdGhpczIucHJvcHMuY29sdW1uLmdldFJvd01ldGFEYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybiBfdGhpczIucHJvcHMuY29sdW1uLmdldFJvd01ldGFEYXRhKF90aGlzMi5wcm9wcy5yb3dEYXRhLCBfdGhpczIucHJvcHMuY29sdW1uKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gX3RoaXMyLmVkaXRvcjtcblx0ICB9O1xuXG5cdCAgdGhpcy5nZXRJbnB1dE5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gX3RoaXMyLmdldEVkaXRvcigpLmdldElucHV0Tm9kZSgpO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBzZWxlY3RlZCA9IF90aGlzMi5wcm9wcy5jZWxsTWV0YURhdGEuc2VsZWN0ZWQ7XG5cdCAgICB2YXIga2V5Q29kZSA9IHNlbGVjdGVkLmluaXRpYWxLZXlDb2RlO1xuXHQgICAgaWYgKGtleUNvZGUgPT09ICdEZWxldGUnIHx8IGtleUNvZGUgPT09ICdCYWNrc3BhY2UnKSB7XG5cdCAgICAgIHJldHVybiAnJztcblx0ICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gJ0VudGVyJykge1xuXHQgICAgICByZXR1cm4gX3RoaXMyLnByb3BzLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdGV4dCA9IGtleUNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpIDogX3RoaXMyLnByb3BzLnZhbHVlO1xuXHQgICAgcmV0dXJuIHRleHQ7XG5cdCAgfTtcblxuXHQgIHRoaXMuZ2V0Q29udGFpbmVyQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gam9pbkNsYXNzZXMoe1xuXHQgICAgICAnaGFzLWVycm9yJzogX3RoaXMyLnN0YXRlLmlzSW52YWxpZCA9PT0gdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgIHZhciBvcHRzID0gYXJncyB8fCB7fTtcblx0ICAgIHZhciB1cGRhdGVkID0gX3RoaXMyLmdldEVkaXRvcigpLmdldFZhbHVlKCk7XG5cdCAgICBpZiAoX3RoaXMyLmlzTmV3VmFsdWVWYWxpZCh1cGRhdGVkKSkge1xuXHQgICAgICBfdGhpczIuY2hhbmdlQ29tbWl0dGVkID0gdHJ1ZTtcblx0ICAgICAgdmFyIGNlbGxLZXkgPSBfdGhpczIucHJvcHMuY29sdW1uLmtleTtcblx0ICAgICAgX3RoaXMyLnByb3BzLmNlbGxNZXRhRGF0YS5vbkNvbW1pdCh7IGNlbGxLZXk6IGNlbGxLZXksIHJvd0lkeDogX3RoaXMyLnByb3BzLnJvd0lkeCwgdXBkYXRlZDogdXBkYXRlZCwga2V5OiBvcHRzLmtleSB9KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdGhpcy5jb21taXRDYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBfdGhpczIuY2hhbmdlQ2FuY2VsZWQgPSB0cnVlO1xuXHQgICAgX3RoaXMyLnByb3BzLmNlbGxNZXRhRGF0YS5vbkNvbW1pdENhbmNlbCgpO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzTmV3VmFsdWVWYWxpZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMyLmdldEVkaXRvcigpLnZhbGlkYXRlKSkge1xuXHQgICAgICB2YXIgaXNWYWxpZCA9IF90aGlzMi5nZXRFZGl0b3IoKS52YWxpZGF0ZSh2YWx1ZSk7XG5cdCAgICAgIF90aGlzMi5zZXRTdGF0ZSh7IGlzSW52YWxpZDogIWlzVmFsaWQgfSk7XG5cdCAgICAgIHJldHVybiBpc1ZhbGlkO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgdGhpcy5zZXRDYXJldEF0RW5kT2ZJbnB1dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpbnB1dCA9IF90aGlzMi5nZXRJbnB1dE5vZGUoKTtcblx0ICAgIC8vIHRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MTEwODgvdXNlLWphdmFzY3JpcHQtdG8tcGxhY2UtY3Vyc29yLWF0LWVuZC1vZi10ZXh0LWluLXRleHQtaW5wdXQtZWxlbWVudFxuXHQgICAgdmFyIHR4dExlbmd0aCA9IGlucHV0LnZhbHVlLmxlbmd0aDtcblx0ICAgIGlmIChpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuXHQgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSh0eHRMZW5ndGgsIHR4dExlbmd0aCk7XG5cdCAgICB9IGVsc2UgaWYgKGlucHV0LmNyZWF0ZVRleHRSYW5nZSkge1xuXHQgICAgICB2YXIgZmllbGRSYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuXHQgICAgICBmaWVsZFJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgdHh0TGVuZ3RoKTtcblx0ICAgICAgZmllbGRSYW5nZS5jb2xsYXBzZSgpO1xuXHQgICAgICBmaWVsZFJhbmdlLnNlbGVjdCgpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLmlzQ2FyZXRBdEJlZ2lubmluZ09mSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaW5wdXROb2RlID0gX3RoaXMyLmdldElucHV0Tm9kZSgpO1xuXHQgICAgcmV0dXJuIGlucHV0Tm9kZS5zZWxlY3Rpb25TdGFydCA9PT0gaW5wdXROb2RlLnNlbGVjdGlvbkVuZCAmJiBpbnB1dE5vZGUuc2VsZWN0aW9uU3RhcnQgPT09IDA7XG5cdCAgfTtcblxuXHQgIHRoaXMuaXNDYXJldEF0RW5kT2ZJbnB1dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpbnB1dE5vZGUgPSBfdGhpczIuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICByZXR1cm4gaW5wdXROb2RlLnNlbGVjdGlvblN0YXJ0ID09PSBpbnB1dE5vZGUudmFsdWUubGVuZ3RoO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzQm9keUNsaWNrZWQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBfdGhpczIuZ2V0UmVsYXRlZFRhcmdldChlKTtcblx0ICAgIHJldHVybiByZWxhdGVkVGFyZ2V0ID09PSBudWxsO1xuXHQgIH07XG5cblx0ICB0aGlzLmlzVmlld3BvcnRDbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gX3RoaXMyLmdldFJlbGF0ZWRUYXJnZXQoZSk7XG5cdCAgICByZXR1cm4gcmVsYXRlZFRhcmdldC5jbGFzc05hbWUuaW5kZXhPZigncmVhY3QtZ3JpZC1WaWV3cG9ydCcpID4gLTE7XG5cdCAgfTtcblxuXHQgIHRoaXMuaXNDbGlja0luc2lkZUVkaXRvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgcmVsYXRlZFRhcmdldCA9IF90aGlzMi5nZXRSZWxhdGVkVGFyZ2V0KGUpO1xuXHQgICAgcmV0dXJuIGUuY3VycmVudFRhcmdldC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCdlZGl0aW5nJykgPiAtMSB8fCByZWxhdGVkVGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCdyZWFjdC1ncmlkLUNlbGwnKSA+IC0xO1xuXHQgIH07XG5cblx0ICB0aGlzLmdldFJlbGF0ZWRUYXJnZXQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIGUucmVsYXRlZFRhcmdldCB8fCBlLmV4cGxpY2l0T3JpZ2luYWxUYXJnZXQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgLy8gSUUxMVxuXHQgIH07XG5cblx0ICB0aGlzLmhhbmRsZVJpZ2h0Q2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICB9O1xuXG5cdCAgdGhpcy5oYW5kbGVCbHVyID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICBpZiAoX3RoaXMyLmlzQm9keUNsaWNrZWQoZSkpIHtcblx0ICAgICAgX3RoaXMyLmNvbW1pdChlKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFfdGhpczIuaXNCb2R5Q2xpY2tlZChlKSkge1xuXHQgICAgICAvLyBwcmV2ZW50IG51bGwgcmVmZXJlbmNlXG5cdCAgICAgIGlmIChfdGhpczIuaXNWaWV3cG9ydENsaWNrZWQoZSkgfHwgIV90aGlzMi5pc0NsaWNrSW5zaWRlRWRpdG9yKGUpKSB7XG5cdCAgICAgICAgX3RoaXMyLmNvbW1pdChlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLnNldFRleHRJbnB1dEZvY3VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHNlbGVjdGVkID0gX3RoaXMyLnByb3BzLmNlbGxNZXRhRGF0YS5zZWxlY3RlZDtcblx0ICAgIHZhciBrZXlDb2RlID0gc2VsZWN0ZWQuaW5pdGlhbEtleUNvZGU7XG5cdCAgICB2YXIgaW5wdXROb2RlID0gX3RoaXMyLmdldElucHV0Tm9kZSgpO1xuXHQgICAgaW5wdXROb2RlLmZvY3VzKCk7XG5cdCAgICBpZiAoaW5wdXROb2RlLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcblx0ICAgICAgaWYgKCEoMCwgX2tleWJvYXJkVXRpbHMuaXNLZXlQcmludGFibGUpKGtleUNvZGUpKSB7XG5cdCAgICAgICAgaW5wdXROb2RlLmZvY3VzKCk7XG5cdCAgICAgICAgaW5wdXROb2RlLnNlbGVjdCgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlucHV0Tm9kZS5zZWxlY3QoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICB0aGlzLnJlbmRlclN0YXR1c0ljb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoX3RoaXMyLnN0YXRlLmlzSW52YWxpZCA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUgZm9ybS1jb250cm9sLWZlZWRiYWNrJyB9KTtcblx0ICAgIH1cblx0ICB9O1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRWRpdG9yQ29udGFpbmVyO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBDaGVja2JveEVkaXRvcjogX193ZWJwYWNrX3JlcXVpcmVfXyg0NyksXG5cdCAgRWRpdG9yQmFzZTogX193ZWJwYWNrX3JlcXVpcmVfXyg0OCksXG5cdCAgU2ltcGxlVGV4dEVkaXRvcjogX193ZWJwYWNrX3JlcXVpcmVfXyg0OSlcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5cdHZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5cdHZhciBfcmVhY3REb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cdHZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG5cblxuXHR2YXIgZm9jdXNhYmxlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIGZvY3VzYWJsZUNvbXBvbmVudFdyYXBwZXIoV3JhcHBlZENvbXBvbmVudCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHQgICAgX2luaGVyaXRzKENvbXBvbmVudFdyYXBwZXIsIF9Db21wb25lbnQpO1xuXG5cdCAgICBmdW5jdGlvbiBDb21wb25lbnRXcmFwcGVyKCkge1xuXHQgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50V3JhcHBlcik7XG5cblx0ICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMpKTtcblxuXHQgICAgICBfdGhpcy5jaGVja0ZvY3VzID0gX3RoaXMuY2hlY2tGb2N1cy5iaW5kKF90aGlzKTtcblx0ICAgICAgX3RoaXMuc3RhdGUgPSB7IGlzU2Nyb2xsaW5nOiBmYWxzZSB9O1xuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cblx0ICAgIENvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0ICAgICAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuaXNTZWxlY3RlZCh0aGlzLnByb3BzKSAhPT0gV3JhcHBlZENvbXBvbmVudC5pc1NlbGVjdGVkKG5leHRQcm9wcyk7XG5cdCAgICB9O1xuXG5cdCAgICBDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0ICAgICAgdmFyIGlzU2Nyb2xsaW5nID0gV3JhcHBlZENvbXBvbmVudC5pc1Njcm9sbGluZyhuZXh0UHJvcHMpO1xuXHQgICAgICBpZiAoaXNTY3JvbGxpbmcgJiYgIXRoaXMuc3RhdGUuaXNTY3JvbGxpbmcpIHtcblx0ICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNTY3JvbGxpbmc6IGlzU2Nyb2xsaW5nIH0pO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHQgICAgICB0aGlzLmNoZWNrRm9jdXMoKTtcblx0ICAgIH07XG5cblx0ICAgIENvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcblx0ICAgICAgdGhpcy5jaGVja0ZvY3VzKCk7XG5cdCAgICB9O1xuXG5cdCAgICBDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZS5jaGVja0ZvY3VzID0gZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcblx0ICAgICAgaWYgKFdyYXBwZWRDb21wb25lbnQuaXNTZWxlY3RlZCh0aGlzLnByb3BzKSAmJiB0aGlzLnN0YXRlLmlzU2Nyb2xsaW5nKSB7XG5cdCAgICAgICAgdGhpcy5mb2N1cygpO1xuXHQgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1Njcm9sbGluZzogZmFsc2UgfSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIENvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG5cdCAgICAgIF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHQgICAgfTtcblxuXHQgICAgQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpKTtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBDb21wb25lbnRXcmFwcGVyO1xuXHQgIH0oX3JlYWN0LkNvbXBvbmVudCk7XG5cdH07XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZm9jdXNhYmxlQ29tcG9uZW50V3JhcHBlcjtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgU2ltcGxlQ2VsbEZvcm1hdHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXyg1MSksXG5cdCAgU2VsZWN0QWxsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKVxuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX0dyaWRQcm9wSGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcblxuXHR2YXIgX0dyaWRQcm9wSGVscGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HcmlkUHJvcEhlbHBlcnMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICB0ZXN0OiB7IEdyaWRQcm9wSGVscGVyczogX0dyaWRQcm9wSGVscGVyczJbJ2RlZmF1bHQnXSB9XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfcm93cyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuXHQgIF9yb3dzLnB1c2goe1xuXHQgICAgaWQ6IGksXG5cdCAgICB0aXRsZTogJ1RpdGxlICcgKyBpLFxuXHQgICAgY291bnQ6IGkgKiAxMDAwXG5cdCAgfSk7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgY29sdW1uczogW3tcblx0ICAgIGtleTogJ2lkJyxcblx0ICAgIG5hbWU6ICdJRCcsXG5cdCAgICB3aWR0aDogMTAwXG5cdCAgfSwge1xuXHQgICAga2V5OiAndGl0bGUnLFxuXHQgICAgbmFtZTogJ1RpdGxlJyxcblx0ICAgIHdpZHRoOiAxMDBcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb3VudCcsXG5cdCAgICBuYW1lOiAnQ291bnQnLFxuXHQgICAgd2lkdGg6IDEwMFxuXHQgIH1dLFxuXHQgIHJvd0dldHRlcjogZnVuY3Rpb24gcm93R2V0dGVyKGkpIHtcblx0ICAgIHJldHVybiBfcm93c1tpXTtcblx0ICB9LFxuXHQgIHJvd3NDb3VudDogZnVuY3Rpb24gcm93c0NvdW50KCkge1xuXHQgICAgcmV0dXJuIF9yb3dzLmxlbmd0aDtcblx0ICB9LFxuXHQgIGNlbGxNZXRhRGF0YToge1xuXHQgICAgc2VsZWN0ZWQ6IHsgaWR4OiAyLCByb3dJZHg6IDMgfSxcblx0ICAgIGRyYWdnZWQ6IG51bGwsXG5cdCAgICBjb3BpZWQ6IG51bGxcblx0ICB9XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfUm93Q29tcGFyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuXHR2YXIgX1Jvd0NvbXBhcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jvd0NvbXBhcmVyKTtcblxuXHR2YXIgX1Jvd3NDb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxuXHR2YXIgX1Jvd3NDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm93c0NvbnRhaW5lcik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5cdHZhciBHcmlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gR3JpZDtcblx0bW9kdWxlLmV4cG9ydHMuUm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cdG1vZHVsZS5leHBvcnRzLkNlbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0bW9kdWxlLmV4cG9ydHMuSGVhZGVyQ2VsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXHRtb2R1bGUuZXhwb3J0cy5Sb3dDb21wYXJlciA9IF9Sb3dDb21wYXJlcjJbJ2RlZmF1bHQnXTtcblx0bW9kdWxlLmV4cG9ydHMuRW1wdHlDaGlsZFJvdyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblx0bW9kdWxlLmV4cG9ydHMuUm93c0NvbnRhaW5lciA9IF9Sb3dzQ29udGFpbmVyMlsnZGVmYXVsdCddO1xuXHRtb2R1bGUuZXhwb3J0cy5lZGl0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xuXHRtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjcpO1xuXHRtb2R1bGUuZXhwb3J0cy51dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXHRtb2R1bGUuZXhwb3J0cy5zaGFwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cdG1vZHVsZS5leHBvcnRzLl9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0bW9kdWxlLmV4cG9ydHMuX2hlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOCk7XG5cbi8qKiovIH0pLFxuLyogMTMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGlzRW1wdHlBcnJheSA9IGZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcblx0ICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDA7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5QXJyYXk7XG5cbi8qKiovIH0pLFxuLyogMTMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcblx0ICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDAgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG5cbi8qKiovIH0pLFxuLyogMTMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfaW1tdXRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cblx0dmFyIGlzSW1tdXRhYmxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGlzSW1tdXRhYmxlQ29sbGVjdGlvbihvYmpUb1ZlcmlmeSkge1xuXHQgIHJldHVybiBfaW1tdXRhYmxlLkl0ZXJhYmxlLmlzSXRlcmFibGUob2JqVG9WZXJpZnkpO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaXNJbW11dGFibGVDb2xsZWN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDEzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2ltbXV0YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX2ltbXV0YWJsZS5NYXAuaXNNYXA7XG5cbi8qKiovIH0pLFxuLyogMTM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGdldE1peGVkVHlwZVZhbHVlUmV0cmlldmVyID0gZnVuY3Rpb24gZ2V0TWl4ZWRUeXBlVmFsdWVSZXRyaWV2ZXIoaXNJbW11dGFibGUpIHtcblx0ICB2YXIgcmV0T2JqID0ge307XG5cdCAgdmFyIHJldHJpZXZlciA9IGZ1bmN0aW9uIHJldHJpZXZlcihpdGVtLCBrZXkpIHtcblx0ICAgIHJldHVybiBpdGVtW2tleV07XG5cdCAgfTtcblx0ICB2YXIgaW1tdXRhYmxlUmV0cmlldmVyID0gZnVuY3Rpb24gaW1tdXRhYmxlUmV0cmlldmVyKGltbXV0YWJsZSwga2V5KSB7XG5cdCAgICByZXR1cm4gaW1tdXRhYmxlLmdldChrZXkpO1xuXHQgIH07XG5cblx0ICByZXRPYmouZ2V0VmFsdWUgPSBpc0ltbXV0YWJsZSA/IGltbXV0YWJsZVJldHJpZXZlciA6IHJldHJpZXZlcjtcblxuXHQgIHJldHVybiByZXRPYmo7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBnZXRNaXhlZFR5cGVWYWx1ZVJldHJpZXZlcjtcblxuLyoqKi8gfSksXG4vKiAxMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZnVuY3Rpb24gY3JlYXRlU2Nyb2xsU2hpbShzaXplKSB7XG5cdCAgdmFyIHNoaW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICBpZiAoc2hpbS5jbGFzc0xpc3QpIHtcblx0ICAgIHNoaW0uY2xhc3NMaXN0LmFkZCgncmVhY3QtZ3JpZC1TY3JvbGxTaGltJyk7IC8vIGZsb3cgLSBub3QgY29tcGF0aWJsZSB3aXRoIEhUTUxFbGVtZW50XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNoaW0uY2xhc3NOYW1lICs9ICcgcmVhY3QtZ3JpZC1TY3JvbGxTaGltJztcblx0ICB9XG5cdCAgc2hpbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdCAgc2hpbS5zdHlsZS50b3AgPSAwO1xuXHQgIHNoaW0uc3R5bGUubGVmdCA9IDA7XG5cdCAgc2hpbS5zdHlsZS53aWR0aCA9IHNpemUud2lkdGggKyAncHgnO1xuXHQgIHNoaW0uc3R5bGUuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyAncHgnO1xuXG5cdCAgcmV0dXJuIHNoaW07XG5cdH1cblxuXHRleHBvcnRzLmNyZWF0ZVNjcm9sbFNoaW0gPSBjcmVhdGVTY3JvbGxTaGltO1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzLmdldFJlbmRlcmVkQ29sdW1uQ291bnQgPSBleHBvcnRzLmdldE5leHRTY3JvbGxTdGF0ZSA9IGV4cG9ydHMuZ2V0R3JpZFN0YXRlID0gdW5kZWZpbmVkO1xuXG5cdHZhciBfQ29sdW1uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cdHZhciBfQ29sdW1uVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sdW1uVXRpbHMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuXHR2YXIgbWluID0gTWF0aC5taW47XG5cdHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cblx0ZnVuY3Rpb24gZ2V0R3JpZFN0YXRlKHByb3BzKSB7XG5cdCAgdmFyIHRvdGFsTnVtYmVyQ29sdW1ucyA9IF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRTaXplKHByb3BzLmNvbHVtbk1ldHJpY3MuY29sdW1ucyk7XG5cdCAgdmFyIGNhbnZhc0hlaWdodCA9IHByb3BzLm1pbkhlaWdodCAtIHByb3BzLnJvd09mZnNldEhlaWdodDtcblx0ICB2YXIgcmVuZGVyZWRSb3dzQ291bnQgPSBjZWlsKChwcm9wcy5taW5IZWlnaHQgLSBwcm9wcy5yb3dIZWlnaHQpIC8gcHJvcHMucm93SGVpZ2h0KTtcblx0ICB2YXIgdG90YWxSb3dDb3VudCA9IG1pbihyZW5kZXJlZFJvd3NDb3VudCAqIDQsIHByb3BzLnJvd3NDb3VudCk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGRpc3BsYXlTdGFydDogMCxcblx0ICAgIGRpc3BsYXlFbmQ6IHRvdGFsUm93Q291bnQsXG5cdCAgICB2aXNpYmxlU3RhcnQ6IDAsXG5cdCAgICB2aXNpYmxlRW5kOiB0b3RhbFJvd0NvdW50LFxuXHQgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHQsXG5cdCAgICBzY3JvbGxUb3A6IDAsXG5cdCAgICBzY3JvbGxMZWZ0OiAwLFxuXHQgICAgY29sVmlzaWJsZVN0YXJ0OiAwLFxuXHQgICAgY29sVmlzaWJsZUVuZDogdG90YWxOdW1iZXJDb2x1bW5zLFxuXHQgICAgY29sRGlzcGxheVN0YXJ0OiAwLFxuXHQgICAgY29sRGlzcGxheUVuZDogdG90YWxOdW1iZXJDb2x1bW5zXG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJlbmRlcmVkQ29sdW1uQ291bnQocHJvcHMsIGdldERPTU5vZGVPZmZzZXRXaWR0aCwgZGlzcGxheVN0YXJ0LCB3aWR0aCkge1xuXHQgIHZhciByZW1haW5pbmdXaWR0aCA9IHdpZHRoICYmIHdpZHRoID4gMCA/IHdpZHRoIDogcHJvcHMuY29sdW1uTWV0cmljcy50b3RhbFdpZHRoO1xuXHQgIGlmIChyZW1haW5pbmdXaWR0aCA9PT0gMCkge1xuXHQgICAgcmVtYWluaW5nV2lkdGggPSBnZXRET01Ob2RlT2Zmc2V0V2lkdGgoKTtcblx0ICB9XG5cdCAgdmFyIGNvbHVtbkluZGV4ID0gZGlzcGxheVN0YXJ0O1xuXHQgIHZhciBjb2x1bW5Db3VudCA9IDA7XG5cdCAgd2hpbGUgKHJlbWFpbmluZ1dpZHRoID4gMCkge1xuXHQgICAgdmFyIGNvbHVtbiA9IF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRDb2x1bW4ocHJvcHMuY29sdW1uTWV0cmljcy5jb2x1bW5zLCBjb2x1bW5JbmRleCk7XG5cblx0ICAgIGlmICghY29sdW1uKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBjb2x1bW5Db3VudCsrO1xuXHQgICAgY29sdW1uSW5kZXgrKztcblx0ICAgIHJlbWFpbmluZ1dpZHRoIC09IGNvbHVtbi53aWR0aDtcblx0ICB9XG5cdCAgcmV0dXJuIGNvbHVtbkNvdW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VmlzaWJsZUNvbFN0YXJ0KHByb3BzLCBzY3JvbGxMZWZ0KSB7XG5cdCAgdmFyIHJlbWFpbmluZ1Njcm9sbCA9IHNjcm9sbExlZnQ7XG5cdCAgdmFyIGNvbHVtbkluZGV4ID0gLTE7XG5cdCAgd2hpbGUgKHJlbWFpbmluZ1Njcm9sbCA+PSAwKSB7XG5cdCAgICBjb2x1bW5JbmRleCsrO1xuXHQgICAgcmVtYWluaW5nU2Nyb2xsIC09IF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRDb2x1bW4ocHJvcHMuY29sdW1uTWV0cmljcy5jb2x1bW5zLCBjb2x1bW5JbmRleCkud2lkdGg7XG5cdCAgfVxuXHQgIHJldHVybiBjb2x1bW5JbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE5leHRTY3JvbGxTdGF0ZShwcm9wcywgZ2V0RE9NTm9kZU9mZnNldFdpZHRoLCBzY3JvbGxUb3AsIHNjcm9sbExlZnQsIGhlaWdodCwgcm93SGVpZ2h0LCBsZW5ndGgsIHdpZHRoKSB7XG5cdCAgdmFyIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcblx0ICB2YXIgcmVuZGVyZWRSb3dzQ291bnQgPSBjZWlsKGhlaWdodCAvIHJvd0hlaWdodCk7XG5cdCAgdmFyIHZpc2libGVTdGFydCA9IG1heCgwLCBmbG9vcihzY3JvbGxUb3AgLyByb3dIZWlnaHQpKTtcblx0ICB2YXIgdmlzaWJsZUVuZCA9IG1pbih2aXNpYmxlU3RhcnQgKyByZW5kZXJlZFJvd3NDb3VudCwgbGVuZ3RoKTtcblx0ICB2YXIgZGlzcGxheVN0YXJ0ID0gbWF4KDAsIHZpc2libGVTdGFydCAtIHByb3BzLm92ZXJTY2FuLnJvd3NTdGFydCk7XG5cdCAgdmFyIGRpc3BsYXlFbmQgPSBtaW4odmlzaWJsZUVuZCArIHByb3BzLm92ZXJTY2FuLnJvd3NFbmQsIGxlbmd0aCk7XG5cdCAgdmFyIHRvdGFsTnVtYmVyQ29sdW1ucyA9IF9Db2x1bW5VdGlsczJbJ2RlZmF1bHQnXS5nZXRTaXplKHByb3BzLmNvbHVtbk1ldHJpY3MuY29sdW1ucyk7XG5cdCAgdmFyIGNvbFZpc2libGVTdGFydCA9IHRvdGFsTnVtYmVyQ29sdW1ucyA+IDAgPyBtYXgoMCwgZ2V0VmlzaWJsZUNvbFN0YXJ0KHByb3BzLCBzY3JvbGxMZWZ0KSkgOiAwO1xuXHQgIHZhciByZW5kZXJlZENvbHVtbkNvdW50ID0gZ2V0UmVuZGVyZWRDb2x1bW5Db3VudChwcm9wcywgZ2V0RE9NTm9kZU9mZnNldFdpZHRoLCBjb2xWaXNpYmxlU3RhcnQsIHdpZHRoKTtcblx0ICB2YXIgY29sVmlzaWJsZUVuZCA9IHJlbmRlcmVkQ29sdW1uQ291bnQgIT09IDAgPyBjb2xWaXNpYmxlU3RhcnQgKyByZW5kZXJlZENvbHVtbkNvdW50IDogdG90YWxOdW1iZXJDb2x1bW5zO1xuXHQgIHZhciBjb2xEaXNwbGF5U3RhcnQgPSBtYXgoMCwgY29sVmlzaWJsZVN0YXJ0IC0gcHJvcHMub3ZlclNjYW4uY29sc1N0YXJ0KTtcblx0ICB2YXIgY29sRGlzcGxheUVuZCA9IG1pbihjb2xWaXNpYmxlRW5kICsgcHJvcHMub3ZlclNjYW4uY29sc0VuZCwgdG90YWxOdW1iZXJDb2x1bW5zKTtcblxuXHQgIHZhciBuZXh0U2Nyb2xsU3RhdGUgPSB7XG5cdCAgICB2aXNpYmxlU3RhcnQ6IHZpc2libGVTdGFydCxcblx0ICAgIHZpc2libGVFbmQ6IHZpc2libGVFbmQsXG5cdCAgICBkaXNwbGF5U3RhcnQ6IGRpc3BsYXlTdGFydCxcblx0ICAgIGRpc3BsYXlFbmQ6IGRpc3BsYXlFbmQsXG5cdCAgICBoZWlnaHQ6IGhlaWdodCxcblx0ICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wLFxuXHQgICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcblx0ICAgIGNvbFZpc2libGVTdGFydDogY29sVmlzaWJsZVN0YXJ0LFxuXHQgICAgY29sVmlzaWJsZUVuZDogY29sVmlzaWJsZUVuZCxcblx0ICAgIGNvbERpc3BsYXlTdGFydDogY29sRGlzcGxheVN0YXJ0LFxuXHQgICAgY29sRGlzcGxheUVuZDogY29sRGlzcGxheUVuZCxcblx0ICAgIGlzU2Nyb2xsaW5nOiBpc1Njcm9sbGluZ1xuXHQgIH07XG5cblx0ICByZXR1cm4gbmV4dFNjcm9sbFN0YXRlO1xuXHR9XG5cblx0ZXhwb3J0cy5nZXRHcmlkU3RhdGUgPSBnZXRHcmlkU3RhdGU7XG5cdGV4cG9ydHMuZ2V0TmV4dFNjcm9sbFN0YXRlID0gZ2V0TmV4dFNjcm9sbFN0YXRlO1xuXHRleHBvcnRzLmdldFJlbmRlcmVkQ29sdW1uQ291bnQgPSBnZXRSZW5kZXJlZENvbHVtbkNvdW50O1xuXG4vKioqLyB9KSxcbi8qIDEzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNykoKTtcblx0Ly8gaW1wb3J0c1xuXG5cblx0Ly8gbW9kdWxlXG5cdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yZWFjdC1ncmlkLUNlbGx7YmFja2dyb3VuZC1jb2xvcjojZmZmO3BhZGRpbmctbGVmdDo4cHg7cGFkZGluZy1yaWdodDo4cHg7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZWVlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkZGR9LnJlYWN0LWdyaWQtQ2VsbDpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCAjNjZhZmU5O291dGxpbmUtb2Zmc2V0Oi0ycHh9LnJlYWN0LWdyaWQtQ2VsbC0tbG9ja2VkOmZvY3Vze3otaW5kZXg6MTAwfS5yZWFjdC1ncmlkLUNlbGw6Zm9jdXMgLmRyYWctaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTotNXB4O3JpZ2h0Oi00cHg7YmFja2dyb3VuZDojNjZhZmU5O3dpZHRoOjhweDtoZWlnaHQ6OHB4O2JvcmRlcjoxcHggc29saWQgI2ZmZjtib3JkZXItcmlnaHQ6MDtib3JkZXItYm90dG9tOjA7ei1pbmRleDo4O2N1cnNvcjpjcm9zc2hhaXI7Y3Vyc29yOi13ZWJraXQtZ3JhYn0ucmVhY3QtZ3JpZC1DZWxsOm5vdCguZWRpdGluZykgLnJlYWN0LWdyaWQtQ2VsbF9fdmFsdWV7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7b3ZlcmZsb3c6aGlkZGVufS5yZWFjdC1ncmlkLUNlbGw6bm90KC5lZGl0aW5nKTpub3QoLnJkZy1jaGlsZC1jZWxsKSAucmVhY3QtZ3JpZC1DZWxsX192YWx1ZXtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS5yZGctY2hpbGQtY2VsbCAucmVhY3QtZ3JpZC1DZWxsX192YWx1ZXtsaW5lLWhlaWdodDozNXB4fS5yZWFjdC1ncmlkLUNlbGwucmVhZG9ubHl7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5yZWFjdC1ncmlkLUNlbGwuY29waWVke2JhY2tncm91bmQ6cmdiYSgwLDAsMjU1LC4yKSFpbXBvcnRhbnR9LnJlYWN0LWdyaWQtQ2VsbC0tbG9ja2VkOmxhc3Qtb2YtdHlwZXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkICNkZGQ7Ym94LXNoYWRvdzpub25lfS5yZWFjdC1ncmlkLUNlbGw6aG92ZXI6Zm9jdXMgLmRyYWctaGFuZGxlIC5nbHlwaGljb24tYXJyb3ctZG93bntkaXNwbGF5OlxcXCJibG9ja1xcXCJ9LnJlYWN0LWdyaWQtQ2VsbC5pcy1kcmFnZ2VkLW92ZXItZG93bntib3JkZXItcmlnaHQ6MXB4IGRhc2hlZCAjMDAwO2JvcmRlci1sZWZ0OjFweCBkYXNoZWQgIzAwMDtib3JkZXItYm90dG9tOjFweCBkYXNoZWQgIzAwMH0ucmVhY3QtZ3JpZC1DZWxsLmlzLWRyYWdnZWQtb3Zlci11cHtib3JkZXItcmlnaHQ6MXB4IGRhc2hlZCAjMDAwO2JvcmRlci1sZWZ0OjFweCBkYXNoZWQgIzAwMDtib3JkZXItdG9wOjFweCBkYXNoZWQgIzAwMH0ucmVhY3QtZ3JpZC1DZWxsLmlzLWRyYWdnZWQtb3Zlci11cCAuZHJhZy1oYW5kbGV7dG9wOi01cHh9LnJlYWN0LWdyaWQtQ2VsbDpob3ZlcntiYWNrZ3JvdW5kOiNlZWV9LnJlYWN0LWdyaWQtY2VsbCAuZm9ybS1jb250cm9sLWZlZWRiYWNre2NvbG9yOiNhOTQ0NDI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MTBweDt6LWluZGV4OjEwMDAwMDA7ZGlzcGxheTpibG9jazt3aWR0aDozNHB4O2hlaWdodDozNHB4fS5yZWFjdC1ncmlkLUNlbGwud2FzLWRyYWdnZWQtb3Zlcntib3JkZXItcmlnaHQ6MXB4IGRhc2hlZCAjMDAwO2JvcmRlci1sZWZ0OjFweCBkYXNoZWQgIzAwMH0ucmVhY3QtZ3JpZC1DZWxsOmhvdmVyOmZvY3VzIC5kcmFnLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206LThweDtyaWdodDotN3B4O2JhY2tncm91bmQ6I2ZmZjt3aWR0aDoxNnB4O2hlaWdodDoxNnB4O2JvcmRlcjoxcHggc29saWQgIzY2YWZlOTt6LWluZGV4Ojg7Y3Vyc29yOmNyb3NzaGFpcjtjdXJzb3I6LXdlYmtpdC1ncmFifS5yZWFjdC1ncmlkLVJvdy5yb3ctc2VsZWN0ZWQgLnJlYWN0LWdyaWQtQ2VsbHtiYWNrZ3JvdW5kLWNvbG9yOiNkYmVjZmF9LnJlYWN0LWdyaWQtQ2VsbC5lZGl0aW5ne3BhZGRpbmc6MDtvdmVyZmxvdzp2aXNpYmxlIWltcG9ydGFudH0ucmVhY3QtZ3JpZC1DZWxsLS1sb2NrZWQuZWRpdGluZ3t6LWluZGV4OjEwMH0ucmVhY3QtZ3JpZC1DZWxsLmVkaXRpbmcgLmhhcy1lcnJvciBpbnB1dHtib3JkZXI6MnB4IHNvbGlkIHJlZCFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czoycHghaW1wb3J0YW50fS5yZWFjdC1ncmlkLUNlbGxfX3ZhbHVlIHVse21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7ZGlzcGxheTppbmxpbmUtYmxvY2t9LnJlYWN0LWdyaWQtQ2VsbF9fdmFsdWUgLmJ0bi1zbXtwYWRkaW5nOjB9LmNlbGwtdG9vbHRpcHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9ja30uY2VsbC10b29sdGlwOmhvdmVye3otaW5kZXg6MTAxfS5jZWxsLXRvb2x0aXAgLmNlbGwtdG9vbHRpcC10ZXh0e3Zpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjE1MHB4O2JhY2tncm91bmQtY29sb3I6IzAwMDtjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6NXB4IDA7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO2JvdHRvbTotMTUwJTtsZWZ0OjUwJTttYXJnaW4tbGVmdDotNjBweDtvcGFjaXR5OjFzfS5jZWxsLXRvb2x0aXA6aG92ZXIgLmNlbGwtdG9vbHRpcC10ZXh0e3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5Oi44fS5jZWxsLXRvb2x0aXAgLmNlbGwtdG9vbHRpcC10ZXh0OmFmdGVye2NvbnRlbnQ6XFxcIiBcXFwiO3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbToxMDAlO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi01cHg7Ym9yZGVyLXdpZHRoOjVweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMwMDB9LnJlYWN0LWdyaWQtQ2FudmFzLm9wYXF1ZSAucmVhY3QtZ3JpZC1DZWxsLmNlbGwtdG9vbHRpcDpob3ZlciAuY2VsbC10b29sdGlwLXRleHR7dmlzaWJpbGl0eTpoaWRkZW59LnJkZy1jZWxsLWV4cGFuZHt0b3A6MDtyaWdodDoyMHB4O3Bvc2l0aW9uOmFic29sdXRlO2N1cnNvcjpwb2ludGVyfS5yZGctY2hpbGQtcm93LWFjdGlvbi1jcm9zcy1sYXN0OmJlZm9yZSwucmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3M6YmVmb3JlLHJkZy1jaGlsZC1yb3ctYWN0aW9uLWNyb3NzLWxhc3Q6YWZ0ZXIscmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3M6YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOmdyZXk7aGVpZ2h0OjUwJX0ucmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3M6YmVmb3Jle2xlZnQ6MjFweDt3aWR0aDoxcHg7aGVpZ2h0OjM1cHh9LnJkZy1jaGlsZC1yb3ctYWN0aW9uLWNyb3NzLWxhc3Q6YmVmb3Jle2xlZnQ6MjFweDt3aWR0aDoxcHh9LnJkZy1jaGlsZC1yb3ctYWN0aW9uLWNyb3NzLWxhc3Q6YWZ0ZXIsLnJkZy1jaGlsZC1yb3ctYWN0aW9uLWNyb3NzOmFmdGVye3RvcDo1MCU7bGVmdDoyMHB4O2hlaWdodDoxcHg7d2lkdGg6MTVweDtjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6Z3JleX0ucmRnLWNoaWxkLXJvdy1hY3Rpb24tY3Jvc3M6aG92ZXJ7YmFja2dyb3VuZDpyZWR9LnJkZy1jaGlsZC1yb3ctYnRue3Bvc2l0aW9uOmFic29sdXRlO2N1cnNvcjpwb2ludGVyO2JvcmRlcjoxcHggc29saWQgZ3JleTtib3JkZXItcmFkaXVzOjE0cHg7ei1pbmRleDozO2JhY2tncm91bmQ6I2ZmZn0ucmRnLWNoaWxkLXJvdy1idG4gZGl2e2ZvbnQtc2l6ZToxMnB4O3RleHQtYWxpZ246Y2VudGVyO2xpbmUtaGVpZ2h0OjE5cHg7Y29sb3I6Z3JleTtoZWlnaHQ6MjBweDt3aWR0aDoyMHB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDo2MCU7bGVmdDo1MyU7bWFyZ2luLXRvcDotMTBweDttYXJnaW4tbGVmdDotMTBweH0ucmRnLWVtcHR5LWNoaWxkLXJvdzpob3ZlciAuZ2x5cGhpY29uLXBsdXMtc2lnbiwucmRnLWVtcHR5LWNoaWxkLXJvdzpob3ZlciBhe2NvbG9yOmdyZWVufS5yZGctY2hpbGQtcm93LWJ0biAuZ2x5cGhpY29uLXJlbW92ZS1zaWduOmhvdmVye2NvbG9yOnJlZH0ubGFzdC1jb2x1bW4gLmNlbGwtdG9vbHRpcC10ZXh0e3JpZ2h0OjEwMCU7bGVmdDowIWltcG9ydGFudH0ucmRnLWNlbGwtYWN0aW9ue2Zsb2F0OnJpZ2h0O2hlaWdodDoxMDAlfS5yZGctY2VsbC1hY3Rpb24tbGFzdHttYXJnaW4tcmlnaHQ6LThweH0ucmRnLWNlbGwtYWN0aW9uLWJ1dHRvbnt3aWR0aDozNXB4O2hlaWdodDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6dGFibGV9LnJkZy1jZWxsLWFjdGlvbi1idXR0b24+c3BhbntkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlfS5yZGctY2VsbC1hY3Rpb24tYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2ZmZn0ucmRnLWNlbGwtYWN0aW9uLWJ1dHRvbi10b2dnbGVke2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXItcmlnaHQ6MXB4IHNvbGlkICNjY2M7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNjY2N9LnJkZy1jZWxsLWFjdGlvbi1idXR0b24tdG9nZ2xlZDphZnRlcntjb250ZW50OlxcXCJcXFwiO2hlaWdodDoxcHg7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOi0xcHg7bGVmdDowO3JpZ2h0OjA7YmFja2dyb3VuZDppbmhlcml0O3otaW5kZXg6MTAwMDF9LnJkZy1jZWxsLWFjdGlvbi1tZW51e3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO3JpZ2h0OjA7ei1pbmRleDoxMDAwO2Zsb2F0OmxlZnQ7bWluLXdpZHRoOjE2MHB4O3BhZGRpbmc6NXB4IDA7Zm9udC1zaXplOjE0cHg7dGV4dC1hbGlnbjpsZWZ0O2xpc3Qtc3R5bGU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7LXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7YmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JvcmRlcjoxcHggc29saWQgI2NjY30ucmRnLWNlbGwtYWN0aW9uLW1lbnU+c3BhbntkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Y2xlYXI6Ym90aDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO3doaXRlLXNwYWNlOm5vd3JhcH0ucmRnLWNlbGwtYWN0aW9uLW1lbnU+c3Bhbjpob3Zlcntjb2xvcjojMjYyNjI2O3RleHQtZGVjb3JhdGlvbjpub25lO2JhY2tncm91bmQtY29sb3I6I2Y1ZjVmNX1cIiwgXCJcIl0pO1xuXG5cdC8vIGV4cG9ydHNcblxuXG4vKioqLyB9KSxcbi8qIDEzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNykoKTtcblx0Ly8gaW1wb3J0c1xuXG5cblx0Ly8gbW9kdWxlXG5cdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yYWRpby1jdXN0b20sLnJlYWN0LWdyaWQtY2hlY2tib3h7b3BhY2l0eTowO3Bvc2l0aW9uOmFic29sdXRlfS5yYWRpby1jdXN0b20sLnJhZGlvLWN1c3RvbS1sYWJlbCwucmVhY3QtZ3JpZC1jaGVja2JveCwucmVhY3QtZ3JpZC1jaGVja2JveC1sYWJlbHtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Y3Vyc29yOnBvaW50ZXJ9LnJhZGlvLWN1c3RvbS1sYWJlbCwucmVhY3QtZ3JpZC1jaGVja2JveC1sYWJlbHtwb3NpdGlvbjpyZWxhdGl2ZX0ucmFkaW8tY3VzdG9tKy5yYWRpby1jdXN0b20tbGFiZWw6YmVmb3JlLC5yZWFjdC1ncmlkLWNoZWNrYm94Ky5yZWFjdC1ncmlkLWNoZWNrYm94LWxhYmVsOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO2JhY2tncm91bmQ6I2ZmZjtib3JkZXI6MnB4IHNvbGlkICNkZGQ7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7dGV4dC1hbGlnbjpjZW50ZXJ9LnJlYWN0LWdyaWQtY2hlY2tib3g6Y2hlY2tlZCsucmVhY3QtZ3JpZC1jaGVja2JveC1sYWJlbDpiZWZvcmV7YmFja2dyb3VuZDojMDA1Mjk1O2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgNHB4ICNmZmZ9LnJhZGlvLWN1c3RvbTpmb2N1cysucmFkaW8tY3VzdG9tLWxhYmVsLC5yZWFjdC1ncmlkLWNoZWNrYm94OmZvY3VzKy5yZWFjdC1ncmlkLWNoZWNrYm94LWxhYmVse291dGxpbmU6MXB4IHNvbGlkICNkZGR9LnJlYWN0LWdyaWQtSGVhZGVyQ2VsbCBpbnB1dFt0eXBlPWNoZWNrYm94XXt6LWluZGV4Ojk5OTk5fS5yZWFjdC1ncmlkLUhlYWRlckNlbGw+LnJlYWN0LWdyaWQtY2hlY2tib3gtY29udGFpbmVye3BhZGRpbmc6MCAxMHB4O2hlaWdodDoxMDAlfS5yZWFjdC1ncmlkLUhlYWRlckNlbGw+LnJlYWN0LWdyaWQtY2hlY2tib3gtY29udGFpbmVyPi5yZWFjdC1ncmlkLWNoZWNrYm94LWxhYmVse21hcmdpbjowO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9LnJhZGlvLWN1c3RvbSsucmFkaW8tY3VzdG9tLWxhYmVsOmJlZm9yZXtib3JkZXItcmFkaXVzOjUwJX0ucmFkaW8tY3VzdG9tOmNoZWNrZWQrLnJhZGlvLWN1c3RvbS1sYWJlbDpiZWZvcmV7YmFja2dyb3VuZDojY2NjO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgNHB4ICNmZmZ9LmNoZWNrYm94LWFsaWdue3RleHQtYWxpZ246Y2VudGVyfVwiLCBcIlwiXSk7XG5cblx0Ly8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSgpO1xuXHQvLyBpbXBvcnRzXG5cblxuXHQvLyBtb2R1bGVcblx0ZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnJlYWN0LWdyaWQtQ29udGFpbmVye2NsZWFyOmJvdGg7bWFyZ2luLXRvcDowO3BhZGRpbmc6MH0ucmVhY3QtZ3JpZC1NYWlue2JhY2tncm91bmQtY29sb3I6I2ZmZjtjb2xvcjppbmhlcml0O3BhZGRpbmc6MDtvdXRsaW5lOjFweCBzb2xpZCAjZTdlYWVjO2NsZWFyOmJvdGh9LnJlYWN0LWdyaWQtR3JpZHtib3JkZXI6MXB4IHNvbGlkICNkZGR9LnJlYWN0LWdyaWQtQ2FudmFzLC5yZWFjdC1ncmlkLUdyaWR7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5yZWFjdC1ncmlkLUNlbGwgaW5wdXQuZWRpdG9yLW1haW4sc2VsZWN0LmVkaXRvci1tYWlue2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtoZWlnaHQ6MzRweDtwYWRkaW5nOjZweCAxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7Y29sb3I6IzU1NTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7YmFja2dyb3VuZC1pbWFnZTpub25lO2JvcmRlcjoxcHggc29saWQgI2NjYztib3JkZXItcmFkaXVzOjRweDstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA3NSk7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMDc1KX1pbnB1dC5lZGl0b3ItbWFpbjpmb2N1cyxzZWxlY3QuZWRpdG9yLW1haW46Zm9jdXN7Ym9yZGVyLWNvbG9yOiM2NmFmZTk7Ym9yZGVyOjJweCBzb2xpZCAjNjZhZmU5O2JhY2tncm91bmQ6I2VlZTtib3JkZXItcmFkaXVzOjRweH0ucmVhY3QtZ3JpZC1DZWxsIGlucHV0LmVkaXRvci1tYWluOjotbW96LXBsYWNlaG9sZGVyLHNlbGVjdC5lZGl0b3ItbWFpbjo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojOTk5O29wYWNpdHk6MX0ucmVhY3QtZ3JpZC1DZWxsIGlucHV0LmVkaXRvci1tYWluOi1tcy1pbnB1dC1wbGFjZWhvbGRlcixzZWxlY3QuZWRpdG9yLW1haW46LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM5OTl9LnJlYWN0LWdyaWQtQ2VsbCBpbnB1dC5lZGl0b3ItbWFpbjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcixzZWxlY3QuZWRpdG9yLW1haW46Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6Izk5OX0ucmVhY3QtZ3JpZC1DZWxsIGlucHV0LmVkaXRvci1tYWluW2Rpc2FibGVkXSwucmVhY3QtZ3JpZC1DZWxsIGlucHV0LmVkaXRvci1tYWluW3JlYWRvbmx5XSxmaWVsZHNldFtkaXNhYmxlZF0gLnJlYWN0LWdyaWQtQ2VsbCBpbnB1dC5lZGl0b3ItbWFpbixmaWVsZHNldFtkaXNhYmxlZF0gc2VsZWN0LmVkaXRvci1tYWluLHNlbGVjdC5lZGl0b3ItbWFpbltkaXNhYmxlZF0sc2VsZWN0LmVkaXRvci1tYWluW3JlYWRvbmx5XXtjdXJzb3I6bm90LWFsbG93ZWQ7YmFja2dyb3VuZC1jb2xvcjojZWVlO29wYWNpdHk6MX10ZXh0YXJlYS5yZWFjdC1ncmlkLUNlbGwgaW5wdXQuZWRpdG9yLW1haW4sdGV4dGFyZWFzZWxlY3QuZWRpdG9yLW1haW57aGVpZ2h0OmF1dG99LnJlYWN0LWdyaWQtU2Nyb2xsU2hpbXt6LWluZGV4OjEwMDAyfVwiLCBcIlwiXSk7XG5cblx0Ly8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSgpO1xuXHQvLyBpbXBvcnRzXG5cblxuXHQvLyBtb2R1bGVcblx0ZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnJlYWN0LWdyaWQtSGVhZGVye2JveC1zaGFkb3c6MCAwIDRweCAwICNkZGQ7YmFja2dyb3VuZDojZjlmOWY5fS5yZWFjdC1ncmlkLUhlYWRlci0tcmVzaXppbmd7Y3Vyc29yOmV3LXJlc2l6ZX0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsLC5yZWFjdC1ncmlkLUhlYWRlclJvd3std2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnJlYWN0LWdyaWQtSGVhZGVyQ2VsbHtiYWNrZ3JvdW5kOiNmOWY5Zjk7cGFkZGluZzo4cHg7Zm9udC13ZWlnaHQ6NzAwO2JvcmRlci1yaWdodDoxcHggc29saWQgI2RkZDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZGRkfS5yZWFjdC1ncmlkLUhlYWRlckNlbGxfX3ZhbHVle3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS5yZWFjdC1ncmlkLUhlYWRlckNlbGxfX3Jlc2l6ZUhhbmRsZTpob3ZlcntjdXJzb3I6ZXctcmVzaXplO2JhY2tncm91bmQ6I2RkZH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsLS1sb2NrZWQ6bGFzdC1vZi10eXBle2JveC1zaGFkb3c6bm9uZX0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsLS1yZXNpemluZyAucmVhY3QtZ3JpZC1IZWFkZXJDZWxsX19yZXNpemVIYW5kbGV7YmFja2dyb3VuZDojZGRkfS5yZWFjdC1ncmlkLUhlYWRlckNlbGxfX2RyYWdnYWJsZXtjdXJzb3I6Y29sLXJlc2l6ZX0ucmRnLWNhbi1kcm9wPi5yZWFjdC1ncmlkLUhlYWRlckNlbGx7YmFja2dyb3VuZDojZWNlY2VjfS5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdHttYXgtaGVpZ2h0OjMwcHg7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdC1jb250cm9se21heC1oZWlnaHQ6MzBweDtib3JkZXI6MXB4IHNvbGlkICNjY2M7Y29sb3I6IzU1NTtib3JkZXItcmFkaXVzOjNweH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5pcy1mb2N1c2VkOm5vdCguaXMtb3Blbik+LlNlbGVjdC1jb250cm9se2JvcmRlci1jb2xvcjojNjZhZmU5O291dGxpbmU6MDstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA3NSksMCAwIDhweCByZ2JhKDEwMiwxNzUsMjMzLC42KTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4wNzUpLDAgMCA4cHggcmdiYSgxMDIsMTc1LDIzMywuNil9LnJlYWN0LWdyaWQtSGVhZGVyQ2VsbCAuU2VsZWN0LWNvbnRyb2wgLlNlbGVjdC1wbGFjZWhvbGRlcntsaW5lLWhlaWdodDoyMHB4O2NvbG9yOiM5OTk7cGFkZGluZzo0cHh9LnJlYWN0LWdyaWQtSGVhZGVyQ2VsbCAuU2VsZWN0LWNvbnRyb2wgLlNlbGVjdC1pbnB1dHttYXgtaGVpZ2h0OjI4cHg7cGFkZGluZzo0cHg7bWFyZ2luLWxlZnQ6MH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtY29udHJvbCAuU2VsZWN0LWlucHV0IGlucHV0e3BhZGRpbmc6MDtoZWlnaHQ6MTAwJX0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtY29udHJvbCAuU2VsZWN0LWFycm93LXpvbmUgLlNlbGVjdC1hcnJvd3tib3JkZXItY29sb3I6Z3JheSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItd2lkdGg6NHB4IDRweCAyLjVweH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtY29udHJvbCAuU2VsZWN0LXZhbHVle3BhZGRpbmc6NHB4O2xpbmUtaGVpZ2h0OjIwcHghaW1wb3J0YW50fS5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdC0tbXVsdGkgLlNlbGVjdC1jb250cm9sIC5TZWxlY3QtdmFsdWV7cGFkZGluZzowO2xpbmUtaGVpZ2h0OjE2cHghaW1wb3J0YW50O21heC1oZWlnaHQ6MjBweH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtLW11bHRpIC5TZWxlY3QtY29udHJvbCAuU2VsZWN0LXZhbHVlIC5TZWxlY3QtdmFsdWUtaWNvbiwucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtLW11bHRpIC5TZWxlY3QtY29udHJvbCAuU2VsZWN0LXZhbHVlIC5TZWxlY3QtdmFsdWUtbGFiZWx7bWF4LWhlaWdodDoyMHB4fS5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdC1jb250cm9sIC5TZWxlY3QtdmFsdWUgLlNlbGVjdC12YWx1ZS1sYWJlbHtjb2xvcjojNTU1IWltcG9ydGFudH0ucmVhY3QtZ3JpZC1IZWFkZXJDZWxsIC5TZWxlY3QtbWVudS1vdXRlciAuU2VsZWN0LW9wdGlvbntwYWRkaW5nOjRweDtsaW5lLWhlaWdodDoyMHB4fS5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdC1tZW51LW91dGVyIC5TZWxlY3QtbWVudSAuU2VsZWN0LW9wdGlvbi5pcy1mb2N1c2VkLC5yZWFjdC1ncmlkLUhlYWRlckNlbGwgLlNlbGVjdC1tZW51LW91dGVyIC5TZWxlY3QtbWVudSAuU2VsZWN0LW9wdGlvbi5pcy1zZWxlY3RlZHtjb2xvcjojNTU1fVwiLCBcIlwiXSk7XG5cblx0Ly8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSgpO1xuXHQvLyBpbXBvcnRzXG5cblxuXHQvLyBtb2R1bGVcblx0ZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnJlYWN0LWdyaWQtUm93LnJvdy1jb250ZXh0LW1lbnUgLnJlYWN0LWdyaWQtQ2VsbCwucmVhY3QtZ3JpZC1Sb3c6aG92ZXIgLnJlYWN0LWdyaWQtQ2VsbHtiYWNrZ3JvdW5kLWNvbG9yOiNmOWY5Zjl9LnJlYWN0LWdyaWQtUm93OmhvdmVyIC5yZGctcm93LWluZGV4e2Rpc3BsYXk6bm9uZX0ucmVhY3QtZ3JpZC1Sb3c6aG92ZXIgLnJkZy1hY3Rpb25zLWNoZWNrYm94e2Rpc3BsYXk6YmxvY2t9LnJlYWN0LWdyaWQtUm93OmhvdmVyIC5yZGctZHJhZy1yb3ctaGFuZGxle2N1cnNvcjptb3ZlO2N1cnNvcjpncmFiO2N1cnNvcjotbW96LWdyYWI7Y3Vyc29yOi13ZWJraXQtZ3JhYjt3aWR0aDoxMnB4O2hlaWdodDozMHB4O21hcmdpbi1sZWZ0OjA7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0NqeHpkbWNnZDJsa2RHZzlJamx3ZUNJZ2FHVnBaMmgwUFNJeU9YQjRJaUIyYVdWM1FtOTRQU0l3SURBZ09TQXlPU0lnZG1WeWMybHZiajBpTVM0eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWo0S0lDQWdJRHdoTFMwZ1IyVnVaWEpoZEc5eU9pQlRhMlYwWTJnZ016a2dLRE14TmpZM0tTQXRJR2gwZEhBNkx5OTNkM2N1WW05b1pXMXBZVzVqYjJScGJtY3VZMjl0TDNOclpYUmphQ0F0TFQ0S0lDQWdJRHgwYVhSc1pUNWtjbUZuSUdsamIyNDhMM1JwZEd4bFBnb2dJQ0FnUEdSbGMyTStRM0psWVhSbFpDQjNhWFJvSUZOclpYUmphQzQ4TDJSbGMyTStDaUFnSUNBOFpHVm1jejQ4TDJSbFpuTStDaUFnSUNBOFp5QnBaRDBpUVdOMGRXRnNhWE5oZEdsdmJpMTJNaUlnYzNSeWIydGxQU0p1YjI1bElpQnpkSEp2YTJVdGQybGtkR2c5SWpFaUlHWnBiR3c5SW01dmJtVWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0krQ2lBZ0lDQWdJQ0FnUEdjZ2FXUTlJa1JsYzJ0MGIzQWlJSFJ5WVc1elptOXliVDBpZEhKaGJuTnNZWFJsS0MweE5TNHdNREF3TURBc0lDMHlOakl1TURBd01EQXdLU0lnWm1sc2JEMGlJMFE0UkRoRU9DSStDaUFnSUNBZ0lDQWdJQ0FnSUR4bklHbGtQU0pKYm5SbGNtRmpkR2x2Ym5NaUlIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREUxTGpBd01EQXdNQ3dnTWpVNExqQXdNREF3TUNraVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWxKdmR5MURiMjUwY205c2N5SWdkSEpoYm5ObWIzSnRQU0owY21GdWMyeGhkR1VvTUM0d01EQXdNREFzSURJdU1EQXdNREF3S1NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQR2NnYVdROUltUnlZV2N0YVdOdmJpSWdkSEpoYm5ObWIzSnRQU0owY21GdWMyeGhkR1VvTUM0d01EQXdNREFzSURJdU1EQXdNREF3S1NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4amFYSmpiR1VnYVdROUlrOTJZV3d0TXpBaUlHTjRQU0l5SWlCamVUMGlNaUlnY2owaU1pSStQQzlqYVhKamJHVStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE16QWlJR040UFNJM0lpQmplVDBpTWlJZ2NqMGlNaUkrUEM5amFYSmpiR1UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhqYVhKamJHVWdhV1E5SWs5MllXd3RNekFpSUdONFBTSXlJaUJqZVQwaU55SWdjajBpTWlJK1BDOWphWEpqYkdVK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4amFYSmpiR1VnYVdROUlrOTJZV3d0TXpBaUlHTjRQU0kzSWlCamVUMGlOeUlnY2owaU1pSStQQzlqYVhKamJHVStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE16QWlJR040UFNJeUlpQmplVDBpTVRJaUlISTlJaklpUGp3dlkybHlZMnhsUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4WTJseVkyeGxJR2xrUFNKUGRtRnNMVE13SWlCamVEMGlOeUlnWTNrOUlqRXlJaUJ5UFNJeUlqNDhMMk5wY21Oc1pUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHTnBjbU5zWlNCcFpEMGlUM1poYkMwek1DSWdZM2c5SWpJaUlHTjVQU0l4TnlJZ2NqMGlNaUkrUEM5amFYSmpiR1UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhqYVhKamJHVWdhV1E5SWs5MllXd3RNekFpSUdONFBTSTNJaUJqZVQwaU1UY2lJSEk5SWpJaVBqd3ZZMmx5WTJ4bFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOFkybHlZMnhsSUdsa1BTSlBkbUZzTFRNd0lpQmplRDBpTWlJZ1kzazlJakl5SWlCeVBTSXlJajQ4TDJOcGNtTnNaVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQR05wY21Oc1pTQnBaRDBpVDNaaGJDMHpNQ0lnWTNnOUlqY2lJR041UFNJeU1pSWdjajBpTWlJK1BDOWphWEpqYkdVK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4amFYSmpiR1VnYVdROUlrOTJZV3d0TXpBaUlHTjRQU0l5SWlCamVUMGlNamNpSUhJOUlqSWlQand2WTJseVkyeGxQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThZMmx5WTJ4bElHbGtQU0pQZG1Gc0xUTXdJaUJqZUQwaU55SWdZM2s5SWpJM0lpQnlQU0l5SWo0OEwyTnBjbU5zWlQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBOEwyYytDaUFnSUNBOEwyYytDand2YzNablBnPT1cXFwiKTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXR9LnJlYWN0LWdyaWQtUm93LnJvdy1zZWxlY3RlZCwucmVhY3QtZ3JpZC1Sb3cgLnJvdy1zZWxlY3RlZHtiYWNrZ3JvdW5kLWNvbG9yOiNkYmVjZmF9LnJlYWN0LWdyaWQtcm93LWdyb3VwIC5yb3ctZXhwYW5kLWljb246aG92ZXJ7Y29sb3I6Izc3N30ucmVhY3QtZ3JpZC1yb3ctaW5kZXh7cGFkZGluZzowIDE4cHh9LnJkZy1yb3ctaW5kZXh7ZGlzcGxheTpibG9jazt0ZXh0LWFsaWduOmNlbnRlcn0ucmRnLXJvdy1hY3Rpb25zLWNlbGx7cGFkZGluZzowfS5yZGctYWN0aW9ucy1jaGVja2JveHtkaXNwbGF5Om5vbmU7dGV4dC1hbGlnbjpjZW50ZXJ9LnJkZy1hY3Rpb25zLWNoZWNrYm94LnNlbGVjdGVke2Rpc3BsYXk6YmxvY2t9LnJkZy1kcmFnZ2luZ3tjdXJzb3I6LXdlYmtpdC1ncmFiYmluZztjdXJzb3I6LW1vei1ncmFiYmluZztjdXJzb3I6Z3JhYmJpbmd9LnJkZy1kcmFnZ2VkLXJvd3tib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMDAwfVwiLCBcIlwiXSk7XG5cblx0Ly8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKiBcblx0ICovXG5cblx0ZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBhcmc7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuXHQgKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuXHQgKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuXHQgKi9cblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZztcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKiovIH0pLFxuLyogMTQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKi9cblxuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cblx0ICpcblx0ICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcblx0ICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG5cdCAqIGV4cGVjdGluZy5cblx0ICpcblx0ICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcblx0ICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuXHQgKi9cblxuXHR2YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5cdGlmIChmYWxzZSkge1xuXHQgIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcblx0ICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG5cdCAgaWYgKCFjb25kaXRpb24pIHtcblx0ICAgIHZhciBlcnJvcjtcblx0ICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG5cdCAgICAgIHZhciBhcmdJbmRleCA9IDA7XG5cdCAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG5cdCAgICAgIH0pKTtcblx0ICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcblx0ICAgIH1cblxuXHQgICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuXHQgICAgdGhyb3cgZXJyb3I7XG5cdCAgfVxuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcblx0ICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuXHQgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblx0ICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuXHQgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcblx0ICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuXHQgKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcblx0ICpcblx0ICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcblx0ICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG5cdCAqXG5cdCAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cblx0ICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICovXG5cdHZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbihvYmopIHtcblx0ICB2YXIgcmV0ID0ge307XG5cdCAgdmFyIGtleTtcblx0ICBpZiAoIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuXHQgIH1cblx0ICBmb3IgKGtleSBpbiBvYmopIHtcblx0ICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICByZXRba2V5XSA9IGtleTtcblx0ICB9XG5cdCAgcmV0dXJuIHJldDtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxuXG4vKioqLyB9KSxcbi8qIDE0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qXG5cdG9iamVjdC1hc3NpZ25cblx0KGMpIFNpbmRyZSBTb3JodXNcblx0QGxpY2Vuc2UgTUlUXG5cdCovXG5cblx0J3VzZSBzdHJpY3QnO1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHR2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cdGZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRcdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE9iamVjdCh2YWwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHRcdH1cblx0XHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdFx0dmFyIHRlc3QzID0ge307XG5cdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHRcdHZhciBmcm9tO1xuXHRcdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdFx0dmFyIHN5bWJvbHM7XG5cblx0XHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdG87XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQzKTtcblx0dmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KTtcblx0dmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuXHQgICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcblx0ICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpbnZhcmlhbnQoXG5cdCAgICAgIGZhbHNlLFxuXHQgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG5cdCAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcblx0ICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG5cdCAgICApO1xuXHQgIH07XG5cdCAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcblx0ICBmdW5jdGlvbiBnZXRTaGltKCkge1xuXHQgICAgcmV0dXJuIHNoaW07XG5cdCAgfTtcblx0ICAvLyBJbXBvcnRhbnQhXG5cdCAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG5cdCAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuXHQgICAgYXJyYXk6IHNoaW0sXG5cdCAgICBib29sOiBzaGltLFxuXHQgICAgZnVuYzogc2hpbSxcblx0ICAgIG51bWJlcjogc2hpbSxcblx0ICAgIG9iamVjdDogc2hpbSxcblx0ICAgIHN0cmluZzogc2hpbSxcblx0ICAgIHN5bWJvbDogc2hpbSxcblxuXHQgICAgYW55OiBzaGltLFxuXHQgICAgYXJyYXlPZjogZ2V0U2hpbSxcblx0ICAgIGVsZW1lbnQ6IHNoaW0sXG5cdCAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuXHQgICAgbm9kZTogc2hpbSxcblx0ICAgIG9iamVjdE9mOiBnZXRTaGltLFxuXHQgICAgb25lT2Y6IGdldFNoaW0sXG5cdCAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG5cdCAgICBzaGFwZTogZ2V0U2hpbSxcblx0ICAgIGV4YWN0OiBnZXRTaGltXG5cdCAgfTtcblxuXHQgIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcblx0ICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuXHQgIHJldHVybiBSZWFjdFByb3BUeXBlcztcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDE0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGEtZ3JpZC9kaXN0L3JlYWN0LWRhdGEtZ3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgSlNPTjUgZnJvbSAnanNvbjUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydFZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZWRyYXdDaGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZHJhd0NoYXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCl7XHJcbiAgICAgICAgdGhpcy5yZWRyYXdDaGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5jaGFydCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYXJ0LmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVkcmF3Q2hhcnQoKXtcclxuICAgICAgICBpZih0aGlzLnN0YXRlLmNoYXJ0ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2hhcnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5jaGFydCA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXREaXZJZCgpKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRDaGFydERhdGEoKTtcclxuICAgICAgICAgICAgdmFyIHlBeGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZihkYXRhICE9IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGF0YXNldHMpKXtcclxuICAgICAgICAgICAgICAgIHZhciBheGlzID0gW107XHJcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFzZXRzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZS55QXhpc0lEICE9IHVuZGVmaW5lZCAmJiBlLnlBeGlzSUQgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFheGlzLmluY2x1ZGVzKGUueUF4aXNJRCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnB1c2goZS55QXhpc0lEKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihheGlzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHlBeGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGF4aXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4ZXMucHVzaCh7dHlwZTogJ2xpbmVhcicsIGRpc3BsYXk6IHRydWUsIHBvc2l0aW9uOiAnbGVmdCcsIGlkOiBheGlzW2ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGVzLnB1c2goe3R5cGU6ICdsaW5lYXInLCBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogJ3JpZ2h0JywgaWQ6IGF4aXNbaV0sIGdyaWRMaW5lczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPbkNoYXJ0QXJlYTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMucHJvcHMuY2hhcnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBCb29sZWFuKHRoaXMucHJvcHMucmVzcG9uc2l2ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnByb3BzLmxlZ2VuZFBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICh0aGlzLnByb3BzLnRpdGxlU2l6ZSA9PSB1bmRlZmluZWQgPyAxNCA6IHRoaXMucHJvcHMudGl0bGVTaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogKHRoaXMucHJvcHMudGl0bGUgIT0gdW5kZWZpbmVkICYmIHRoaXMucHJvcHMudGl0bGUgIT0gXCJcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMucHJvcHMudGl0bGVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZih5QXhlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb25maWcub3B0aW9ucy5zY2FsZXMgPSB7eUF4ZXM6IHlBeGVzfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5wcm9wcy5zdHlsZTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnByb3BzLndpZHRoICE9IHVuZGVmaW5lZCA/IHRoaXMucHJvcHMud2lkdGggOiBcIjQwMHB4XCI7XHJcbiAgICAgICAgaWYoc3R5bGUud2lkdGggIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodCAhPSB1bmRlZmluZWQgPyB0aGlzLnByb3BzLmhlaWdodCA6IFwiMzAwcHhcIjtcclxuICAgICAgICBpZihzdHlsZS5oZWlnaHQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0OyAgXHJcbiAgICAgICAgfSBcclxuXHJcbiAgICAgICAgaWYoKHRoaXMuc3RhdGUud2lkdGggIT0gd2lkdGggfHwgdGhpcy5zdGF0ZS5oZWlnaHQgIT0gaGVpZ2h0KSAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYXJ0ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2hhcnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNoYXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gIFwiZmllbGRcIjtcclxuICAgICAgICBpZih0aGlzLnByb3BzLmNsYXNzTmFtZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIHRoaXMucHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gc3R5bGU9e3N0eWxlfSA+XHJcbiAgICAgICAgICAgIDxjYW52YXMgaWQ9e3RoaXMuZ2V0RGl2SWQoKX0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0+PC9jYW52YXM+XHJcbiAgICAgICAgPC9kaXY+O1xyXG4gICAgfVxyXG5cclxuICAgIGdldERpdklkKCl7XHJcbiAgICAgICAgcmV0dXJuIFwiZHdraXQtY2hhcnQtXCIgKyB0aGlzLnByb3BzLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2hhcnREYXRhKCl7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5kYXRhc2V0Q3VzdG9tKXtcclxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBbXTtcclxuICAgICAgICAgICAgaWYobWUucHJvcHMuZGF0YUxhYmVscyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGFiZWxzID0gbWUucHJvcHMuZGF0YUxhYmVscy5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxzLFxyXG4gICAgICAgICAgICAgICAgZGF0YXNldHM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1lLnByb3BzLmRhdGFzZXRMYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBzdGVwcGVkTGluZTogbWUucHJvcHMuZGF0YXNldFN0ZXBwZWRMaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBtZS5wcm9wcy5kYXRhc2V0Qm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtZS5wcm9wcy5kYXRhc2V0QmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG1lLnByb3BzLmRhdGFzZXRGaWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiBtZS5wcm9wcy5kYXRhc2V0Qm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbWUucHJvcHMudmFsdWVcclxuICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlPYmoodGhpcy5wcm9wcy52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29weU9iaihvYmopIHtcclxuICAgICAgICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xyXG4gICAgICAgIHZhciBjb3B5ID0gb2JqLmNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgY29weVthdHRyXSA9IHRoaXMuY29weU9iaihvYmpbYXR0cl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL2NoYXJ0dmlldy5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IEZvcm0sIERyb3Bkb3duLCBCdXR0b24gfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmtmbG93QmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBjb21tYW5kczogcHJvcHMuY29tbWFuZHMsXHJcbiAgICAgIHN0YXRlczogcHJvcHMuc3RhdGVzXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGVja0dldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCgpO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKXtcclxuICAgIHRoaXMuaXNNb3VudCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpe1xyXG4gICAgdGhpcy5pc01vdW50ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjaGVja0dldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCgpe1xyXG4gICAgaWYodGhpcy5wcm9wcy5nZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wgPT0gdW5kZWZpbmVkICYmIFxyXG4gICAgICB0aGlzLnByb3BzLmNvbW1hbmRzID09IHVuZGVmaW5lZCAmJiBcclxuICAgICAgdGhpcy5wcm9wcy5zdGF0ZXMgPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBpZihjb25zb2xlICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2Zsb3dCYXI6IFRoaXMgY29udHJvbCByZXF1cmVzIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCBvciBjb21tYW5kcyBhbmQgc3RhdGVzIG5vdCB1bmRlZmluZWQgcGFyYW1ldGVycyFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucHJvcHMuZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sKHRoaXMsIHt9LCBmdW5jdGlvbih7Y29tbWFuZHMsIHN0YXRlc30pe1xyXG4gICAgICAgICAgICBtZS5zdGF0ZS5jb21tYW5kcyA9IGNvbW1hbmRzO1xyXG4gICAgICAgICAgICBtZS5zdGF0ZS5zdGF0ZXMgPSBzdGF0ZXM7XHJcblxyXG4gICAgICAgICAgICBpZihtZS5wcm9wcy5oYW5kbGVFdmVudCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZUV2ZW50KHtrZXk6IG1lLnByb3BzLm5hbWUsIGV2ZW50TmFtZTogXCJvblJlY2VpdmVkQ29tbWFuZHNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kczogbWUuc3RhdGUuY29tbWFuZHMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXM6IG1lLnN0YXRlLnN0YXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYobWUuaXNNb3VudClcclxuICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJlbmRlcigpIHtcclxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZSArIFwiIGR3a2l0LXdvcmtmbG93YmFyXCI7XHJcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnByb3BzLnN0eWxlO1xyXG5cclxuICAgIHZhciBjb21tYW5kcyA9IHRoaXMuc3RhdGUuY29tbWFuZHMgIT0gdW5kZWZpbmVkID8gdGhpcy5zdGF0ZS5jb21tYW5kcyA6IHRoaXMucHJvcHMuY29tbWFuZHM7XHJcbiAgICB2YXIgc3RhdGVzID0gdGhpcy5zdGF0ZS5zdGF0ZXMgIT0gdW5kZWZpbmVkID8gdGhpcy5zdGF0ZS5zdGF0ZXMgOiB0aGlzLnByb3BzLnN0YXRlcztcclxuXHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gc3R5bGU9e3N0eWxlfT5cclxuICAgICAgPEZvcm0uR3JvdXA+XHJcbiAgICAgICAge3RoaXMucmVuZGVyQ29tbWFuZHMoY29tbWFuZHMpfVxyXG4gICAgICAgIHt0aGlzLnJlbmRlclNldFN0YXRlKHN0YXRlcyl9XHJcbiAgICAgIDwvRm9ybS5Hcm91cD5cclxuICAgIDwvZGl2PjtcclxuICB9XHJcblxyXG4gIHJlbmRlckNvbW1hbmRzKGNvbW1hbmRzKXtcclxuICAgIGlmKEFycmF5LmlzQXJyYXkoY29tbWFuZHMpICYmIGNvbW1hbmRzLmxlbmd0aCA+IDApXHJcbiAgICB7XHJcbiAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgIHZhciByZXMgPSBbXTtcclxuXHJcbiAgICAgIGNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24oYil7XHJcbiAgICAgICAgcmVzLnB1c2goPEJ1dHRvbiBrZXk9e2IudmFsdWV9IGNsYXNzTmFtZT17XCJidXR0b250eXBlXCIgKyBiLnR5cGV9IG9uQ2xpY2s9e21lLm9uQ29tbWFuZC5iaW5kKG1lLCBiKX0+e2IudGV4dH08L0J1dHRvbj4pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyU2V0U3RhdGUoc3RhdGVzKXtcclxuICAgIGlmKEJvb2xlYW4odGhpcy5wcm9wcy5ibG9ja1NldFN0YXRlKSl7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzdGF0ZXMpICYmIHN0YXRlcy5sZW5ndGggPiAwKXtcclxuICAgICAgdmFyIGRpc2FibGVDbGljayA9IHRoaXMuc3RhdGVbXCJzZXRzdGF0ZVwiXSA9PSB1bmRlZmluZWQgfHwgdGhpcy5zdGF0ZVtcInNldHN0YXRlXCJdID09IFwiXCI7XHJcblxyXG4gICAgICB2YXIgc2V0U3RhdGVCdXR0b24gPSBcIlNldCBzdGF0ZVwiO1xyXG4gICAgICBcclxuICAgICAgaWYodGhpcy5wcm9wcy5zZXRTdGF0ZUJ1dHRvbiAhPSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5zZXRTdGF0ZUJ1dHRvbiAhPSBcIlwiICl7XHJcbiAgICAgICAgc2V0U3RhdGVCdXR0b24gPSB0aGlzLnByb3BzLnNldFN0YXRlQnV0dG9uO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgaWYod2luZG93LkRXS2l0QWRtaW5MYW5nICE9IHVuZGVmaW5lZCAmJiB3aW5kb3cuRFdLaXRBZG1pbkxhbmcud29ya2Zsb3diYXIgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgIHNldFN0YXRlQnV0dG9uID0gd2luZG93LkRXS2l0QWRtaW5MYW5nLndvcmtmbG93YmFyLnNldHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFs8Rm9ybS5Ecm9wZG93biBcclxuICAgICAgICBrZXk9XCJzZXRzdGF0ZVwiXHJcbiAgICAgICAgbmFtZT1cInNldHN0YXRlXCIgXHJcbiAgICAgICAgY2xhc3NOYW1lPVwic2V0c3RhdGVcIlxyXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiU3RhdGVzXCIgXHJcbiAgICAgICAgb3B0aW9ucz17c3RhdGVzfSAgXHJcbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlZC5iaW5kKHRoaXMpfSBcclxuICAgICAgICBzZWxlY3Rpb24gZmx1aWQgc2VhcmNoIC8+LFxyXG4gICAgICAgIDxCdXR0b24ga2V5PVwiYnRuc2V0c3RhdGVcIiBkaXNhYmxlZD17ZGlzYWJsZUNsaWNrfSBjbGFzc05hbWU9XCJidXR0b250eXBlMlwiIG9uQ2xpY2s9e3RoaXMub25TZXRTdGF0ZS5iaW5kKHRoaXMpfT57c2V0U3RhdGVCdXR0b259PC9CdXR0b24+XHJcbiAgICAgIF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgb25Db21tYW5kKGJ1dHRvbil7XHJcbiAgICBpZih0aGlzLnByb3BzLmhhbmRsZUV2ZW50ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgIHRoaXMucHJvcHMuaGFuZGxlRXZlbnQoe2tleTogdGhpcy5wcm9wcy5uYW1lLCBldmVudE5hbWU6IFwib25Db21tYW5kQ2xpY2tcIiwgcGFyYW1ldGVyczogeyBjb21tYW5kOiBidXR0b24gfSB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uU2V0U3RhdGUoKXtcclxuICAgIGlmKHRoaXMucHJvcHMuaGFuZGxlRXZlbnQgIT0gdW5kZWZpbmVkKXtcclxuXHJcbiAgICAgIHZhciBzdGF0ZXMgPSB0aGlzLnN0YXRlLnN0YXRlcyAhPSB1bmRlZmluZWQgPyB0aGlzLnN0YXRlLnN0YXRlcyA6IHRoaXMucHJvcHMuc3RhdGVzO1xyXG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBpZihzdGF0ZXNbaV0udmFsdWUgPT0gdGhpcy5zdGF0ZS5zZXRzdGF0ZSl7XHJcbiAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZXNbaV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucHJvcHMuaGFuZGxlRXZlbnQoe2tleTogdGhpcy5wcm9wcy5uYW1lLCBldmVudE5hbWU6IFwib25TZXRTdGF0ZUNsaWNrXCIsIHBhcmFtZXRlcnM6IHsgc3RhdGU6IGN1cnJlbnRTdGF0ZSB9fSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoYW5kbGVDaGFuZ2VkKGUsIHtuYW1lLCB2YWx1ZX0pe1xyXG4gICAgdGhpcy5zdGF0ZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL3dvcmtmbG93YmFyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgRm9ybSwgRHJvcGRvd24sIE1lbnUgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpY3Rpb25hcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW11cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBwcm9wcy5wYWdlU2l6ZTtcclxuICAgICAgICBpZih0aGlzLnBhZ2VTaXplID09IHVuZGVmaW5lZCB8fCB0aGlzLnBhZ2VTaXplID09IFwiXCIpXHJcbiAgICAgICAgICAgIHRoaXMucGFnZVNpemUgPSAxMDA7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHMuZGF0YU1vZGVsICE9IHByZXZTdGF0ZS5kYXRhTW9kZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDogbmV4dFByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCxcclxuICAgICAgICAgICAgICAgIGRhdGFNb2RlbDogbmV4dFByb3BzLmRhdGFNb2RlbCxcclxuICAgICAgICAgICAgICAgIG5lZWRGZXRjaDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG5lZWRWYWx1ZUZldGNoOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG5leHRQcm9wcy5wYWdpbmcgJiYgbmV4dFByb3BzLnZhbHVlICE9IHByZXZTdGF0ZS52YWx1ZSAmJiBuZXh0UHJvcHMudmFsdWUgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5lZWRWYWx1ZUZldGNoOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLkdldEFkZGl0aW9uYWxEYXRhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5HZXRBZGRpdGlvbmFsRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEdldEFkZGl0aW9uYWxEYXRhKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGFNb2RlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5idWlsZGVybW9kZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJEaWN0aW9uYXJ5OiBTZXQgRGF0YU1vZGVsIGxhYmVsIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5nZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMucHJvcHMuYnVpbGRlcm1vZGUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGljdGlvbmFyeTogRm9yIHBhZ2luZyBvbiBzZXJ2ZXIgbmVlZCB0byBzZXQgZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sIGZ1bmMhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5uZWVkRmV0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7bW9kZWw6IHRoaXMuc3RhdGUuZGF0YU1vZGVsfTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9hZFBhZ2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5wcm9wcy5wYWdpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnN0YXJ0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnBhZ2VTaXplID0gdGhpcy5wYWdlU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pc0ZldGNoaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubmVlZEZldGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCh0aGlzLCBzZXR0aW5ncywgZnVuY3Rpb24gKHtpdGVtcywgcm93c0NvdW50fSkgeyAvL1RPRE8gY2FuY2VsbGF0aW9uIHRva2VuIGZyb20gYXN5bmMgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIG1lLnNldERhdGEoe2l0ZW1zLCByb3dzQ291bnQsIHBhZ2U6IGxhc3RMb2FkUGFnZX0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUubmVlZFZhbHVlRmV0Y2gpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5uZWVkVmFsdWVGZXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQ3VycmVudFZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBjb250cm9sUHJvcHMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHRoaXMucHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHAgPT0gXCJwYXJlbnRJc0Zvcm1cIiB8fFxyXG4gICAgICAgICAgICAgICAgcCA9PSBcImdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbFwiIHx8XHJcbiAgICAgICAgICAgICAgICBwID09IFwiZGF0YU1vZGVsXCIgfHxcclxuICAgICAgICAgICAgICAgIHAgPT0gXCJjbGVhcmFibGVcIiB8fFxyXG4gICAgICAgICAgICAgICAgcCA9PSBcImNvbHVtbnNcIiB8fFxyXG4gICAgICAgICAgICAgICAgcCA9PSBcInBhZ2luZ1wiIHx8XHJcbiAgICAgICAgICAgICAgICBwID09IFwicGFnZVNpemVcIilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb250cm9sUHJvcHNbcF0gPSB0aGlzLnByb3BzW3BdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5yZWFkT25seSlcclxuICAgICAgICAgICAgY29udHJvbFByb3BzLmRpc2FibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgY29udHJvbFByb3BzLm9wdGlvbnMgPSB0aGlzLnN0YXRlLm9wdGlvbnM7XHJcbiAgICAgICAgY29udHJvbFByb3BzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIGlmKHRoaXMucHJvcHMucGFnaW5nKXtcclxuICAgICAgICAgICAgY29udHJvbFByb3BzLm9uU2VhcmNoQ2hhbmdlID0gdGhpcy5oYW5kbGVTZWFyY2hDaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgY29udHJvbFByb3BzLm9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5vcGVuKXtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xQcm9wcy5vcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbnRyb2xQcm9wcy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBpZiAoY29udHJvbFByb3BzLnZhbHVlID09IHVuZGVmaW5lZCB8fCBjb250cm9sUHJvcHMudmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbFByb3BzLnZhbHVlID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb250cm9sUHJvcHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sUHJvcHMudmFsdWUgPSB0aGlzLmdldEFycmF5VmFsdWVzKGNvbnRyb2xQcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRyb2xQcm9wcy5sb2FkaW5nID0gdGhpcy5zdGF0ZS5pc0ZldGNoaW5nO1xyXG4gICAgICAgIGNvbnRyb2xQcm9wcy5zZWFyY2hRdWVyeSA9IHRoaXMuc3RhdGUuc2VhcmNoUXVlcnk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnBhcmVudElzRm9ybSkge1xyXG4gICAgICAgICAgICByZXR1cm4gPEZvcm0uRHJvcGRvd24gey4uLmNvbnRyb2xQcm9wc30gLz47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGl2Q2xhc3MgPSBcInVpIGxhYmVsZWQgaW5wdXRcIjtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJvcHMuZmx1aWQpXHJcbiAgICAgICAgICAgICAgICBkaXZDbGFzcyArPSBcIiBmbHVpZFwiO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYodGhpcy5wcm9wcy5lcnJvcilcclxuICAgICAgICAgICAgICAgIGRpdkNsYXNzICs9IFwiIGVycm9yXCI7XHJcbiAgICAgICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17ZGl2Q2xhc3N9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMubGFiZWwgIT0gdW5kZWZpbmVkICYmIDxkaXYgY2xhc3NOYW1lPVwidWkgbGFiZWwgbGFiZWxcIj57dGhpcy5wcm9wcy5sYWJlbH08L2Rpdj59XHJcbiAgICAgICAgICAgICAgICA8RHJvcGRvd24gey4uLmNvbnRyb2xQcm9wc30gLz5cclxuICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNoYW5nZShlLCB7bmFtZSwgdmFsdWV9KSB7XHJcbiAgICAgICAgbGV0IGxvYWRGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5tdWx0aXBsZSl7XHJcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKXtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ZpbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodiA9PT0gXCJfX2xvYWRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmluZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaXNGaW5kKXtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih2YWx1ZSA9PT0gXCJfX2xvYWRcIil7XHJcbiAgICAgICAgICAgIGxvYWRGbGFnID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxvYWRGbGFnKXtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNGZXRjaGluZzogdHJ1ZX0pO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5zdGF0ZS5vcGVuICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub3BlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLCB7bmFtZTogdGhpcy5wcm9wcy5uYW1lLCB2YWx1ZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ2xvc2UoKXtcclxuICAgICAgICBpZih0aGlzLnN0YXRlLm9wZW4gIT0gdHJ1ZSAmJiB0aGlzLnN0YXRlLnNlYXJjaFF1ZXJ5ICE9IFwiXCIpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlzRmV0Y2hpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlYXJjaFF1ZXJ5ID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sYXN0TG9hZFBhZ2UgPSAtMTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9hZE5leHRQYWdlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVTZWFyY2hDaGFuZ2UoZSwgeyBzZWFyY2hRdWVyeSB9KXtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXNGZXRjaGluZyA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hRdWVyeTogc2VhcmNoUXVlcnksXHJcbiAgICAgICAgICAgICAgICBsYXN0TG9hZFBhZ2U6IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbWUubG9hZE5leHRQYWdlKHRydWUpO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZE5leHRQYWdlKHJlc2V0KXtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHttb2RlbDogdGhpcy5zdGF0ZS5kYXRhTW9kZWx9O1xyXG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5zdGF0ZS5sYXN0TG9hZFBhZ2UgKyAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKG1lLnN0YXRlLnNlYXJjaFF1ZXJ5ICE9IHVuZGVmaW5lZCAmJiBtZS5zdGF0ZS5zZWFyY2hRdWVyeSAhPSBcIlwiKXtcclxuICAgICAgICAgICAgc2V0dGluZ3MuZmlsdGVycyA9IFt7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuZ2V0Q29sbHVtbnNGb3JGaWx0ZXIoKSxcclxuICAgICAgICAgICAgICAgIHRlcm06IFwibGlrZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLnNlYXJjaFF1ZXJ5XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzZXR0aW5ncy5zdGFydEluZGV4ID0gcGFnZSAqIHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgc2V0dGluZ3MucGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCh0aGlzLCBzZXR0aW5ncywgZnVuY3Rpb24gKHtpdGVtcywgcm93c0NvdW50fSkge1xyXG4gICAgICAgICAgICBtZS5zZXREYXRhKHtpdGVtcywgcm93c0NvdW50LCBwYWdlOiBwYWdlfSwgcmVzZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERhdGEoe2l0ZW1zLCByb3dzQ291bnQsIHBhZ2V9LCByZXNldCl7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYocmVzZXQpe1xyXG4gICAgICAgICAgICBvcHRpb25zID0gaXRlbXM7XHJcbiAgICAgICAgICAgIGlmKHJvd3NDb3VudCA+IG9wdGlvbnMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gKHRoaXMuc3RhdGUuc2VhcmNoUXVlcnkgIT0gdW5kZWZpbmVkID8gdGhpcy5zdGF0ZS5zZWFyY2hRdWVyeSA6IFwiXCIpICsgXCIuLi5cIjtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7a2V5OiBcIl9fbG9hZFwiLCB2YWx1ZTogXCJfX2xvYWRcIiwgdGV4dH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnByb3BzLmNsZWFyYWJsZSkgJiYgIUJvb2xlYW4odGhpcy5wcm9wcy5tdWx0aXBsZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudW5zaGlmdCh7a2V5OiBcIl9fcmVzZXRcIiwgdmFsdWU6IFwiXCIsIHRleHQ6IFwiICAgXCJ9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoQm9vbGVhbih0aGlzLnByb3BzLm11bHRpcGxlKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy5nZXRBcnJheVZhbHVlcyh0aGlzLnByb3BzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8IHZhbHVlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaj0wOyBqPCB0aGlzLnN0YXRlLm9wdGlvbnMubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5zdGF0ZS5vcHRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PSBvcHRpb24udmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51bnNoaWZ0KG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMuc3RhdGUub3B0aW9ucztcclxuICAgICAgICAgICAgbGV0IGxvYWRpbmdJdGVtID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmKG9wdGlvbnMubGVuZ3RoID4gMCAmJiBvcHRpb25zW29wdGlvbnMubGVuZ3RoIC0gMV0ua2V5ID09IFwiX19sb2FkXCIpe1xyXG4gICAgICAgICAgICAgICAgbG9hZGluZ0l0ZW0gPSBvcHRpb25zLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9IG9wdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9uLmtleSA9PSBpdGVtLmtleSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihsb2FkaW5nSXRlbSAhPSB1bmRlZmluZWQgJiYgcm93c0NvdW50ID4gb3B0aW9ucy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gobG9hZGluZ0l0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgbmVlZEZldGNoOiBmYWxzZSwgXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIHJvd3NDb3VudCwgXHJcbiAgICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLCBcclxuICAgICAgICAgICAgbGFzdExvYWRQYWdlOiBwYWdlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEFycmF5VmFsdWVzKHZhbHVlKXtcclxuICAgICAgICBsZXQgcmVzID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcykpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlQXJyYXk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUFycmF5ID0gSlNPTi5wYXJzZShyZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUFycmF5ID0gW3Jlc107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHZhbHVlQXJyYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEN1cnJlbnRWYWx1ZSgpe1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy52YWx1ZSAhPSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy52YWx1ZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgaWYodGhpcy5wcm9wcy5tdWx0aXBsZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy5nZXRBcnJheVZhbHVlcyh0aGlzLnByb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGxldCB1bmZpbmRlZFZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNGaW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqPTA7IGo8dGhpcy5zdGF0ZS5vcHRpb25zLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMuc3RhdGUub3B0aW9uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9uLnZhbHVlID09IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmluZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZighaXNGaW5kKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5maW5kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHVuZmluZGVkVmFsdWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHttb2RlbDogdGhpcy5zdGF0ZS5kYXRhTW9kZWx9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZpbHRlcnMgPSBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IFwiX19pZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtOiAnaW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5maW5kZWRWYWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNGZXRjaGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5nZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wodGhpcywgc2V0dGluZ3MsIGZ1bmN0aW9uICh7aXRlbXN9KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFkZEFkZGl0aW9uYWxPcHRpb25zKGl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzRmluZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGkgPCB0aGlzLnN0YXRlLm9wdGlvbnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSB0aGlzLnN0YXRlLm9wdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9uLnZhbHVlID09IHRoaXMucHJvcHMudmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIWlzRmluZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0ge21vZGVsOiB0aGlzLnN0YXRlLmRhdGFNb2RlbH07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZmlsdGVycyA9IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogXCJfX2lkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm06ICc9JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lLnByb3BzLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlzRmV0Y2hpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sKHRoaXMsIHNldHRpbmdzLCBmdW5jdGlvbiAoe2l0ZW1zfSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hZGRBZGRpdGlvbmFsT3B0aW9ucyhpdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkQWRkaXRpb25hbE9wdGlvbnMoaXRlbXMpe1xyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGl0ZW1zKSB8fCBpdGVtcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuc3RhdGUub3B0aW9ucztcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xyXG4gICAgICAgICAgICBsZXQgaXNGaW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBvcHRpb25zLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbnNbal0ua2V5ID09IGl0ZW1zW2ldLmtleSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIWlzRmluZCl7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVuc2hpZnQoaXRlbXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmlzRmV0Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29sbHVtbnNGb3JGaWx0ZXIoKXtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoJyBhc2MnLCAnZ2knKTtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5wcm9wcy5jb2x1bW5zLnJlcGxhY2UocGF0dGVybiwgJycpO1xyXG5cclxuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnIGRlc2MnLCAnZ2knKTtcclxuICAgICAgICByZXMgPSByZXMucmVwbGFjZShwYXR0ZXJuLCAnJyk7XHJcblxyXG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCcgJywgJ2dpJyk7XHJcbiAgICAgICAgcmVzID0gcmVzLnJlcGxhY2UocGF0dGVybiwgJycpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbnRyb2wvZGljdGlvbmFyeS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IEZvcm0sIFJhZGlvIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7fVxyXG4gIH1cclxuXHJcbiAgXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuICg8ZGl2IHsuLi50aGlzLnByb3BzfT48L2Rpdj4pO1xyXG4gICAgXHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbnRyb2wvY29udGFpbmVyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0NvbnRlbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7fVxyXG4gIH1cclxuXHJcbiAgXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgdmFyIHNwYW5Qcm9wcyA9IHtcclxuICAgICAgbmFtZTogdGhpcy5wcm9wcy5uYW1lLFxyXG4gICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHNbXCJzdHlsZS1jdXN0b21jc3NcIl0sXHJcbiAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxyXG4gICAgICBcImRhdGEtYnVpbGRlcnR5cGVcIiA6IHRoaXMucHJvcHNbXCJkYXRhLWJ1aWxkZXJ0eXBlXCJdXHJcbiAgICB9O1xyXG4gICBcclxuXHJcbiAgICBpZih0aGlzLnByb3BzLmlzSHRtbCl7XHJcbiAgICAgIHJldHVybiA8c3BhbiB7Li4uc3BhblByb3BzfSBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogdGhpcy5wcm9wcy5jb250ZW50fX0gLz5cclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnByb3BzLmNvbnRlbnQgIT0gdW5kZWZpbmVkID8gXHJcbiAgICAgICAgICB0aGlzLnByb3BzLmNvbnRlbnQucmVwbGFjZSgnXFxuJywnPGJyLz4nKTpcclxuICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gKDxzcGFuIHsuLi5zcGFuUHJvcHN9Pntjb250ZW50fTwvc3Bhbj4pO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL3N0YXRpY2NvbnRlbnQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IEJ1aWxkZXJBY3Rpb25zIGZyb20gJy4vYWN0aW9ucydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRyb2xCYXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgb25EcmFnU3RhcnQoaXRlbSwgZSkge1xyXG4gICAgICB2YXIgc2VsZWN0b3IgPSAnLmR3a2l0LWZvcm1idWlsZGVyLXpvbmUnO1xyXG4gIFxyXG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgJycpOyBcclxuICAgICAgaWYoaXRlbS5mb3JDb250YWluZXJUeXBlICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgbGV0IGNUeXBlcyA9IGl0ZW0uZm9yQ29udGFpbmVyVHlwZS5zcGxpdCgnLCcpO1xyXG4gICAgICAgIGxldCBzdWJTZWxlY3RvciA9IFwiXCI7XHJcbiAgICAgICAgY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oYyl7XHJcbiAgICAgICAgICBpZihzdWJTZWxlY3Rvci5sZW5ndGggPiAwKSBcclxuICAgICAgICAgICAgc3ViU2VsZWN0b3IgKz0gXCIsXCI7XHJcbiAgICAgICAgICBzdWJTZWxlY3RvciArPSBcIltkYXRhLWJ1aWxkZXJ0eXBlPSdcIiArIGMgKyBcIiddID4gXCIgKyBzZWxlY3RvcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZWxlY3RvciA9IHN1YlNlbGVjdG9yO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgICQoc2VsZWN0b3IpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2R3a2l0LWZvcm1idWlsZGVyLXpvbmUtYWN0aXZlJylcclxuICAgICAgICAgIC5vbignZHJhZ2VudGVyJywgdGhpcy5vblRhcmdldERyYWdFbnRlci5iaW5kKHRoaXMsIGl0ZW0sICdkd2tpdC1mb3JtYnVpbGRlci16b25lLXNlbGVjdCcpKVxyXG4gICAgICAgICAgLm9uKCdkcmFnbGVhdmUnLCB0aGlzLm9uVGFyZ2V0RHJhZ0xlYXZlLmJpbmQodGhpcywgaXRlbSwgJ2R3a2l0LWZvcm1idWlsZGVyLXpvbmUtc2VsZWN0JykpXHJcbiAgICAgICAgICAub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24oZSkge2UucHJldmVudERlZmF1bHQoKTt9KVxyXG4gICAgICAgICAgLm9uKCdkcm9wJywgdGhpcy5vbkRyb3AuYmluZCh0aGlzLCBpdGVtKSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBvblRhcmdldERyYWdFbnRlcihpdGVtLCBjc3MsIGUpIHtcclxuICAgICAgJChlLnRhcmdldCkuYWRkQ2xhc3MoY3NzKTtcclxuICAgIH1cclxuICBcclxuICAgIG9uVGFyZ2V0RHJhZ0xlYXZlKGl0ZW0sIGNzcywgZSkge1xyXG4gICAgICAkKGUudGFyZ2V0KS5yZW1vdmVDbGFzcyhjc3MpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgb25EcmFnRW5kKGl0ZW0pIHtcclxuICAgICAgdmFyIHpvbmVzID0gJCgnLmR3a2l0LWZvcm1idWlsZGVyLXpvbmUnKTtcclxuICBcclxuICAgICAgem9uZXMucmVtb3ZlQ2xhc3MoJ2R3a2l0LWZvcm1idWlsZGVyLXpvbmUtYWN0aXZlJyk7XHJcbiAgICAgIHpvbmVzLnJlbW92ZUNsYXNzKCdkd2tpdC1mb3JtYnVpbGRlci16b25lLXNlbGVjdCcpXHJcbiAgICAgIHpvbmVzLm9mZigpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgb25Ecm9wKGl0ZW0sIGUpe1xyXG4gICAgICB2YXIgZWwgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgaWYoZWwubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICBCdWlsZGVyQWN0aW9ucy5tb3ZlKGl0ZW0ua2V5LCBlbFswXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub25EcmFnRW5kKGl0ZW0pO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBjbGFzc05hbWUgPSBcImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXJcIjtcclxuICAgICAgaWYodGhpcy5wcm9wcy5pc0dyb3VwKVxyXG4gICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIFwiZHdraXQtZm9ybWJ1aWxkZXItaXRlbS10b29sYmFyLWNvbnRyb2xiYXJncm91cFwiO1xyXG4gICAgICBcclxuICAgICAgaWYodGhpcy5wcm9wcy5jb250cm9sT25SaWdodCl7XHJcbiAgICAgICAgY2xhc3NOYW1lICs9IFwiIFwiICsgXCJkd2tpdC1mb3JtYnVpbGRlci1pdGVtLXRvb2xiYXItcmlnaHRcIjtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIFwiZHdraXQtZm9ybWJ1aWxkZXItaXRlbS10b29sYmFyLWxlZnRcIjtcclxuICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IFxyXG4gICAgICAgICAgb25Nb3VzZU92ZXI9e3RoaXMub25Nb3VzZU92ZXIuYmluZCh0aGlzKX1cclxuICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKX0+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXItYnV0dG9uc1wiID5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXItdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLnRleHR9XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGltZyBzcmM9XCIvaW1hZ2VzL2R3a2l0YnVpbGRlci1tb3ZlLnN2Z1wiIGNsYXNzTmFtZT1cIm1vdmVcIiBoZWlnaHQ9XCIxNnB4XCIgZHJhZ2dhYmxlPXt0cnVlfSAgXHJcbiAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17dGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMsIHRoaXMucHJvcHMubW9kZWwpfVxyXG4gICAgICAgICAgICAgICAgb25EcmFnRW5kPXt0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMsIHRoaXMucHJvcHMubW9kZWwpfVxyXG4gICAgICAgICAgICAgICAgb25EcmFnPXt0aGlzLm9uRHJhZy5iaW5kKHRoaXMpfSAvPlxyXG4gICAgICAgICAgICAgIDxpbWcgc3JjPVwiL2ltYWdlcy9kd2tpdGJ1aWxkZXItZWRpdC5zdmdcIiBoZWlnaHQ9XCIxNnB4XCIgb25DbGljaz17dGhpcy5wcm9wcy5vbkVkaXQuYmluZCh0aGlzLnByb3BzLnBhcmVudCwgdGhpcy5wcm9wcy5tb2RlbCl9IC8+XHJcbiAgICAgICAgICAgICAgPGltZyBzcmM9XCIvaW1hZ2VzL2R3a2l0YnVpbGRlci1jb3B5LnN2Z1wiIGhlaWdodD1cIjE2cHhcIiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ29weS5iaW5kKHRoaXMucHJvcHMucGFyZW50LCB0aGlzLnByb3BzLm1vZGVsKX0gLz5cclxuICAgICAgICAgICAgICA8aW1nIHNyYz1cIi9pbWFnZXMvZHdraXRidWlsZGVyLWRlbGV0ZS5zdmdcIiBoZWlnaHQ9XCIxNnB4XCIgb25DbGljaz17dGhpcy5wcm9wcy5vbkRlbGV0ZS5iaW5kKHRoaXMucHJvcHMucGFyZW50LCB0aGlzLnByb3BzLm1vZGVsKX0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW91c2VPdmVyKGUpe1xyXG4gICAgICB2YXIgZWwgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKFwiLmR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXJcIik7XHJcbiAgICAgIGlmKHRoaXMucHJvcHMuY29udHJvbE9uUmlnaHQpe1xyXG4gICAgICAgIGVsLnByZXYoKS5hZGRDbGFzcyhcImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tc2VsZWN0ZWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICBlbC5uZXh0KCkuYWRkQ2xhc3MoXCJkd2tpdC1mb3JtYnVpbGRlci1pdGVtLXNlbGVjdGVkXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VzZUxlYXZlKGUpe1xyXG4gICAgICB2YXIgZWwgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgdmFyIHBhcmVudHMgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKFwiLmR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tdG9vbGJhci1oZWFkZXJcIik7XHJcbiAgICAgIGlmKHRoaXMucHJvcHMuY29udHJvbE9uUmlnaHQpe1xyXG4gICAgICAgIGVsLnByZXYoKS5yZW1vdmVDbGFzcyhcImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgcGFyZW50cy5wcmV2KCkucmVtb3ZlQ2xhc3MoXCJkd2tpdC1mb3JtYnVpbGRlci1pdGVtLXNlbGVjdGVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgZWwubmV4dCgpLnJlbW92ZUNsYXNzKFwiZHdraXQtZm9ybWJ1aWxkZXItaXRlbS1zZWxlY3RlZFwiKTtcclxuICAgICAgICBwYXJlbnRzLm5leHQoKS5yZW1vdmVDbGFzcyhcImR3a2l0LWZvcm1idWlsZGVyLWl0ZW0tc2VsZWN0ZWRcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWcoZSl7XHJcbiAgICAgIHZhciBzdGVwID0gMTA7XHJcbiAgICAgIGlmIChlLmNsaWVudFkgPCAxNTApIHtcclxuICAgICAgICB0aGlzLnNjcm9sbCgtc3RlcCk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaWYgKGUuY2xpZW50WSA+ICgkKHdpbmRvdykuaGVpZ2h0KCkgLSAxNTApKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGwoc3RlcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIHNjcm9sbChzdGVwKSB7XHJcbiAgICAgIHZhciBzY3JvbGxZID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xyXG4gICAgICAkKHdpbmRvdykuc2Nyb2xsVG9wKHNjcm9sbFkgKyBzdGVwKTtcclxuICAgICAgaWYgKCFzdG9wKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgc2Nyb2xsKHN0ZXApIH0sIDIwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udHJvbGJhci5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IFRyaWdnZXIsIERyb3Bkb3duLCBJbWFnZSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJvcGRvd25UcmlnZ2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIFxyXG4gICAgdmFyIGNvbnRyb2xQcm9wcyA9IHt9O1xyXG4gICAgZm9yKHZhciBwIGluIHRoaXMucHJvcHMpe1xyXG4gICAgICAgIGlmKHAgPT0gXCJpbWFnZVVybFwiIHx8IFxyXG4gICAgICAgICAgICBwID09IFwiZGVmYXVsdFZhbHVlXCIgfHxcclxuICAgICAgICAgICAgcCA9PSBcInZhbHVlXCIgfHxcclxuICAgICAgICAgICAgcCA9PSBcImhhbmRsZUV2ZW50XCIgfHxcclxuICAgICAgICAgICAgcCA9PSBcIml0ZW1zXCIgKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb250cm9sUHJvcHNbcF0gPSB0aGlzLnByb3BzW3BdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRyb2xQcm9wcy5vcHRpb25zID0gW107XHJcbiAgICB0aGlzLnByb3BzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcblxyXG4gICAgICBsZXQgaXNTa2lwID0gZmFsc2U7XHJcbiAgICAgIGlmKGl0ZW0udmlzaWJsZUNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkICYmIGl0ZW0udmlzaWJsZUNvbmRpdGlvbiAhPT0gbnVsbCAmJiBpdGVtLnZpc2libGVDb25kaXRpb24gIT09IFwiXCIpe1xyXG4gICAgICAgIGxldCBhcmdzID0gJyc7XHJcbiAgICAgICAgbGV0IGJvZHkgPSAncmV0dXJuICcgKyBpdGVtLnZpc2libGVDb25kaXRpb247XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBpZighbmV3IEZ1bmN0aW9uKGFyZ3MsIGJvZHkpKCkpe1xyXG4gICAgICAgICAgICAgIGlzU2tpcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goZSl7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIWlzU2tpcClcclxuICAgICAgICBjb250cm9sUHJvcHMub3B0aW9ucy5wdXNoKHt2YWx1ZTogaXRlbS50YXJnZXQsIHRleHQ6IGl0ZW0udGl0bGUsIHRhcmdldDogaXRlbS50YXJnZXR9KTtcclxuICAgICAgICBcclxuICAgIH0pO1xyXG4gICAgY29udHJvbFByb3BzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgY29udHJvbFByb3BzLnRyaWdnZXIgPSA8c3Bhbj5cclxuICAgICAgICB7dGhpcy5wcm9wcy5pbWFnZVVybCAhPSB1bmRlZmluZWQgJiYgPEltYWdlIGF2YXRhciBzcmM9e3RoaXMucHJvcHMuaW1hZ2VVcmx9IC8+fSB7dGhpcy5wcm9wcy52YWx1ZSAhPSB1bmRlZmluZWQgPyB0aGlzLnByb3BzLnZhbHVlIDogdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWV9XHJcbiAgICA8L3NwYW4+O1xyXG4gICAgcmV0dXJuIDxEcm9wZG93biB7Li4uY29udHJvbFByb3BzfVxyXG4gICAgICBvbk1vdXNlRG93bj17dGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpfVxyXG4gICAgLz47XHJcbiAgfVxyXG5cclxuICBvbkNoYW5nZShlLCB7IG5hbWUsIHZhbHVlIH0pe1xyXG4gICAgaWYodGhpcy5zdGF0ZS5vcGVuZGlhbG9nID09IHRydWUpe1xyXG4gICAgICB0aGlzLnN0YXRlLm9wZW5kaWFsb2cgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMucHJvcHMuaGFuZGxlRXZlbnQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICB0aGlzLnByb3BzLmhhbmRsZUV2ZW50KHtlLCBrZXk6IHRoaXMucHJvcHMubmFtZSwgZXZlbnROYW1lOiBcIm9uSXRlbUNsaWNrXCIsIHBhcmFtZXRlcnM6IHsgdGFyZ2V0OiB2YWx1ZSB9fSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1vdXNlRG93bihlKXtcclxuICAgIHRoaXMuc3RhdGUub3BlbmRpYWxvZyA9ICFCb29sZWFuKHRoaXMuc3RhdGUub3BlbmRpYWxvZyk7XHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbnRyb2wvZHJvcGRvd250cmlnZ2VyLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHtNZW51LCBTdGF0aXN0aWMsIFRhYiwgRm9ybSwgR3JpZCwgQ2FyZCwgSW5wdXQsIERyb3Bkb3duLCBDaGVja2JveCwgVGV4dEFyZWEsIEJ1dHRvbiwgSWNvbiwgTWVzc2FnZSwgSW1hZ2UsIExhYmVsLCBIZWFkZXIsIEl0ZW0sIFNlZ21lbnQsIE1vZGFsLCBCcmVhZGNydW1ifSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuaW1wb3J0IFVwbG9hZCBmcm9tICcuL3VwbG9hZCdcclxuaW1wb3J0IEpTT041IGZyb20gJ2pzb241J1xyXG5pbXBvcnQgRGF0ZVBpY2tlciBmcm9tICcuL2RhdGVwaWNrZXInXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZW1hbnRpY0NvbnRyb2wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7fVxyXG4gIH1cclxuXHJcbiAgXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgbGV0IG1lID0gdGhpcztcclxuICAgIHZhciBwcm9wc0NvbnRyb2wgPSB7fVxyXG4gICAgZm9yKHZhciBwIGluIHRoaXMucHJvcHMpe1xyXG4gICAgICBpZihwID09PSBcImFkZGl0aW9uYWxQYXJhbXNcIiB8fCBwID09PSBcIml0ZW1zXCIpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgcHJvcHNDb250cm9sW3BdID0gdGhpcy5wcm9wc1twXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kZWwgPSB0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMubW9kZWw7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuYWRkaXRpb25hbFBhcmFtcy5kYXRhO1xyXG4gICAgdmFyIGVycm9ycyA9IHRoaXMucHJvcHMuYWRkaXRpb25hbFBhcmFtcy5lcnJvcnM7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMuY2hpbGRyZW47XHJcbiAgICB2YXIgcGFyZW50SXRlbSA9IHRoaXMucHJvcHMuYWRkaXRpb25hbFBhcmFtcy5wYXJlbnRJdGVtO1xyXG4gICAgdmFyIGhhbmRsZUV2ZW50ID0gdGhpcy5wcm9wcy5hZGRpdGlvbmFsUGFyYW1zLmhhbmRsZUV2ZW50O1xyXG4gICAgXHJcbiAgICB2YXIgdHlwZSA9IG1vZGVsW1wiZGF0YS1idWlsZGVydHlwZVwiXTtcclxuXHJcbiAgICB2YXIgcmVzO1xyXG4gICAgaWYodHlwZSA9PT0gJ2hlYWRlcicpe1xyXG4gICAgICByZXMgPSA8SGVhZGVyIHsuLi5wcm9wc0NvbnRyb2x9XHJcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ249e21vZGVsLnRleHRBbGlnbn0gXHJcbiAgICAgICAgICAgICAgICAgICAgICBzaXplPXttb2RlbC5zaXplfSBcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9e3RoaXMucHJvcHMuY29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgIHN1YmhlYWRlcj17dGhpcy5wcm9wcy5zdWJoZWFkZXJ9Lz47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHR5cGUgPT09ICdidXR0b24nKXtcclxuICAgICAgcHJvcHNDb250cm9sLmZsb2F0ZWQgPSBtb2RlbC5mbG9hdGVkO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuc2l6ZSA9IG1vZGVsLnNpemUgIT09IFwiXCIgPyBtb2RlbC5zaXplIDogbnVsbDtcclxuICAgICAgcHJvcHNDb250cm9sLmNvbnRlbnQgPSBtb2RlbC5jb250ZW50O1xyXG4gICAgICBwcm9wc0NvbnRyb2wudHlwZSA9IG1vZGVsLmJ1dHRvblR5cGU7XHJcbiAgICAgIHByb3BzQ29udHJvbC5iYXNpYyA9IG1vZGVsLmJhc2ljO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuY2lyY3VsYXIgPSBtb2RlbC5jaXJjdWxhcjtcclxuICAgICAgcHJvcHNDb250cm9sLmNvbXBhY3QgPSBtb2RlbC5jb21wYWN0O1xyXG4gICAgICBwcm9wc0NvbnRyb2wuZGlzYWJsZWQgPSBtb2RlbC5kaXNhYmxlZDtcclxuICAgICAgcHJvcHNDb250cm9sLmZsdWlkID0gbW9kZWwuZmx1aWQ7XHJcbiAgICAgIHByb3BzQ29udHJvbC5pbnZlcnRlZCA9IG1vZGVsLmludmVydGVkO1xyXG4gICAgICBwcm9wc0NvbnRyb2wubG9hZGluZyA9IG1vZGVsLmxvYWRpbmc7XHJcbiAgICAgIHByb3BzQ29udHJvbC5wcmltYXJ5ID0gbW9kZWwucHJpbWFyeTtcclxuICAgICAgcHJvcHNDb250cm9sLnNlY29uZGFyeSA9IG1vZGVsLnNlY29uZGFyeTtcclxuICAgICAgcHJvcHNDb250cm9sLnRvZ2dsZSA9IG1vZGVsLnRvZ2dsZTtcclxuXHJcbiAgICAgIGlmKGhhbmRsZUV2ZW50ICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5vbkNsaWNrID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXZlbnQoe3N5bnRoZXRpY0V2ZW50OiBlLCBrZXk6IHByb3BzQ29udHJvbC5uYW1lLCBldmVudE5hbWU6IFwib25DbGlja1wifSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy5pc0Zvcm0ocGFyZW50SXRlbSkpe1xyXG4gICAgICAgIHJlcyA9IDxGb3JtLkJ1dHRvbiB7Li4ucHJvcHNDb250cm9sfS8+O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgcmVzID0gPEJ1dHRvbiB7Li4ucHJvcHNDb250cm9sfS8+O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHR5cGUgPT09ICdsYWJlbCcpe1xyXG4gICAgICByZXMgPSAoPExhYmVsIHsuLi5wcm9wc0NvbnRyb2x9XHJcbiAgICAgICAgICAgICAgICAgICAgICBzaXplPXttb2RlbC5zaXplfSBcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9e3RoaXMucHJvcHMuY29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVkPXttb2RlbC5hdHRhY2hlZH1cclxuICAgICAgICAgICAgICAgICAgICAgIGJhc2ljPXttb2RlbC5iYXNpY31cclxuICAgICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyPXttb2RlbC5jaXJjdWxhcn1cclxuICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcj17bW9kZWwuY29ybmVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXRpbmc9e21vZGVsLmZsb2F0aW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbD17bW9kZWwuaG9yaXpvbnRhbH1cclxuICAgICAgICAgICAgICAgICAgICAgIHBvaW50aW5nPXttb2RlbC5wb2ludGluZ30+XHJcbiAgICAgICAgICAgIDwvTGFiZWw+KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ21lc3NhZ2UnKXtcclxuICAgICAgcmVzID0gKDxNZXNzYWdlIHsuLi5wcm9wc0NvbnRyb2x9XHJcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdGVkPXttb2RlbC5mbG9hdGVkfSBcclxuICAgICAgICAgICAgICAgICAgICAgIHNpemU9e21vZGVsLnNpemV9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudD17dGhpcy5wcm9wcy5jb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGFjdD17bW9kZWwuY29tcGFjdH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yPXttb2RlbC5lcnJvcn1cclxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0aW5nPXttb2RlbC5mbG9hdGluZ31cclxuICAgICAgICAgICAgICAgICAgICAgIGluZm89e21vZGVsLmluZm99XHJcbiAgICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZT17bW9kZWwubmVnYXRpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZT17bW9kZWwucG9zaXRpdmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzPXttb2RlbC5zdWNjZXNzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgd2FybmluZz17bW9kZWwud2FybmluZ31cclxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcj17dGhpcy5wcm9wcy5oZWFkZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDwvTWVzc2FnZT4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZih0eXBlID09PSAnaW5wdXQnKXtcclxuICAgICAgcHJvcHNDb250cm9sLmRlZmF1bHRWYWx1ZSA9IG1vZGVsLmRlZmF1bHR2YWx1ZTtcclxuICAgICAgcHJvcHNDb250cm9sLnNpemUgPSBtb2RlbC5zaXplO1xyXG4gICAgICBcclxuICAgICAgaWYobW9kZWwubGFiZWwgIT0gdW5kZWZpbmVkICYmIG1vZGVsLmxhYmVsICE9IFwiXCIpXHJcbiAgICAgICAgcHJvcHNDb250cm9sLmxhYmVsID0gbW9kZWwubGFiZWw7XHJcbiAgICAgIFxyXG4gICAgICBwcm9wc0NvbnRyb2wubGFiZWxQb3NpdGlvbiA9IG1vZGVsLmxhYmVsUG9zaXRpb247XHJcbiAgICAgIHByb3BzQ29udHJvbC5wbGFjZWhvbGRlciA9IG1vZGVsLnBsYWNlaG9sZGVyO1xyXG4gICAgICBwcm9wc0NvbnRyb2wudHlwZSA9IG1vZGVsLnR5cGU7XHJcbiAgICAgIHByb3BzQ29udHJvbC5sb2FkaW5nID0gbW9kZWwubG9hZGluZztcclxuICAgICAgcHJvcHNDb250cm9sLmludmVydGVkID0gbW9kZWwuaW52ZXJ0ZWQ7XHJcbiAgICAgIHByb3BzQ29udHJvbC5lcnJvciA9IG1vZGVsLmVycm9yOyBcclxuICAgICAgcHJvcHNDb250cm9sLmRpc2FibGVkID0gbW9kZWwuZGlzYWJsZWQ7XHJcbiAgICAgIHByb3BzQ29udHJvbC50cmFuc3BhcmVudCA9IG1vZGVsLnRyYW5zcGFyZW50O1xyXG4gICAgICBwcm9wc0NvbnRyb2wuZmx1aWQgPSBtb2RlbC5mbHVpZDtcclxuICAgICAgcHJvcHNDb250cm9sLnJlYWRPbmx5ID0gbW9kZWwucmVhZE9ubHkgfHwgdGhpcy5wcm9wcy5yZWFkT25seTtcclxuICAgICAgXHJcbiAgICAgIGlmKGhhbmRsZUV2ZW50ICE9IG51bGwpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUsIHtuYW1lLCB2YWx1ZX0pe1xyXG4gICAgICAgICAgaGFuZGxlRXZlbnQoe3N5bnRoZXRpY0V2ZW50OiBlLCBrZXk6IHByb3BzQ29udHJvbC5uYW1lLCBldmVudE5hbWU6IFwib25DaGFuZ2VcIiwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoZGF0YSAhPSB1bmRlZmluZWQgJiYgZGF0YSAhPSBudWxsKXtcclxuICAgICAgICBwcm9wc0NvbnRyb2wudmFsdWUgPSBkYXRhW3Byb3BzQ29udHJvbC5uYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcHJvcHNDb250cm9sLnZhbHVlID0gXCJcIjtcclxuXHJcbiAgICAgIGlmKHR5cGVvZiBlcnJvcnMgPT09IFwib2JqZWN0XCIgJiYgZXJyb3JzW21vZGVsLmtleV0gIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgcHJvcHNDb250cm9sLmVycm9yID0gQm9vbGVhbihlcnJvcnNbbW9kZWwua2V5XSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKHByb3BzQ29udHJvbC50eXBlID09PSBcImZpbGVcIil7XHJcbiAgICAgICAgcHJvcHNDb250cm9sLmlzRm9ybSA9IHRoaXMuaXNGb3JtKHBhcmVudEl0ZW0pO1xyXG4gICAgICAgIHJlcyA9IDxVcGxvYWQgey4uLnByb3BzQ29udHJvbH1cclxuICAgICAgICAgIGRvd25sb2FkVXJsPXt0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMuZG93bmxvYWRVcmx9XHJcbiAgICAgICAgICB1cGxvYWRVcmw9e3RoaXMucHJvcHMuYWRkaXRpb25hbFBhcmFtcy51cGxvYWRVcmx9IC8+O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYocHJvcHNDb250cm9sLnR5cGUgPT09IFwiZGF0ZVwiIHx8IFxyXG4gICAgICAgICAgcHJvcHNDb250cm9sLnR5cGUgPT09IFwidGltZVwiIHx8XHJcbiAgICAgICAgICBwcm9wc0NvbnRyb2wudHlwZSA9PT0gXCJkYXRldGltZVwiKXtcclxuICAgICAgICBwcm9wc0NvbnRyb2wuaXNGb3JtID0gdGhpcy5pc0Zvcm0ocGFyZW50SXRlbSk7XHJcbiAgICAgICAvLyBwcm9wc0NvbnRyb2wuZGF0ZUZvcm1hdCA9IG1vZGVsLmRhdGVGb3JtYXQ7XHJcbiAgICAgICAgcmVzID0gPERhdGVQaWNrZXIgey4uLnByb3BzQ29udHJvbH0gLz5cclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIGlmKHRoaXMuaXNGb3JtKHBhcmVudEl0ZW0pKXtcclxuICAgICAgICAgIHJlcyA9ICg8Rm9ybS5JbnB1dCB7Li4ucHJvcHNDb250cm9sfSAvPik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICByZXMgPSAoPElucHV0IHsuLi5wcm9wc0NvbnRyb2x9IC8+KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ3RleHRhcmVhJyl7XHJcbiAgICAgIHByb3BzQ29udHJvbC5wbGFjZWhvbGRlciA9IG1vZGVsLnBsYWNlaG9sZGVyO1xyXG4gICAgICBwcm9wc0NvbnRyb2wucm93cyA9IChtb2RlbC5yb3dzICE9PSBudWxsICYmIG1vZGVsLnJvd3MgIT09IHVuZGVmaW5lZCkgPyBOdW1iZXIobW9kZWwucm93cykgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBpZihtb2RlbC5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmxhYmVsICE9PSBcIlwiKVxyXG4gICAgICAgIHByb3BzQ29udHJvbC5sYWJlbCA9IG1vZGVsLmxhYmVsO1xyXG5cclxuICAgICAgcHJvcHNDb250cm9sLmF1dG9IZWlnaHQgPSBtb2RlbC5hdXRvSGVpZ2h0O1xyXG4gICAgICBwcm9wc0NvbnRyb2wucmVhZE9ubHkgPSBtb2RlbC5yZWFkT25seSB8fCB0aGlzLnByb3BzLnJlYWRPbmx5O1xyXG5cclxuICAgICAgaWYoaGFuZGxlRXZlbnQgIT09IG51bGwpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUsIHtuYW1lLCB2YWx1ZX0pe1xyXG4gICAgICAgICAgaGFuZGxlRXZlbnQoe3N5bnRoZXRpY0V2ZW50OiBlLCBrZXk6IHByb3BzQ29udHJvbC5uYW1lLCBldmVudE5hbWU6IFwib25DaGFuZ2VcIiwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYoZGF0YSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgcHJvcHNDb250cm9sLnZhbHVlID0gZGF0YVtwcm9wc0NvbnRyb2wubmFtZV07XHJcblxyXG4gICAgICBpZih0eXBlb2YgZXJyb3JzID09PSBcIm9iamVjdFwiICYmIGVycm9yc1ttb2RlbC5rZXldICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5lcnJvciA9IEJvb2xlYW4oZXJyb3JzW21vZGVsLmtleV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLmlzRm9ybShwYXJlbnRJdGVtKSl7XHJcbiAgICAgICAgcmVzID0gKDxGb3JtLlRleHRBcmVhIHsuLi5wcm9wc0NvbnRyb2x9IC8+KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIHJlcyA9ICg8VGV4dEFyZWEgey4uLnByb3BzQ29udHJvbH0gLz4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHR5cGUgPT09ICdjaGVja2JveCcpe1xyXG5cclxuICAgICAgaWYobW9kZWwubGFiZWwgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5sYWJlbCAhPT0gXCJcIilcclxuICAgICAgICBwcm9wc0NvbnRyb2wubGFiZWw9IG1vZGVsLmxhYmVsO1xyXG5cclxuICAgICAgcHJvcHNDb250cm9sLnBsYWNlaG9sZGVyPW1vZGVsLnBsYWNlaG9sZGVyO1xyXG4gICAgICBwcm9wc0NvbnRyb2wudHlwZT1tb2RlbC50eXBlO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuZGlzYWJsZWQ9bW9kZWwuZGlzYWJsZWQ7XHJcbiAgICAgIHByb3BzQ29udHJvbC5maXR0ZWQ9bW9kZWwuZml0dGVkO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuaW5kZXRlcm1pbmF0ZT1tb2RlbC5pbmRldGVybWluYXRlOyBcclxuICAgICAgcHJvcHNDb250cm9sLnJlYWRPbmx5PW1vZGVsLnJlYWRPbmx5IHx8IHRoaXMucHJvcHMucmVhZE9ubHk7XHJcbiAgICAgIHByb3BzQ29udHJvbC5zbGlkZXI9bW9kZWwuc2xpZGVyO1xyXG4gICAgICBwcm9wc0NvbnRyb2wudG9nZ2xlPW1vZGVsLnRvZ2dsZTtcclxuICAgICAgXHJcbiAgICAgIGlmKGhhbmRsZUV2ZW50ICE9PSBudWxsKXtcclxuICAgICAgICBwcm9wc0NvbnRyb2wub25DaGFuZ2UgPSBmdW5jdGlvbihlLCB7bmFtZSwgY2hlY2tlZH0pe1xyXG4gICAgICAgICAgaGFuZGxlRXZlbnQoe3N5bnRoZXRpY0V2ZW50OiBlLCBrZXk6IHByb3BzQ29udHJvbC5uYW1lLCBldmVudE5hbWU6IFwib25DaGFuZ2VcIiwgbmFtZTogbmFtZSwgdmFsdWU6IGNoZWNrZWR9KTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihkYXRhICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGlmKHR5cGVvZih2YXJpYWJsZSkgPT09IFwiYm9vbGVhblwiKXtcclxuICAgICAgICAgIHByb3BzQ29udHJvbC5jaGVja2VkID0gZGF0YVtwcm9wc0NvbnRyb2wubmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZGF0YVtwcm9wc0NvbnRyb2wubmFtZV0gPT09IFwidHJ1ZVwiIHx8IGRhdGFbcHJvcHNDb250cm9sLm5hbWVdID09PSBcIjFcIil7XHJcbiAgICAgICAgICBwcm9wc0NvbnRyb2wuY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgIGlmKGRhdGFbcHJvcHNDb250cm9sLm5hbWVdID09PSBcImZhbHNlXCIgfHwgZGF0YVtwcm9wc0NvbnRyb2wubmFtZV0gPT09IFwiMFwiKXtcclxuICAgICAgICAgIHByb3BzQ29udHJvbC5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICBwcm9wc0NvbnRyb2wuY2hlY2tlZCA9IEJvb2xlYW4oZGF0YVtwcm9wc0NvbnRyb2wubmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodHlwZW9mIGVycm9ycyA9PT0gXCJvYmplY3RcIiAmJiBlcnJvcnNbbW9kZWwua2V5XSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBwcm9wc0NvbnRyb2wuZXJyb3IgPSBCb29sZWFuKGVycm9yc1ttb2RlbC5rZXldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy5pc0Zvcm0ocGFyZW50SXRlbSkpe1xyXG4gICAgICAgIHJlcyA9ICg8Rm9ybS5DaGVja2JveCB7Li4ucHJvcHNDb250cm9sfSAvPik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICByZXMgPSAoPENoZWNrYm94IHsuLi5wcm9wc0NvbnRyb2x9IC8+KTtcclxuICAgICAgfSBcclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ2Ryb3Bkb3duJyl7XHJcbiAgICAgIHZhciBvcHRpb25zID0gW107XHJcbiAgICAgIGlmKG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXSkpe1xyXG4gICAgICAgICAgb3B0aW9ucyA9IG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgIG9wdGlvbnMgPSBKU09ONS5wYXJzZShtb2RlbFtcImRhdGEtZWxlbWVudHNcIl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYobW9kZWwubGFiZWwgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5sYWJlbCAhPT0gXCJcIilcclxuICAgICAgICBwcm9wc0NvbnRyb2wubGFiZWwgPSBtb2RlbC5sYWJlbDtcclxuICAgICAgICBcclxuICAgICAgcHJvcHNDb250cm9sLmRlZmF1bHRWYWx1ZT1tb2RlbC5kZWZhdWx0dmFsdWU7XHJcbiAgICAgIHByb3BzQ29udHJvbC5wbGFjZWhvbGRlcj1tb2RlbC5wbGFjZWhvbGRlcjtcclxuICAgICAgcHJvcHNDb250cm9sLm9wdGlvbnM9b3B0aW9ucztcclxuICAgICAgcHJvcHNDb250cm9sLmxvYWRpbmc9bW9kZWwubG9hZGluZztcclxuICAgICAgcHJvcHNDb250cm9sLmVycm9yPW1vZGVsLmVycm9yO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuZmx1aWQ9bW9kZWwuZmx1aWQ7XHJcbiAgICAgIHByb3BzQ29udHJvbC5zZWxlY3Rpb249bW9kZWwuc2VsZWN0aW9uO1xyXG4gICAgICBwcm9wc0NvbnRyb2wubXVsdGlwbGU9bW9kZWwubXVsdGlwbGU7XHJcbiAgICAgIHByb3BzQ29udHJvbC5zZWFyY2g9bW9kZWwuc2VhcmNoO1xyXG4gICAgICBwcm9wc0NvbnRyb2wuZGlzYWJsZWQgPSBtb2RlbC5kaXNhYmxlZCB8fCBtb2RlbC5yZWFkT25seSB8fCB0aGlzLnByb3BzLnJlYWRPbmx5O1xyXG5cclxuICAgICAgaWYoZGF0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHByb3BzQ29udHJvbC52YWx1ZSA9IGRhdGFbcHJvcHNDb250cm9sLm5hbWVdO1xyXG4gICAgICAgIFxyXG4gICAgICBpZih0eXBlb2YgZXJyb3JzID09PSBcIm9iamVjdFwiICYmIGVycm9yc1ttb2RlbC5rZXldICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5lcnJvciA9IEJvb2xlYW4oZXJyb3JzW21vZGVsLmtleV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihoYW5kbGVFdmVudCAhPT0gbnVsbCl7XHJcbiAgICAgICAgcHJvcHNDb250cm9sLm9uQ2hhbmdlID0gZnVuY3Rpb24oZSwge25hbWUsIHZhbHVlfSl7XHJcbiAgICAgICAgICBoYW5kbGVFdmVudCh7c3ludGhldGljRXZlbnQ6IGUsIGtleTogcHJvcHNDb250cm9sLm5hbWUsIGV2ZW50TmFtZTogXCJvbkNoYW5nZVwiLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9wc0NvbnRyb2wuYWxsb3dBZGRpdGlvbnMgPSBtb2RlbC5hbGxvd0FkZEl0ZW1zO1xyXG4gICAgICBpZihwcm9wc0NvbnRyb2wuYWxsb3dBZGRpdGlvbnMpe1xyXG4gICAgICAgIHByb3BzQ29udHJvbC5vbkFkZEl0ZW0gPSBmdW5jdGlvbihlLCB7IHZhbHVlIH0pe1xyXG4gICAgICAgICAgbGV0IHYgPSBwcm9wc0NvbnRyb2wudmFsdWU7XHJcbiAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHYpKVxyXG4gICAgICAgICAgICB2LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdiA9IFt2YWx1ZV07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcHJvcHNDb250cm9sLm9uQ2hhbmdlKGUsIHtuYW1lOiBwcm9wc0NvbnRyb2wubmFtZSwgdmFsdWU6IHZ9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKHByb3BzQ29udHJvbC5tdWx0aXBsZSl7XHJcbiAgICAgICAgaWYocHJvcHNDb250cm9sLnZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHNDb250cm9sLnZhbHVlID09PSBudWxsKXtcclxuICAgICAgICAgIHByb3BzQ29udHJvbC52YWx1ZSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkocHJvcHNDb250cm9sLnZhbHVlKSl7XHJcbiAgICAgICAgICBsZXQgdmFsdWVBcnJheTtcclxuICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgdmFsdWVBcnJheSA9IEpTT041LnBhcnNlKHByb3BzQ29udHJvbC52YWx1ZSk7XHJcbiAgICAgICAgICB9IFxyXG4gICAgICAgICAgY2F0Y2goZSl7fTtcclxuXHJcbiAgICAgICAgICBpZighQXJyYXkuaXNBcnJheSh2YWx1ZUFycmF5KSl7XHJcbiAgICAgICAgICAgIHZhbHVlQXJyYXkgPSBbcHJvcHNDb250cm9sLnZhbHVlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcHJvcHNDb250cm9sLnZhbHVlID0gdmFsdWVBcnJheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHByb3BzQ29udHJvbC5hbGxvd0FkZGl0aW9ucyl7XHJcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duQ2hlY2tBZGRpdGlvbmFsKHByb3BzQ29udHJvbC52YWx1ZSwgcHJvcHNDb250cm9sLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy5pc0Zvcm0ocGFyZW50SXRlbSkpe1xyXG4gICAgICAgIHJlcyA9ICg8Rm9ybS5Ecm9wZG93biB7Li4ucHJvcHNDb250cm9sfSAvPik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICByZXMgPSAoPERyb3Bkb3duIHsuLi5wcm9wc0NvbnRyb2x9IC8+KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ3N0YXRpc3RpYycpe1xyXG4gICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgaWYobW9kZWxbXCJkYXRhLWVsZW1lbnRzXCJdICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkobW9kZWxbXCJkYXRhLWVsZW1lbnRzXCJdKSl7XHJcbiAgICAgICAgICBpdGVtcyA9IG1vZGVsW1wiZGF0YS1lbGVtZW50c1wiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgIGl0ZW1zID0gSlNPTjUucGFyc2UobW9kZWxbXCJkYXRhLWVsZW1lbnRzXCJdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlcyA9ICg8U3RhdGlzdGljLkdyb3VwIHsuLi5wcm9wc0NvbnRyb2x9XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXRlZD17bW9kZWwuZmxvYXRlZH1cclxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsPXttb2RlbC5ob3Jpem9udGFsfVxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU9e21vZGVsLnNpemV9XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfS8+KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ2ltYWdlJyl7XHJcbiAgICAgICAgcmVzID0gKDxJbWFnZSB7Li4ucHJvcHNDb250cm9sfVxyXG4gICAgICAgICAgICAgICAgICAgICAgYXZhdGFyPXttb2RlbC5hdmF0YXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICBib3JkZXJlZD17bW9kZWwuYm9yZGVyZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJlZD17bW9kZWwuY2VudGVyZWR9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e21vZGVsLmRpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaW5saW5lPXttb2RlbC5pbmxpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICBocmVmPXt0aGlzLnByb3BzLmhyZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICBzcmM9e3RoaXMucHJvcHMuc3JjfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXRlZD17bW9kZWwuZmxvYXRlZH1cclxuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlPXttb2RlbC5zaGFwZX1cclxuICAgICAgICAgICAgICAgICAgICAgIHNwYWNlZD17bW9kZWwuc3BhY2VkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbj17bW9kZWwudmVydGljYWxBbGlnbn1cclxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17bW9kZWwuaGVpZ2h0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e21vZGVsLndpZHRofSAvPik7XHJcbiAgICB9XHJcblxyXG4gICAgZWxzZSBpZih0eXBlID09PSAnZm9ybScpe1xyXG4gICAgICAgICAgcmVzID0gKDxGb3JtIHsuLi5wcm9wc0NvbnRyb2x9XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICBzaXplPXttb2RlbC5zaXplfSBcclxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e21vZGVsLmxvYWRpbmd9XHJcbiAgICAgICAgICAgICAgICBlcnJvcj17bW9kZWwuZXJyb3J9XHJcbiAgICAgICAgICAgICAgICBpbnZlcnRlZD17bW9kZWwuaW52ZXJ0ZWR9XHJcbiAgICAgICAgICAgICAgICByZXBseT17bW9kZWwucmVwbHl9XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzPXttb2RlbC5zdWNjZXNzfVxyXG4gICAgICAgICAgICAgICAgd2FybmluZz17bW9kZWwud2FybmluZ30+XHJcbiAgICAgICAgICAgIDwvRm9ybT4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZih0eXBlID09PSAnZm9ybWdyb3VwJyl7XHJcbiAgICAgIHZhciB3aWR0aHMgPSBtb2RlbC53aWR0aHM7XHJcbiAgICAgIGlmKHdpZHRocyA9PT0gXCJjdXN0b21cIilcclxuICAgICAgICB3aWR0aHMgPSBtb2RlbC53aWR0aHNDdXN0b207XHJcbiAgICAgIFxyXG4gICAgICBpZihtb2RlbC5vcmllbnRhdGlvbilcclxuICAgICAgICBwcm9wc0NvbnRyb2xbbW9kZWwub3JpZW50YXRpb25dID0gdHJ1ZTtcclxuXHJcbiAgICAgIHJlcyA9ICg8Rm9ybS5Hcm91cCB7Li4ucHJvcHNDb250cm9sfVxyXG4gICAgICAgICAgICAgICAgd2lkdGhzPXt3aWR0aHN9XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59PlxyXG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodHlwZSA9PT0gJ2JyZWFkY3J1bWInKXtcclxuICAgICAgbGV0IGNoaWxkcmVuID0gW107XHJcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5pdGVtcykpe1xyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpIDwgdGhpcy5wcm9wcy5pdGVtcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMucHJvcHMuaXRlbXNbaV07XHJcbiAgICAgICAgICBsZXQgY2hpbGRQcm9wcyA9IHtrZXk6IGl9O1xyXG4gICAgICAgICAgY2hpbGRQcm9wcy5hY3RpdmUgPSBpdGVtLmFjdGl2ZTtcclxuICAgICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGl0ZW0udXJsO1xyXG4gICAgICAgICAgaWYoaGFuZGxlRXZlbnQgIT09IG51bGwpe1xyXG4gICAgICAgICAgICBjaGlsZFByb3BzLm9uQ2xpY2sgPSBmdW5jdGlvbihlLCB7bmFtZSwgY2hlY2tlZH0pe1xyXG4gICAgICAgICAgICAgIGhhbmRsZUV2ZW50KHtzeW50aGV0aWNFdmVudDogZSwga2V5OiBwcm9wc0NvbnRyb2wubmFtZSwgZXZlbnROYW1lOiBcIm9uSXRlbUNsaWNrXCIsIHBhcmFtZXRlcnM6IHt0YXJnZXQ6IGl0ZW0udXJsfX0pO1xyXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goPEJyZWFkY3J1bWIuU2VjdGlvbiB7Li4uY2hpbGRQcm9wc30+e2l0ZW0udGV4dCA9PT0gdW5kZWZpbmVkID8gXCI8bm90IHNldD5cIiA6IGl0ZW0udGV4dH08L0JyZWFkY3J1bWIuU2VjdGlvbj4pO1xyXG4gICAgICAgICAgaWYoaSA8IHRoaXMucHJvcHMuaXRlbXMubGVuZ3RoIC0gMSl7XHJcbiAgICAgICAgICAgIGxldCBkaXZpZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAga2V5OiBpICsgXCJfZFwiXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmKGl0ZW0uZGl2aWRlciAhPT0gXCJcIilcclxuICAgICAgICAgICAgICBkaXZpZGVyUHJvcHMuaWNvbiA9IGl0ZW0uZGl2aWRlcjtcclxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCg8QnJlYWRjcnVtYi5EaXZpZGVyIHsuLi5kaXZpZGVyUHJvcHN9IC8+KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmVzID0gPEJyZWFkY3J1bWIgey4uLnByb3BzQ29udHJvbH0gY2hpbGRyZW49e2NoaWxkcmVufSAvPjtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIHJlcyA9IDxzcGFuPlVua25vdyB0eXBlICd7dHlwZX0nIG9mICd7dGhpcy5wcm9wcy5uYW1lfScgZWxlbWVudC48L3NwYW4+O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIGlzRm9ybShtKXtcclxuICAgIHJldHVybiAobSAhPSBudWxsICYmIFxyXG4gICAgICAgIChtW1wiZGF0YS1idWlsZGVydHlwZVwiXSA9PT0gXCJmb3JtXCIgfHwgXHJcbiAgICAgICAgbVtcImRhdGEtYnVpbGRlcnR5cGVcIl0gPT09IFwiZm9ybWdyb3VwXCIpKTtcclxuICB9XHJcblxyXG4gIGRyb3Bkb3duQ2hlY2tBZGRpdGlvbmFsKHZhbHVlLCBvcHRpb25zKXtcclxuICAgIGlmKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2KXtcclxuICAgICAgbGV0IGlzRmluZCA9IGZhbHNlO1xyXG4gICAgICBmb3IobGV0IGk9MDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGxldCBvID0gb3B0aW9uc1tpXTtcclxuICAgICAgICBpZih2ID09PSBvLnZhbHVlKXtcclxuICAgICAgICAgIGlzRmluZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGlzRmluZCA9PSBmYWxzZSl7XHJcbiAgICAgICAgb3B0aW9ucy5wdXNoKHt2YWx1ZTogdiwgdGV4dDogdn0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29udHJvbC9zZW1hbnRpY2NvbnRyb2wuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBGb3JtLCBEcm9wZG93biwgQnV0dG9uIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnXHJcbmltcG9ydCBEcm9wem9uZUNvbXBvbmVudCBmcm9tICdyZWFjdC1kcm9wem9uZS1jb21wb25lbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJvcHpvbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGNvbW1hbmRzOiBwcm9wcy5jb21tYW5kcyxcclxuICAgICAgc3RhdGVzOiBwcm9wcy5zdGF0ZXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCl7XHJcbiAgICB0aGlzLmlzTW91bnQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcclxuICAgIHRoaXMuaXNNb3VudCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIFxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMuZGF0YTtcclxuICAgIHZhciBlcnJvcnMgPSB0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMuZXJyb3JzO1xyXG4gICAgdmFyIHBhcmVudEl0ZW0gPSB0aGlzLnByb3BzLmFkZGl0aW9uYWxQYXJhbXMucGFyZW50SXRlbTtcclxuICAgIHZhciBoYW5kbGVFdmVudCA9IHRoaXMucHJvcHMuYWRkaXRpb25hbFBhcmFtcy5oYW5kbGVFdmVudDtcclxuXHJcbiAgICB2YXIgaWNvbkZpbGV0eXBlcyA9IHVuZGVmaW5lZDtcclxuICAgIGlmKHRoaXMucHJvcHMuaWNvbkZpbGV0eXBlcyAhPSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5pY29uRmlsZXR5cGVzICE9IFwiXCIpe1xyXG4gICAgICBsZXQgdHlwZXMgPSB0aGlzLnByb3BzLmljb25GaWxldHlwZXMuc3BsaXQoXCIsXCIpO1xyXG4gICAgICBpZihBcnJheS5pc0FycmF5KHR5cGVzKSAmJiB0eXBlcy5sZW5ndGggPiAwKXtcclxuICAgICAgICBpY29uRmlsZXR5cGVzID0gW107XHJcbiAgICAgICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0KXtcclxuICAgICAgICAgIGljb25GaWxldHlwZXMucHVzaCh0LnRyaW0oKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGpzQ29uZmlnID0ge1xyXG4gICAgICBhZGRSZW1vdmVMaW5rczogdGhpcy5wcm9wcy5hZGRSZW1vdmVMaW5rcyxcclxuICAgICAgYXV0b1Byb2Nlc3NRdWV1ZTogdGhpcy5wcm9wcy5hdXRvUHJvY2Vzc1F1ZXVlICYmIHRoaXMucHJvcHMucG9zdFVybCAhPSB1bmRlZmluZWRcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNvbXBvbmVudENvbmZpZyA9IHtcclxuICAgICAgaWNvbkZpbGV0eXBlcyxcclxuICAgICAgc2hvd0ZpbGV0eXBlSWNvbjogdGhpcy5wcm9wcy5zaG93RmlsZXR5cGVJY29uLFxyXG4gICAgICBwb3N0VXJsOiB0aGlzLnByb3BzLnBvc3RVcmwgPT0gdW5kZWZpbmVkID8gXCJuby11cmxcIiA6IHRoaXMucHJvcHMucG9zdFVybFxyXG4gICAgfTtcclxuXHJcbiAgICBcclxuICAgIHZhciBldmVudEhhbmRsZXJzID0ge1xyXG4gICAgICBzdWNjZXNzOiBtZS5maWxlVXBsb2FkU3VjY2Vzcy5iaW5kKHRoaXMpXHJcbiAgICB9O1xyXG4gICAgLy8gaWYoaGFuZGxlRXZlbnQgIT0gdW5kZWZpbmVkKXtcclxuICAgIC8vICAgdmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XHJcbiAgICAvLyAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe1xyXG4gICAgLy8gICAgIGV2ZW50SGFuZGxlcnNbZV0gPSBoYW5kbGVFdmVudCh7IGtleTogbWUucHJvcHMubmFtZSwgZXZlbnROYW1lOiBlfSk7XHJcbiAgICAvLyAgIH0pO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGxldCBjb250cm9sID0gdGhpcy5wcm9wcy5yZWFkT25seSA/IFxyXG4gICAgICA8ZGl2PjwvZGl2PiA6IFxyXG4gICAgICA8RHJvcHpvbmVDb21wb25lbnQgY29uZmlnPXtjb21wb25lbnRDb25maWd9IGV2ZW50SGFuZGxlcnM9e2V2ZW50SGFuZGxlcnN9IGRqc0NvbmZpZz17ZGpzQ29uZmlnfSA+PC9Ecm9wem9uZUNvbXBvbmVudD47XHJcbiAgICBcclxuICAgIGxldCByZXMgPSB1bmRlZmluZWQ7XHJcbiAgICBpZih0aGlzLmlzRm9ybShwYXJlbnRJdGVtKSl7XHJcbiAgICAgIHJlcyA9IDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj57Y29udHJvbH08L2Rpdj47XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICByZXMgPSBjb250cm9sO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIGlzRm9ybShtKXtcclxuICAgIHJldHVybiAobSAhPSBudWxsICYmIFxyXG4gICAgICAgIChtW1wiZGF0YS1idWlsZGVydHlwZVwiXSA9PSBcImZvcm1cIiB8fCBcclxuICAgICAgICBtW1wiZGF0YS1idWlsZGVydHlwZVwiXSA9PSBcImZvcm1ncm91cFwiKSk7XHJcbiAgfTtcclxuXHJcbiAgZmlsZVVwbG9hZFN1Y2Nlc3MoZmlsZSwgcmVzcG9uc2Upe1xyXG4gICAgdmFyIGhhbmRsZUV2ZW50ID0gdGhpcy5wcm9wcy5hZGRpdGlvbmFsUGFyYW1zLmhhbmRsZUV2ZW50O1xyXG4gICAgaWYoaGFuZGxlRXZlbnQgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgaGFuZGxlRXZlbnQoe2tleTogdGhpcy5wcm9wcy5uYW1lLCBcclxuICAgICAgICBldmVudE5hbWU6IFwic3VjY2Vzc1wiLCBcclxuICAgICAgICBuYW1lOiB0aGlzLnByb3BzLm5hbWUsIFxyXG4gICAgICAgIHZhbHVlOiByZXNwb25zZS5tZXNzYWdlLFxyXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcclxuICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgIHRva2VuOiByZXNwb25zZS5tZXNzYWdlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICBmaWxlLl9yZW1vdmVMaW5rLmNsaWNrKCk7XHJcbiAgICAgIH0sNTAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEV2ZW50cygpe1xyXG4gICAgcmV0dXJuIFtcImRyb3BcIiwgXHJcbiAgICAgIFwiZHJhZ3N0YXJ0XCIsXHJcbiAgICAgIFwiZHJhZ2VuZFwiLFxyXG4gICAgICBcImRyYWdlbnRlclwiLFxyXG4gICAgICBcImRyYWdvdmVyXCIsXHJcbiAgICAgIFwiZHJhZ2xlYXZlXCIsXHJcbiAgICAgIFwiYWRkZWRmaWxlXCIsXHJcbiAgICAgIFwicmVtb3ZlZGZpbGVcIixcclxuICAgICAgXCJ0aHVtYm5haWxcIixcclxuICAgICAgXCJlcnJvclwiLFxyXG4gICAgICBcInByb2Nlc3NpbmdcIixcclxuICAgICAgXCJ1cGxvYWRwcm9ncmVzc1wiLFxyXG4gICAgICBcInNlbmRpbmdcIixcclxuICAgICAgXCJzdWNjZXNzXCIsXHJcbiAgICAgIFwiY29tcGxldGVcIixcclxuICAgICAgXCJjYW5jZWxlZFwiLFxyXG4gICAgICBcIm1heGZpbGVzcmVhY2hlZFwiLFxyXG4gICAgICBcIm1heGZpbGVzZXhjZWVkZWRcIixcclxuICAgICAgXCJwcm9jZXNzaW5nbXVsdGlwbGVcIixcclxuICAgICAgXCJzZW5kaW5nbXVsdGlwbGVcIixcclxuICAgICAgXCJzdWNjZXNzbXVsdGlwbGVcIixcclxuICAgICAgXCJjb21wbGV0ZW11bHRpcGxlXCIsXHJcbiAgICAgIFwiY2FuY2VsZWRtdWx0aXBsZVwiLFxyXG4gICAgICBcInRvdGFsdXBsb2FkcHJvZ3Jlc3NcIixcclxuICAgICAgXCJyZXNldFwiLFxyXG4gICAgICBcInF1ZXVlY29tcGxldGVkXCJdO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL2Ryb3B6b25lLmpzeCIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcInJlYWN0XCIpLHJlcXVpcmUoXCJyZWFjdC1kb21cIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wicmVhY3RcIixcInJlYWN0LWRvbVwiXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlJlYWN0RHJvcHpvbmU9dChyZXF1aXJlKFwicmVhY3RcIikscmVxdWlyZShcInJlYWN0LWRvbVwiKSk6ZS5SZWFjdERyb3B6b25lPXQoZS5SZWFjdCxlLlJlYWN0RE9NKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoaSl7aWYobltpXSlyZXR1cm4gbltpXS5leHBvcnRzO3ZhciByPW5baV09e2k6aSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2ldLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLHQpLHIubD0hMCxyLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4saSl7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDppfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xKX0oW2Z1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkRyb3B6b25lQ29tcG9uZW50PXZvaWQgMDt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaS5rZXksaSl9fXJldHVybiBmdW5jdGlvbih0LG4saSl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksaSYmZSh0LGkpLHR9fSgpLG89aShuKDApKSxzPWkobigyKSksYT1pKG4oMykpLGw9big0KSx1PW51bGwsYz10LkRyb3B6b25lQ29tcG9uZW50PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KTt2YXIgbj1mdW5jdGlvbihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fSh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMsZSkpO3JldHVybiBuLnN0YXRlPXtmaWxlczpbXX0sbn1yZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX0odCxvLmRlZmF1bHQuQ29tcG9uZW50KSxyKHQsW3trZXk6XCJnZXREanNDb25maWdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXt1cmw6dGhpcy5wcm9wcy5jb25maWcucG9zdFVybD90aGlzLnByb3BzLmNvbmZpZy5wb3N0VXJsOm51bGx9O3JldHVybiB0aGlzLnByb3BzLmRqc0NvbmZpZz8oMCxhLmRlZmF1bHQpKCEwLHt9LGUsdGhpcy5wcm9wcy5kanNDb25maWcpOmV9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0RGpzQ29uZmlnKCk7KHU9dXx8big1KSkuYXV0b0Rpc2NvdmVyPSExLHRoaXMucHJvcHMuY29uZmlnLnBvc3RVcmx8fHRoaXMucHJvcHMuZXZlbnRIYW5kbGVycy5kcm9wfHxjb25zb2xlLmluZm8oJ05laXRoZXIgcG9zdFVybCBub3IgYSBcImRyb3BcIiBldmVudEhhbmRsZXIgc3BlY2lmaWVkLCB0aGUgUmVhY3QtRHJvcHpvbmUgY29tcG9uZW50IG1pZ2h0IG1pc2JlaGF2ZS4nKTt2YXIgdD10aGlzLnByb3BzLmNvbmZpZy5kcm9wem9uZVNlbGVjdG9yfHxzLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7dGhpcy5kcm9wem9uZT1uZXcgdSh0LGUpLHRoaXMuc2V0dXBFdmVudHMoKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLmRyb3B6b25lKWlmKHRoaXMuZHJvcHpvbmUuZ2V0QWN0aXZlRmlsZXMoKS5sZW5ndGg+MCl7dGhpcy5xdWV1ZURlc3Ryb3k9ITA7dmFyIHQ9d2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCl7cmV0dXJuITE9PT1lLnF1ZXVlRGVzdHJveT93aW5kb3cuY2xlYXJJbnRlcnZhbCh0KTowPT09ZS5kcm9wem9uZS5nZXRBY3RpdmVGaWxlcygpLmxlbmd0aD8oZS5kcm9wem9uZT1lLmRlc3Ryb3koZS5kcm9wem9uZSksd2luZG93LmNsZWFySW50ZXJ2YWwodCkpOnZvaWQgMH0sNTAwKX1lbHNlIHRoaXMuZHJvcHpvbmU9dGhpcy5kZXN0cm95KHRoaXMuZHJvcHpvbmUpfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5xdWV1ZURlc3Ryb3k9ITEsIXRoaXMuZHJvcHpvbmUpe3ZhciBlPXRoaXMucHJvcHMuY29uZmlnLmRyb3B6b25lU2VsZWN0b3J8fHMuZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTt0aGlzLmRyb3B6b25lPW5ldyB1KGUsdGhpcy5nZXREanNDb25maWcoKSl9fX0se2tleTpcImNvbXBvbmVudFdpbGxVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9dm9pZCAwO2U9dGhpcy5wcm9wcy5kanNDb25maWc/dGhpcy5wcm9wcy5kanNDb25maWc6e307dHJ5e3Q9dGhpcy5wcm9wcy5jb25maWcucG9zdFVybD97dXJsOnRoaXMucHJvcHMuY29uZmlnLnBvc3RVcmx9Ont9fWNhdGNoKGUpe3Q9e319dGhpcy5kcm9wem9uZS5vcHRpb25zPSgwLGEuZGVmYXVsdCkoITAse30sdGhpcy5kcm9wem9uZS5vcHRpb25zLGUsdCl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1bXSx0PXRoaXMuc3RhdGUuZmlsZXMsbj10aGlzLnByb3BzLmNvbmZpZyxpPXRoaXMucHJvcHMuY2xhc3NOYW1lP1wiZmlsZXBpY2tlciBkcm9wem9uZSBcIit0aGlzLnByb3BzLmNsYXNzTmFtZTpcImZpbGVwaWNrZXIgZHJvcHpvbmVcIjtpZihuLnNob3dGaWxldHlwZUljb24mJm4uaWNvbkZpbGV0eXBlcyYmKCF0fHx0Lmxlbmd0aDwxKSlmb3IodmFyIHI9MDtyPHRoaXMucHJvcHMuY29uZmlnLmljb25GaWxldHlwZXMubGVuZ3RoO3IrPTEpZS5wdXNoKG8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KGwuSWNvbix7ZmlsZXR5cGU6bi5pY29uRmlsZXR5cGVzW3JdLGtleTpcImljb24tY29tcG9uZW50XCIrcn0pKTtyZXR1cm4hdGhpcy5wcm9wcy5jb25maWcucG9zdFVybCYmdGhpcy5wcm9wcy5hY3Rpb24/by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIse2FjdGlvbjp0aGlzLnByb3BzLmFjdGlvbixjbGFzc05hbWU6aX0sZSx0aGlzLnByb3BzLmNoaWxkcmVuKTpvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6aX0sXCIgXCIsZSxcIiBcIix0aGlzLnByb3BzLmNoaWxkcmVuLFwiIFwiKX19LHtrZXk6XCJzZXR1cEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMucHJvcHMuZXZlbnRIYW5kbGVycztpZih0aGlzLmRyb3B6b25lJiZ0KXtmb3IodmFyIG4gaW4gdClpZih0Lmhhc093blByb3BlcnR5KG4pJiZ0W25dKWlmKFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0W25dKSlmb3IodmFyIGk9MDtpPHRbbl0ubGVuZ3RoO2krPTEpXCJpbml0XCI9PT1uP3Rbbl1baV0odGhpcy5kcm9wem9uZSk6dGhpcy5kcm9wem9uZS5vbihuLHRbbl1baV0pO2Vsc2VcImluaXRcIj09PW4/dFtuXSh0aGlzLmRyb3B6b25lKTp0aGlzLmRyb3B6b25lLm9uKG4sdFtuXSk7dGhpcy5kcm9wem9uZS5vbihcImFkZGVkZmlsZVwiLGZ1bmN0aW9uKHQpe2lmKHQpe3ZhciBuPWUuc3RhdGUuZmlsZXN8fFtdO24ucHVzaCh0KSxlLnNldFN0YXRlKHtmaWxlczpufSl9fSksdGhpcy5kcm9wem9uZS5vbihcInJlbW92ZWRmaWxlXCIsZnVuY3Rpb24odCl7aWYodCl7dmFyIG49ZS5zdGF0ZS5maWxlc3x8W107bi5mb3JFYWNoKGZ1bmN0aW9uKGUsaSl7ZS5uYW1lPT09dC5uYW1lJiZlLnNpemU9PT10LnNpemUmJm4uc3BsaWNlKGksMSl9KSxlLnNldFN0YXRlKHtmaWxlczpufSl9fSl9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5vZmYoKSxlLmRlc3Ryb3koKX19XSksdH0oKTtjLmRlZmF1bHRQcm9wcz17ZGpzQ29uZmlnOnt9LGNvbmZpZzp7fSxldmVudEhhbmRsZXJzOnt9fSx0LmRlZmF1bHQ9Y30sZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkscj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkuaXNBcnJheT9BcnJheS5pc0FycmF5KGUpOlwiW29iamVjdCBBcnJheV1cIj09PXIuY2FsbChlKX0scz1mdW5jdGlvbihlKXtpZighZXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9PXIuY2FsbChlKSlyZXR1cm4hMTt2YXIgdCxuPWkuY2FsbChlLFwiY29uc3RydWN0b3JcIiksbz1lLmNvbnN0cnVjdG9yJiZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSYmaS5jYWxsKGUuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKTtpZihlLmNvbnN0cnVjdG9yJiYhbiYmIW8pcmV0dXJuITE7Zm9yKHQgaW4gZSk7cmV0dXJuIHZvaWQgMD09PXR8fGkuY2FsbChlLHQpfTtlLmV4cG9ydHM9ZnVuY3Rpb24gZSgpe3ZhciB0LG4saSxyLGEsbCx1PWFyZ3VtZW50c1swXSxjPTEsZD1hcmd1bWVudHMubGVuZ3RoLHA9ITE7Zm9yKFwiYm9vbGVhblwiPT10eXBlb2YgdSYmKHA9dSx1PWFyZ3VtZW50c1sxXXx8e30sYz0yKSwobnVsbD09dXx8XCJvYmplY3RcIiE9dHlwZW9mIHUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHUpJiYodT17fSk7YzxkOysrYylpZihudWxsIT0odD1hcmd1bWVudHNbY10pKWZvcihuIGluIHQpaT11W25dLHUhPT0ocj10W25dKSYmKHAmJnImJihzKHIpfHwoYT1vKHIpKSk/KGE/KGE9ITEsbD1pJiZvKGkpP2k6W10pOmw9aSYmcyhpKT9pOnt9LHVbbl09ZShwLGwscikpOnZvaWQgMCE9PXImJih1W25dPXIpKTtyZXR1cm4gdX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lkljb249dm9pZCAwO3ZhciBpLHI9bigwKSxvPShpPXIpJiZpLl9fZXNNb2R1bGU/aTp7ZGVmYXVsdDppfTt0Lkljb249ZnVuY3Rpb24oZSl7cmV0dXJuIG8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1maWxldHlwZVwiOmUuZmlsZXR5cGUsY2xhc3NOYW1lOlwiZmlsZXBpY2tlci1maWxlLWljb25cIn0pfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1yZXR1cm4gZnVuY3Rpb24odCxuLGkpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLGkmJmUodCxpKSx0fX0oKSxyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe24odGhpcyxlKX1yZXR1cm4gaShlLFt7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSx0aGlzLl9jYWxsYmFja3NbZV18fCh0aGlzLl9jYWxsYmFja3NbZV09W10pLHRoaXMuX2NhbGxiYWNrc1tlXS5wdXNoKHQpLHRoaXN9fSx7a2V5OlwiZW1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O3ZhciB0PXRoaXMuX2NhbGxiYWNrc1tlXTtpZih0KXtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxpPUFycmF5KG4+MT9uLTE6MCkscj0xO3I8bjtyKyspaVtyLTFdPWFyZ3VtZW50c1tyXTtmb3IodmFyIG89MCxzPXM9dDshKG8+PXMubGVuZ3RoKTspc1tvKytdLmFwcGx5KHRoaXMsaSl9cmV0dXJuIHRoaXN9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZighdGhpcy5fY2FsbGJhY2tzfHwwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXt9LHRoaXM7dmFyIG49dGhpcy5fY2FsbGJhY2tzW2VdO2lmKCFuKXJldHVybiB0aGlzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2VdLHRoaXM7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspaWYobltpXT09PXQpe24uc3BsaWNlKGksMSk7YnJlYWt9cmV0dXJuIHRoaXN9fV0pLGV9KCksbz1mdW5jdGlvbihlKXtmdW5jdGlvbiBvKGUsaSl7bih0aGlzLG8pO3ZhciByLHM9dCh0aGlzLChvLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKG8pKS5jYWxsKHRoaXMpKSxhPXZvaWQgMDtpZihzLmVsZW1lbnQ9ZSxzLnZlcnNpb249by52ZXJzaW9uLHMuZGVmYXVsdE9wdGlvbnMucHJldmlld1RlbXBsYXRlPXMuZGVmYXVsdE9wdGlvbnMucHJldmlld1RlbXBsYXRlLnJlcGxhY2UoL1xcbiovZyxcIlwiKSxzLmNsaWNrYWJsZUVsZW1lbnRzPVtdLHMubGlzdGVuZXJzPVtdLHMuZmlsZXM9W10sXCJzdHJpbmdcIj09dHlwZW9mIHMuZWxlbWVudCYmKHMuZWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHMuZWxlbWVudCkpLCFzLmVsZW1lbnR8fG51bGw9PXMuZWxlbWVudC5ub2RlVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRyb3B6b25lIGVsZW1lbnQuXCIpO2lmKHMuZWxlbWVudC5kcm9wem9uZSl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wem9uZSBhbHJlYWR5IGF0dGFjaGVkLlwiKTtvLmluc3RhbmNlcy5wdXNoKHMpLHMuZWxlbWVudC5kcm9wem9uZT1zO3ZhciBsLHU9bnVsbCE9KHI9by5vcHRpb25zRm9yRWxlbWVudChzLmVsZW1lbnQpKT9yOnt9O2lmKHMub3B0aW9ucz1vLmV4dGVuZCh7fSxzLmRlZmF1bHRPcHRpb25zLHUsbnVsbCE9aT9pOnt9KSxzLm9wdGlvbnMuZm9yY2VGYWxsYmFja3x8IW8uaXNCcm93c2VyU3VwcG9ydGVkKCkpcmV0dXJuIGw9cy5vcHRpb25zLmZhbGxiYWNrLmNhbGwocyksdChzLGwpO2lmKG51bGw9PXMub3B0aW9ucy51cmwmJihzLm9wdGlvbnMudXJsPXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikpLCFzLm9wdGlvbnMudXJsKXRocm93IG5ldyBFcnJvcihcIk5vIFVSTCBwcm92aWRlZC5cIik7aWYocy5vcHRpb25zLmFjY2VwdGVkRmlsZXMmJnMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcyl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgcHJvdmlkZSBib3RoICdhY2NlcHRlZEZpbGVzJyBhbmQgJ2FjY2VwdGVkTWltZVR5cGVzJy4gJ2FjY2VwdGVkTWltZVR5cGVzJyBpcyBkZXByZWNhdGVkLlwiKTtpZihzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUmJnMub3B0aW9ucy5jaHVua2luZyl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHNldCBib3RoOiB1cGxvYWRNdWx0aXBsZSBhbmQgY2h1bmtpbmcuXCIpO3JldHVybiBzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMmJihzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcz1zLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMsZGVsZXRlIHMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcyksbnVsbCE9cy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lJiYocy5vcHRpb25zLnJlbmFtZUZpbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHMub3B0aW9ucy5yZW5hbWVGaWxlbmFtZS5jYWxsKHMsZS5uYW1lLGUpfSkscy5vcHRpb25zLm1ldGhvZD1zLm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCksKGE9cy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpJiZhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSwhMSE9PXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lciYmKHMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lcj9zLnByZXZpZXdzQ29udGFpbmVyPW8uZ2V0RWxlbWVudChzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIsXCJwcmV2aWV3c0NvbnRhaW5lclwiKTpzLnByZXZpZXdzQ29udGFpbmVyPXMuZWxlbWVudCkscy5vcHRpb25zLmNsaWNrYWJsZSYmKCEwPT09cy5vcHRpb25zLmNsaWNrYWJsZT9zLmNsaWNrYWJsZUVsZW1lbnRzPVtzLmVsZW1lbnRdOnMuY2xpY2thYmxlRWxlbWVudHM9by5nZXRFbGVtZW50cyhzLm9wdGlvbnMuY2xpY2thYmxlLFwiY2xpY2thYmxlXCIpKSxzLmluaXQoKSxzfXJldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfShvLHIpLGkobyxudWxsLFt7a2V5OlwiaW5pdENsYXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3RvdHlwZS5FbWl0dGVyPXIsdGhpcy5wcm90b3R5cGUuZXZlbnRzPVtcImRyb3BcIixcImRyYWdzdGFydFwiLFwiZHJhZ2VuZFwiLFwiZHJhZ2VudGVyXCIsXCJkcmFnb3ZlclwiLFwiZHJhZ2xlYXZlXCIsXCJhZGRlZGZpbGVcIixcImFkZGVkZmlsZXNcIixcInJlbW92ZWRmaWxlXCIsXCJ0aHVtYm5haWxcIixcImVycm9yXCIsXCJlcnJvcm11bHRpcGxlXCIsXCJwcm9jZXNzaW5nXCIsXCJwcm9jZXNzaW5nbXVsdGlwbGVcIixcInVwbG9hZHByb2dyZXNzXCIsXCJ0b3RhbHVwbG9hZHByb2dyZXNzXCIsXCJzZW5kaW5nXCIsXCJzZW5kaW5nbXVsdGlwbGVcIixcInN1Y2Nlc3NcIixcInN1Y2Nlc3NtdWx0aXBsZVwiLFwiY2FuY2VsZWRcIixcImNhbmNlbGVkbXVsdGlwbGVcIixcImNvbXBsZXRlXCIsXCJjb21wbGV0ZW11bHRpcGxlXCIsXCJyZXNldFwiLFwibWF4ZmlsZXNleGNlZWRlZFwiLFwibWF4ZmlsZXNyZWFjaGVkXCIsXCJxdWV1ZWNvbXBsZXRlXCJdLHRoaXMucHJvdG90eXBlLmRlZmF1bHRPcHRpb25zPXt1cmw6bnVsbCxtZXRob2Q6XCJwb3N0XCIsd2l0aENyZWRlbnRpYWxzOiExLHRpbWVvdXQ6M2U0LHBhcmFsbGVsVXBsb2FkczoyLHVwbG9hZE11bHRpcGxlOiExLGNodW5raW5nOiExLGZvcmNlQ2h1bmtpbmc6ITEsY2h1bmtTaXplOjJlNixwYXJhbGxlbENodW5rVXBsb2FkczohMSxyZXRyeUNodW5rczohMSxyZXRyeUNodW5rc0xpbWl0OjMsbWF4RmlsZXNpemU6MjU2LHBhcmFtTmFtZTpcImZpbGVcIixjcmVhdGVJbWFnZVRodW1ibmFpbHM6ITAsbWF4VGh1bWJuYWlsRmlsZXNpemU6MTAsdGh1bWJuYWlsV2lkdGg6MTIwLHRodW1ibmFpbEhlaWdodDoxMjAsdGh1bWJuYWlsTWV0aG9kOlwiY3JvcFwiLHJlc2l6ZVdpZHRoOm51bGwscmVzaXplSGVpZ2h0Om51bGwscmVzaXplTWltZVR5cGU6bnVsbCxyZXNpemVRdWFsaXR5Oi44LHJlc2l6ZU1ldGhvZDpcImNvbnRhaW5cIixmaWxlc2l6ZUJhc2U6MWUzLG1heEZpbGVzOm51bGwsaGVhZGVyczpudWxsLGNsaWNrYWJsZTohMCxpZ25vcmVIaWRkZW5GaWxlczohMCxhY2NlcHRlZEZpbGVzOm51bGwsYWNjZXB0ZWRNaW1lVHlwZXM6bnVsbCxhdXRvUHJvY2Vzc1F1ZXVlOiEwLGF1dG9RdWV1ZTohMCxhZGRSZW1vdmVMaW5rczohMSxwcmV2aWV3c0NvbnRhaW5lcjpudWxsLGhpZGRlbklucHV0Q29udGFpbmVyOlwiYm9keVwiLGNhcHR1cmU6bnVsbCxyZW5hbWVGaWxlbmFtZTpudWxsLHJlbmFtZUZpbGU6bnVsbCxmb3JjZUZhbGxiYWNrOiExLGRpY3REZWZhdWx0TWVzc2FnZTpcIkRyb3AgZmlsZXMgaGVyZSB0byB1cGxvYWRcIixkaWN0RmFsbGJhY2tNZXNzYWdlOlwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZHJhZyduJ2Ryb3AgZmlsZSB1cGxvYWRzLlwiLGRpY3RGYWxsYmFja1RleHQ6XCJQbGVhc2UgdXNlIHRoZSBmYWxsYmFjayBmb3JtIGJlbG93IHRvIHVwbG9hZCB5b3VyIGZpbGVzIGxpa2UgaW4gdGhlIG9sZGVuIGRheXMuXCIsZGljdEZpbGVUb29CaWc6XCJGaWxlIGlzIHRvbyBiaWcgKHt7ZmlsZXNpemV9fU1pQikuIE1heCBmaWxlc2l6ZToge3ttYXhGaWxlc2l6ZX19TWlCLlwiLGRpY3RJbnZhbGlkRmlsZVR5cGU6XCJZb3UgY2FuJ3QgdXBsb2FkIGZpbGVzIG9mIHRoaXMgdHlwZS5cIixkaWN0UmVzcG9uc2VFcnJvcjpcIlNlcnZlciByZXNwb25kZWQgd2l0aCB7e3N0YXR1c0NvZGV9fSBjb2RlLlwiLGRpY3RDYW5jZWxVcGxvYWQ6XCJDYW5jZWwgdXBsb2FkXCIsZGljdFVwbG9hZENhbmNlbGVkOlwiVXBsb2FkIGNhbmNlbGVkLlwiLGRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb246XCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2FuY2VsIHRoaXMgdXBsb2FkP1wiLGRpY3RSZW1vdmVGaWxlOlwiUmVtb3ZlIGZpbGVcIixkaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbjpudWxsLGRpY3RNYXhGaWxlc0V4Y2VlZGVkOlwiWW91IGNhbiBub3QgdXBsb2FkIGFueSBtb3JlIGZpbGVzLlwiLGRpY3RGaWxlU2l6ZVVuaXRzOnt0YjpcIlRCXCIsZ2I6XCJHQlwiLG1iOlwiTUJcIixrYjpcIktCXCIsYjpcImJcIn0saW5pdDpmdW5jdGlvbigpe30scGFyYW1zOmZ1bmN0aW9uKGUsdCxuKXtpZihuKXJldHVybntkenV1aWQ6bi5maWxlLnVwbG9hZC51dWlkLGR6Y2h1bmtpbmRleDpuLmluZGV4LGR6dG90YWxmaWxlc2l6ZTpuLmZpbGUuc2l6ZSxkemNodW5rc2l6ZTp0aGlzLm9wdGlvbnMuY2h1bmtTaXplLGR6dG90YWxjaHVua2NvdW50Om4uZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50LGR6Y2h1bmtieXRlb2Zmc2V0Om4uaW5kZXgqdGhpcy5vcHRpb25zLmNodW5rU2l6ZX19LGFjY2VwdDpmdW5jdGlvbihlLHQpe3JldHVybiB0KCl9LGNodW5rc1VwbG9hZGVkOmZ1bmN0aW9uKGUsdCl7dCgpfSxmYWxsYmFjazpmdW5jdGlvbigpe3ZhciBlPXZvaWQgMDt0aGlzLmVsZW1lbnQuY2xhc3NOYW1lPXRoaXMuZWxlbWVudC5jbGFzc05hbWUrXCIgZHotYnJvd3Nlci1ub3Qtc3VwcG9ydGVkXCI7Zm9yKHZhciB0PTAsbj1uPXRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKTshKHQ+PW4ubGVuZ3RoKTspe3ZhciBpPW5bdCsrXTtpZigvKF58IClkei1tZXNzYWdlKCR8ICkvLnRlc3QoaS5jbGFzc05hbWUpKXtlPWksaS5jbGFzc05hbWU9XCJkei1tZXNzYWdlXCI7YnJlYWt9fWV8fChlPW8uY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cImR6LW1lc3NhZ2VcIj48c3Bhbj48L3NwYW4+PC9kaXY+JyksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGUpKTt2YXIgcj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3BhblwiKVswXTtyZXR1cm4gciYmKG51bGwhPXIudGV4dENvbnRlbnQ/ci50ZXh0Q29udGVudD10aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrTWVzc2FnZTpudWxsIT1yLmlubmVyVGV4dCYmKHIuaW5uZXJUZXh0PXRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlKSksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0RmFsbGJhY2tGb3JtKCkpfSxyZXNpemU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9e3NyY1g6MCxzcmNZOjAsc3JjV2lkdGg6ZS53aWR0aCxzcmNIZWlnaHQ6ZS5oZWlnaHR9LG89ZS53aWR0aC9lLmhlaWdodDtudWxsPT10JiZudWxsPT1uPyh0PXIuc3JjV2lkdGgsbj1yLnNyY0hlaWdodCk6bnVsbD09dD90PW4qbzpudWxsPT1uJiYobj10L28pO3ZhciBzPSh0PU1hdGgubWluKHQsci5zcmNXaWR0aCkpLyhuPU1hdGgubWluKG4sci5zcmNIZWlnaHQpKTtpZihyLnNyY1dpZHRoPnR8fHIuc3JjSGVpZ2h0Pm4paWYoXCJjcm9wXCI9PT1pKW8+cz8oci5zcmNIZWlnaHQ9ZS5oZWlnaHQsci5zcmNXaWR0aD1yLnNyY0hlaWdodCpzKTooci5zcmNXaWR0aD1lLndpZHRoLHIuc3JjSGVpZ2h0PXIuc3JjV2lkdGgvcyk7ZWxzZXtpZihcImNvbnRhaW5cIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByZXNpemVNZXRob2QgJ1wiK2krXCInXCIpO28+cz9uPXQvbzp0PW4qb31yZXR1cm4gci5zcmNYPShlLndpZHRoLXIuc3JjV2lkdGgpLzIsci5zcmNZPShlLmhlaWdodC1yLnNyY0hlaWdodCkvMixyLnRyZ1dpZHRoPXQsci50cmdIZWlnaHQ9bixyfSx0cmFuc2Zvcm1GaWxlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuKHRoaXMub3B0aW9ucy5yZXNpemVXaWR0aHx8dGhpcy5vcHRpb25zLnJlc2l6ZUhlaWdodCkmJmUudHlwZS5tYXRjaCgvaW1hZ2UuKi8pP3RoaXMucmVzaXplSW1hZ2UoZSx0aGlzLm9wdGlvbnMucmVzaXplV2lkdGgsdGhpcy5vcHRpb25zLnJlc2l6ZUhlaWdodCx0aGlzLm9wdGlvbnMucmVzaXplTWV0aG9kLHQpOnQoZSl9LHByZXZpZXdUZW1wbGF0ZTonPGRpdiBjbGFzcz1cImR6LXByZXZpZXcgZHotZmlsZS1wcmV2aWV3XCI+XFxuICA8ZGl2IGNsYXNzPVwiZHotaW1hZ2VcIj48aW1nIGRhdGEtZHotdGh1bWJuYWlsIC8+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiZHotZGV0YWlsc1wiPlxcbiAgICA8ZGl2IGNsYXNzPVwiZHotc2l6ZVwiPjxzcGFuIGRhdGEtZHotc2l6ZT48L3NwYW4+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJkei1maWxlbmFtZVwiPjxzcGFuIGRhdGEtZHotbmFtZT48L3NwYW4+PC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJkei1wcm9ncmVzc1wiPjxzcGFuIGNsYXNzPVwiZHotdXBsb2FkXCIgZGF0YS1kei11cGxvYWRwcm9ncmVzcz48L3NwYW4+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiZHotZXJyb3ItbWVzc2FnZVwiPjxzcGFuIGRhdGEtZHotZXJyb3JtZXNzYWdlPjwvc3Bhbj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJkei1zdWNjZXNzLW1hcmtcIj5cXG4gICAgPHN2ZyB3aWR0aD1cIjU0cHhcIiBoZWlnaHQ9XCI1NHB4XCIgdmlld0JveD1cIjAgMCA1NCA1NFwiIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6c2tldGNoPVwiaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zXCI+XFxuICAgICAgPHRpdGxlPkNoZWNrPC90aXRsZT5cXG4gICAgICA8ZGVmcz48L2RlZnM+XFxuICAgICAgPGcgaWQ9XCJQYWdlLTFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIHNrZXRjaDp0eXBlPVwiTVNQYWdlXCI+XFxuICAgICAgICA8cGF0aCBkPVwiTTIzLjUsMzEuODQzMTQ1OCBMMTcuNTg1MjQxOSwyNS45MjgzODc3IEMxNi4wMjQ4MjUzLDI0LjM2Nzk3MTEgMTMuNDkxMDI5NCwyNC4zNjY4MzUgMTEuOTI4OTMyMiwyNS45Mjg5MzIyIEMxMC4zNzAwMTM2LDI3LjQ4Nzg1MDggMTAuMzY2NTkxMiwzMC4wMjM0NDU1IDExLjkyODM4NzcsMzEuNTg1MjQxOSBMMjAuNDE0NzU4MSw0MC4wNzE2MTIzIEMyMC41MTMzOTk5LDQwLjE3MDI1NDEgMjAuNjE1OTMxNSw0MC4yNjI2NjQ5IDIwLjcyMTg2MTUsNDAuMzQ4ODQzNSBDMjIuMjgzNTY2OSw0MS44NzI1NjUxIDI0Ljc5NDIzNCw0MS44NjI2MjAyIDI2LjM0NjE1NjQsNDAuMzEwNjk3OCBMNDMuMzEwNjk3OCwyMy4zNDYxNTY0IEM0NC44NzcxMDIxLDIxLjc3OTc1MjEgNDQuODc1ODA1NywxOS4yNDgzODg3IDQzLjMxMzcwODUsMTcuNjg2MjkxNSBDNDEuNzU0Nzg5OSwxNi4xMjczNzI5IDM5LjIxNzYwMzUsMTYuMTI1NTQyMiAzNy42NTM4NDM2LDE3LjY4OTMwMjIgTDIzLjUsMzEuODQzMTQ1OCBaIE0yNyw1MyBDNDEuMzU5NDAzNSw1MyA1Myw0MS4zNTk0MDM1IDUzLDI3IEM1MywxMi42NDA1OTY1IDQxLjM1OTQwMzUsMSAyNywxIEMxMi42NDA1OTY1LDEgMSwxMi42NDA1OTY1IDEsMjcgQzEsNDEuMzU5NDAzNSAxMi42NDA1OTY1LDUzIDI3LDUzIFpcIiBpZD1cIk92YWwtMlwiIHN0cm9rZS1vcGFjaXR5PVwiMC4xOTg3OTQxNThcIiBzdHJva2U9XCIjNzQ3NDc0XCIgZmlsbC1vcGFjaXR5PVwiMC44MTY1MTk0NzVcIiBmaWxsPVwiI0ZGRkZGRlwiIHNrZXRjaDp0eXBlPVwiTVNTaGFwZUdyb3VwXCI+PC9wYXRoPlxcbiAgICAgIDwvZz5cXG4gICAgPC9zdmc+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJkei1lcnJvci1tYXJrXCI+XFxuICAgIDxzdmcgd2lkdGg9XCI1NHB4XCIgaGVpZ2h0PVwiNTRweFwiIHZpZXdCb3g9XCIwIDAgNTQgNTRcIiB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOnNrZXRjaD1cImh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9uc1wiPlxcbiAgICAgIDx0aXRsZT5FcnJvcjwvdGl0bGU+XFxuICAgICAgPGRlZnM+PC9kZWZzPlxcbiAgICAgIDxnIGlkPVwiUGFnZS0xXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBza2V0Y2g6dHlwZT1cIk1TUGFnZVwiPlxcbiAgICAgICAgPGcgaWQ9XCJDaGVjay0rLU92YWwtMlwiIHNrZXRjaDp0eXBlPVwiTVNMYXllckdyb3VwXCIgc3Ryb2tlPVwiIzc0NzQ3NFwiIHN0cm9rZS1vcGFjaXR5PVwiMC4xOTg3OTQxNThcIiBmaWxsPVwiI0ZGRkZGRlwiIGZpbGwtb3BhY2l0eT1cIjAuODE2NTE5NDc1XCI+XFxuICAgICAgICAgIDxwYXRoIGQ9XCJNMzIuNjU2ODU0MiwyOSBMMzguMzEwNjk3OCwyMy4zNDYxNTY0IEMzOS44NzcxMDIxLDIxLjc3OTc1MjEgMzkuODc1ODA1NywxOS4yNDgzODg3IDM4LjMxMzcwODUsMTcuNjg2MjkxNSBDMzYuNzU0Nzg5OSwxNi4xMjczNzI5IDM0LjIxNzYwMzUsMTYuMTI1NTQyMiAzMi42NTM4NDM2LDE3LjY4OTMwMjIgTDI3LDIzLjM0MzE0NTggTDIxLjM0NjE1NjQsMTcuNjg5MzAyMiBDMTkuNzgyMzk2NSwxNi4xMjU1NDIyIDE3LjI0NTIxMDEsMTYuMTI3MzcyOSAxNS42ODYyOTE1LDE3LjY4NjI5MTUgQzE0LjEyNDE5NDMsMTkuMjQ4Mzg4NyAxNC4xMjI4OTc5LDIxLjc3OTc1MjEgMTUuNjg5MzAyMiwyMy4zNDYxNTY0IEwyMS4zNDMxNDU4LDI5IEwxNS42ODkzMDIyLDM0LjY1Mzg0MzYgQzE0LjEyMjg5NzksMzYuMjIwMjQ3OSAxNC4xMjQxOTQzLDM4Ljc1MTYxMTMgMTUuNjg2MjkxNSw0MC4zMTM3MDg1IEMxNy4yNDUyMTAxLDQxLjg3MjYyNzEgMTkuNzgyMzk2NSw0MS44NzQ0NTc4IDIxLjM0NjE1NjQsNDAuMzEwNjk3OCBMMjcsMzQuNjU2ODU0MiBMMzIuNjUzODQzNiw0MC4zMTA2OTc4IEMzNC4yMTc2MDM1LDQxLjg3NDQ1NzggMzYuNzU0Nzg5OSw0MS44NzI2MjcxIDM4LjMxMzcwODUsNDAuMzEzNzA4NSBDMzkuODc1ODA1NywzOC43NTE2MTEzIDM5Ljg3NzEwMjEsMzYuMjIwMjQ3OSAzOC4zMTA2OTc4LDM0LjY1Mzg0MzYgTDMyLjY1Njg1NDIsMjkgWiBNMjcsNTMgQzQxLjM1OTQwMzUsNTMgNTMsNDEuMzU5NDAzNSA1MywyNyBDNTMsMTIuNjQwNTk2NSA0MS4zNTk0MDM1LDEgMjcsMSBDMTIuNjQwNTk2NSwxIDEsMTIuNjQwNTk2NSAxLDI3IEMxLDQxLjM1OTQwMzUgMTIuNjQwNTk2NSw1MyAyNyw1MyBaXCIgaWQ9XCJPdmFsLTJcIiBza2V0Y2g6dHlwZT1cIk1TU2hhcGVHcm91cFwiPjwvcGF0aD5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L2c+XFxuICAgIDwvc3ZnPlxcbiAgPC9kaXY+XFxuPC9kaXY+Jyxkcm9wOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWRyYWctaG92ZXJcIil9LGRyYWdzdGFydDpmdW5jdGlvbihlKXt9LGRyYWdlbmQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKX0sZHJhZ2VudGVyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWRyYWctaG92ZXJcIil9LGRyYWdvdmVyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWRyYWctaG92ZXJcIil9LGRyYWdsZWF2ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1kcmFnLWhvdmVyXCIpfSxwYXN0ZTpmdW5jdGlvbihlKXt9LHJlc2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotc3RhcnRlZFwiKX0sYWRkZWRmaWxlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYodGhpcy5lbGVtZW50PT09dGhpcy5wcmV2aWV3c0NvbnRhaW5lciYmdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1zdGFydGVkXCIpLHRoaXMucHJldmlld3NDb250YWluZXIpe2UucHJldmlld0VsZW1lbnQ9by5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUudHJpbSgpKSxlLnByZXZpZXdUZW1wbGF0ZT1lLnByZXZpZXdFbGVtZW50LHRoaXMucHJldmlld3NDb250YWluZXIuYXBwZW5kQ2hpbGQoZS5wcmV2aWV3RWxlbWVudCk7Zm9yKHZhciBuPTAsaT1pPWUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LW5hbWVdXCIpOyEobj49aS5sZW5ndGgpOyl7dmFyIHI9aVtuKytdO3IudGV4dENvbnRlbnQ9ZS5uYW1lfWZvcih2YXIgcz0wLGE9YT1lLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1zaXplXVwiKTshKHM+PWEubGVuZ3RoKTspKHI9YVtzKytdKS5pbm5lckhUTUw9dGhpcy5maWxlc2l6ZShlLnNpemUpO3RoaXMub3B0aW9ucy5hZGRSZW1vdmVMaW5rcyYmKGUuX3JlbW92ZUxpbms9by5jcmVhdGVFbGVtZW50KCc8YSBjbGFzcz1cImR6LXJlbW92ZVwiIGhyZWY9XCJqYXZhc2NyaXB0OnVuZGVmaW5lZDtcIiBkYXRhLWR6LXJlbW92ZT4nK3RoaXMub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZStcIjwvYT5cIiksZS5wcmV2aWV3RWxlbWVudC5hcHBlbmRDaGlsZChlLl9yZW1vdmVMaW5rKSk7Zm9yKHZhciBsPWZ1bmN0aW9uKG4pe3JldHVybiBuLnByZXZlbnREZWZhdWx0KCksbi5zdG9wUHJvcGFnYXRpb24oKSxlLnN0YXR1cz09PW8uVVBMT0FESU5HP28uY29uZmlybSh0Lm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbixmdW5jdGlvbigpe3JldHVybiB0LnJlbW92ZUZpbGUoZSl9KTp0Lm9wdGlvbnMuZGljdFJlbW92ZUZpbGVDb25maXJtYXRpb24/by5jb25maXJtKHQub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbixmdW5jdGlvbigpe3JldHVybiB0LnJlbW92ZUZpbGUoZSl9KTp0LnJlbW92ZUZpbGUoZSl9LHU9MCxjPWM9ZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotcmVtb3ZlXVwiKTshKHU+PWMubGVuZ3RoKTspY1t1KytdLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGwpfX0scmVtb3ZlZGZpbGU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUucHJldmlld0VsZW1lbnQmJm51bGwhPWUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZSYmZS5wcmV2aWV3RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUucHJldmlld0VsZW1lbnQpLHRoaXMuX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCl9LHRodW1ibmFpbDpmdW5jdGlvbihlLHQpe2lmKGUucHJldmlld0VsZW1lbnQpe2UucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWZpbGUtcHJldmlld1wiKTtmb3IodmFyIG49MCxpPWk9ZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotdGh1bWJuYWlsXVwiKTshKG4+PWkubGVuZ3RoKTspe3ZhciByPWlbbisrXTtyLmFsdD1lLm5hbWUsci5zcmM9dH1yZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1pbWFnZS1wcmV2aWV3XCIpfSwxKX19LGVycm9yOmZ1bmN0aW9uKGUsdCl7aWYoZS5wcmV2aWV3RWxlbWVudCl7ZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotZXJyb3JcIiksXCJTdHJpbmdcIiE9dHlwZW9mIHQmJnQuZXJyb3ImJih0PXQuZXJyb3IpO2Zvcih2YXIgbj0wLGk9aT1lLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1lcnJvcm1lc3NhZ2VdXCIpOyEobj49aS5sZW5ndGgpOylpW24rK10udGV4dENvbnRlbnQ9dH19LGVycm9ybXVsdGlwbGU6ZnVuY3Rpb24oKXt9LHByb2Nlc3Npbmc6ZnVuY3Rpb24oZSl7aWYoZS5wcmV2aWV3RWxlbWVudCYmKGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LXByb2Nlc3NpbmdcIiksZS5fcmVtb3ZlTGluaykpcmV0dXJuIGUuX3JlbW92ZUxpbmsudGV4dENvbnRlbnQ9dGhpcy5vcHRpb25zLmRpY3RDYW5jZWxVcGxvYWR9LHByb2Nlc3NpbmdtdWx0aXBsZTpmdW5jdGlvbigpe30sdXBsb2FkcHJvZ3Jlc3M6ZnVuY3Rpb24oZSx0LG4pe2lmKGUucHJldmlld0VsZW1lbnQpZm9yKHZhciBpPTAscj1yPWUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXVwbG9hZHByb2dyZXNzXVwiKTshKGk+PXIubGVuZ3RoKTspe3ZhciBvPXJbaSsrXTtcIlBST0dSRVNTXCI9PT1vLm5vZGVOYW1lP28udmFsdWU9dDpvLnN0eWxlLndpZHRoPXQrXCIlXCJ9fSx0b3RhbHVwbG9hZHByb2dyZXNzOmZ1bmN0aW9uKCl7fSxzZW5kaW5nOmZ1bmN0aW9uKCl7fSxzZW5kaW5nbXVsdGlwbGU6ZnVuY3Rpb24oKXt9LHN1Y2Nlc3M6ZnVuY3Rpb24oZSl7aWYoZS5wcmV2aWV3RWxlbWVudClyZXR1cm4gZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotc3VjY2Vzc1wiKX0sc3VjY2Vzc211bHRpcGxlOmZ1bmN0aW9uKCl7fSxjYW5jZWxlZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lbWl0KFwiZXJyb3JcIixlLHRoaXMub3B0aW9ucy5kaWN0VXBsb2FkQ2FuY2VsZWQpfSxjYW5jZWxlZG11bHRpcGxlOmZ1bmN0aW9uKCl7fSxjb21wbGV0ZTpmdW5jdGlvbihlKXtpZihlLl9yZW1vdmVMaW5rJiYoZS5fcmVtb3ZlTGluay50ZXh0Q29udGVudD10aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGUpLGUucHJldmlld0VsZW1lbnQpcmV0dXJuIGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWNvbXBsZXRlXCIpfSxjb21wbGV0ZW11bHRpcGxlOmZ1bmN0aW9uKCl7fSxtYXhmaWxlc2V4Y2VlZGVkOmZ1bmN0aW9uKCl7fSxtYXhmaWxlc3JlYWNoZWQ6ZnVuY3Rpb24oKXt9LHF1ZXVlY29tcGxldGU6ZnVuY3Rpb24oKXt9LGFkZGVkZmlsZXM6ZnVuY3Rpb24oKXt9fSx0aGlzLnByb3RvdHlwZS5fdGh1bWJuYWlsUXVldWU9W10sdGhpcy5wcm90b3R5cGUuX3Byb2Nlc3NpbmdUaHVtYm5haWw9ITF9fSx7a2V5OlwiZXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1BcnJheSh0PjE/dC0xOjApLGk9MTtpPHQ7aSsrKW5baS0xXT1hcmd1bWVudHNbaV07Zm9yKHZhciByPTAsbz1vPW47IShyPj1vLmxlbmd0aCk7KXt2YXIgcz1vW3IrK107Zm9yKHZhciBhIGluIHMpe3ZhciBsPXNbYV07ZVthXT1sfX1yZXR1cm4gZX19XSksaShvLFt7a2V5OlwiZ2V0QWNjZXB0ZWRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjY2VwdGVkfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlfSl9fSx7a2V5OlwiZ2V0UmVqZWN0ZWRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFlLmFjY2VwdGVkfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlfSl9fSx7a2V5OlwiZ2V0RmlsZXNXaXRoU3RhdHVzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0YXR1cz09PWV9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KX19LHtrZXk6XCJnZXRRdWV1ZWRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKG8uUVVFVUVEKX19LHtrZXk6XCJnZXRVcGxvYWRpbmdGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKG8uVVBMT0FESU5HKX19LHtrZXk6XCJnZXRBZGRlZEZpbGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGaWxlc1dpdGhTdGF0dXMoby5BRERFRCl9fSx7a2V5OlwiZ2V0QWN0aXZlRmlsZXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbGVzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGF0dXM9PT1vLlVQTE9BRElOR3x8ZS5zdGF0dXM9PT1vLlFVRVVFRH0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZX0pfX0se2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7XCJmb3JtXCI9PT10aGlzLmVsZW1lbnQudGFnTmFtZSYmdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImVuY3R5cGVcIixcIm11bHRpcGFydC9mb3JtLWRhdGFcIiksdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImRyb3B6b25lXCIpJiYhdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZHotbWVzc2FnZVwiKSYmdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG8uY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cImR6LWRlZmF1bHQgZHotbWVzc2FnZVwiPjxzcGFuPicrdGhpcy5vcHRpb25zLmRpY3REZWZhdWx0TWVzc2FnZStcIjwvc3Bhbj48L2Rpdj5cIikpLHRoaXMuY2xpY2thYmxlRWxlbWVudHMubGVuZ3RoJiZmdW5jdGlvbiB0KCl7cmV0dXJuIGUuaGlkZGVuRmlsZUlucHV0JiZlLmhpZGRlbkZpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUuaGlkZGVuRmlsZUlucHV0KSxlLmhpZGRlbkZpbGVJbnB1dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksZS5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiZmlsZVwiKSwobnVsbD09PWUub3B0aW9ucy5tYXhGaWxlc3x8ZS5vcHRpb25zLm1heEZpbGVzPjEpJiZlLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLFwibXVsdGlwbGVcIiksZS5oaWRkZW5GaWxlSW5wdXQuY2xhc3NOYW1lPVwiZHotaGlkZGVuLWlucHV0XCIsbnVsbCE9PWUub3B0aW9ucy5hY2NlcHRlZEZpbGVzJiZlLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhY2NlcHRcIixlLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyksbnVsbCE9PWUub3B0aW9ucy5jYXB0dXJlJiZlLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJjYXB0dXJlXCIsZS5vcHRpb25zLmNhcHR1cmUpLGUuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIixlLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsZS5oaWRkZW5GaWxlSW5wdXQuc3R5bGUudG9wPVwiMFwiLGUuaGlkZGVuRmlsZUlucHV0LnN0eWxlLmxlZnQ9XCIwXCIsZS5oaWRkZW5GaWxlSW5wdXQuc3R5bGUuaGVpZ2h0PVwiMFwiLGUuaGlkZGVuRmlsZUlucHV0LnN0eWxlLndpZHRoPVwiMFwiLGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZS5vcHRpb25zLmhpZGRlbklucHV0Q29udGFpbmVyKS5hcHBlbmRDaGlsZChlLmhpZGRlbkZpbGVJbnB1dCksZS5oaWRkZW5GaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGZ1bmN0aW9uKCl7dmFyIG49ZS5oaWRkZW5GaWxlSW5wdXQuZmlsZXM7aWYobi5sZW5ndGgpZm9yKHZhciBpPTAscj1yPW47IShpPj1yLmxlbmd0aCk7KXt2YXIgbz1yW2krK107ZS5hZGRGaWxlKG8pfXJldHVybiBlLmVtaXQoXCJhZGRlZGZpbGVzXCIsbiksdCgpfSl9KCksdGhpcy5VUkw9bnVsbCE9PXdpbmRvdy5VUkw/d2luZG93LlVSTDp3aW5kb3cud2Via2l0VVJMO2Zvcih2YXIgdD0wLG49bj10aGlzLmV2ZW50czshKHQ+PW4ubGVuZ3RoKTspe3ZhciBpPW5bdCsrXTt0aGlzLm9uKGksdGhpcy5vcHRpb25zW2ldKX10aGlzLm9uKFwidXBsb2FkcHJvZ3Jlc3NcIixmdW5jdGlvbigpe3JldHVybiBlLnVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKX0pLHRoaXMub24oXCJyZW1vdmVkZmlsZVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUudXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzcygpfSksdGhpcy5vbihcImNhbmNlbGVkXCIsZnVuY3Rpb24odCl7cmV0dXJuIGUuZW1pdChcImNvbXBsZXRlXCIsdCl9KSx0aGlzLm9uKFwiY29tcGxldGVcIixmdW5jdGlvbih0KXtpZigwPT09ZS5nZXRBZGRlZEZpbGVzKCkubGVuZ3RoJiYwPT09ZS5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aCYmMD09PWUuZ2V0UXVldWVkRmlsZXMoKS5sZW5ndGgpcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZS5lbWl0KFwicXVldWVjb21wbGV0ZVwiKX0sMCl9KTt2YXIgcj1mdW5jdGlvbihlKXtyZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExfTtyZXR1cm4gdGhpcy5saXN0ZW5lcnM9W3tlbGVtZW50OnRoaXMuZWxlbWVudCxldmVudHM6e2RyYWdzdGFydDpmdW5jdGlvbih0KXtyZXR1cm4gZS5lbWl0KFwiZHJhZ3N0YXJ0XCIsdCl9LGRyYWdlbnRlcjpmdW5jdGlvbih0KXtyZXR1cm4gcih0KSxlLmVtaXQoXCJkcmFnZW50ZXJcIix0KX0sZHJhZ292ZXI6ZnVuY3Rpb24odCl7dmFyIG49dm9pZCAwO3RyeXtuPXQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWR9Y2F0Y2goZSl7fXJldHVybiB0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0PVwibW92ZVwiPT09bnx8XCJsaW5rTW92ZVwiPT09bj9cIm1vdmVcIjpcImNvcHlcIixyKHQpLGUuZW1pdChcImRyYWdvdmVyXCIsdCl9LGRyYWdsZWF2ZTpmdW5jdGlvbih0KXtyZXR1cm4gZS5lbWl0KFwiZHJhZ2xlYXZlXCIsdCl9LGRyb3A6ZnVuY3Rpb24odCl7cmV0dXJuIHIodCksZS5kcm9wKHQpfSxkcmFnZW5kOmZ1bmN0aW9uKHQpe3JldHVybiBlLmVtaXQoXCJkcmFnZW5kXCIsdCl9fX1dLHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5saXN0ZW5lcnMucHVzaCh7ZWxlbWVudDp0LGV2ZW50czp7Y2xpY2s6ZnVuY3Rpb24obil7cmV0dXJuKHQhPT1lLmVsZW1lbnR8fG4udGFyZ2V0PT09ZS5lbGVtZW50fHxvLmVsZW1lbnRJbnNpZGUobi50YXJnZXQsZS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZHotbWVzc2FnZVwiKSkpJiZlLmhpZGRlbkZpbGVJbnB1dC5jbGljaygpLCEwfX19KX0pLHRoaXMuZW5hYmxlKCksdGhpcy5vcHRpb25zLmluaXQuY2FsbCh0aGlzKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNhYmxlKCksdGhpcy5yZW1vdmVBbGxGaWxlcyghMCksKG51bGwhPXRoaXMuaGlkZGVuRmlsZUlucHV0P3RoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGU6dm9pZCAwKSYmKHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpLHRoaXMuaGlkZGVuRmlsZUlucHV0PW51bGwpLGRlbGV0ZSB0aGlzLmVsZW1lbnQuZHJvcHpvbmUsby5pbnN0YW5jZXMuc3BsaWNlKG8uaW5zdGFuY2VzLmluZGV4T2YodGhpcyksMSl9fSx7a2V5OlwidXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dm9pZCAwLHQ9MCxuPTA7aWYodGhpcy5nZXRBY3RpdmVGaWxlcygpLmxlbmd0aCl7Zm9yKHZhciBpPTAscj1yPXRoaXMuZ2V0QWN0aXZlRmlsZXMoKTshKGk+PXIubGVuZ3RoKTspe3ZhciBvPXJbaSsrXTt0Kz1vLnVwbG9hZC5ieXRlc1NlbnQsbis9by51cGxvYWQudG90YWx9ZT0xMDAqdC9ufWVsc2UgZT0xMDA7cmV0dXJuIHRoaXMuZW1pdChcInRvdGFsdXBsb2FkcHJvZ3Jlc3NcIixlLG4sdCl9fSx7a2V5OlwiX2dldFBhcmFtTmFtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbU5hbWU/dGhpcy5vcHRpb25zLnBhcmFtTmFtZShlKTp0aGlzLm9wdGlvbnMucGFyYW1OYW1lKyh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGU/XCJbXCIrZStcIl1cIjpcIlwiKX19LHtrZXk6XCJfcmVuYW1lRmlsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlP2UubmFtZTp0aGlzLm9wdGlvbnMucmVuYW1lRmlsZShlKX19LHtrZXk6XCJnZXRGYWxsYmFja0Zvcm1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9dm9pZCAwO2lmKGU9dGhpcy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpcmV0dXJuIGU7dmFyIG49JzxkaXYgY2xhc3M9XCJkei1mYWxsYmFja1wiPic7dGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQmJihuKz1cIjxwPlwiK3RoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tUZXh0K1wiPC9wPlwiKSxuKz0nPGlucHV0IHR5cGU9XCJmaWxlXCIgbmFtZT1cIicrdGhpcy5fZ2V0UGFyYW1OYW1lKDApKydcIiAnKyh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGU/J211bHRpcGxlPVwibXVsdGlwbGVcIic6dm9pZCAwKSsnIC8+PGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlVwbG9hZCFcIj48L2Rpdj4nO3ZhciBpPW8uY3JlYXRlRWxlbWVudChuKTtyZXR1cm5cIkZPUk1cIiE9PXRoaXMuZWxlbWVudC50YWdOYW1lPyh0PW8uY3JlYXRlRWxlbWVudCgnPGZvcm0gYWN0aW9uPVwiJyt0aGlzLm9wdGlvbnMudXJsKydcIiBlbmN0eXBlPVwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIG1ldGhvZD1cIicrdGhpcy5vcHRpb25zLm1ldGhvZCsnXCI+PC9mb3JtPicpKS5hcHBlbmRDaGlsZChpKToodGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImVuY3R5cGVcIixcIm11bHRpcGFydC9mb3JtLWRhdGFcIiksdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcIm1ldGhvZFwiLHRoaXMub3B0aW9ucy5tZXRob2QpKSxudWxsIT10P3Q6aX19LHtrZXk6XCJnZXRFeGlzdGluZ0ZhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W1wiZGl2XCIsXCJmb3JtXCJdLHQ9MDt0PGUubGVuZ3RoO3QrKyl7dmFyIG4saT1lW3RdO2lmKG49ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj1uPWU7ISh0Pj1uLmxlbmd0aCk7KXt2YXIgaT1uW3QrK107aWYoLyhefCApZmFsbGJhY2soJHwgKS8udGVzdChpLmNsYXNzTmFtZSkpcmV0dXJuIGl9fSh0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoaSkpKXJldHVybiBufX19LHtrZXk6XCJzZXR1cEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saXN0ZW5lcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlLmV2ZW50cyl7dmFyIGk9ZS5ldmVudHNbbl07dC5wdXNoKGUuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG4saSwhMSkpfXJldHVybiB0fSgpfSl9fSx7a2V5OlwicmVtb3ZlRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUuZXZlbnRzKXt2YXIgaT1lLmV2ZW50c1tuXTt0LnB1c2goZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobixpLCExKSl9cmV0dXJuIHR9KCl9KX19LHtrZXk6XCJkaXNhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZShcImR6LWNsaWNrYWJsZVwiKX0pLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSx0aGlzLmRpc2FibGVkPSEwLHRoaXMuZmlsZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLmNhbmNlbFVwbG9hZCh0KX0pfX0se2tleTpcImVuYWJsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGRlbGV0ZSB0aGlzLmRpc2FibGVkLHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc0xpc3QuYWRkKFwiZHotY2xpY2thYmxlXCIpfSksdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCl9fSx7a2V5OlwiZmlsZXNpemVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0wLG49XCJiXCI7aWYoZT4wKXtmb3IodmFyIGk9W1widGJcIixcImdiXCIsXCJtYlwiLFwia2JcIixcImJcIl0scj0wO3I8aS5sZW5ndGg7cisrKXt2YXIgbz1pW3JdO2lmKGU+PU1hdGgucG93KHRoaXMub3B0aW9ucy5maWxlc2l6ZUJhc2UsNC1yKS8xMCl7dD1lL01hdGgucG93KHRoaXMub3B0aW9ucy5maWxlc2l6ZUJhc2UsNC1yKSxuPW87YnJlYWt9fXQ9TWF0aC5yb3VuZCgxMCp0KS8xMH1yZXR1cm5cIjxzdHJvbmc+XCIrdCtcIjwvc3Ryb25nPiBcIit0aGlzLm9wdGlvbnMuZGljdEZpbGVTaXplVW5pdHNbbl19fSx7a2V5OlwiX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5vcHRpb25zLm1heEZpbGVzJiZ0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGg+PXRoaXMub3B0aW9ucy5tYXhGaWxlcz8odGhpcy5nZXRBY2NlcHRlZEZpbGVzKCkubGVuZ3RoPT09dGhpcy5vcHRpb25zLm1heEZpbGVzJiZ0aGlzLmVtaXQoXCJtYXhmaWxlc3JlYWNoZWRcIix0aGlzLmZpbGVzKSx0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LW1heC1maWxlcy1yZWFjaGVkXCIpKTp0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LW1heC1maWxlcy1yZWFjaGVkXCIpfX0se2tleTpcImRyb3BcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlLmRhdGFUcmFuc2Zlcil7dGhpcy5lbWl0KFwiZHJvcFwiLGUpO2Zvcih2YXIgdD1bXSxuPTA7bjxlLmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGg7bisrKXRbbl09ZS5kYXRhVHJhbnNmZXIuZmlsZXNbbl07aWYodGhpcy5lbWl0KFwiYWRkZWRmaWxlc1wiLHQpLHQubGVuZ3RoKXt2YXIgaT1lLmRhdGFUcmFuc2Zlci5pdGVtcztpJiZpLmxlbmd0aCYmbnVsbCE9aVswXS53ZWJraXRHZXRBc0VudHJ5P3RoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKGkpOnRoaXMuaGFuZGxlRmlsZXModCl9fX19LHtrZXk6XCJwYXN0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKG51bGwhPSh2b2lkIDAhPT0odD1udWxsIT1lP2UuY2xpcGJvYXJkRGF0YTp2b2lkIDApJiZudWxsIT09dD9mdW5jdGlvbihlKXtyZXR1cm4gZS5pdGVtc30odCk6dm9pZCAwKSl7dmFyIHQ7dGhpcy5lbWl0KFwicGFzdGVcIixlKTt2YXIgbj1lLmNsaXBib2FyZERhdGEuaXRlbXM7cmV0dXJuIG4ubGVuZ3RoP3RoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKG4pOnZvaWQgMH19fSx7a2V5OlwiaGFuZGxlRmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPW49ZTshKHQ+PW4ubGVuZ3RoKTspe3ZhciBpPW5bdCsrXTt0aGlzLmFkZEZpbGUoaSl9fX0se2tleTpcIl9hZGRGaWxlc0Zyb21JdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLGk9MCxyPXI9ZTshKGk+PXIubGVuZ3RoKTspe3ZhciBvLHM9cltpKytdO251bGwhPXMud2Via2l0R2V0QXNFbnRyeSYmKG89cy53ZWJraXRHZXRBc0VudHJ5KCkpP28uaXNGaWxlP24ucHVzaCh0LmFkZEZpbGUocy5nZXRBc0ZpbGUoKSkpOm8uaXNEaXJlY3Rvcnk/bi5wdXNoKHQuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShvLG8ubmFtZSkpOm4ucHVzaCh2b2lkIDApOm51bGw9PXMuZ2V0QXNGaWxlfHxudWxsIT1zLmtpbmQmJlwiZmlsZVwiIT09cy5raW5kP24ucHVzaCh2b2lkIDApOm4ucHVzaCh0LmFkZEZpbGUocy5nZXRBc0ZpbGUoKSkpfXJldHVybiBufSgpfX0se2tleTpcIl9hZGRGaWxlc0Zyb21EaXJlY3RvcnlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1lLmNyZWF0ZVJlYWRlcigpLHI9ZnVuY3Rpb24oZSl7cmV0dXJuIHQ9Y29uc29sZSxuPVwibG9nXCIsaT1mdW5jdGlvbih0KXtyZXR1cm4gdC5sb2coZSl9LHZvaWQgMCE9PXQmJm51bGwhPT10JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W25dP2kodCxuKTp2b2lkIDA7dmFyIHQsbixpfTtyZXR1cm4gZnVuY3Rpb24gZSgpe3JldHVybiBpLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGkpe2lmKGkubGVuZ3RoPjApe2Zvcih2YXIgcj0wLG89bz1pOyEocj49by5sZW5ndGgpOyl7dmFyIHM9b1tyKytdO3MuaXNGaWxlP3MuZmlsZShmdW5jdGlvbihlKXtpZighbi5vcHRpb25zLmlnbm9yZUhpZGRlbkZpbGVzfHxcIi5cIiE9PWUubmFtZS5zdWJzdHJpbmcoMCwxKSlyZXR1cm4gZS5mdWxsUGF0aD10K1wiL1wiK2UubmFtZSxuLmFkZEZpbGUoZSl9KTpzLmlzRGlyZWN0b3J5JiZuLl9hZGRGaWxlc0Zyb21EaXJlY3Rvcnkocyx0K1wiL1wiK3MubmFtZSl9ZSgpfXJldHVybiBudWxsfSxyKX0oKX19LHtrZXk6XCJhY2NlcHRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlLnNpemU+MTAyNCp0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUqMTAyND90KHRoaXMub3B0aW9ucy5kaWN0RmlsZVRvb0JpZy5yZXBsYWNlKFwie3tmaWxlc2l6ZX19XCIsTWF0aC5yb3VuZChlLnNpemUvMTAyNC8xMC4yNCkvMTAwKS5yZXBsYWNlKFwie3ttYXhGaWxlc2l6ZX19XCIsdGhpcy5vcHRpb25zLm1heEZpbGVzaXplKSk6by5pc1ZhbGlkRmlsZShlLHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzKT9udWxsIT10aGlzLm9wdGlvbnMubWF4RmlsZXMmJnRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aD49dGhpcy5vcHRpb25zLm1heEZpbGVzPyh0KHRoaXMub3B0aW9ucy5kaWN0TWF4RmlsZXNFeGNlZWRlZC5yZXBsYWNlKFwie3ttYXhGaWxlc319XCIsdGhpcy5vcHRpb25zLm1heEZpbGVzKSksdGhpcy5lbWl0KFwibWF4ZmlsZXNleGNlZWRlZFwiLGUpKTp0aGlzLm9wdGlvbnMuYWNjZXB0LmNhbGwodGhpcyxlLHQpOnQodGhpcy5vcHRpb25zLmRpY3RJbnZhbGlkRmlsZVR5cGUpfX0se2tleTpcImFkZEZpbGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLnVwbG9hZD17dXVpZDpvLnV1aWR2NCgpLHByb2dyZXNzOjAsdG90YWw6ZS5zaXplLGJ5dGVzU2VudDowLGZpbGVuYW1lOnRoaXMuX3JlbmFtZUZpbGUoZSksY2h1bmtlZDp0aGlzLm9wdGlvbnMuY2h1bmtpbmcmJih0aGlzLm9wdGlvbnMuZm9yY2VDaHVua2luZ3x8ZS5zaXplPnRoaXMub3B0aW9ucy5jaHVua1NpemUpLHRvdGFsQ2h1bmtDb3VudDpNYXRoLmNlaWwoZS5zaXplL3RoaXMub3B0aW9ucy5jaHVua1NpemUpfSx0aGlzLmZpbGVzLnB1c2goZSksZS5zdGF0dXM9by5BRERFRCx0aGlzLmVtaXQoXCJhZGRlZGZpbGVcIixlKSx0aGlzLl9lbnF1ZXVlVGh1bWJuYWlsKGUpLHRoaXMuYWNjZXB0KGUsZnVuY3Rpb24obil7cmV0dXJuIG4/KGUuYWNjZXB0ZWQ9ITEsdC5fZXJyb3JQcm9jZXNzaW5nKFtlXSxuKSk6KGUuYWNjZXB0ZWQ9ITAsdC5vcHRpb25zLmF1dG9RdWV1ZSYmdC5lbnF1ZXVlRmlsZShlKSksdC5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKX0pfX0se2tleTpcImVucXVldWVGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49bj1lOyEodD49bi5sZW5ndGgpOyl7dmFyIGk9blt0KytdO3RoaXMuZW5xdWV1ZUZpbGUoaSl9cmV0dXJuIG51bGx9fSx7a2V5OlwiZW5xdWV1ZUZpbGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKGUuc3RhdHVzIT09by5BRERFRHx8ITAhPT1lLmFjY2VwdGVkKXRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBjYW4ndCBiZSBxdWV1ZWQgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBvciB3YXMgcmVqZWN0ZWQuXCIpO2lmKGUuc3RhdHVzPW8uUVVFVUVELHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKXJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHQucHJvY2Vzc1F1ZXVlKCl9LDApfX0se2tleTpcIl9lbnF1ZXVlVGh1bWJuYWlsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLm9wdGlvbnMuY3JlYXRlSW1hZ2VUaHVtYm5haWxzJiZlLnR5cGUubWF0Y2goL2ltYWdlLiovKSYmZS5zaXplPD0xMDI0KnRoaXMub3B0aW9ucy5tYXhUaHVtYm5haWxGaWxlc2l6ZSoxMDI0KXJldHVybiB0aGlzLl90aHVtYm5haWxRdWV1ZS5wdXNoKGUpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdC5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCl9LDApfX0se2tleTpcIl9wcm9jZXNzVGh1bWJuYWlsUXVldWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoIXRoaXMuX3Byb2Nlc3NpbmdUaHVtYm5haWwmJjAhPT10aGlzLl90aHVtYm5haWxRdWV1ZS5sZW5ndGgpe3RoaXMuX3Byb2Nlc3NpbmdUaHVtYm5haWw9ITA7dmFyIHQ9dGhpcy5fdGh1bWJuYWlsUXVldWUuc2hpZnQoKTtyZXR1cm4gdGhpcy5jcmVhdGVUaHVtYm5haWwodCx0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsdGhpcy5vcHRpb25zLnRodW1ibmFpbEhlaWdodCx0aGlzLm9wdGlvbnMudGh1bWJuYWlsTWV0aG9kLCEwLGZ1bmN0aW9uKG4pe3JldHVybiBlLmVtaXQoXCJ0aHVtYm5haWxcIix0LG4pLGUuX3Byb2Nlc3NpbmdUaHVtYm5haWw9ITEsZS5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCl9KX19fSx7a2V5OlwicmVtb3ZlRmlsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUuc3RhdHVzPT09by5VUExPQURJTkcmJnRoaXMuY2FuY2VsVXBsb2FkKGUpLHRoaXMuZmlsZXM9cyh0aGlzLmZpbGVzLGUpLHRoaXMuZW1pdChcInJlbW92ZWRmaWxlXCIsZSksMD09PXRoaXMuZmlsZXMubGVuZ3RoKXJldHVybiB0aGlzLmVtaXQoXCJyZXNldFwiKX19LHtrZXk6XCJyZW1vdmVBbGxGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe251bGw9PWUmJihlPSExKTtmb3IodmFyIHQ9MCxuPW49dGhpcy5maWxlcy5zbGljZSgpOyEodD49bi5sZW5ndGgpOyl7dmFyIGk9blt0KytdOyhpLnN0YXR1cyE9PW8uVVBMT0FESU5HfHxlKSYmdGhpcy5yZW1vdmVGaWxlKGkpfXJldHVybiBudWxsfX0se2tleTpcInJlc2l6ZUltYWdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgcz10aGlzO3JldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChlLHQsbixpLCExLGZ1bmN0aW9uKHQsbil7aWYobnVsbD09bilyZXR1cm4gcihlKTt2YXIgaT1zLm9wdGlvbnMucmVzaXplTWltZVR5cGU7bnVsbD09aSYmKGk9ZS50eXBlKTt2YXIgYT1uLnRvRGF0YVVSTChpLHMub3B0aW9ucy5yZXNpemVRdWFsaXR5KTtyZXR1cm5cImltYWdlL2pwZWdcIiE9PWkmJlwiaW1hZ2UvanBnXCIhPT1pfHwoYT11LnJlc3RvcmUoZS5kYXRhVVJMLGEpKSxyKG8uZGF0YVVSSXRvQmxvYihhKSl9KX19LHtrZXk6XCJjcmVhdGVUaHVtYm5haWxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLHIsbyl7dmFyIHM9dGhpcyxhPW5ldyBGaWxlUmVhZGVyO3JldHVybiBhLm9ubG9hZD1mdW5jdGlvbigpe2lmKGUuZGF0YVVSTD1hLnJlc3VsdCxcImltYWdlL3N2Zyt4bWxcIiE9PWUudHlwZSlyZXR1cm4gcy5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKGUsdCxuLGkscixvKTtudWxsIT1vJiZvKGEucmVzdWx0KX0sYS5yZWFkQXNEYXRhVVJMKGUpfX0se2tleTpcImNyZWF0ZVRodW1ibmFpbEZyb21VcmxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLHIsbyxzKXt2YXIgYT10aGlzLHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtyZXR1cm4gcyYmKHUuY3Jvc3NPcmlnaW49cyksdS5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgcz1mdW5jdGlvbihlKXtyZXR1cm4gZSgxKX07cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEVYSUYmJm51bGwhPT1FWElGJiZyJiYocz1mdW5jdGlvbihlKXtyZXR1cm4gRVhJRi5nZXREYXRhKHUsZnVuY3Rpb24oKXtyZXR1cm4gZShFWElGLmdldFRhZyh0aGlzLFwiT3JpZW50YXRpb25cIikpfSl9KSxzKGZ1bmN0aW9uKHIpe2Uud2lkdGg9dS53aWR0aCxlLmhlaWdodD11LmhlaWdodDt2YXIgcz1hLm9wdGlvbnMucmVzaXplLmNhbGwoYSxlLHQsbixpKSxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksZD1jLmdldENvbnRleHQoXCIyZFwiKTtzd2l0Y2goYy53aWR0aD1zLnRyZ1dpZHRoLGMuaGVpZ2h0PXMudHJnSGVpZ2h0LHI+NCYmKGMud2lkdGg9cy50cmdIZWlnaHQsYy5oZWlnaHQ9cy50cmdXaWR0aCkscil7Y2FzZSAyOmQudHJhbnNsYXRlKGMud2lkdGgsMCksZC5zY2FsZSgtMSwxKTticmVhaztjYXNlIDM6ZC50cmFuc2xhdGUoYy53aWR0aCxjLmhlaWdodCksZC5yb3RhdGUoTWF0aC5QSSk7YnJlYWs7Y2FzZSA0OmQudHJhbnNsYXRlKDAsYy5oZWlnaHQpLGQuc2NhbGUoMSwtMSk7YnJlYWs7Y2FzZSA1OmQucm90YXRlKC41Kk1hdGguUEkpLGQuc2NhbGUoMSwtMSk7YnJlYWs7Y2FzZSA2OmQucm90YXRlKC41Kk1hdGguUEkpLGQudHJhbnNsYXRlKDAsLWMuaGVpZ2h0KTticmVhaztjYXNlIDc6ZC5yb3RhdGUoLjUqTWF0aC5QSSksZC50cmFuc2xhdGUoYy53aWR0aCwtYy5oZWlnaHQpLGQuc2NhbGUoLTEsMSk7YnJlYWs7Y2FzZSA4OmQucm90YXRlKC0uNSpNYXRoLlBJKSxkLnRyYW5zbGF0ZSgtYy53aWR0aCwwKX1sKGQsdSxudWxsIT1zLnNyY1g/cy5zcmNYOjAsbnVsbCE9cy5zcmNZP3Muc3JjWTowLHMuc3JjV2lkdGgscy5zcmNIZWlnaHQsbnVsbCE9cy50cmdYP3MudHJnWDowLG51bGwhPXMudHJnWT9zLnRyZ1k6MCxzLnRyZ1dpZHRoLHMudHJnSGVpZ2h0KTt2YXIgcD1jLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtpZihudWxsIT1vKXJldHVybiBvKHAsYyl9KX0sbnVsbCE9byYmKHUub25lcnJvcj1vKSx1LnNyYz1lLmRhdGFVUkx9fSx7a2V5OlwicHJvY2Vzc1F1ZXVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzLHQ9dGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aCxuPXQ7aWYoISh0Pj1lKSl7dmFyIGk9dGhpcy5nZXRRdWV1ZWRGaWxlcygpO2lmKGkubGVuZ3RoPjApe2lmKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSlyZXR1cm4gdGhpcy5wcm9jZXNzRmlsZXMoaS5zbGljZSgwLGUtdCkpO2Zvcig7bjxlOyl7aWYoIWkubGVuZ3RoKXJldHVybjt0aGlzLnByb2Nlc3NGaWxlKGkuc2hpZnQoKSksbisrfX19fX0se2tleTpcInByb2Nlc3NGaWxlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHJvY2Vzc0ZpbGVzKFtlXSl9fSx7a2V5OlwicHJvY2Vzc0ZpbGVzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj1uPWU7ISh0Pj1uLmxlbmd0aCk7KXt2YXIgaT1uW3QrK107aS5wcm9jZXNzaW5nPSEwLGkuc3RhdHVzPW8uVVBMT0FESU5HLHRoaXMuZW1pdChcInByb2Nlc3NpbmdcIixpKX1yZXR1cm4gdGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlJiZ0aGlzLmVtaXQoXCJwcm9jZXNzaW5nbXVsdGlwbGVcIixlKSx0aGlzLnVwbG9hZEZpbGVzKGUpfX0se2tleTpcIl9nZXRGaWxlc1dpdGhYaHJcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQueGhyPT09ZX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZX0pfX0se2tleTpcImNhbmNlbFVwbG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUuc3RhdHVzPT09by5VUExPQURJTkcpe2Zvcih2YXIgdD10aGlzLl9nZXRGaWxlc1dpdGhYaHIoZS54aHIpLG49MCxpPWk9dDshKG4+PWkubGVuZ3RoKTspaVtuKytdLnN0YXR1cz1vLkNBTkNFTEVEO3ZvaWQgMCE9PWUueGhyJiZlLnhoci5hYm9ydCgpO2Zvcih2YXIgcj0wLHM9cz10OyEocj49cy5sZW5ndGgpOyl7dmFyIGE9c1tyKytdO3RoaXMuZW1pdChcImNhbmNlbGVkXCIsYSl9dGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlJiZ0aGlzLmVtaXQoXCJjYW5jZWxlZG11bHRpcGxlXCIsdCl9ZWxzZSBlLnN0YXR1cyE9PW8uQURERUQmJmUuc3RhdHVzIT09by5RVUVVRUR8fChlLnN0YXR1cz1vLkNBTkNFTEVELHRoaXMuZW1pdChcImNhbmNlbGVkXCIsZSksdGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlJiZ0aGlzLmVtaXQoXCJjYW5jZWxlZG11bHRpcGxlXCIsW2VdKSk7aWYodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCl9fSx7a2V5OlwicmVzb2x2ZU9wdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49QXJyYXkodD4xP3QtMTowKSxpPTE7aTx0O2krKyluW2ktMV09YXJndW1lbnRzW2ldO3JldHVybiBlLmFwcGx5KHRoaXMsbil9cmV0dXJuIGV9fSx7a2V5OlwidXBsb2FkRmlsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnVwbG9hZEZpbGVzKFtlXSl9fSx7a2V5OlwidXBsb2FkRmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuX3RyYW5zZm9ybUZpbGVzKGUsZnVuY3Rpb24obil7aWYoZVswXS51cGxvYWQuY2h1bmtlZCl7dmFyIGk9ZVswXSxyPW5bMF07aS51cGxvYWQuY2h1bmtzPVtdO3ZhciBzPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTA7dm9pZCAwIT09aS51cGxvYWQuY2h1bmtzW25dOyluKys7aWYoIShuPj1pLnVwbG9hZC50b3RhbENodW5rQ291bnQpKXt2YXIgcz1uKnQub3B0aW9ucy5jaHVua1NpemUsYT1NYXRoLm1pbihzK3Qub3B0aW9ucy5jaHVua1NpemUsaS5zaXplKSxsPXtuYW1lOnQuX2dldFBhcmFtTmFtZSgwKSxkYXRhOnIud2Via2l0U2xpY2U/ci53ZWJraXRTbGljZShzLGEpOnIuc2xpY2UocyxhKSxmaWxlbmFtZTppLnVwbG9hZC5maWxlbmFtZSxjaHVua0luZGV4Om59O2kudXBsb2FkLmNodW5rc1tuXT17ZmlsZTppLGluZGV4Om4sZGF0YUJsb2NrOmwsc3RhdHVzOm8uVVBMT0FESU5HLHByb2dyZXNzOjAscmV0cmllczowfSx0Ll91cGxvYWREYXRhKGUsW2xdKX19O2lmKGkudXBsb2FkLmZpbmlzaGVkQ2h1bmtVcGxvYWQ9ZnVuY3Rpb24obil7dmFyIHI9ITA7bi5zdGF0dXM9by5TVUNDRVNTLG4uZGF0YUJsb2NrPW51bGw7Zm9yKHZhciBhPTA7YTxpLnVwbG9hZC50b3RhbENodW5rQ291bnQ7YSsrKXtpZih2b2lkIDA9PT1pLnVwbG9hZC5jaHVua3NbYV0pcmV0dXJuIHMoKTtpLnVwbG9hZC5jaHVua3NbYV0uc3RhdHVzIT09by5TVUNDRVNTJiYocj0hMSl9ciYmdC5vcHRpb25zLmNodW5rc1VwbG9hZGVkKGksZnVuY3Rpb24oKXt0Ll9maW5pc2hlZChlLFwiXCIsbnVsbCl9KX0sdC5vcHRpb25zLnBhcmFsbGVsQ2h1bmtVcGxvYWRzKWZvcih2YXIgYT0wO2E8aS51cGxvYWQudG90YWxDaHVua0NvdW50O2ErKylzKCk7ZWxzZSBzKCl9ZWxzZXtmb3IodmFyIGw9W10sdT0wO3U8ZS5sZW5ndGg7dSsrKWxbdV09e25hbWU6dC5fZ2V0UGFyYW1OYW1lKHUpLGRhdGE6blt1XSxmaWxlbmFtZTplW3VdLnVwbG9hZC5maWxlbmFtZX07dC5fdXBsb2FkRGF0YShlLGwpfX0pfX0se2tleTpcIl9nZXRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7bisrKWlmKHZvaWQgMCE9PWUudXBsb2FkLmNodW5rc1tuXSYmZS51cGxvYWQuY2h1bmtzW25dLnhocj09PXQpcmV0dXJuIGUudXBsb2FkLmNodW5rc1tuXX19LHtrZXk6XCJfdXBsb2FkRGF0YVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPXRoaXMsaT1uZXcgWE1MSHR0cFJlcXVlc3Qscj0wLHM9cz1lOyEocj49cy5sZW5ndGgpOylzW3IrK10ueGhyPWk7ZVswXS51cGxvYWQuY2h1bmtlZCYmKGVbMF0udXBsb2FkLmNodW5rc1t0WzBdLmNodW5rSW5kZXhdLnhocj1pKTt2YXIgYT10aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLm1ldGhvZCxlKSxsPXRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMudXJsLGUpO2kub3BlbihhLGwsITApLGkudGltZW91dD10aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnRpbWVvdXQsZSksaS53aXRoQ3JlZGVudGlhbHM9ISF0aGlzLm9wdGlvbnMud2l0aENyZWRlbnRpYWxzLGkub25sb2FkPWZ1bmN0aW9uKHQpe24uX2ZpbmlzaGVkVXBsb2FkaW5nKGUsaSx0KX0saS5vbmVycm9yPWZ1bmN0aW9uKCl7bi5faGFuZGxlVXBsb2FkRXJyb3IoZSxpKX0sKG51bGwhPWkudXBsb2FkP2kudXBsb2FkOmkpLm9ucHJvZ3Jlc3M9ZnVuY3Rpb24odCl7cmV0dXJuIG4uX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZSxpLHQpfTt2YXIgdT17QWNjZXB0OlwiYXBwbGljYXRpb24vanNvblwiLFwiQ2FjaGUtQ29udHJvbFwiOlwibm8tY2FjaGVcIixcIlgtUmVxdWVzdGVkLVdpdGhcIjpcIlhNTEh0dHBSZXF1ZXN0XCJ9O2Zvcih2YXIgYyBpbiB0aGlzLm9wdGlvbnMuaGVhZGVycyYmby5leHRlbmQodSx0aGlzLm9wdGlvbnMuaGVhZGVycyksdSl7dmFyIGQ9dVtjXTtkJiZpLnNldFJlcXVlc3RIZWFkZXIoYyxkKX12YXIgcD1uZXcgRm9ybURhdGE7aWYodGhpcy5vcHRpb25zLnBhcmFtcyl7dmFyIGg9dGhpcy5vcHRpb25zLnBhcmFtcztmb3IodmFyIGYgaW5cImZ1bmN0aW9uXCI9PXR5cGVvZiBoJiYoaD1oLmNhbGwodGhpcyxlLGksZVswXS51cGxvYWQuY2h1bmtlZD90aGlzLl9nZXRDaHVuayhlWzBdLGkpOm51bGwpKSxoKXt2YXIgbT1oW2ZdO3AuYXBwZW5kKGYsbSl9fWZvcih2YXIgdj0wLGc9Zz1lOyEodj49Zy5sZW5ndGgpOyl7dmFyIHk9Z1t2KytdO3RoaXMuZW1pdChcInNlbmRpbmdcIix5LGkscCl9dGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlJiZ0aGlzLmVtaXQoXCJzZW5kaW5nbXVsdGlwbGVcIixlLGkscCksdGhpcy5fYWRkRm9ybUVsZW1lbnREYXRhKHApO2Zvcih2YXIgaz0wO2s8dC5sZW5ndGg7aysrKXt2YXIgYj10W2tdO3AuYXBwZW5kKGIubmFtZSxiLmRhdGEsYi5maWxlbmFtZSl9dGhpcy5zdWJtaXRSZXF1ZXN0KGkscCxlKX19LHtrZXk6XCJfdHJhbnNmb3JtRmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10aGlzLGk9W10scj0wLG89MDtvPGUubGVuZ3RoO28rKykhZnVuY3Rpb24obyl7bi5vcHRpb25zLnRyYW5zZm9ybUZpbGUuY2FsbChuLGVbb10sZnVuY3Rpb24obil7aVtvXT1uLCsrcj09PWUubGVuZ3RoJiZ0KGkpfSl9KG8pfX0se2tleTpcIl9hZGRGb3JtRWxlbWVudERhdGFcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihcIkZPUk1cIj09PXRoaXMuZWxlbWVudC50YWdOYW1lKWZvcih2YXIgdD0wLG49bj10aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBidXR0b25cIik7ISh0Pj1uLmxlbmd0aCk7KXt2YXIgaT1uW3QrK10scj1pLmdldEF0dHJpYnV0ZShcIm5hbWVcIiksbz1pLmdldEF0dHJpYnV0ZShcInR5cGVcIik7aWYobyYmKG89by50b0xvd2VyQ2FzZSgpKSx2b2lkIDAhPT1yJiZudWxsIT09cilpZihcIlNFTEVDVFwiPT09aS50YWdOYW1lJiZpLmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKWZvcih2YXIgcz0wLGE9YT1pLm9wdGlvbnM7IShzPj1hLmxlbmd0aCk7KXt2YXIgbD1hW3MrK107bC5zZWxlY3RlZCYmZS5hcHBlbmQocixsLnZhbHVlKX1lbHNlKCFvfHxcImNoZWNrYm94XCIhPT1vJiZcInJhZGlvXCIhPT1vfHxpLmNoZWNrZWQpJiZlLmFwcGVuZChyLGkudmFsdWUpfX19LHtrZXk6XCJfdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT12b2lkIDA7aWYodm9pZCAwIT09bil7aWYoaT0xMDAqbi5sb2FkZWQvbi50b3RhbCxlWzBdLnVwbG9hZC5jaHVua2VkKXt2YXIgcj1lWzBdLG89dGhpcy5fZ2V0Q2h1bmsocix0KTtvLnByb2dyZXNzPWksby50b3RhbD1uLnRvdGFsLG8uYnl0ZXNTZW50PW4ubG9hZGVkLHIudXBsb2FkLnByb2dyZXNzPTAsci51cGxvYWQudG90YWw9MCxyLnVwbG9hZC5ieXRlc1NlbnQ9MDtmb3IodmFyIHM9MDtzPHIudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDtzKyspdm9pZCAwIT09ci51cGxvYWQuY2h1bmtzW3NdJiZ2b2lkIDAhPT1yLnVwbG9hZC5jaHVua3Nbc10ucHJvZ3Jlc3MmJihyLnVwbG9hZC5wcm9ncmVzcys9ci51cGxvYWQuY2h1bmtzW3NdLnByb2dyZXNzLHIudXBsb2FkLnRvdGFsKz1yLnVwbG9hZC5jaHVua3Nbc10udG90YWwsci51cGxvYWQuYnl0ZXNTZW50Kz1yLnVwbG9hZC5jaHVua3Nbc10uYnl0ZXNTZW50KTtyLnVwbG9hZC5wcm9ncmVzcz1yLnVwbG9hZC5wcm9ncmVzcy9yLnVwbG9hZC50b3RhbENodW5rQ291bnR9ZWxzZSBmb3IodmFyIGE9MCxsPWw9ZTshKGE+PWwubGVuZ3RoKTspe3ZhciB1PWxbYSsrXTt1LnVwbG9hZC5wcm9ncmVzcz1pLHUudXBsb2FkLnRvdGFsPW4udG90YWwsdS51cGxvYWQuYnl0ZXNTZW50PW4ubG9hZGVkfWZvcih2YXIgYz0wLGQ9ZD1lOyEoYz49ZC5sZW5ndGgpOyl7dmFyIHA9ZFtjKytdO3RoaXMuZW1pdChcInVwbG9hZHByb2dyZXNzXCIscCxwLnVwbG9hZC5wcm9ncmVzcyxwLnVwbG9hZC5ieXRlc1NlbnQpfX1lbHNle3ZhciBoPSEwO2k9MTAwO2Zvcih2YXIgZj0wLG09bT1lOyEoZj49bS5sZW5ndGgpOyl7dmFyIHY9bVtmKytdOzEwMD09PXYudXBsb2FkLnByb2dyZXNzJiZ2LnVwbG9hZC5ieXRlc1NlbnQ9PT12LnVwbG9hZC50b3RhbHx8KGg9ITEpLHYudXBsb2FkLnByb2dyZXNzPWksdi51cGxvYWQuYnl0ZXNTZW50PXYudXBsb2FkLnRvdGFsfWlmKGgpcmV0dXJuO2Zvcih2YXIgZz0wLHk9eT1lOyEoZz49eS5sZW5ndGgpOyl7dmFyIGs9eVtnKytdO3RoaXMuZW1pdChcInVwbG9hZHByb2dyZXNzXCIsayxpLGsudXBsb2FkLmJ5dGVzU2VudCl9fX19LHtrZXk6XCJfZmluaXNoZWRVcGxvYWRpbmdcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dm9pZCAwO2lmKGVbMF0uc3RhdHVzIT09by5DQU5DRUxFRCYmND09PXQucmVhZHlTdGF0ZSl7aWYoXCJhcnJheWJ1ZmZlclwiIT09dC5yZXNwb25zZVR5cGUmJlwiYmxvYlwiIT09dC5yZXNwb25zZVR5cGUmJihpPXQucmVzcG9uc2VUZXh0LHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikmJn50LmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSl0cnl7aT1KU09OLnBhcnNlKGkpfWNhdGNoKGUpe249ZSxpPVwiSW52YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gc2VydmVyLlwifXRoaXMuX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZSksMjAwPD10LnN0YXR1cyYmdC5zdGF0dXM8MzAwP2VbMF0udXBsb2FkLmNodW5rZWQ/ZVswXS51cGxvYWQuZmluaXNoZWRDaHVua1VwbG9hZCh0aGlzLl9nZXRDaHVuayhlWzBdLHQpKTp0aGlzLl9maW5pc2hlZChlLGksbik6dGhpcy5faGFuZGxlVXBsb2FkRXJyb3IoZSx0LGkpfX19LHtrZXk6XCJfaGFuZGxlVXBsb2FkRXJyb3JcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoZVswXS5zdGF0dXMhPT1vLkNBTkNFTEVEKXtpZihlWzBdLnVwbG9hZC5jaHVua2VkJiZ0aGlzLm9wdGlvbnMucmV0cnlDaHVua3Mpe3ZhciBpPXRoaXMuX2dldENodW5rKGVbMF0sdCk7aWYoaS5yZXRyaWVzKys8dGhpcy5vcHRpb25zLnJldHJ5Q2h1bmtzTGltaXQpcmV0dXJuIHZvaWQgdGhpcy5fdXBsb2FkRGF0YShlLFtpLmRhdGFCbG9ja10pO2NvbnNvbGUud2FybihcIlJldHJpZWQgdGhpcyBjaHVuayB0b28gb2Z0ZW4uIEdpdmluZyB1cC5cIil9Zm9yKHZhciByPTAscz1zPWU7IShyPj1zLmxlbmd0aCk7KXNbcisrXSx0aGlzLl9lcnJvclByb2Nlc3NpbmcoZSxufHx0aGlzLm9wdGlvbnMuZGljdFJlc3BvbnNlRXJyb3IucmVwbGFjZShcInt7c3RhdHVzQ29kZX19XCIsdC5zdGF0dXMpLHQpfX19LHtrZXk6XCJzdWJtaXRSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2Uuc2VuZCh0KX19LHtrZXk6XCJfZmluaXNoZWRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciBpPTAscj1yPWU7IShpPj1yLmxlbmd0aCk7KXt2YXIgcz1yW2krK107cy5zdGF0dXM9by5TVUNDRVNTLHRoaXMuZW1pdChcInN1Y2Nlc3NcIixzLHQsbiksdGhpcy5lbWl0KFwiY29tcGxldGVcIixzKX1pZih0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUmJih0aGlzLmVtaXQoXCJzdWNjZXNzbXVsdGlwbGVcIixlLHQsbiksdGhpcy5lbWl0KFwiY29tcGxldGVtdWx0aXBsZVwiLGUpKSx0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSlyZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKX19LHtrZXk6XCJfZXJyb3JQcm9jZXNzaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgaT0wLHI9cj1lOyEoaT49ci5sZW5ndGgpOyl7dmFyIHM9cltpKytdO3Muc3RhdHVzPW8uRVJST1IsdGhpcy5lbWl0KFwiZXJyb3JcIixzLHQsbiksdGhpcy5lbWl0KFwiY29tcGxldGVcIixzKX1pZih0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUmJih0aGlzLmVtaXQoXCJlcnJvcm11bHRpcGxlXCIsZSx0LG4pLHRoaXMuZW1pdChcImNvbXBsZXRlbXVsdGlwbGVcIixlKSksdGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCl9fV0sW3trZXk6XCJ1dWlkdjRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLGZ1bmN0aW9uKGUpe3ZhciB0PTE2Kk1hdGgucmFuZG9tKCl8MDtyZXR1cm4oXCJ4XCI9PT1lP3Q6MyZ0fDgpLnRvU3RyaW5nKDE2KX0pfX1dKSxvfSgpO28uaW5pdENsYXNzKCksby52ZXJzaW9uPVwiNS40LjBcIixvLm9wdGlvbnM9e30sby5vcHRpb25zRm9yRWxlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKT9vLm9wdGlvbnNbYShlLmdldEF0dHJpYnV0ZShcImlkXCIpKV06dm9pZCAwfSxvLmluc3RhbmNlcz1bXSxvLmZvckVsZW1lbnQ9ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSkpLG51bGw9PShudWxsIT1lP2UuZHJvcHpvbmU6dm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoXCJObyBEcm9wem9uZSBmb3VuZCBmb3IgZ2l2ZW4gZWxlbWVudC4gVGhpcyBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSdyZSB0cnlpbmcgdG8gYWNjZXNzIGl0IGJlZm9yZSBEcm9wem9uZSBoYWQgdGhlIHRpbWUgdG8gaW5pdGlhbGl6ZS4gVXNlIHRoZSBgaW5pdGAgb3B0aW9uIHRvIHNldHVwIGFueSBhZGRpdGlvbmFsIG9ic2VydmVycyBvbiB5b3VyIERyb3B6b25lLlwiKTtyZXR1cm4gZS5kcm9wem9uZX0sby5hdXRvRGlzY292ZXI9ITAsby5kaXNjb3Zlcj1mdW5jdGlvbigpe3ZhciBlPXZvaWQgMDtpZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKWU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5kcm9wem9uZVwiKTtlbHNle2U9W107dmFyIHQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLGk9MCxyPXI9dDshKGk+PXIubGVuZ3RoKTspe3ZhciBvPXJbaSsrXTsvKF58IClkcm9wem9uZSgkfCApLy50ZXN0KG8uY2xhc3NOYW1lKT9uLnB1c2goZS5wdXNoKG8pKTpuLnB1c2godm9pZCAwKX1yZXR1cm4gbn0oKX07dChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSksdChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZvcm1cIikpfXJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxuPTAsaT1pPWU7IShuPj1pLmxlbmd0aCk7KXt2YXIgcj1pW24rK107ITEhPT1vLm9wdGlvbnNGb3JFbGVtZW50KHIpP3QucHVzaChuZXcgbyhyKSk6dC5wdXNoKHZvaWQgMCl9cmV0dXJuIHR9KCl9LG8uYmxhY2tsaXN0ZWRCcm93c2Vycz1bL29wZXJhLiooTWFjaW50b3NofFdpbmRvd3MgUGhvbmUpLip2ZXJzaW9uXFwvMTIvaV0sby5pc0Jyb3dzZXJTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXt2YXIgZT0hMDtpZih3aW5kb3cuRmlsZSYmd2luZG93LkZpbGVSZWFkZXImJndpbmRvdy5GaWxlTGlzdCYmd2luZG93LkJsb2ImJndpbmRvdy5Gb3JtRGF0YSYmZG9jdW1lbnQucXVlcnlTZWxlY3RvcilpZihcImNsYXNzTGlzdFwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpZm9yKHZhciB0PTAsbj1uPW8uYmxhY2tsaXN0ZWRCcm93c2VyczshKHQ+PW4ubGVuZ3RoKTspblt0KytdLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJihlPSExKTtlbHNlIGU9ITE7ZWxzZSBlPSExO3JldHVybiBlfSxvLmRhdGFVUkl0b0Jsb2I9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWF0b2IoZS5zcGxpdChcIixcIilbMV0pLG49ZS5zcGxpdChcIixcIilbMF0uc3BsaXQoXCI6XCIpWzFdLnNwbGl0KFwiO1wiKVswXSxpPW5ldyBBcnJheUJ1ZmZlcih0Lmxlbmd0aCkscj1uZXcgVWludDhBcnJheShpKSxvPTAscz10Lmxlbmd0aCxhPTA8PXM7YT9vPD1zOm8+PXM7YT9vKys6by0tKXJbb109dC5jaGFyQ29kZUF0KG8pO3JldHVybiBuZXcgQmxvYihbaV0se3R5cGU6bn0pfTt2YXIgcz1mdW5jdGlvbihlLHQpe3JldHVybiBlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PXR9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KX0sYT1mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bXFwtX10oXFx3KS9nLGZ1bmN0aW9uKGUpe3JldHVybiBlLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpfSl9O28uY3JlYXRlRWxlbWVudD1mdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY2hpbGROb2Rlc1swXX0sby5lbGVtZW50SW5zaWRlPWZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpcmV0dXJuITA7Zm9yKDtlPWUucGFyZW50Tm9kZTspaWYoZT09PXQpcmV0dXJuITA7cmV0dXJuITF9LG8uZ2V0RWxlbWVudD1mdW5jdGlvbihlLHQpe3ZhciBuPXZvaWQgMDtpZihcInN0cmluZ1wiPT10eXBlb2YgZT9uPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSk6bnVsbCE9ZS5ub2RlVHlwZSYmKG49ZSksbnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGBcIit0K1wiYCBvcHRpb24gcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIGEgQ1NTIHNlbGVjdG9yIG9yIGEgcGxhaW4gSFRNTCBlbGVtZW50LlwiKTtyZXR1cm4gbn0sby5nZXRFbGVtZW50cz1mdW5jdGlvbihlLHQpe3ZhciBuPXZvaWQgMCxpPXZvaWQgMDtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2k9W107dHJ5e2Zvcih2YXIgcj0wLG89bz1lOyEocj49by5sZW5ndGgpOyluPW9bcisrXSxpLnB1c2godGhpcy5nZXRFbGVtZW50KG4sdCkpfWNhdGNoKGUpe2k9bnVsbH19ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aT1bXTtmb3IodmFyIHM9MCxhPWE9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKTshKHM+PWEubGVuZ3RoKTspbj1hW3MrK10saS5wdXNoKG4pfWVsc2UgbnVsbCE9ZS5ub2RlVHlwZSYmKGk9W2VdKTtpZihudWxsPT1pfHwhaS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgXCIrdCtcImAgb3B0aW9uIHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSBhIENTUyBzZWxlY3RvciwgYSBwbGFpbiBIVE1MIGVsZW1lbnQgb3IgYSBsaXN0IG9mIHRob3NlLlwiKTtyZXR1cm4gaX0sby5jb25maXJtPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gd2luZG93LmNvbmZpcm0oZSk/dCgpOm51bGwhPW4/bigpOnZvaWQgMH0sby5pc1ZhbGlkRmlsZT1mdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiEwO3Q9dC5zcGxpdChcIixcIik7Zm9yKHZhciBuPWUudHlwZSxpPW4ucmVwbGFjZSgvXFwvLiokLyxcIlwiKSxyPTAsbz1vPXQ7IShyPj1vLmxlbmd0aCk7KXt2YXIgcz1vW3IrK107aWYoXCIuXCI9PT0ocz1zLnRyaW0oKSkuY2hhckF0KDApKXtpZigtMSE9PWUubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yocy50b0xvd2VyQ2FzZSgpLGUubmFtZS5sZW5ndGgtcy5sZW5ndGgpKXJldHVybiEwfWVsc2UgaWYoL1xcL1xcKiQvLnRlc3Qocykpe2lmKGk9PT1zLnJlcGxhY2UoL1xcLy4qJC8sXCJcIikpcmV0dXJuITB9ZWxzZSBpZihuPT09cylyZXR1cm4hMH1yZXR1cm4hMX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGpRdWVyeSYmbnVsbCE9PWpRdWVyeSYmKGpRdWVyeS5mbi5kcm9wem9uZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvKHRoaXMsZSl9KX0pLHZvaWQgMCE9PWUmJm51bGwhPT1lP2UuZXhwb3J0cz1vOndpbmRvdy5Ecm9wem9uZT1vLG8uQURERUQ9XCJhZGRlZFwiLG8uUVVFVUVEPVwicXVldWVkXCIsby5BQ0NFUFRFRD1vLlFVRVVFRCxvLlVQTE9BRElORz1cInVwbG9hZGluZ1wiLG8uUFJPQ0VTU0lORz1vLlVQTE9BRElORyxvLkNBTkNFTEVEPVwiY2FuY2VsZWRcIixvLkVSUk9SPVwiZXJyb3JcIixvLlNVQ0NFU1M9XCJzdWNjZXNzXCI7dmFyIGw9ZnVuY3Rpb24oZSx0LG4saSxyLG8scyxhLGwsdSl7dmFyIGM9ZnVuY3Rpb24oZSl7ZS5uYXR1cmFsV2lkdGg7dmFyIHQ9ZS5uYXR1cmFsSGVpZ2h0LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtuLndpZHRoPTEsbi5oZWlnaHQ9dDt2YXIgaT1uLmdldENvbnRleHQoXCIyZFwiKTtpLmRyYXdJbWFnZShlLDAsMCk7Zm9yKHZhciByPWkuZ2V0SW1hZ2VEYXRhKDEsMCwxLHQpLmRhdGEsbz0wLHM9dCxhPXQ7YT5vOykwPT09cls0KihhLTEpKzNdP3M9YTpvPWEsYT1zK28+PjE7dmFyIGw9YS90O3JldHVybiAwPT09bD8xOmx9KHQpO3JldHVybiBlLmRyYXdJbWFnZSh0LG4saSxyLG8scyxhLGwsdS9jKX0sdT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtuKHRoaXMsZSl9cmV0dXJuIGkoZSxudWxsLFt7a2V5OlwiaW5pdENsYXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLktFWV9TVFI9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0se2tleTpcImVuY29kZTY0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVwiXCIsbj12b2lkIDAsaT12b2lkIDAscj1cIlwiLG89dm9pZCAwLHM9dm9pZCAwLGE9dm9pZCAwLGw9XCJcIix1PTA7bz0obj1lW3UrK10pPj4yLHM9KDMmbik8PDR8KGk9ZVt1KytdKT4+NCxhPSgxNSZpKTw8Mnwocj1lW3UrK10pPj42LGw9NjMmcixpc05hTihpKT9hPWw9NjQ6aXNOYU4ocikmJihsPTY0KSx0PXQrdGhpcy5LRVlfU1RSLmNoYXJBdChvKSt0aGlzLktFWV9TVFIuY2hhckF0KHMpK3RoaXMuS0VZX1NUUi5jaGFyQXQoYSkrdGhpcy5LRVlfU1RSLmNoYXJBdChsKSxuPWk9cj1cIlwiLG89cz1hPWw9XCJcIix1PGUubGVuZ3RoOyk7cmV0dXJuIHR9fSx7a2V5OlwicmVzdG9yZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIWUubWF0Y2goXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKSlyZXR1cm4gdDt2YXIgbj10aGlzLmRlY29kZTY0KGUucmVwbGFjZShcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIsXCJcIikpLGk9dGhpcy5zbGljZTJTZWdtZW50cyhuKSxyPXRoaXMuZXhpZk1hbmlwdWxhdGlvbih0LGkpO3JldHVyblwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIit0aGlzLmVuY29kZTY0KHIpfX0se2tleTpcImV4aWZNYW5pcHVsYXRpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuZ2V0RXhpZkFycmF5KHQpLGk9dGhpcy5pbnNlcnRFeGlmKGUsbik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGkpfX0se2tleTpcImdldEV4aWZBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD12b2lkIDAsbj0wO248ZS5sZW5ndGg7KXtpZigyNTU9PT0odD1lW25dKVswXSYyMjU9PT10WzFdKXJldHVybiB0O24rK31yZXR1cm5bXX19LHtrZXk6XCJpbnNlcnRFeGlmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLnJlcGxhY2UoXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiLFwiXCIpLGk9dGhpcy5kZWNvZGU2NChuKSxyPWkuaW5kZXhPZigyNTUsMyksbz1pLnNsaWNlKDAscikscz1pLnNsaWNlKHIpLGE9bztyZXR1cm4gYT0oYT1hLmNvbmNhdCh0KSkuY29uY2F0KHMpfX0se2tleTpcInNsaWNlMlNlZ21lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj1bXTshKDI1NT09PWVbdF0mMjE4PT09ZVt0KzFdKTspe2lmKDI1NT09PWVbdF0mMjE2PT09ZVt0KzFdKXQrPTI7ZWxzZXt2YXIgaT10KygyNTYqZVt0KzJdK2VbdCszXSkrMixyPWUuc2xpY2UodCxpKTtuLnB1c2gociksdD1pfWlmKHQ+ZS5sZW5ndGgpYnJlYWt9cmV0dXJuIG59fSx7a2V5OlwiZGVjb2RlNjRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD12b2lkIDAsbj12b2lkIDAsaT1cIlwiLHI9dm9pZCAwLG89dm9pZCAwLHM9XCJcIixhPTAsbD1bXTtmb3IoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLmV4ZWMoZSkmJmNvbnNvbGUud2FybihcIlRoZXJlIHdlcmUgaW52YWxpZCBiYXNlNjQgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dC5cXG5WYWxpZCBiYXNlNjQgY2hhcmFjdGVycyBhcmUgQS1aLCBhLXosIDAtOSwgJysnLCAnLycsYW5kICc9J1xcbkV4cGVjdCBlcnJvcnMgaW4gZGVjb2RpbmcuXCIpLGU9ZS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZyxcIlwiKTt0PXRoaXMuS0VZX1NUUi5pbmRleE9mKGUuY2hhckF0KGErKykpPDwyfChyPXRoaXMuS0VZX1NUUi5pbmRleE9mKGUuY2hhckF0KGErKykpKT4+NCxuPSgxNSZyKTw8NHwobz10aGlzLktFWV9TVFIuaW5kZXhPZihlLmNoYXJBdChhKyspKSk+PjIsaT0oMyZvKTw8Nnwocz10aGlzLktFWV9TVFIuaW5kZXhPZihlLmNoYXJBdChhKyspKSksbC5wdXNoKHQpLDY0IT09byYmbC5wdXNoKG4pLDY0IT09cyYmbC5wdXNoKGkpLHQ9bj1pPVwiXCIscj1vPXM9XCJcIixhPGUubGVuZ3RoOyk7cmV0dXJuIGx9fV0pLGV9KCk7dS5pbml0Q2xhc3MoKSxvLl9hdXRvRGlzY292ZXJGdW5jdGlvbj1mdW5jdGlvbigpe2lmKG8uYXV0b0Rpc2NvdmVyKXJldHVybiBvLmRpc2NvdmVyKCl9LGZ1bmN0aW9uKGUsdCl7dmFyIG49ITEsaT0hMCxyPWUuZG9jdW1lbnQsbz1yLmRvY3VtZW50RWxlbWVudCxzPXIuYWRkRXZlbnRMaXN0ZW5lcj9cImFkZEV2ZW50TGlzdGVuZXJcIjpcImF0dGFjaEV2ZW50XCIsYT1yLmFkZEV2ZW50TGlzdGVuZXI/XCJyZW1vdmVFdmVudExpc3RlbmVyXCI6XCJkZXRhY2hFdmVudFwiLGw9ci5hZGRFdmVudExpc3RlbmVyP1wiXCI6XCJvblwiLHU9ZnVuY3Rpb24gaShvKXtpZihcInJlYWR5c3RhdGVjaGFuZ2VcIiE9PW8udHlwZXx8XCJjb21wbGV0ZVwiPT09ci5yZWFkeVN0YXRlKXJldHVybihcImxvYWRcIj09PW8udHlwZT9lOnIpW2FdKGwrby50eXBlLGksITEpLCFuJiYobj0hMCk/dC5jYWxsKGUsby50eXBlfHxvKTp2b2lkIDB9O2lmKFwiY29tcGxldGVcIiE9PXIucmVhZHlTdGF0ZSl7aWYoci5jcmVhdGVFdmVudE9iamVjdCYmby5kb1Njcm9sbCl7dHJ5e2k9IWUuZnJhbWVFbGVtZW50fWNhdGNoKGUpe31pJiZmdW5jdGlvbiBlKCl7dHJ5e28uZG9TY3JvbGwoXCJsZWZ0XCIpfWNhdGNoKHQpe3JldHVybiB2b2lkIHNldFRpbWVvdXQoZSw1MCl9cmV0dXJuIHUoXCJwb2xsXCIpfSgpfXJbc10obCtcIkRPTUNvbnRlbnRMb2FkZWRcIix1LCExKSxyW3NdKGwrXCJyZWFkeXN0YXRlY2hhbmdlXCIsdSwhMSksZVtzXShsK1wibG9hZFwiLHUsITEpfX0od2luZG93LG8uX2F1dG9EaXNjb3ZlckZ1bmN0aW9uKX0pLmNhbGwodCxuKDYpKGUpKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUud2VicGFja1BvbHlmaWxsfHwoZS5kZXByZWNhdGU9ZnVuY3Rpb24oKXt9LGUucGF0aHM9W10sZS5jaGlsZHJlbnx8KGUuY2hpbGRyZW49W10pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwibG9hZGVkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUubH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImlkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtZHJvcHpvbmUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJvcHpvbmUtY29tcG9uZW50L2Rpc3QvcmVhY3QtZHJvcHpvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgU2VhcmNoIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hDb250cm9sIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHt2YWx1ZSA6ICcnfTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICBcclxuICAgIHZhciBjb250cm9sUHJvcHMgPSB7fTtcclxuICAgIGZvcih2YXIgcCBpbiB0aGlzLnByb3BzKXtcclxuICAgICAgICBpZiggcCA9PSBcInZhbHVlXCIgfHxcclxuICAgICAgICAgICAgcCA9PSBcImhhbmRsZUV2ZW50XCIpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRyb2xQcm9wc1twXSA9IHRoaXMucHJvcHNbcF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAoPFNlYXJjaFxyXG4gICAgICB7Li4uY29udHJvbFByb3BzfVxyXG4gICAgICBmbHVpZD17dHJ1ZX1cclxuICAgICAgbG9hZGluZz17dGhpcy5zdGF0ZS5pc0xvYWRpbmd9XHJcbiAgICAgIG9uUmVzdWx0U2VsZWN0PXt0aGlzLmhhbmRsZVJlc3VsdFNlbGVjdC5iaW5kKHRoaXMpfVxyXG4gICAgICBvblNlYXJjaENoYW5nZT17dGhpcy5oYW5kbGVTZWFyY2hDaGFuZ2UuYmluZCh0aGlzKX1cclxuICAgICAgcmVzdWx0cz17dGhpcy5zdGF0ZS5yZXN1bHRzfVxyXG4gICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cclxuICAgICAgLz4pO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRTZWFyY2goKXtcclxuICAgIHRoaXMuc2V0U3RhdGUoeyBpc0xvYWRpbmc6IGZhbHNlLCByZXN1bHRzOiBbXX0pO1xyXG4gIH1cclxuICBcclxuICBoYW5kbGVSZXN1bHRTZWxlY3QoZSwge3Jlc3VsdH0pe1xyXG4gICAgaWYgKHRoaXMucHJvcHMuaGFuZGxlRXZlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnByb3BzLmhhbmRsZUV2ZW50KHtrZXk6IHRoaXMucHJvcHMubmFtZSwgZXZlbnROYW1lOiBcIm9uU2VsZWN0XCIsIHBhcmFtZXRlcnM6IHJlc3VsdH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlU2VhcmNoQ2hhbmdlKGUsIHt2YWx1ZX0pe1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIG1lLnNldFN0YXRlKHsgaXNMb2FkaW5nOiB0cnVlLCB2YWx1ZSB9KTtcclxuICAgIFxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICBpZiAobWUuc3RhdGUudmFsdWUgPT09IG51bGwgfHwgbWUuc3RhdGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBtZS5zdGF0ZS52YWx1ZS5sZW5ndGggPCAyKXsgXHJcbiAgICAgICAgcmV0dXJuIG1lLnJlc2V0U2VhcmNoKCk7XHJcbiAgICAgIH1cclxuICAgICAgbWUuc2VhcmNoKG1lLnN0YXRlLnZhbHVlKTtcclxuICAgIH0sIDIwMCk7XHJcbiAgfVxyXG5cclxuICBzZWFyY2goc2VhcmNoU3RyKXtcclxuICAgIGxldCBtZSA9IHRoaXM7XHJcbiAgICBsZXQgdXJsID0gdGhpcy5wcm9wcy51cmw7XHJcbiAgICB1cmwgKz0gdGhpcy5wcm9wcy51cmwuaW5jbHVkZXMoJz8nKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICB1cmwgKz0gXCJ0ZXJtPVwiICsgc2VhcmNoU3RyO1xyXG4gICAgZmV0Y2godXJsLCB7XHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXHJcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfSlcclxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHNcclxuICAgICAgICB9KTtcclxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICBpZihjb25zb2xlID09IHVuZGVmaW5lZClcclxuICAgICAgICBhbGVydChlcnJvcik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb250cm9sL3NlYXJjaC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgRFdLaXRTdG9yZSBmcm9tICcuL3N0b3JlJztcclxuaW1wb3J0IEJ1aWxkZXJBY3Rpb25zIGZyb20gJy4vYWN0aW9ucyc7XHJcbmltcG9ydCBEV0tpdEZvcm1Db250cm9scyBmcm9tICcuL2NvbnRyb2xzJztcclxuaW1wb3J0IHtCdXR0b24sIENoZWNrYm94fSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmV2aWV3IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGRhdGE6IFtdLFxyXG4gICAgICBlZGl0RWxlbWVudDogbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIERXS2l0U3RvcmUubGlzdGVuKHRoaXMuZGF0YUNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG4gIFxyXG4gIGRhdGFDaGFuZ2VkKGRhdGEpe1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgIGRhdGEsXHJcbiAgICAgIGVkaXRFbGVtZW50OiBudWxsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9vbkVkaXQoaXRlbSkge1xyXG4gICAgQnVpbGRlckFjdGlvbnMuc2hvd0VkaXRGb3JtKGl0ZW0ua2V5KTtcclxuICB9XHJcblxyXG4gIF9vbkNvcHkoaXRlbSkge1xyXG4gICAgRFdLaXRTdG9yZS5jb3B5KGl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgX29uRGVzdHJveShpdGVtKSB7XHJcbiAgICBEV0tpdFN0b3JlLnJlbW92ZShpdGVtKTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVFdmVudChwKXtcclxuICAgIC8vIGlmKGNvbnNvbGUgIT0gdW5kZWZpbmVkKXtcclxuICAgIC8vICAgY29uc29sZS5sb2coXCJEV0tpdEZvcm1CdWlsZGVyOiBoYW5kbGVFdmVudFwiLCBwKTtcclxuICAgIC8vIH1cclxuICB9XHJcbiAgXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgdmFyIGl0ZW1zID0gRFdLaXRGb3JtQ29udHJvbHMuY3JlYXRlQ29udHJvbHModGhpcyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLnN0YXRlLmRhdGEsXHJcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYnVpbGRlcm1vZGU6IHRydWUsXHJcbiAgICAgICAgICAgIGV2ZW50T25FZGl0OiB0aGlzLl9vbkVkaXQsXHJcbiAgICAgICAgICAgIGV2ZW50T25EZWxldGU6IHRoaXMuX29uRGVzdHJveSxcclxuICAgICAgICAgICAgZXZlbnRPbkNvcHk6IHRoaXMuX29uQ29weSxcclxuICAgICAgICAgICAgcGFyZW50SXRlbTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBoYW5kbGVFdmVudDogdGhpcy5faGFuZGxlRXZlbnQsXHJcbiAgICAgICAgICAgIGdldEZvcm1GdW5jOiB0aGlzLnByb3BzLmdldEZvcm1GdW5jLFxyXG4gICAgICAgICAgICBnZXRGb3JtRmlzdDogdGhpcy5wcm9wcy5nZXRGb3JtRmlzdCxcclxuICAgICAgICAgICAgZ2V0QWRkaXRpb25hbERhdGFGb3JDb250cm9sOiB0aGlzLnByb3BzLmdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbCxcclxuICAgICAgICAgICAgZGlzYWJsZVJlZnM6IHRydWUsXHJcbiAgICAgICAgICAgIGRvd25sb2FkVXJsOiB0aGlzLnByb3BzLmRvd25sb2FkVXJsLFxyXG4gICAgICAgICAgICB1cGxvYWRVcmw6IHRoaXMucHJvcHMudXBsb2FkVXJsLFxyXG4gICAgICAgICAgICBjb250cm9sc1RvUmVwbGFjZTogW10sXHJcbiAgICAgICAgICAgIG5lZWRDaGVja1JlcGxhY2U6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuICAgICAgXHJcbiAgICB2YXIgZHJvcHpvbmV0ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYodGhpcy5wcm9wcy5sb2NhbGl6YXRpb24gIT0gdW5kZWZpbmVkICYmIHRoaXMucHJvcHMubG9jYWxpemF0aW9uLnByZXZpZXcgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgZHJvcHpvbmV0ZXh0ID0gdGhpcy5wcm9wcy5sb2NhbGl6YXRpb24ucHJldmlldy5kcm9wem9uZXRleHQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZHJvcHpvbmUgPSBEV0tpdEZvcm1Db250cm9scy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUoXCJkcm9wem9uZV9oZWFkZXJcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRyb3B6b25ldGV4dCk7XHJcbiAgICB2YXIgZHJvcHpvbmVfZm9vdGVyID0gaXRlbXMubGVuZ3RoID4gMCA/IFxyXG4gICAgICBEV0tpdEZvcm1Db250cm9scy5jcmVhdGVCdWlsZGVyRHJvcHpvbmUoXCJkcm9wem9uZV9mb290ZXJcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRyb3B6b25ldGV4dCkgXHJcbiAgICAgIDogJyc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiAgY2xhc3NOYW1lPVwiZHdraXQtZm9ybWJ1aWxkZXItcHJldmlld1wiPlxyXG4gICAgICAgIHtkcm9wem9uZX1cclxuICAgICAgICB7aXRlbXN9XHJcbiAgICAgICAge2Ryb3B6b25lX2Zvb3Rlcn1cclxuICAgICAgPC9kaXY+XHJcbiAgICApXHJcbiAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ByZXZpZXcuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xyXG5pbXBvcnQgRFdLaXRTdG9yZSBmcm9tICcuL3N0b3JlJztcclxuaW1wb3J0IEJ1aWxkZXJBY3Rpb25zIGZyb20gJy4vYWN0aW9ucyc7XHJcbmltcG9ydCBEV0tpdEZvcm1Db250cm9scyBmcm9tICcuL2NvbnRyb2xzJztcclxuaW1wb3J0IHtGb3JtLCBHcmlkLCBDYXJkLCBJbnB1dCwgRHJvcGRvd24sIENoZWNrYm94LCBUZXh0QXJlYSwgQnV0dG9uLCBJY29uLCBNZXNzYWdlLCBJbWFnZSwgTGFiZWwsIEhlYWRlciwgSXRlbSwgU2VnbWVudCwgTW9kYWwsIENvbmZpcm19IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdEZvcm0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAga2V5OiB1bmRlZmluZWQsXHJcbiAgICAgIGl0ZW06IHVuZGVmaW5lZCxcclxuICAgICAgb3BlbjogZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgRFdLaXRTdG9yZS5saXN0ZW5UbyhCdWlsZGVyQWN0aW9ucy5zaG93RWRpdEZvcm0sIHRoaXMub25TaG93LmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlQ2hhbmdlKGUsIHsgbmFtZSwgdmFsdWUsIGNoZWNrZWQgfSl7XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuc3RhdGUuaXRlbTtcclxuICAgIFxyXG4gICAgaWYodmFsdWUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICBkYXRhW25hbWVdID0gY2hlY2tlZDtcclxuICAgIGVsc2VcclxuICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0U3RhdGUoe2l0ZW06IGRhdGF9KTtcclxuICB9XHJcblxyXG4gIG9uU2hvdyhrZXkpe1xyXG4gICAgIHZhciBkYXRhID0gRFdLaXRTdG9yZS5nZXRCeUtleShrZXkpO1xyXG4gICAgIHZhciBpdGVtID0ge307XHJcbiAgICAgZm9yKHZhciBpIGluIGRhdGEpe1xyXG4gICAgICAgaWYodHlwZW9mKGRhdGFbaV0pID09IFwib2JqZWN0XCIpe1xyXG4gICAgICAgIGl0ZW1baV0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKTtcclxuICAgICAgIH1cclxuICAgICAgIGVsc2V7XHJcbiAgICAgICAgaXRlbVtpXSA9IGRhdGFbaV07XHJcbiAgICAgICB9XHJcbiAgICAgfVxyXG5cclxuICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAga2V5OiBrZXksXHJcbiAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgIG9wZW46IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaXNDaGFuZ2VkSXRlbSgpe1xyXG4gICAgdmFyIGRhdGEgPSBEV0tpdFN0b3JlLmdldEJ5S2V5KHRoaXMuc3RhdGUua2V5KTtcclxuICAgIHZhciBpdGVtID0gdGhpcy5zdGF0ZS5pdGVtO1xyXG5cclxuICAgIGZvcih2YXIgaSBpbiBpdGVtKXtcclxuICAgICAgaWYoSlNPTi5zdHJpbmdpZnkoaXRlbVtpXSkgIT0gSlNPTi5zdHJpbmdpZnkoZGF0YVtpXSkpXHJcbiAgICAgICAgaWYoaSA9PSBcImV2ZW50c1wiICYmXHJcbiAgICAgICAgICAoaXRlbVtpXSA9PSB1bmRlZmluZWQgfHwgSlNPTi5zdHJpbmdpZnkoaXRlbVtpXSkgPT0gXCJ7fVwiKSAmJlxyXG4gICAgICAgICAgKGRhdGFbaV0gPT0gdW5kZWZpbmVkIHx8IEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pID09IFwie31cIikpe1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29udHJvbHNMaXN0KCl7XHJcbiAgICByZXR1cm4gRFdLaXRTdG9yZS5nZXRBbGxLZXlzKERXS2l0U3RvcmUuZ2V0RGF0YSgpKTtcclxuICB9XHJcblxyXG4gIHNob3dDb25maXJtKHRleHQsIGNvbmZpcm1IYW5kbGUpe1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNvbmZpcm06IHRydWUsIGNvbmZpcm10ZXh0OiB0ZXh0LCBjb25maXJtSGFuZGxlOiBjb25maXJtSGFuZGxlIH0pO1xyXG4gIH1cclxuXHJcbiAgb25DbG9zZSgpIHtcclxuICAgIHZhciBpc2NoYW5nZWQgPSB0aGlzLmlzQ2hhbmdlZEl0ZW0oKTtcclxuICAgIGlmKGlzY2hhbmdlZCl7XHJcbiAgICAgICAgbGV0IG1zZyA9IFwiQ2xvc2Ugd2l0aG91dCBzYXZlP1wiO1xyXG4gICAgICAgIGlmKHRoaXMucHJvcHMubG9jYWxpemF0aW9uICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICBtc2cgPSB0aGlzLnByb3BzLmxvY2FsaXphdGlvbi5iYXNlLmNsb3Nld2l0aG91dHNhdmVxdWVzdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hvd0NvbmZpcm0obXNnLCB0aGlzLm9uQ2xvc2VDb25maXJtZWQuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgIHRoaXMub25DbG9zZUNvbmZpcm1lZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25TYXZlKCkge1xyXG4gICAgRFdLaXRTdG9yZS51cGRhdGVJdGVtQnlLZXkodGhpcy5zdGF0ZS5rZXksIHRoaXMuc3RhdGUuaXRlbSk7XHJcbiAgICB0aGlzLm9uQ2xvc2VDb25maXJtZWQoKTtcclxuICB9XHJcblxyXG4gIG9uQ2xvc2VDb25maXJtZWQoKSB7XHJcbiAgICB0aGlzLnNldFN0YXRlKHsgb3BlbjogZmFsc2UsIGNvbmZpcm06IGZhbHNlIH0pO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRXJyb3IodGV4dCl7XHJcblxyXG4gICAgdmFyIGNsb3NlYnRuID0gXCJDbG9zZVwiO1xyXG4gICAgaWYodGhpcy5wcm9wcy5sb2NhbGl6YXRpb24gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgY2xvc2VidG4gPSB0aGlzLnByb3BzLmxvY2FsaXphdGlvbi5iYXNlLmNsb3NlYnV0dG9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoPE1vZGFsIG9wZW49e3RoaXMuc3RhdGUub3Blbn0gb25DbG9zZT17dGhpcy5vbkNsb3NlLmJpbmQodGhpcyl9PlxyXG4gICAgICAgICAgPE1vZGFsLkhlYWRlcj5cclxuICAgICAgICAgICAgRXJyb3JcclxuICAgICAgICAgIDwvTW9kYWwuSGVhZGVyPlxyXG4gICAgICAgICAgPE1vZGFsLkNvbnRlbnQ+XHJcbiAgICAgICAgICAgIDxwPnt0ZXh0fTwvcD5cclxuICAgICAgICAgIDwvTW9kYWwuQ29udGVudD5cclxuICAgICAgICAgIDxNb2RhbC5BY3Rpb25zPlxyXG4gICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e3RoaXMub25DbG9zZS5iaW5kKHRoaXMpfT5cclxuICAgICAgICAgICAgICB7Y2xvc2VidG59XHJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgPC9Nb2RhbC5BY3Rpb25zPlxyXG4gICAgICAgIDwvTW9kYWw+KTtcclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIGlmKHRoaXMuc3RhdGUuaXRlbSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuICg8ZGl2Lz4pOyBcclxuXHJcbiAgICB2YXIgZWRpdEZvcm0gPSBEV0tpdEZvcm1Db250cm9scy5nZXRFZGl0Q29udHJvbEJ5VHlwZSh0aGlzLnN0YXRlLml0ZW1bXCJkYXRhLWJ1aWxkZXJ0eXBlXCJdKTtcclxuICAgIGlmKGVkaXRGb3JtID09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoXCJFZGl0Rm9ybSBpcyBub3QgZm91bmQgZm9yIHRoaXMgY29udHJvbCFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9rYnRuID0gXCJPS1wiO1xyXG4gICAgaWYodGhpcy5wcm9wcy5sb2NhbGl6YXRpb24gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgb2tidG4gPSB0aGlzLnByb3BzLmxvY2FsaXphdGlvbi5iYXNlLm9rYnV0dG9uO1xyXG4gICAgfVxyXG4gICAgdmFyIGNhbmNlbGJ0biA9IFwiQ2FuY2VsXCI7XHJcbiAgICBpZih0aGlzLnByb3BzLmxvY2FsaXphdGlvbiAhPSB1bmRlZmluZWQpe1xyXG4gICAgICBjYW5jZWxidG4gPSB0aGlzLnByb3BzLmxvY2FsaXphdGlvbi5iYXNlLmNhbmNlbGJ1dHRvbjtcclxuICAgIH1cclxuICAgIHZhciBxdWVzdGlvbnRpdGxlID0gXCJRdWVzdGlvblwiO1xyXG4gICAgaWYodGhpcy5wcm9wcy5sb2NhbGl6YXRpb24gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgcXVlc3Rpb250aXRsZSA9IHRoaXMucHJvcHMubG9jYWxpemF0aW9uLmJhc2UucXVlc3Rpb250aXRsZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29uZmlybUhhbmRsZUNhbmNlbCA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBjb25maXJtOiBmYWxzZSB9KTtcclxuICAgIHJldHVybiA8ZGl2PlxyXG4gICAgICAgIHtSZWFjdC5jcmVhdGVFbGVtZW50KGVkaXRGb3JtLCB7IGtleTogXCJlZGl0Zm9ybVwiLCBcclxuICAgICAgICAgIGRhdGE6IHRoaXMuc3RhdGUuaXRlbSwgXHJcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMsXHJcbiAgICAgICAgICBvcGVuOiB0aGlzLnN0YXRlLm9wZW4sXHJcbiAgICAgICAgICBvblNhdmU6IHRoaXMub25TYXZlLFxyXG4gICAgICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxyXG4gICAgICAgICAgYWN0aW9uczogdGhpcy5wcm9wcy5hY3Rpb25zLFxyXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImR3a2l0LWZvcm1idWlsZGVyLWVkaXRmb3JtXCIsXHJcbiAgICAgICAgICBsb2NhbGl6YXRpb246IHRoaXMucHJvcHMubG9jYWxpemF0aW9uXHJcbiAgICAgICAgfSl9XHJcbiAgICAgICAgPE1vZGFsIHNpemU9XCJzbWFsbFwiIG9wZW49e3RoaXMuc3RhdGUuY29uZmlybX0gZGltbWVyPVwiaW52ZXJ0ZWRcIiBvbkNsb3NlPXtjb25maXJtSGFuZGxlQ2FuY2VsfT5cclxuICAgICAgICAgIDxNb2RhbC5IZWFkZXI+XHJcbiAgICAgICAgICAgIHtxdWVzdGlvbnRpdGxlfVxyXG4gICAgICAgICAgPC9Nb2RhbC5IZWFkZXI+XHJcbiAgICAgICAgICA8TW9kYWwuQ29udGVudD5cclxuICAgICAgICAgICAgPHA+e3RoaXMuc3RhdGUuY29uZmlybXRleHR9PC9wPlxyXG4gICAgICAgICAgPC9Nb2RhbC5Db250ZW50PlxyXG4gICAgICAgICAgPE1vZGFsLkFjdGlvbnM+XHJcbiAgICAgICAgICAgIDxCdXR0b24gY2xhc3NOYW1lPVwiYnV0dG9udHlwZTFcIiBvbkNsaWNrPXt0aGlzLnN0YXRlLmNvbmZpcm1IYW5kbGV9Pntva2J0bn08L0J1dHRvbj5cclxuICAgICAgICAgICAgPEJ1dHRvbiBjbGFzc05hbWU9XCJidXR0b250eXBlMlwiIG9uQ2xpY2s9e2NvbmZpcm1IYW5kbGVDYW5jZWx9PntjYW5jZWxidG59PC9CdXR0b24+XHJcbiAgICAgICAgICA8L01vZGFsLkFjdGlvbnM+XHJcbiAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICA8L2Rpdj5cclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGZvcm0uanN4IiwidmFyIGxhbmcgPSB7XHJcbiAgY2xlYXJidXR0b246IFwiQ2xlYXJcIixcclxuICB1cGxvYWRidXR0b246IFwiVXBsb2FkXCIsXHJcbiAgZG93bmxvYWRidXR0b246IFwiRG93bmxvYWRcIixcclxuICB0b29sYmFyOntcclxuICAgIHNlcENvbnRhaW5lcnM6IFwiQ29udGFpbmVyc1wiLFxyXG4gICAgY29udGFpbmVyOiBcIkRJVlwiLFxyXG4gICAgZm9ybTogXCJGb3JtXCIsXHJcbiAgICBmb3JtZ3JvdXA6IFwiRm9ybSBHcm91cFwiLFxyXG4gICAgbWVudTogXCJNZW51XCIsXHJcbiAgICB3b3JrZmxvd2JhcjogXCJXb3JrZmxvdyBiYXJcIixcclxuICAgIGN1c3RvbWJsb2NrOiBcIkN1c3RvbSBibG9ja1wiLFxyXG4gICAgc2VwQ29sbGVjdGlvbjogXCJDb2xsZWN0aW9uc1wiLFxyXG4gICAgZ3JpZHZpZXc6IFwiR3JpZFZpZXdcIixcclxuICAgIGNvbGxlY3Rpb25lZGl0b3I6IFwiQ29sbGVjdGlvbiBFZGl0b3JcIixcclxuICAgIHNlcENvbnRyb2xzOiBcIkNvbnRyb2xzXCIsXHJcbiAgICBoZWFkZXI6IFwiSGVhZGVyXCIsXHJcbiAgICBpbnB1dDogXCJJbnB1dFwiLFxyXG4gICAgdGV4dGFyZWE6IFwiVGV4dEFyZWFcIixcclxuICAgIGRpY3Rpb25hcnk6IFwiRGljdGlvbmFyeVwiLFxyXG4gICAgZHJvcGRvd246IFwiRHJvcGRvd25cIixcclxuICAgIGNoZWNrYm94OiBcIkNoZWNrQm94XCIsXHJcbiAgICByYWRpb2dyb3VwOiBcIlJhZGlvIGdyb3VwXCIsXHJcbiAgICBidXR0b246IFwiQnV0dG9uXCIsXHJcbiAgICBsYWJlbDogXCJMYWJlbFwiLFxyXG4gICAgbWVzc2FnZTogXCJNZXNzYWdlXCIsXHJcbiAgICBpbWFnZTogXCJJbWFnZVwiLFxyXG4gICAgc3RhdGlzdGljOiBcIlN0YXRpc3RpY1wiLFxyXG4gICAgY3VzdG9tY29udHJvbDogXCJDdXN0b20gY29udHJvbFwiLFxyXG4gICAgc3RhdGljY29udGVudDogXCJTdGF0aWMgQ29udGVudFwiLFxyXG4gICAgZHJvcGRvd250cmlnZ2VyOiBcIkRyb3Bkb3duIHRyaWdnZXJcIixcclxuICAgIHNlcENoYXJ0czogXCJDaGFydHNcIixcclxuICAgIGJhcmNoYXJ0OiBcIkJhclwiLFxyXG4gICAgbGluZWNoYXJ0OiBcIkxpbmVcIixcclxuICAgIHNjYXR0ZXJjaGFydDogXCJTY2F0dGVyXCIsXHJcbiAgICBkb3VnaG51dGNoYXJ0OiBcIkRvdWdobnV0XCIsXHJcbiAgICBwaWVjaGFydDogXCJQaWVcIixcclxuICAgIHJhZGFyY2hhcnQ6IFwiUmFkYXJcIlxyXG4gIH0sXHJcbiAgcHJldmlldzoge1xyXG4gICAgZHJvcHpvbmV0ZXh0OiBcIkRST1AgWk9ORVwiXHJcbiAgfSxcclxuICBlZGl0Zm9ybXM6IHtcclxuICAgIGJhc2U6e1xyXG4gICAgICBnZW5lcmFsdGFiOiBcIkdlbmVyYWxcIixcclxuICAgICAgc3R5bGV0YWI6IFwiU3R5bGVcIixcclxuICAgICAgZXZlbnRzdGFiOiBcIkV2ZW50c1wiLFxyXG4gICAgICBvdGhlcnRhYjogXCJPdGhlclwiLFxyXG4gICAgICB3aWR0aGZpZWxkOiBcIldpZHRoXCIsXHJcbiAgICAgIGhlaWdodGZpZWxkOiBcIkhlaWdodFwiLFxyXG4gICAgICBtYXJnaW50b3BmaWVsZDogXCJNYXJnaW4gVG9wXCIsXHJcbiAgICAgIG1hcmdpbmJvdHRvbWZpZWxkOiBcIk1hcmdpbiBCb3R0b21cIixcclxuICAgICAgbWFyZ2lubGVmdGZpZWxkOiBcIk1hcmdpbiBMZWZ0XCIsXHJcbiAgICAgIG1hcmdpbnJpZ2h0ZmllbGQ6IFwiTWFyZ2luIFJpZ2h0XCIsXHJcbiAgICAgIGN1c3RvbWNzc2NsYXNzZmllbGQ6IFwiQ3VzdG9tIENTUyBjbGFzc1wiLFxyXG4gICAgICBzdHlsZWZpZWxkOiBcIlN0eWxlXCIsXHJcbiAgICAgIGhpZGRlbmZpZWxkOiBcIkhpZGRlblwiLFxyXG4gICAgICBjb250cm9saGFzbm9ldmVudHNtc2c6IFwiVGhpcyBjb250cm9sIGhhcyBubyBldmVudHMuXCIsXHJcbiAgICAgIGV2ZW50c2luZm9tc2c6IFwiVGhlc2UgZmxhZ3MgZW5hYmxlIHByb2Nlc3NpbmcgZnJvbSB0aGlzIGVsZW1lbnQuXCIsXHJcblxyXG4gICAgICByZXF1aXJlZGZpZWxkOiBcIlJlcXVpcmVkXCIsXHJcbiAgICAgIGRlZmF1bHR2YWx1ZWZpZWxkOiBcIkRlZmF1bHQgdmFsdWVcIixcclxuICAgICAgZGVmYXVsdHZhbHVlZmllbGQ6IFwiRGVmYXVsdCB2YWx1ZVwiLFxyXG4gICAgICBjdXN0b212YWxpZGF0aW9uZmllbGQ6IFwiQ3VzdG9tIFZhbGlkYXRpb25cIixcclxuICAgICAgdmlzaWJsZWNvbmRpdGlvbmZpZWxkOiBcIlZpc2libGUgY29uZGl0aW9uXCIsXHJcbiAgICAgIHJlYWRvbmx5Y29uZGl0aW9uZmllbGQ6IFwiUmVhZE9ubHkgY29uZGl0aW9uXCIsXHJcblxyXG4gICAgICBzYXZlYnV0dG9uOiBcIlNhdmVcIixcclxuICAgICAgY2FuY2VsYnV0dG9uOiBcIkNhbmNlbFwiLFxyXG4gICAgICBva2J1dHRvbjogXCJPS1wiLFxyXG4gICAgICBjbG9zZWJ1dHRvbjogXCJDbG9zZVwiLFxyXG5cclxuICAgICAgc2l6ZWRlZmF1bHQ6IFwiRGVmYXVsdFwiLFxyXG4gICAgICBzaXplbWluaTogXCJNaW5pXCIsXHJcbiAgICAgIHNpemV0aW55OiBcIlRpbnlcIixcclxuICAgICAgc2l6ZXNtYWxsOiBcIlNtYWxsXCIsXHJcbiAgICAgIHNpemVtZWRpdW06IFwiTWVkaXVtXCIsXHJcbiAgICAgIHNpemVsYXJnZTogXCJMYXJnZVwiLFxyXG4gICAgICBzaXplYmlnOiBcIkJpZ1wiLFxyXG4gICAgICBzaXplaHVnZTogXCJIdWdlXCIsXHJcbiAgICAgIHNpemVtYXNzaXZlOiBcIk1hc3NpdmVcIixcclxuXHJcbiAgICAgIGF0dGFjaGVkbm9uZTogXCJOb25lXCIsXHJcbiAgICAgIGF0dGFjaGVkdG9wOiBcIlRvcFwiLFxyXG4gICAgICBhdHRhY2hlZGJvdHRvbTogXCJCb3R0b21cIixcclxuICAgICAgYXR0YWNoZWR0b3ByaWdodDogXCJUb3AgcmlnaHRcIixcclxuICAgICAgYXR0YWNoZWR0b3BsZWZ0OiBcIlRvcCBsZWZ0XCIsXHJcbiAgICAgIGF0dGFjaGVkYm90dG9tbGVmdDogXCJCb3R0b20gbGVmdFwiLFxyXG4gICAgICBhdHRhY2hlZGJvdHRvbXJpZ2h0OiBcIkJvdHRvbSByaWdodFwiLFxyXG5cclxuICAgICAgbGFiZWxkZWZhdWx0OiBcIkRlZmF1bHRcIixcclxuICAgICAgbGFiZWxsZWZ0OiBcIkxlZnRcIixcclxuICAgICAgbGFiZWxyaWdodDogXCJSaWdodFwiLFxyXG4gICAgICBsYWJlbGxlZnRjb3JuZXI6IFwiTGVmdCBjb3JuZXJcIixcclxuICAgICAgbGFiZWxyaWdodGNvcm5lcjogXCJSaWdodCBjb3JuZXJcIixcclxuXHJcbiAgICAgIGNsb3Nld2l0aG91dHNhdmVxdWVzdGlvbjogXCJDbG9zZSB3aXRob3V0IHNhdmU/XCIsXHJcbiAgICAgIHF1ZXN0aW9udGl0bGU6IFwiUXVlc3Rpb25cIixcclxuICAgICAgb25jaGFuZ2V0aW1lb3V0IDogXCJvbkNoYW5nZSB0aW1lb3V0XCJcclxuICAgIH0sXHJcbiAgICBoZWFkZXJmb3JtIDp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIHNpemVmaWVsZDogXCJTaXplXCIsXHJcbiAgICAgIGNvbnRlbnRmaWVsZDogXCJDb250ZW50XCIsXHJcbiAgICAgIHRleHRhbGlnbmZpZWxkOiBcIlRleHQgQWxpZ25cIixcclxuICAgICAgdGV4dGFsaWdubGVmdDogXCJMZWZ0XCIsXHJcbiAgICAgIHRleHRhbGlnbmNlbnRlcjogXCJDZW50ZXJcIixcclxuICAgICAgdGV4dGFsaWducmlnaHQ6IFwiUmlnaHRcIixcclxuICAgICAgc3ViaGVhZGVyZmllbGQ6IFwiU3ViaGVhZGVyXCJcclxuICAgIH0sXHJcbiAgICBidXR0b25mb3JtIDp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIHR5cGVmaWVsZDogXCJUeXBlXCIsXHJcbiAgICAgIHR5cGVub25lZmllbGQ6IFwiTm9uZVwiLFxyXG4gICAgICB0eXBlc3VibWl0ZmllbGQ6IFwiU3VibWl0XCIsXHJcbiAgICAgIHNpemVmaWVsZDogXCJTaXplXCIsXHJcbiAgICAgIGNvbnRlbnRmaWVsZDogXCJDb250ZW50XCIsXHJcbiAgICAgIG9wdGlvbnNmaWVsZDogXCJPcHRpb25zXCIsXHJcbiAgICAgIGJhc2ljZmllbGQ6IFwiQmFzaWNcIixcclxuICAgICAgY2lyY3VsYXJmaWVsZDogXCJDaXJjdWxhclwiLFxyXG4gICAgICBjb21wYWN0ZmllbGQ6IFwiQ29tcGFjdFwiLFxyXG4gICAgICBkaXNhYmxlZGZpZWxkOiBcIkRpc2FibGVkXCIsXHJcbiAgICAgIGZsdWlkZmllbGQ6IFwiRmx1aWRcIixcclxuICAgICAgaW52ZXJ0ZWRmaWVsZDogXCJJbnZlcnRlZFwiLFxyXG4gICAgICBsb2FkaW5nZmllbGQ6IFwiTG9hZGluZ1wiLFxyXG4gICAgICBwcmltYXJ5ZmllbGQ6IFwiUHJpbWFyeVwiLFxyXG4gICAgICBzZWNvbmRhcnlmaWVsZDogXCJTZWNvbmRhcnlcIixcclxuICAgICAgdG9nZ2xlZmllbGQ6IFwiVG9nZ2xlXCIsXHJcbiAgICAgIGZsb2F0ZWRmaWVsZDogXCJGbG9hdGVkXCIsXHJcbiAgICAgIGZsb2F0ZWRkZWZhdWx0ZmllbGQ6IFwiRGVmYXVsdFwiLFxyXG4gICAgICBmbG9hdGVkbGVmdGZpZWxkOiBcIkxlZnRcIixcclxuICAgICAgZmxvYXRlZHJpZ2h0ZmllbGQ6IFwiUmlnaHRcIixcclxuICAgIH0sXHJcbiAgICBsYWJlbGZvcm0gOntcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgYXR0YWNoZWRmaWVsZDpcIkF0dGFjaGVkXCIsXHJcbiAgICAgIGNvbnRlbnRmaWVsZDogXCJDb250ZW50XCIsXHJcbiAgICAgIHNpemVmaWVsZDogXCJTaXplXCIsIFxyXG4gICAgICBvcHRpb25zZmllbGQ6IFwiT3B0aW9uc1wiLFxyXG4gICAgICBjb250ZW50ZmllbGQ6IFwiQ29udGVudFwiLFxyXG4gICAgICBiYXNpY2ZpZWxkOiBcIkJhc2ljXCIsXHJcbiAgICAgIGNpcmN1bGFyZmllbGQ6IFwiQ2lyY3VsYXJcIixcclxuICAgICAgY29ybmVyZmllbGQ6IFwiQ29ybmVyXCIsXHJcbiAgICAgIGZsb2F0aW5nZmllbGQ6IFwiRmxvYXRpbmdcIixcclxuICAgICAgaG9yaXpvbnRhbGZpZWxkOiBcIkhvcml6b250YWxcIixcclxuICAgICAgcG9pbnRpbmdmaWVsZDogXCJQb2ludGluZ1wiXHJcbiAgICB9LFxyXG4gICAgc3RhdGljY29udGVudGZvcm06e1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBmb250c2l6ZWZpZWxkOiBcIkZvbnQgc2l6ZVwiLFxyXG4gICAgICBjb250ZW50ZmllbGQ6IFwiQ29udGVudFwiLFxyXG4gICAgICBhbGxvd2h0bWxmaWVsZDogXCJBbGxvdyBIVE1MXCJcclxuICAgIH0sXHJcbiAgICBtZXNzYWdlZm9ybTp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIGhlYWRlcmZpZWxkOiBcIkhlYWRlclwiLFxyXG4gICAgICBvcHRpb25zZmllbGQ6IFwiT3B0aW9uc1wiLFxyXG4gICAgICBjb21wYWN0ZmllbGQ6IFwiQ29tcGFjdFwiLFxyXG4gICAgICBlcnJvcmZpZWxkOiBcIkVycm9yXCIsXHJcbiAgICAgIGZsb2F0aW5nZmllbGQ6IFwiRmxvYXRpbmdcIixcclxuICAgICAgaW5mb2ZpZWxkOiBcIkluZm9cIixcclxuICAgICAgbmVnYXRpdmVmaWVsZDogXCJOZWdhdGl2ZVwiLFxyXG4gICAgICBwb3NpdGl2ZWZpZWxkOiBcIlBvc2l0aXZlXCIsXHJcbiAgICAgIHN1Y2Nlc3NmaWVsZDogXCJTdWNjZXNzXCIsXHJcbiAgICAgIHdhcm5pbmdmaWVsZDogXCJXYXJuaW5nXCIsXHJcbiAgICAgIGNvbnRlbnRmaWVsZDogXCJDb250ZW50XCIsXHJcbiAgICAgIHNpemVmaWVsZDogXCJTaXplXCJcclxuICAgIH0sXHJcbiAgICBpbnB1dGZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgbGFiZWxmaWVsZDpcIkxhYmVsXCIsXHJcbiAgICAgIHR5cGVmaWVsZDogXCJUeXBlXCIsXHJcbiAgICAgIHR5cGV0ZXh0OiBcIlRleHRcIixcclxuICAgICAgdHlwZW51bWJlcjogXCJOdW1iZXJcIixcclxuICAgICAgdHlwZWRhdGU6IFwiRGF0ZVwiLFxyXG4gICAgICB0eXBldGltZTogXCJUaW1lXCIsXHJcbiAgICAgIHR5cGVkYXRldGltZTogXCJEYXRlICYgVGltZVwiLFxyXG4gICAgICB0eXBlcGFzc3dvZDogXCJQYXNzd29yZFwiLFxyXG4gICAgICBsYWJlbHBvc2l0aW9uZmllbGQ6IFwiTGFiZWwgcG9zaXRpb25cIixcclxuICAgICAgb3B0aW9uc2ZpZWxkOiBcIk9wdGlvbnNcIixcclxuICAgICAgbG9hZGluZ2ZpZWxkOiBcIkxvYWRpbmdcIixcclxuICAgICAgaW52ZXJ0ZWRmaWVsZDogXCJJbnZlcnRlZFwiLFxyXG4gICAgICBlcnJvcmZpZWxkOiBcIkVycm9yXCIsXHJcbiAgICAgIGRpc2FibGVkZmllbGQ6IFwiRGlzYWJsZWRcIixcclxuICAgICAgdHJhbnNwYXJlbnRmaWVsZDogXCJUcmFuc3BhcmVudFwiLFxyXG4gICAgICBmbHVpZGZpZWxkOiBcIkZsdWlkXCIsXHJcbiAgICAgIHJlYWRvbmx5ZmllbGQ6IFwiUmVhZCBvbmx5XCIsXHJcbiAgICAgIHBsYWNlaG9sZGVyZmllbGQ6IFwiUGxhY2Vob2xkZXJcIixcclxuICAgICAgc2l6ZWZpZWxkOlwiU2l6ZVwiLFxyXG4gICAgICBkYXRlZm9ybWF0ZmllbGQ6IFwiRGF0ZSBGb3JtYXRcIlxyXG4gICAgfSxcclxuICAgIHRleHRhcmVhZm9ybToge1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBsYWJlbGZpZWxkOlwiTGFiZWxcIixcclxuICAgICAgcm93c2ZpZWxkOiBcIlJvd3NcIixcclxuICAgICAgb3B0aW9uc2ZpZWxkOiBcIk9wdGlvbnNcIixcclxuICAgICAgcGxhY2Vob2xkZXJmaWVsZDogXCJQbGFjZWhvbGRlclwiLFxyXG4gICAgICBhdXRvaGVpZ2h0ZmllbGQ6IFwiQXV0byBoZWlnaHRcIixcclxuICAgICAgcmVhZG9ubHlmaWVsZDogXCJSZWFkIG9ubHlcIixcclxuICAgIH0sXHJcbiAgICBjaGVja2JveGZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgbGFiZWxmaWVsZDpcIkxhYmVsXCIsXHJcbiAgICAgIG9wdGlvbnNmaWVsZDogXCJPcHRpb25zXCIsXHJcbiAgICAgIGZpdHRlZGZpZWxkOiBcIkZpdHRlZFwiLFxyXG4gICAgICBpbmRldGVybWluYXRlZmllbGQ6IFwiSW5kZXRlcm1pbmF0ZVwiLFxyXG4gICAgICByZWFkb25seWZpZWxkOiBcIlJlYWRPbmx5XCIsXHJcbiAgICAgIGRpc2FibGVkZmllbGQ6IFwiRGlzYWJsZWRcIixcclxuICAgICAgc2xpZGVyZmllbGQ6IFwiU2xpZGVyXCIsXHJcbiAgICAgIHRvZ2dsZWZpZWxkOiBcIlRvZ2dsZVwiXHJcbiAgICB9LFxyXG4gICAgZHJvcGRvd25mb3JtOiB7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIGxhYmVsZmllbGQ6XCJMYWJlbFwiLFxyXG4gICAgICBkYXRhZmllbGQ6IFwiRGF0YVwiLFxyXG4gICAgICBkYXRha2V5Y29sdW1uOiBcIktleVwiLFxyXG4gICAgICBkYXRhdmFsdWVjb2x1bW46IFwiVmFsdWVcIixcclxuICAgICAgZGF0YXRleHRjb2x1bW46IFwiVGV4dFwiLFxyXG4gICAgICBvcHRpb25zZmllbGQ6IFwiT3B0aW9uc1wiLFxyXG4gICAgICBsb2FkaW5nZmllbGQ6IFwiTG9hZGluZ1wiLFxyXG4gICAgICBlcnJvcmZpZWxkOiBcIkVycm9yXCIsXHJcbiAgICAgIGRpc2FibGVkZmllbGQ6IFwiRGlzYWJsZWRcIixcclxuICAgICAgZmx1aWRmaWVsZDogXCJGbHVpZFwiLFxyXG4gICAgICBtdWx0aXBsZWZpZWxkOiBcIk11bHRpcGxlXCIsXHJcbiAgICAgIHNlYXJjaGZpZWxkOiBcIlNlYXJjaFwiLFxyXG4gICAgICBzZWxlY3Rpb25maWVsZDogXCJTZWxlY3Rpb25cIixcclxuICAgICAgcmVhZG9ubHlmaWVsZDogXCJSZWFkIG9ubHlcIixcclxuICAgICAgY2xlYXJhYmxlZmllbGQ6IFwiQ2xlYXJhYmxlXCIsXHJcbiAgICAgIGFsbG93QWRkSXRlbXNmaWVsZDogXCJBbGxvdyBhZGQgaXRlbXNcIlxyXG4gICAgfSxcclxuICAgIGRpY3Rpb25hcnlmb3JtOiB7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIGxhYmVsZmllbGQ6XCJMYWJlbFwiLFxyXG4gICAgICBkYXRhbW9kZWxmaWVsZDogXCJEYXRhIG1vZGVsXCIsXHJcbiAgICAgIHBsYWNlaG9sZGVyZmllbGQ6IFwiUGxhY2Vob2xkZXJcIixcclxuICAgICAgY29sdW1uc2ZpZWxkOiBcIkNvbHVtbnMgKE5hbWUgQVNDLCBFbWFpbClcIixcclxuICAgICAgb3B0aW9uc2ZpZWxkOiBcIk9wdGlvbnNcIixcclxuICAgICAgbG9hZGluZ2ZpZWxkOiBcIkxvYWRpbmdcIixcclxuICAgICAgZXJyb3JmaWVsZDogXCJFcnJvclwiLFxyXG4gICAgICBkaXNhYmxlZGZpZWxkOiBcIkRpc2FibGVkXCIsXHJcbiAgICAgIGZsdWlkZmllbGQ6IFwiRmx1aWRcIixcclxuICAgICAgbXVsdGlwbGVmaWVsZDogXCJNdWx0aXBsZVwiLFxyXG4gICAgICBzZWFyY2hmaWVsZDogXCJTZWFyY2hcIixcclxuICAgICAgc2VsZWN0aW9uZmllbGQ6IFwiU2VsZWN0aW9uXCIsXHJcbiAgICAgIHJlYWRvbmx5ZmllbGQ6IFwiUmVhZCBvbmx5XCIsXHJcbiAgICAgIGNsZWFyYWJsZWZpZWxkOiBcIkNsZWFyYWJsZVwiLFxyXG4gICAgICBwYWdpbmdmaWVsZDogXCJTZXJ2ZXIgcGFnaW5hdGlvblwiLFxyXG4gICAgICBwYWdlc2l6ZWZpZWxkOiBcIlBhZ2UgU2l6ZVwiLFxyXG4gICAgICBwYXJlbnRpZEZpZWxkOiBcIlBhcmVudCBGaWVsZFwiXHJcbiAgICB9LFxyXG4gICAgcmFkaW9ncm91cGZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgbGFiZWxmaWVsZDpcIkxhYmVsXCIsXHJcbiAgICAgIGRhdGFmaWVsZDogXCJEYXRhXCIsXHJcbiAgICAgIGRhdGFrZXljb2x1bW46IFwiS2V5XCIsXHJcbiAgICAgIGRhdGF2YWx1ZWNvbHVtbjogXCJWYWx1ZVwiLFxyXG4gICAgICBkYXRhdGV4dGNvbHVtbjogXCJUZXh0XCIsXHJcbiAgICAgIGdyb3VwZGlyZWN0ZmllbGQ6IFwiR3JvdXAgZGlyZWN0XCIsXHJcbiAgICAgIGRpcmVjdGlvbmdvcml6b250YWxmaWVsZDogXCJHb3Jpem9udGFsXCIsXHJcbiAgICAgIGRpcmVjdGlvbnZlcnRpY2FsZmllbGQ6IFwiVmVydGljYWxcIixcclxuICAgICAgcmVhZG9ubHlmaWVsZDogXCJSZWFkIG9ubHlcIlxyXG4gICAgfSxcclxuICAgIGZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgc2l6ZWZpZWxkOiBcIlNpemVcIixcclxuICAgICAgb3B0aW9uc2ZpZWxkOiBcIk9wdGlvbnNcIixcclxuICAgICAgbG9hZGluZ2ZpZWxkOiBcIkxvYWRpbmdcIixcclxuICAgICAgZXJyb3JmaWVsZDogXCJFcnJvclwiLFxyXG4gICAgICBpbnZlcnRlZGZpZWxkOiBcIkludmVydGVkXCIsXHJcbiAgICAgIHJlcGx5ZmllbGQ6IFwiUmVwbHlcIixcclxuICAgICAgc3VjY2Vzc2ZpZWxkOiBcIlN1Y2Nlc3NcIixcclxuICAgICAgd2FybmluZ2ZpZWxkOiBcIldhcm5pbmdcIlxyXG4gICAgfSxcclxuICAgIGZvcm1ncm91cGZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgd2lkdGhzZmllbGQ6IFwiV2lkdGhzXCIsXHJcbiAgICAgIHdpZHRoc2RlZmF1bHRmaWVsZDogXCJEZWZhdWx0XCIsXHJcbiAgICAgIHdpZHRoc2VxdWFsZmllbGQ6IFwiRXF1YWxcIixcclxuICAgICAgd2lkdGhzY3VzdG9tZmllbGQ6IFwiQ3VzdG9tICgxIC0gMTYpXCIsXHJcbiAgICAgIHR5cGVmaWVsZDogXCJUeXBlXCIsXHJcbiAgICAgIG9yaWVudGF0aW9uY29sdW1uc2ZpZWxkOiBcIkNvbHVtbnNcIixcclxuICAgICAgb3JpZW50YXRpb25yb3dzZmllbGQ6IFwiUm93c1wiXHJcbiAgICB9LFxyXG4gICAgY29udGFpbmVyZm9ybToge1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBmbG9hdGZpZWxkOiBcIkZsb2F0XCIsXHJcbiAgICAgIGZsb2F0bm9uZWZpZWxkOiBcIk5vbmVcIixcclxuICAgICAgZmxvYXRsZWZ0ZmllbGQ6IFwiTGVmdFwiLFxyXG4gICAgICBmbG9hdHJpZ2h0ZmllbGQ6IFwiUmlnaHRcIlxyXG4gICAgfSxcclxuICAgIGltYWdlZm9ybTp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIHNyY2ZpZWxkOiBcIlNyY1wiLFxyXG4gICAgICBocmVmZmllbGQ6IFwiSHJlZlwiLFxyXG4gICAgICBvcHRpb25zZmllbGQ6IFwiT3B0aW9uc1wiLFxyXG4gICAgICBhdmF0YXJmaWVsZDogXCJBdmF0YXJcIixcclxuICAgICAgYm9yZGVyZWRmaWVsZDogXCJCb3JkZXJlZFwiLFxyXG4gICAgICBjZW50ZXJlZGZpZWxkOiBcIkNlbnRlcmVkXCIsXHJcbiAgICAgIGRpc2FibGVkZmllbGQ6IFwiRGlzYWJsZWRcIixcclxuICAgICAgaW5saW5lZmllbGQ6IFwiSW5saW5lXCIsXHJcbiAgICAgIHNwYWNlZGZpZWxkOiBcIlNwYWNlZFwiLFxyXG4gICAgICBmbG9hdGVkZmllbGQ6IFwiRmxvYXRlZFwiLFxyXG4gICAgICBmbG9hdGVkbGVmdGZpZWxkOiBcIkxlZnRcIixcclxuICAgICAgZmxvYXRlZHJpZ2h0ZmllbGQ6IFwiUmlnaHRcIixcclxuICAgICAgdmVydGljYWxhbGlnbmZpZWxkOiBcIlZlcnRpY2FsIGFsaWduXCIsXHJcbiAgICAgIHZlcnRpY2FsYWxpZ250b3BmaWVsZDogXCJUb3BcIixcclxuICAgICAgdmVydGljYWxhbGlnbm1pZGRsZWZpZWxkOiBcIk1pZGRsZVwiLFxyXG4gICAgICB2ZXJ0aWNhbGFsaWduYm90dG9tZmllbGQ6IFwiQm90dG9tXCJcclxuICAgIH0sXHJcbiAgICBzdGF0aXN0aWNmb3JtOiB7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIG9wdGlvbnNmaWVsZDogXCJPcHRpb25zXCIsXHJcbiAgICAgIGZsb2F0ZWRmaWVsZDogXCJGbG9hdGVkXCIsXHJcbiAgICAgIGhvcml6b250YWxmaWVsZDogXCJIb3Jpem9udGFsXCIsXHJcbiAgICAgIGRhdGFmaWVsZDogXCJEYXRhXCIsXHJcbiAgICAgIHNpemVmaWVsZDogXCJTaXplXCJcclxuICAgIH0sXHJcbiAgICBncmlkZm9ybToge1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBvcHRpb25zZmllbGQ6IFwiT3B0aW9uc1wiLFxyXG4gICAgICBtdWx0aXNlbGVjdGZpZWxkOiBcIk11bHRpc2VsZWN0XCIsXHJcbiAgICAgIGZpbHRlcnJvd2ZpZWxkOiBcIkZpbHRlciByb3dcIixcclxuICAgICAgZGlzYWJsZXNvcnRmaWVsZDogXCJEaXNhYmxlIHNvcnRpbmdcIixcclxuICAgICAgZWRpdGZvcm1maWVsZDogXCJFZGl0IGZvcm1cIixcclxuICAgICAgZWRpdGZvcm1zaG93dHlwZWZpZWxkOiBcIkVkaXQgZm9ybSBzaG93IHR5cGVcIixcclxuICAgICAgZWRpdGZvcm10eXBlZGVmYXVsdGZpZWxkOiBcIkRlZmF1bHRcIixcclxuICAgICAgZWRpdGZvcm10eXBlbW9kYWxmaWVsZDogXCJNb2RhbFwiLFxyXG4gICAgICBjb2x1bW5zZmllbGQ6IFwiQ29sdW1uc1wiLFxyXG4gICAgICBrZXljb2x1bW46IFwiS2V5XCIsXHJcbiAgICAgIG5hbWVjb2x1bW46IFwiTmFtZVwiLFxyXG4gICAgICB0eXBlY29sdW1uOiBcIlR5cGVcIixcclxuICAgICAgd2lkdGhjb2x1bW46IFwiV2lkdGhcIixcclxuICAgICAgcmVzaXphYmxlY29sdW1uOiBcIlJlc2l6YWJsZVwiLFxyXG4gICAgICByb3drZXlmaWVsZDogXCJSb3cga2V5XCIsXHJcbiAgICAgIHBhZ2VydHlwZWZpZWxkOiBcIlBhZ2luYXRpb24gdHlwZVwiLFxyXG4gICAgICBwYWdlcnR5cGVub25lZmllbGQ6IFwiTm9uZVwiLFxyXG4gICAgICBwYWdlcnR5cGVzZXJ2ZXJmaWVsZDogXCJTZXJ2ZXJcIixcclxuICAgICAgcGFnZXNpemVmaWVsZDogXCJQYWdlIHNpemVcIixcclxuICAgICAgZGVmYXVsdHNvcnRmaWVsZDogXCJEZWZhdWx0IHNvcnRcIixcclxuICAgICAgcm93aGVpZ2h0ZmllbGQ6IFwiUm93IGhlaWdodFwiLFxyXG4gICAgICBtaW5oZWlnaHRmaWVsZDogXCJNaW4gaGVpZ2h0XCIsXHJcbiAgICAgIGF1dG9oZWlnaHRmaWVsZDogXCJBdXRvIEhlaWdodFwiLFxyXG4gICAgICBvZmZzZXRmaWVsZDogXCJPZmZTZXRcIixcclxuICAgICAgZWRpdFR5cGU6IFwiRWRpdCB0eXBlXCIsXHJcbiAgICAgIGVkaXRmbG93ZmllbGQ6IFwiRWRpdCBmbG93XCJcclxuICAgIH0sXHJcbiAgICBjb2xsZWN0aW9uZWRpdG9yZm9ybToge1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBpZGZpZWxkOiBcIklkIGZpZWxkXCIsXHJcbiAgICAgIG9wdGlvbnNmaWVsZDogXCJPcHRpb25zXCIsXHJcbiAgICAgIHJlYWRvbmx5ZmllbGQ6IFwiUmVhZE9ubHlcIixcclxuICAgICAgZHJhZ2dhYmxlZmllbGQ6IFwiRHJhZ2dhYmxlXCIsXHJcbiAgICAgIGhpZXJhcmNoaWNhbGZpZWxkOiBcIkhpZXJhcmNoaWNhbFwiLFxyXG4gICAgICBjb2xsYXBzZWFsbGZpZWxkOiBcIkNvbGxhcHNlIGFsbFwiLFxyXG4gICAgICBwYXJlbnRpZGZpZWxkOiBcIlBhcmVudElkIGZpZWxkXCIsXHJcbiAgICAgIGNvbHVtbnNmaWVsZDogXCJDb2x1bW5zXCIsXHJcbiAgICAgIGtleWNvbHVtbjogXCJLZXlcIixcclxuICAgICAgbmFtZWNvbHVtbjogXCJOYW1lXCIsXHJcbiAgICAgIGNvbnRyb2xjb2x1bW46IFwiQ29udHJvbFwiLFxyXG4gICAgICB3aWR0aGNvbHVtbjogXCJXaWR0aFwiLFxyXG4gICAgICBkaXNhYmxlQWRkOiBcIkRpc2FibGUgQWRkXCIsXHJcbiAgICAgIGNoaWxkcmVuRmllbGQ6IFwiQ2hpbGRyZW4gZmllbGRcIlxyXG4gICAgfSxcclxuICAgIGN1c3RvbWZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgdHlwZWZpZWxkOiBcIlR5cGUgY29udHJvbFwiLFxyXG4gICAgICBwcm9wc2ZpZWxkOiBcIlByb3BzXCIsXHJcbiAgICAgIGNoaWxkcmVuZmllbGQ6IFwiQ2hpbGRyZW5cIixcclxuICAgIH0sXHJcbiAgICBjdXN0b21ibG9ja2Zvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgc291cmNldHlwZWZpZWxkOiBcIlNvdXJjZSB0eXBlXCIsXHJcbiAgICAgIHNvdXJjZXR5cGVmb3JtZmllbGQ6IFwiRm9ybSBuYW1lXCIsXHJcbiAgICAgIHNvdXJjZXR5cGVqc29uZmllbGQ6IFwiSlNPTiBzb3VyY2VcIixcclxuICAgICAgZm9ybW5hbWVmaWVsZDogXCJGb3JtIG5hbWVcIixcclxuICAgICAgc291cmNlZmllbGQ6IFwiSlNPTiBzb3VyY2VcIixcclxuICAgICAgcGxhY2Vob2xkZXJmaWVsZDogXCJQbGFjZWhvbGRlclwiXHJcbiAgICB9LFxyXG4gICAgbWVudWZvcm06IHtcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgYWN0aXZlaXRlbWZpZWxkOiBcIkFjdGl2ZSBJdGVtXCIsXHJcbiAgICAgIGl0ZW1zZmllbGQ6IFwiSXRlbXNcIixcclxuICAgICAgaXRlbXN0YXJnZXRjb2x1bW46IFwiVGFyZ2V0XCIsXHJcbiAgICAgIGl0ZW1zdGl0bGVjb2x1bW46IFwiVGl0bGVcIixcclxuICAgICAgb3B0aW9uc2ZpZWxkOiBcIk9wdGlvbnNcIixcclxuICAgICAgcG9pbnRpbmdmaWVsZDogXCJQb2ludGluZ1wiLFxyXG4gICAgICBzZWNvbmRhcnlmaWVsZDogXCJTZWNvbmRhcnlcIixcclxuICAgICAgdGFidWxhcmZpZWxkOiBcIlRhYnVsYXJcIixcclxuICAgICAgZmx1aWRmaWVsZDogXCJGbHVpZFwiLFxyXG4gICAgICB2ZXJ0aWNhbGZpZWxkOiBcIlZlcnRpY2FsXCIsXHJcbiAgICAgIGxpbmtmaWVsZDogXCJMaW5rXCIsXHJcbiAgICAgIHZpc2libGVDb25kaXRpb25jb2x1bW46IFwiVmlzaWJsZSBDb25kaXRpb25cIlxyXG4gICAgfSxcclxuICAgIGRyb3Bkb3dudHJpZ2dlcmZvcm06e1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICBkZWZhdWx0dmFsdWVmaWVsZDogXCJEZWZhdWx0IFZhbHVlXCIsXHJcbiAgICAgIGl0ZW1zZmllbGQ6IFwiSXRlbXNcIixcclxuICAgICAgaXRlbXN0YXJnZXRjb2x1bW46IFwiVGFyZ2V0XCIsXHJcbiAgICAgIGl0ZW1zdGl0bGVjb2x1bW46IFwiVGl0bGVcIixcclxuICAgICAgaXRlbXN2aXNpYmxlY29uZGl0aW9uY29sdW1uOiBcIlZpc2libGUgQ29uZGl0aW9uXCIsXHJcbiAgICAgIGltYWdldXJsZmllbGQ6IFwiSW1hZ2VVcmxcIlxyXG4gICAgfSxcclxuICAgIGNoYXJ0Zm9ybTp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIHRpdGxlZmllbGQ6IFwiVGl0bGVcIixcclxuICAgICAgdGl0bGVzaXplZmllbGQ6IFwiVGl0bGUgc2l6ZVwiLFxyXG4gICAgICBsZWdlbmRwb3NpdGlvbmZpZWxkOiBcIkxlZ2VuZCBwb3NpdGlvblwiLFxyXG4gICAgICByZXNwb25zaXZlZmllbGQ6IFwiUmVzcG9uc2l2ZVwiLFxyXG4gICAgICBkYXRhc2V0Y3VzdG9tZmllbGQ6IFwiRGF0YXNldCBjdXN0b21cIixcclxuICAgICAgZGF0YWxhYmVsc3BsYWNlaG9sZGVyOiBcIlExLCBRMiwgUTMsIFE0XCIsXHJcbiAgICAgIGRhdGFsYWJlbHNmaWVsZDogXCJEYXRhIGxhYmVsc1wiLFxyXG4gICAgICBkYXRhc2V0bGFiZWxmaWVsZDogXCJEYXRhc2V0IExhYmVsXCIsXHJcbiAgICAgIGRhdGFzZXRiYWNrZ3JvdW5kY29sb3JmaWVsZDogXCJEYXRhc2V0IEJhY2tncm91bmRDb2xvclwiXHJcbiAgICB9LFxyXG4gICAgd29ya2Zsb3dmb3JtOntcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgc2V0c3RhdGVidXR0b25maWVsZDogXCJTZXQgc3RhdGUgYnV0dG9uXCIsXHJcbiAgICAgIGJsb2Nrc2V0c3RhdGVmaWVsZDogXCJCbG9jayBTZXRTdGF0ZVwiXHJcbiAgICB9LFxyXG4gICAgdXBsb2FkZm9ybTp7XHJcbiAgICAgIG5hbWVmaWVsZDogXCJOYW1lXCIsXHJcbiAgICAgIGljb25GaWxldHlwZXM6IFwiSWNvbiBmaWxlIHR5cGVzXCIsXHJcbiAgICAgIGN1c3RvbVBvc3RVcmw6IFwiQ3VzdG9tIHBvc3QgdXJsXCIsXHJcbiAgICAgIHNob3dGaWxldHlwZUljb246IFwiU2hvdyBmaWxlIHR5cGUgaWNvblwiLFxyXG4gICAgICBhdXRvUHJvY2Vzc1F1ZXVlOiBcIkF1dG8gcHJvY2VzcyBxdWV1ZVwiLFxyXG4gICAgICBhZGRSZW1vdmVMaW5rczogXCJBZGQgcmVtb3ZlIGxpbmtzXCIsXHJcbiAgICAgIG11bHRpbGU6IFwiTXVsdGlwbGUgZmlsZSB1cGxvYWRcIlxyXG4gICAgfSxcclxuICAgIGJyZWFkY3J1bWJmb3JtOntcclxuICAgICAgbmFtZWZpZWxkOiBcIk5hbWVcIixcclxuICAgICAgaXRlbXNmaWVsZDogXCJJdGVtc1wiLFxyXG4gICAgICBpdGVtc3RleHRjb2x1bW46IFwiVGV4dFwiLFxyXG4gICAgICBpdGVtc3VybGNvbHVtbjogXCJVcmxcIixcclxuICAgICAgaXRlbXNhY3RpdmVjb2x1bW46IFwiQWN0aXZlXCIsXHJcbiAgICAgIGl0ZW1zaWNvbmNvbHVtbjogXCJEaXZpZGVyIEljb25cIlxyXG4gICAgfSxcclxuICAgIHNlYXJjaGZvcm06e1xyXG4gICAgICBuYW1lZmllbGQ6IFwiTmFtZVwiLFxyXG4gICAgICB1cmxmaWVsZDogXCJVcmxcIixcclxuICAgICAgY2F0ZWdvcnlmaWVsZDogXCJFbmFibGUgQ2F0ZWdvcmllc1wiXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBsYW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYW5nLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5pbXBvcnQgRFdLaXRTdG9yZSBmcm9tICcuL3N0b3JlJztcclxuaW1wb3J0IERXS2l0Rm9ybUNvbnRyb2xzIGZyb20gJy4vY29udHJvbHMnO1xyXG5pbXBvcnQgVGltZW91dCBmcm9tICcuL3RpbWVvdXQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRFdLaXRGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBkYXRhOiBwcm9wcy5kYXRhLFxyXG4gICAgICAgICAgICBtb2RlbDogcHJvcHMubW9kZWwsXHJcbiAgICAgICAgICAgIGV4dGVuZGVkRGF0YTogcHJvcHMuZXh0ZW5kZWREYXRhLFxyXG4gICAgICAgICAgICBjb250cm9sc1RvUmVwbGFjZTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAvLyB0aGlzLmNvbnRyb2xzVG9SZXBsYWNlID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5jaGVja0xvYWRlZFN0YXRlKHRoaXMuc3RhdGUuZGF0YSwgdGhpcy5zdGF0ZS5tb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlRGVsdGEgPSB7fTtcclxuICAgICAgICBpZiAobmV4dFByb3BzLm1vZGVsdXJsICE9PSB1bmRlZmluZWQgJiYgbmV4dFByb3BzLm1vZGVsdXJsICE9PSBcIlwiICYmIG5leHRQcm9wcy5tb2RlbHVybCAhPT0gcHJldlN0YXRlLm1vZGVsdXJsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEubW9kZWx1cmwgPSBuZXh0UHJvcHMubW9kZWx1cmw7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEubmVlZEZldGNoTW9kZWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE8gYWRkIGpzb24gZXF1YWw/XHJcbiAgICAgICAgaWYgKG5leHRQcm9wcy5tb2RlbCAhPT0gdW5kZWZpbmVkICYmIG5leHRQcm9wcy5tb2RlbCAhPT0gcHJldlN0YXRlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuY29udHJvbHNUb1JlcGxhY2UgPSBudWxsO1xyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLm1vZGVsID0gbmV4dFByb3BzLm1vZGVsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5leHRQcm9wcy5kYXRhdXJsICE9PSB1bmRlZmluZWQgJiYgbmV4dFByb3BzLmRhdGF1cmwgIT09IFwiXCIgJiYgbmV4dFByb3BzLmRhdGF1cmwgIT09IHByZXZTdGF0ZS5kYXRhdXJsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVsdGEuZGF0YXVybCA9IG5leHRQcm9wcy5kYXRhdXJsO1xyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLm5lZWRGZXRjaERhdGEgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dFByb3BzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdGF0ZURlbHRhLmRhdGEgPSBuZXh0UHJvcHMuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0ZURlbHRhO1xyXG4gICAgfVxyXG5cclxuICAgIF9hc3luY0dldERhdGEgPSBudWxsO1xyXG4gICAgX2FzeW5jR2V0TW9kZWwgPSBudWxsO1xyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIHRoaXMuUHJlcGFyZVN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5QcmVwYXJlU3RhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYXN5bmNHZXREYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jR2V0RGF0YS5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYXN5bmNHZXRNb2RlbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hc3luY0dldE1vZGVsLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFByZXBhcmVTdGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm5lZWRGZXRjaE1vZGVsKSB7XHJcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKHtuZWVkRmV0Y2hNb2RlbDogZmFsc2V9KTtcclxuICAgICAgICAgICAgdGhpcy5fYXN5bmNHZXRNb2RlbCA9ICQuZ2V0SlNPTih0aGlzLnN0YXRlLm1vZGVsdXJsKVxyXG4gICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZS5fYXN5bmNHZXRNb2RlbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbWUubW9kZWxDaGFuZ2VkKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChqcXhociwgdGV4dFN0YXR1cywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZS5fYXN5bmNHZXRNb2RlbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gdGV4dFN0YXR1cyArIFwiLCBcIiArIGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLmhhbmRsZUVyckV2ZW50KGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm5lZWRGZXRjaERhdGEpIHtcclxuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe25lZWRGZXRjaERhdGE6IGZhbHNlfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jR2V0RGF0YSA9ICQuZ2V0SlNPTih0aGlzLnN0YXRlLmRhdGF1cmwpXHJcbiAgICAgICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLl9hc3luY0dldERhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLmRhdGFDaGFuZ2VkKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChqcXhociwgdGV4dFN0YXR1cywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZS5fYXN5bmNHZXREYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0ZXh0U3RhdHVzICsgXCIsIFwiICsgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgbWUuaGFuZGxlRXJyRXZlbnQoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb25zKHRoaXMuc3RhdGUubW9kZWwpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tMb2FkZWRTdGF0ZSh0aGlzLnN0YXRlLmRhdGEsIHRoaXMuc3RhdGUubW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZGVsQ2hhbmdlZChtb2RlbCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXHJcbiAgICAgICAgICAgIGNvbnRyb2xzVG9SZXBsYWNlOiBudWxsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb25zKG1vZGVsKVxyXG4gICAgfVxyXG5cclxuICAgIGRhdGFDaGFuZ2VkKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmNoZWNrTG9hZGVkU3RhdGUoZGF0YSwgdGhpcy5zdGF0ZS5tb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tMb2FkZWRTdGF0ZShkYXRhLCBtb2RlbCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5pc0xvYWRlZCAmJiBkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbCAmJiBtb2RlbCAhPT0gdW5kZWZpbmVkICYmIG1vZGVsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2lzTG9hZGVkOiB0cnVlfSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXZlbnRGdW5jKHtcclxuICAgICAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbFJlZjogdGhpcyxcclxuICAgICAgICAgICAgICAgIGZvcm1OYW1lOiB0aGlzLnByb3BzLmZvcm1OYW1lLFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBcImluaXRcIixcclxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImluaXRTeXN0ZW1cIiwgXCJpbml0XCJdLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUV2ZW50KHtlLCBrZXksIGV2ZW50TmFtZSwgcGFyYW1ldGVycywgbmFtZSwgdmFsdWV9KSB7XHJcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGlzT25jaGFuZ2UgPSBldmVudE5hbWUgPT09IFwib25DaGFuZ2VcIjtcclxuICAgICAgICBpZiAoaXNPbmNoYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoIUJvb2xlYW4odGhpcy5wcm9wcy5vbmx5RXh0ZXJuYWxEYXRhQ2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnN0YXRlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2RhdGE6IGRhdGF9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZGF0YUNoYW5nZWQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZGF0YUNoYW5nZWQodGhpcywge2tleSwgdmFsdWV9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMub25Db25kaXRpb25zKGtleSwgZXZlbnROYW1lLCBwYXJhbWV0ZXJzLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ldmVudEZ1bmMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZmluZE1vZGVsSXRlbWJ5S2V5KGtleSk7XHJcbiAgICAgICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoaXRlbS5ldmVudHMgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBpdGVtLmV2ZW50c1tldmVudE5hbWVdICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgaXRlbS5ldmVudHNbZXZlbnROYW1lXS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gaXRlbS5ldmVudHNbZXZlbnROYW1lXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBldmVudFBhcmFtZXRlcnMgPSB7Li4ucGFyYW1ldGVyc307XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LnBhcmFtZXRlcnMpICYmIGV2ZW50LnBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbWV0ZXJzW3AubmFtZV0gPSBwLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29udHJvbCA9IG1lLnJlZnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29udHJvbFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBmaXJlRXZlbnQ7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LnRhcmdldHMpICYmIGV2ZW50LnRhcmdldHMubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudCA9ICgpID0+IGV2ZW50LnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLnByb3BzLmV2ZW50RnVuYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ29udHJvbFJlZjogc291cmNlQ29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ29udHJvbFZhbHVlOiBzb3VyY2VDb250cm9sVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xSZWY6IG1lLnJlZnNbdF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1OYW1lOiBtZS5wcm9wcy5mb3JtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBldmVudE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGV2ZW50LmFjdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGV2ZW50UGFyYW1ldGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50ID0gKCkgPT4gbWUucHJvcHMuZXZlbnRGdW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb250cm9sUmVmOiBzb3VyY2VDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUNvbnRyb2xWYWx1ZTogc291cmNlQ29udHJvbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xSZWY6IHNvdXJjZUNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybU5hbWU6IG1lLnByb3BzLmZvcm1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBldmVudE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogZXZlbnQuYWN0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBldmVudFBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNPbmNoYW5nZVxyXG4gICAgICAgICAgICAgICAgfHwgaXRlbS5vbkNoYW5nZVRpbWVvdXQgPT09IHVuZGVmaW5lZCB8fCBpdGVtLm9uQ2hhbmdlVGltZW91dCA9PT0gXCJcIlxyXG4gICAgICAgICAgICAgICAgfHwgTnVtYmVyKGl0ZW0ub25DaGFuZ2VUaW1lb3V0KSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgVGltZW91dC5TZXQoa2V5LCBmaXJlRXZlbnQsIE51bWJlcihpdGVtLm9uQ2hhbmdlVGltZW91dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrQ29uZGl0aW9ucyhtb2RlbCwgY2hpbGQpIHtcclxuICAgICAgICB2YXIgZW5hYmxlQ2hlY2tDb25kaXRpb25zID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICgobW9kZWxbaV1bXCJvdGhlci12aXNpYmxlQ29uaXRpb25cIl0gIT09IHVuZGVmaW5lZCAmJiBtb2RlbFtpXVtcIm90aGVyLXZpc2libGVDb25pdGlvblwiXSAhPT0gXCJcIikgfHxcclxuICAgICAgICAgICAgICAgICAgICAobW9kZWxbaV1bXCJvdGhlci1yZWFkT25seUNvbml0aW9uXCJdICE9PSB1bmRlZmluZWQgJiYgbW9kZWxbaV1bXCJvdGhlci1yZWFkT25seUNvbml0aW9uXCJdICE9PSBcIlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUNoZWNrQ29uZGl0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxbaV0uY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlQ2hlY2tDb25kaXRpb25zID0gdGhpcy5jaGVja0NvbmRpdGlvbnMobW9kZWxbaV0uY2hpbGRyZW4sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVDaGVja0NvbmRpdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlQ2hlY2tDb25kaXRpb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVDaGVja0NvbmRpdGlvbnMgPSBlbmFibGVDaGVja0NvbmRpdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgb25Db25kaXRpb25zKGtleSwgZXZlbnROYW1lLCBwYXJhbWV0ZXJzLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVuYWJsZUNoZWNrQ29uZGl0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLmV2ZW50RnVuYyh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xSZWY6IHRoaXMucmVmc1trZXldLFxyXG4gICAgICAgICAgICAgICAgZm9ybU5hbWU6IHRoaXMucHJvcHMuZm9ybU5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImNoZWNrQ29uZGl0aW9uc1wiXSxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUVyckV2ZW50KG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ldmVudEVyckZ1bmMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5ldmVudEVyckZ1bmModGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpbmRNb2RlbEl0ZW1ieUtleShrZXksIGFycmF5KSB7XHJcbiAgICAgICAgaWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYXJyYXkgPSB0aGlzLnN0YXRlLm1vZGVsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0ua2V5ID09PSBrZXkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0uY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbmRNb2RlbEl0ZW1ieUtleShrZXksIGFycmF5W2ldLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXS5wbGFjZWhvbGRlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBwaCBpbiBhcnJheVtpXS5wbGFjZWhvbGRlcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5maW5kTW9kZWxJdGVtYnlLZXkoa2V5LCBhcnJheVtpXS5wbGFjZWhvbGRlcnNbcGhdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBsZXQgY29udHJvbHNUb1JlcGxhY2UgPSBbXTtcclxuICAgICAgICBsZXQgbmVlZENoZWNrUmVwbGFjZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCAhPT0gbnVsbCAmJiB0aGlzLnN0YXRlLm1vZGVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29udHJvbHNUb1JlcGxhY2UgPSB0aGlzLnN0YXRlLmNvbnRyb2xzVG9SZXBsYWNlID09PSBudWxsID8gW10gOiB0aGlzLnN0YXRlLmNvbnRyb2xzVG9SZXBsYWNlO1xyXG4gICAgICAgICAgICBuZWVkQ2hlY2tSZXBsYWNlID0gdGhpcy5zdGF0ZS5jb250cm9sc1RvUmVwbGFjZSA9PT0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpdGVtcyA9IERXS2l0Rm9ybUNvbnRyb2xzLmNyZWF0ZUNvbnRyb2xzKHRoaXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLnN0YXRlLm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB0aGlzLnByb3BzLmVycm9ycyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50OiB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBnZXRGb3JtRnVuYzogdGhpcy5wcm9wcy5nZXRGb3JtRnVuYyxcclxuICAgICAgICAgICAgICAgIGdldEFkZGl0aW9uYWxEYXRhRm9yQ29udHJvbDogdGhpcy5wcm9wcy5nZXRBZGRpdGlvbmFsRGF0YUZvckNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICBoaWRlQ29udHJvbHM6IHRoaXMucHJvcHMuaGlkZUNvbnRyb2xzLFxyXG4gICAgICAgICAgICAgICAgcmVhZE9ubHlDb250cm9sczogdGhpcy5wcm9wcy5yZWFkT25seUNvbnRyb2xzLFxyXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMucHJvcHMucmVhZE9ubHksXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRVcmw6IHRoaXMucHJvcHMudXBsb2FkVXJsLFxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmw6IHRoaXMucHJvcHMuZG93bmxvYWRVcmwsXHJcbiAgICAgICAgICAgICAgICBleHRlbmRlZERhdGE6IHRoaXMucHJvcHMuZXh0ZW5kZWREYXRhLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbHNUb1JlcGxhY2U6IGNvbnRyb2xzVG9SZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgbmVlZENoZWNrUmVwbGFjZTogbmVlZENoZWNrUmVwbGFjZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKG5lZWRDaGVja1JlcGxhY2UpIHtcclxuICAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRyb2xzVG9SZXBsYWNlID0gY29udHJvbHNUb1JlcGxhY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBcImR3a2l0LWZvcm1cIiArICh0aGlzLnByb3BzLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgXCJcIiA6XHJcbiAgICAgICAgICAgIChcIiBcIiArIHRoaXMucHJvcHMuY2xhc3NOYW1lKSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxyXG4gICAgICAgICAgICAgICAge2l0ZW1zfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS5qc3giLCJjb25zdCB0aW1lb3V0c0lkTmFtZU1hcCA9IHt9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZW91dCB7XHJcbiAgICBzdGF0aWMgU2V0IChuYW1lLGNhbGxiYWNrLGRlbGF5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aW1lb3V0c0lkTmFtZU1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0c0lkTmFtZU1hcFtuYW1lXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0IChjYWxsYmFjayxkZWxheSk7XHJcbiAgICAgICAgdGltZW91dHNJZE5hbWVNYXBbbmFtZV0gPSB0aW1lb3V0SWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIENsZWFyIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aW1lb3V0c0lkTmFtZU1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0c0lkTmFtZU1hcFtuYW1lXSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aW1lb3V0c0lkTmFtZU1hcFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RpbWVvdXQuanMiXSwic291cmNlUm9vdCI6IiJ9