(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("semantic-ui-react"), require("react-dom"), require("moment"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "semantic-ui-react", "react-dom", "moment"], factory);
	else if(typeof exports === 'object')
		exports["optimajet-form"] = factory(require("react"), require("semantic-ui-react"), require("react-dom"), require("moment"));
	else
		root["optimajet-form"] = factory(root["react"], root["semantic-ui-react"], root["react-dom"], root["moment"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_12__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 25);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.capitalize = capitalize;
exports.callbackName = callbackName;
exports.isObject = isObject;
exports.extend = extend;
exports.isFunction = isFunction;
exports.nextTick = nextTick;
exports.object = object;
exports.isArguments = isArguments;
exports.throwIf = throwIf;
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function callbackName(string, prefix) {
    prefix = prefix || "on";
    return prefix + exports.capitalize(string);
}

/*
 * isObject, extend, isFunction, isArguments are taken from underscore/lodash in
 * order to remove the dependency
 */
function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return type === "function" || type === "object" && !!obj;
}

function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j < keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}

function isFunction(value) {
    return typeof value === "function";
}

exports.EventEmitter = __webpack_require__(28);

function nextTick(callback) {
    setTimeout(callback, 0);
}

function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i < keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}

function isArguments(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && "callee" in value && typeof value.length === "number";
}

function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _joins = __webpack_require__(15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Extract child listenables from a parent from their
 * children property and return them in a keyed Object
 *
 * @param {Object} listenable The parent listenable
 */
var mapChildListenables = function mapChildListenables(listenable) {
    var i = 0,
        children = {},
        childName;
    for (; i < (listenable.children || []).length; ++i) {
        childName = listenable.children[i];
        if (listenable[childName]) {
            children[childName] = listenable[childName];
        }
    }
    return children;
};

/**
 * Make a flat dictionary of all listenables including their
 * possible children (recursively), concatenating names in camelCase.
 *
 * @param {Object} listenables The top-level listenables
 */
var flattenListenables = function flattenListenables(listenables) {
    var flattened = {};
    for (var key in listenables) {
        var listenable = listenables[key];
        var childMap = mapChildListenables(listenable);

        // recursively flatten children
        var children = flattenListenables(childMap);

        // add the primary listenable and chilren
        flattened[key] = listenable;
        for (var childKey in children) {
            var childListenable = children[childKey];
            flattened[key + _.capitalize(childKey)] = childListenable;
        }
    }

    return flattened;
};

/**
 * An internal utility function used by `validateListening`
 *
 * @param {Action|Store} listenable The listenable we want to search for
 * @returns {Boolean} The result of a recursive search among `this.subscriptions`
 */
var hasListener = exports.hasListener = function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i < (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j < listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * A convenience method that listens to all listenables in the given object.
 *
 * @param {Object} listenables An object of listenables. Keys will be used as callback method names.
 */
var listenToMany = exports.listenToMany = function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
};

/**
 * Checks if the current context can listen to the supplied listenable
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @returns {String|Undefined} An error message, or undefined if there was no problem.
 */
var validateListening = exports.validateListening = function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener && listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
};

/**
 * Sets up a subscription to the given listenable for the context object
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @param {Function|String} callback The callback to register as event handler
 * @param {Function|String} defaultCallback The callback to register as default handler
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
};

/**
 * Stops listening to a single listenable
 *
 * @param {Action|Store} listenable The action or store we no longer want to listen to
 * @returns {Boolean} True if a subscription was found and removed, otherwise false.
 */
var stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i < subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
};

/**
 * Stops all subscriptions and empties subscriptions array
 */
var stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
};

/**
 * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.
 * @param {Action|Store} listenable The publisher we want to get initial state from
 * @param {Function|String} defaultCallback The method to receive the data
 */
var fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data && _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
};

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with the last emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)("last");

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with the first emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)("first");

/**
 * The callback will be called once all listenables have triggered at least once.
 * It will be invoked with all emission from each listenable.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)("all");

/**
 * The callback will be called once all listenables have triggered.
 * If a callback triggers twice before that happens, an error is thrown.
 * @param {...Publishers} publishers Publishers that should be tracked.
 * @param {Function|String} callback The method to call when all publishers have emitted
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
 */
var joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)("strict");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = ( true ? exports : {});

JSON5.parse = (function () {
    "use strict";

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,           // The index of the current character
        lineNumber,   // The current line number
        columnNumber, // The current column number
        ch,           // The current character
        escapee = {
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        renderChar = function (chr) {
            return chr === '' ? 'EOF' : "'" + chr + "'";
        },

        error = function (m) {

// Call error when something is wrong.

            var error = new SyntaxError();
            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
            error.at = at;
            // These two property names have been chosen to agree with the ones in Gecko, the only popular
            // environment which seems to supply this info on JSON.parse
            error.lineNumber = lineNumber;
            error.columnNumber = columnNumber;
            throw error;
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at++;
            columnNumber++;
            if (ch === '\n' || ch === '\r' && peek() !== '\n') {
                lineNumber++;
                columnNumber = 0;
            }
            return ch;
        },

        peek = function () {

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        },

        identifier = function () {

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                error("Bad identifier as unquoted key");
            }

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) {
                key += ch;
            }

            return key;
        },

        number = function () {

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') {
                sign = ch;
                next(ch);
            }

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') {
                number = word();
                if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number');
                }
                return (sign === '-') ? -number : number;
            }

            // support for NaN
            if (ch === 'N' ) {
              number = word();
              if (!isNaN(number)) {
                error('expected word to be NaN');
              }
              // ignore sign as -NaN also is NaN
              return number;
            }

            if (ch === '0') {
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') {
                    string += ch;
                    next();
                    base = 16;
                } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal');
                }
            }

            switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9' ) {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
            }

            if(sign === '-') {
                number = -string;
            } else {
                number = +string;
            }

            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff;

// When parsing for string values, we must look for ' or " and \ characters.

            if (ch === '"' || ch === "'") {
                delim = ch;
                while (next()) {
                    if (ch === delim) {
                        next();
                        return string;
                    } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (ch === '\r') {
                            if (peek() === '\n') {
                                next();
                            }
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else if (ch === '\n') {
                        // unescaped newlines are invalid; see:
                        // https://github.com/aseemk/json5/issues/24
                        // TODO this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        inlineComment = function () {

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') {
                error("Not an inline comment");
            }

            do {
                next();
                if (ch === '\n' || ch === '\r') {
                    next();
                    return;
                }
            } while (ch);
        },

        blockComment = function () {

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') {
                error("Not a block comment");
            }

            do {
                next();
                while (ch === '*') {
                    next('*');
                    if (ch === '/') {
                        next('/');
                        return;
                    }
                }
            } while (ch);

            error("Unterminated block comment");
        },

        comment = function () {

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') {
                error("Not a comment");
            }

            next('/');

            if (ch === '/') {
                inlineComment();
            } else if (ch === '*') {
                blockComment();
            } else {
                error("Unrecognized comment");
            }
        },

        white = function () {

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) {
                if (ch === '/') {
                    comment();
                } else if (ws.indexOf(ch) >= 0) {
                    next();
                } else {
                    return;
                }
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            }
            error("Unexpected " + renderChar(ch));
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                while (ch) {
                    if (ch === ']') {
                        next(']');
                        return array;   // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                        error("Missing array element");
                    } else {
                        array.push(value());
                    }
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                while (ch) {
                    if (ch === '}') {
                        next('}');
                        return object;   // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                        key = string();
                    } else {
                        key = identifier();
                    }

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
            return string();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({'': result}, '')) : result;
    };
}());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) {
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") {
            return replacer.call(holder, key, value);
        } else if(replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9') ||
            c === '_' || c === '$';
    }

    function isWordStart(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            c === '_' || c === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1, length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
    function escapeString(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch(typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length-1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    if (obj_part.length) {
                        buffer += makeIndent(indentStr, objStack.length, true)
                    }
                    buffer += "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = {"":obj};
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(40)();
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _semanticUiReact = __webpack_require__(1);

var _upload = __webpack_require__(20);

var _upload2 = _interopRequireDefault(_upload);

var _datepicker = __webpack_require__(21);

var _datepicker2 = _interopRequireDefault(_datepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionEditor = function (_React$Component) {
    _inherits(CollectionEditor, _React$Component);

    function CollectionEditor(props) {
        _classCallCheck(this, CollectionEditor);

        var _this = _possibleConstructorReturn(this, (CollectionEditor.__proto__ || Object.getPrototypeOf(CollectionEditor)).call(this, props));

        _this.state = {
            expanded: {}
        };
        return _this;
    }

    _createClass(CollectionEditor, [{
        key: 'applyCollapseAll',
        value: function applyCollapseAll(data) {
            for (var p in data) {
                if (this.state.expanded[p] == undefined) this.state.expanded[p] = false;
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var columns = this.props.columns;
            var data = this.props.value;
            var error = this.props.error;

            if (Boolean(this.props.collapseAll) && Array.isArray(data)) {
                this.applyCollapseAll(data);
            }

            if (columns == undefined || columns.length == 0) {
                return _react2.default.createElement(
                    'div',
                    null,
                    'Fill columns property!'
                );
            }

            this.state.data = this.getCopyRowsFromProps();
            return _react2.default.createElement(
                'div',
                { style: this.props.style, className: 'field' },
                _react2.default.createElement(
                    'label',
                    null,
                    this.props.label
                ),
                _react2.default.createElement(
                    'table',
                    { className: 'dwkit-collectioneditor' },
                    _react2.default.createElement(
                        'tbody',
                        null,
                        this.renderHeaderRow(columns),
                        this.renderRows(columns, this.state.data, error)
                    )
                )
            );
        }
    }, {
        key: 'renderHeaderRow',
        value: function renderHeaderRow(columns) {
            var res = [];
            var index = 0;
            columns.forEach(function (c) {
                var key;
                var title;
                var width;
                var dataListOptions = undefined;
                if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                    key = c.key;
                    title = c.name;
                    width = c.width;
                    if (Array.isArray(c.dataList)) dataListOptions = c.dataList;
                } else {
                    key = c;
                    title = c;
                }

                if (title != undefined && title.length >= 2) {
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                }

                var dataListControl;
                var dataListId = undefined;
                if (dataListOptions != undefined) {
                    dataListId = key + "_datalist";
                    var optValue = [];
                    dataListOptions.forEach(function (o) {
                        optValue.push(_react2.default.createElement('option', { key: o, value: o }));
                    });
                    dataListControl = _react2.default.createElement(
                        'datalist',
                        { key: dataListId, id: dataListId },
                        optValue
                    );
                }

                res.push(_react2.default.createElement(
                    'td',
                    { key: index, style: { width: width } },
                    title,
                    dataListControl
                ));
                index++;
            });

            if (!Boolean(this.props.readOnly) && this.props.disableAdd !== true) {
                var addcontent = "Add";
                if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.collectioneditor != undefined) {
                    addcontent = window.DWKitAdminLang.collectioneditor.add;
                }
                res.push(_react2.default.createElement(
                    'td',
                    { key: 'btntd', className: 'dwkit-collectioneditor-buttoncol' },
                    _react2.default.createElement(
                        'a',
                        { key: 'btnadd', className: 'dwkit-btn', onClick: this.btnAdd.bind(this) },
                        addcontent
                    )
                ));
            }

            return _react2.default.createElement(
                'tr',
                { key: 'headertr', className: 'dwkit-collectioneditor-header' },
                res
            );
        }
    }, {
        key: 'getDragColumn',
        value: function getDragColumn(rows, i) {
            var draggable = !Boolean(this.props.readOnly) && Boolean(this.props.draggable);
            if (draggable) {
                return _react2.default.createElement(
                    'div',
                    {
                        draggable: draggable,
                        onDragStart: this.onDragStart.bind(this, i, rows),
                        onDragEnd: this.onDragEnd.bind(this, i, rows),
                        onDragOver: this.onDragOver.bind(this),
                        onDrop: this.onDrop.bind(this, i, rows),
                        key: 'celldrag', className: 'dwkit-collectioneditor-action' },
                    _react2.default.createElement(_semanticUiReact.Icon, { onClick: this.onExpand.bind(this, i, false), name: 'ellipsis vertical' })
                );
            }
            return undefined;
        }
    }, {
        key: 'renderRows',
        value: function renderRows(columns, data, errors, parentIdValue, level, prefix) {
            var _this2 = this;

            var me = this;
            var res = [];
            var rows = data;
            if (level == undefined) level = 0;

            if (prefix === undefined) prefix = "";

            for (var i = 0; i < rows.length; i++) {
                if (this.props.childrenField === undefined && this.props.hierarchical) {
                    if (rows[i][this.props.parentIdField] != parentIdValue) {
                        continue;
                    }
                }

                var dragcol = this.getDragColumn(rows, i);
                var expand = undefined;
                var children = undefined;
                if (this.props.hierarchical) {
                    var icon = void 0;
                    var parentPrefix = prefix + String(i + "_");
                    if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                        var parentId = rows[i][this.props.idField];
                        if (parentId != undefined && parentId != "") {
                            children = this.renderRows(columns, data, errors, parentId, level + 1, parentPrefix);
                            if (children.length > 0) {
                                var isexpanded = this.state.expanded[prefix + i];
                                if (isexpanded == undefined || isexpanded == true) {
                                    icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, false), className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                                } else {
                                    icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, true), className: 'dwkit-collectioneditor-imgbutton', src: '/images/expand.svg' });
                                    children = undefined;
                                }
                            }
                        }
                    } else if (Array.isArray(rows[i][this.props.childrenField]) && rows[i][this.props.childrenField].length > 0) {
                        children = this.renderRows(columns, rows[i][this.props.childrenField], errors, undefined, level + 1, parentPrefix);
                        if (children.length > 0) {
                            var isexpanded = this.state.expanded[prefix + i];
                            if (isexpanded == undefined || isexpanded == true) {
                                icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, false), className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                            } else {
                                icon = _react2.default.createElement('img', { onClick: this.onExpand.bind(this, prefix + i, true), className: 'dwkit-collectioneditor-imgbutton', src: '/images/expand.svg' });
                                children = undefined;
                            }
                        }
                    } else {
                        icon = _react2.default.createElement('img', { style: { opacity: 0 }, className: 'dwkit-collectioneditor-imgbutton', src: '/images/collapse.svg' });
                    }

                    expand = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-collectioneditor-action' },
                        icon
                    );
                }

                var row = [];
                var errorOnRow = Array.isArray(errors) ? errors[i] : undefined;
                for (var j = 0; j < columns.length; j++) {
                    var colName = void 0;
                    var control = this.props.readOnly ? "" : "input";
                    var dataListId = undefined;
                    var options = undefined;
                    if (_typeof(columns[j]) === 'object') {
                        colName = columns[j].key;
                        control = columns[j].control;
                        if (Array.isArray(columns[j].dataList)) {
                            dataListId = colName + "_datalist";
                        }

                        if (Array.isArray(columns[j].options)) {
                            options = columns[j].options;
                        }
                    } else {
                        colName = columns[j];
                    }

                    var errorFlag = undefined;
                    if (errorOnRow != undefined) {
                        errorFlag = Boolean(errorOnRow[colName]);
                    }

                    var element = undefined;
                    if (control == "checkbox") {
                        element = _react2.default.createElement(_semanticUiReact.Form.Checkbox, {
                            key: i + "_" + j,
                            name: colName,
                            checked: Boolean(rows[i][colName]),
                            readOnly: Boolean(this.props.readOnly),
                            error: errorFlag,
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "span") {
                        element = _react2.default.createElement(
                            'span',
                            {
                                key: i + "_" + j,
                                name: colName },
                            rows[i][colName]
                        );
                    } else if (control == "number") {
                        var value = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Input, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'number',
                            error: errorFlag,
                            value: value,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "date") {
                        var _value = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_datepicker2.default, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'date',
                            error: errorFlag,
                            value: _value,
                            isForm: true,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "datetime") {
                        var _value2 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_datepicker2.default, {
                            key: i + "_" + j,
                            name: colName,
                            type: 'datetime',
                            error: errorFlag,
                            value: _value2,
                            isForm: true,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    } else if (control == "dropdown") {
                        var _value3 = rows[i][colName] == null ? Boolean(columns[j].multiple) ? [] : "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Dropdown, {
                            key: i + "_" + j,
                            name: colName,
                            multiple: Boolean(columns[j].multiple),
                            error: errorFlag,
                            value: _value3,
                            options: options,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]),
                            selection: true, fluid: true, search: true });
                    } else if (control == "file" || control == "file2") {
                        var _value4 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_upload2.default, {
                            key: i + "_" + j,
                            name: colName,
                            error: errorFlag,
                            value: _value4,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]),
                            downloadUrl: this.props.downloadUrl,
                            uploadUrl: this.props.uploadUrl,
                            isForm: true,
                            hideClearButton: control == "file2" });
                    } else if (control == "custom") {
                        var _value5 = rows[i][colName] == null ? "" : rows[i][colName];
                        if (this.props.placeholders != undefined && Array.isArray(this.props.placeholders[colName]) && this.props.placeholders[colName].length > 0) {
                            var model = this.props.placeholders[colName][0];
                            if (model != undefined) {
                                (function () {
                                    model.key = colName;
                                    var row = rows[i];
                                    element = _this2.props.createControl(_this2, model["data-buildertype"], {
                                        model: model, data: row, errors: errorOnRow,
                                        parentItem: _this2.props.name,
                                        buildermode: _this2.props.buildermode,
                                        handleEvent: function handleEvent(args) {
                                            if (args.eventName == "onChange") {
                                                me.handleChange(row, args.syntheticEvent, { name: args.name, value: args.value, checked: args.checked });
                                            } else {
                                                this.props.handleChange(args);
                                            }
                                        },
                                        getAdditionalDataForControl: _this2.props.getAdditionalDataForControl,
                                        readOnly: _this2.props.readOnly,
                                        uploadUrl: _this2.props.uploadUrl,
                                        downloadUrl: _this2.props.downloadUrl,
                                        controlsToReplace: []
                                    });
                                })();
                            }
                        } else if (this.props.buildermode && this.props.createBuilderDropzone != undefined) {
                            element = this.props.createBuilderDropzone(colName, _value5);
                        }
                    } else {
                        var _value6 = rows[i][colName] == null ? "" : rows[i][colName];
                        element = _react2.default.createElement(_semanticUiReact.Form.Input, {
                            key: i + "_" + j,
                            name: colName,
                            list: dataListId,
                            error: errorFlag,
                            value: _value6,
                            readOnly: Boolean(this.props.readOnly),
                            onChange: this.handleChange.bind(this, rows[i]) });
                    }

                    if (j == 0) {
                        var paddingLeft = void 0;
                        if (level != 0) {
                            paddingLeft = String(level * 15 + 5) + "px";
                        }

                        row.push(_react2.default.createElement(
                            'td',
                            { key: i + "_" + j + "td", style: { paddingLeft: paddingLeft } },
                            expand,
                            dragcol,
                            element
                        ));
                    } else row.push(_react2.default.createElement(
                        'td',
                        { key: i + "_" + j + "td" },
                        element
                    ));
                }

                if (!Boolean(this.props.readOnly)) {
                    if (this.props.hierarchical) {
                        row.push(_react2.default.createElement(
                            'td',
                            { key: 'celldelete', className: 'dwkit-collectioneditor-cellbtn' },
                            _react2.default.createElement(
                                'div',
                                { className: 'field' },
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'addchild', onClick: this.btnAddChild.bind(this, i, rows), link: true, name: 'add' }),
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'delete', onClick: this.btnDelete.bind(this, i, rows), link: true, name: 'delete' })
                            )
                        ));
                    } else {
                        row.push(_react2.default.createElement(
                            'td',
                            { key: 'celldelete', className: 'dwkit-collectioneditor-cellbtn' },
                            _react2.default.createElement(
                                'div',
                                { className: 'field' },
                                _react2.default.createElement(_semanticUiReact.Icon, { key: 'delete', onClick: this.btnDelete.bind(this, i, undefined), link: true, name: 'delete' })
                            )
                        ));
                    }
                }

                res.push(_react2.default.createElement(
                    'tr',
                    { key: prefix + i, className: 'dwkit-collectioneditor-row', 'data-rowindex': i },
                    row
                ));
                res = res.concat(children);
            }

            return res;
        }
    }, {
        key: 'btnDelete',
        value: function btnDelete(index, rows) {
            if (this.props.onChange == undefined) return;

            if (rows === undefined) rows = this.state.data;

            var obj = rows[index];
            rows.splice(index, 1);

            this.sendChangesToParent();
        }
    }, {
        key: 'btnAddChild',
        value: function btnAddChild(index, rows) {
            if (rows === undefined) rows = this.state.data == undefined ? [] : this.state.datae;

            var objParent = rows[index];
            var obj = this.props.defaultrow == undefined ? {} : _extends({}, this.props.defaultrow);

            if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                obj[this.props.parentIdField] = objParent[this.props.idField];
                rows.push(obj);
            } else {
                if (!Array.isArray(rows[index][this.props.childrenField])) rows[index][this.props.childrenField] = [];

                rows[index][this.props.childrenField].push(obj);
            }

            if (this.props.handleEvent != undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onAddChild", parameters: { rowIdx: rows.length - 1, row: obj } });
            }
            this.sendChangesToParent();
        }
    }, {
        key: 'btnAdd',
        value: function btnAdd() {
            var obj = this.props.defaultrow == undefined ? {} : this.props.defaultrow;
            this.state.data.push(obj);

            if (this.props.handleEvent != undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onAdd", parameters: { rowIdx: this.state.data.length - 1, row: obj } });
            }

            this.sendChangesToParent();
        }
    }, {
        key: 'onExpand',
        value: function onExpand(i, value) {
            this.state.expanded[i] = value;
            this.forceUpdate();
        }
    }, {
        key: 'onDragOver',
        value: function onDragOver(e) {
            e.preventDefault();
        }
    }, {
        key: 'onDragStart',
        value: function onDragStart(index, rows, e) {
            e.dataTransfer.setData('index', index);
            this.state.dragElementIndex = index;
            this.state.dragRows = rows;
        }
    }, {
        key: 'onDragEnd',
        value: function onDragEnd(index, e) {
            this.state.dragElementIndex = undefined;
            this.state.dragRows = undefined;
        }
    }, {
        key: 'onDrop',
        value: function onDrop(index, rows, e) {
            var rowIndexA = this.state.dragElementIndex;
            var rowsA = this.state.dragRows;
            var rowIndexB = index;
            var rowsB = rows;
            if (rowIndexA != undefined) {
                if (rowIndexB != rowIndexA) {
                    if (this.props.parentIdField !== undefined && this.props.parentIdField !== "") {
                        rowsA[rowIndexA][this.props.parentIdField] = rowsB[rowIndexB][this.props.parentIdField];
                    }
                    rowsB.splice(rowIndexB, 0, rowsA.splice(rowIndexA, 1)[0]);
                    this.sendChangesToParent();
                }
                e.preventDefault();
            }
            return false;
        }
    }, {
        key: 'handleChange',
        value: function handleChange(item, e, _ref) {
            var name = _ref.name,
                value = _ref.value,
                checked = _ref.checked;

            if (this.props.onChange == undefined) return;

            if (value == undefined && checked != undefined) {
                item[name] = checked;
            } else {
                item[name] = value;
            }

            this.sendChangesToParent();

            if (e != undefined) e.preventDefault();else this.forceUpdate();
        }
    }, {
        key: 'getCopyRowsFromProps',
        value: function getCopyRowsFromProps() {
            var rows = this.props.value == undefined ? [] : this.props.value;
            this.state.stringmode = false;
            if (!Array.isArray(rows)) {
                rows = _json2.default.parse(rows);
                this.state.stringmode = true;
            } else {
                rows = rows.slice();
            }

            return rows;
        }
    }, {
        key: 'sendChangesToParent',
        value: function sendChangesToParent() {
            var rows = this.state.data;
            var res = this.state.stringmode ? _json2.default.stringify(rows) : rows;
            this.props.onChange(null, { name: this.props.name, value: res });
        }
    }]);

    return CollectionEditor;
}(_react2.default.Component);

exports.default = CollectionEditor;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.__keep = exports.joinConcat = exports.joinStrict = exports.joinLeading = exports.all = exports.joinTrailing = exports.use = exports.nextTick = exports.setEventEmitter = exports.createActions = exports.createStore = exports.createAction = exports.utils = exports.StoreMethods = exports.PublisherMethods = exports.ListenerMethods = exports.ActionMethods = exports.version = undefined;

var _ActionMethods = __webpack_require__(14);

var ActionMethods = _interopRequireWildcard(_ActionMethods);

var _ListenerMethods = __webpack_require__(3);

var ListenerMethods = _interopRequireWildcard(_ListenerMethods);

var _PublisherMethods = __webpack_require__(10);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _StoreMethods = __webpack_require__(17);

var StoreMethods = _interopRequireWildcard(_StoreMethods);

var _joins = __webpack_require__(15);

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _createAction = __webpack_require__(31);

var _createStore = __webpack_require__(16);

var _Keep = __webpack_require__(9);

var __keep = _interopRequireWildcard(_Keep);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var version = {
    "reflux-core": "1.0.0"
};

var joinTrailing = (0, _joins.staticJoinCreator)("last");
var all = joinTrailing; // Reflux.all alias for backward compatibility
var joinLeading = (0, _joins.staticJoinCreator)("first");
var joinStrict = (0, _joins.staticJoinCreator)("strict");
var joinConcat = (0, _joins.staticJoinCreator)("all");

var utils = _;


/**
 * Convenience function for creating a set of actions
 *
 * @param definitions the definitions for the actions to be created
 * @returns an object with actions of corresponding action names
 */
var createActions = function () {
    var reducer = function reducer(definitions, actions) {
        Object.keys(definitions).forEach(function (actionName) {
            var val = definitions[actionName];
            actions[actionName] = (0, _createAction.createAction)(val);
        });
    };

    return function (definitions) {
        var actions = {};
        if (definitions instanceof Array) {
            definitions.forEach(function (val) {
                if (_.isObject(val)) {
                    reducer(val, actions);
                } else {
                    actions[val] = (0, _createAction.createAction)(val);
                }
            });
        } else {
            reducer(definitions, actions);
        }
        return actions;
    };
}();

/**
 * Sets the eventmitter that Reflux uses
 */
function setEventEmitter(ctx) {
    _.EventEmitter = ctx;
}

/**
 * Sets the method used for deferring actions and stores
 */
function nextTick(nextTick) {
    _.nextTick = nextTick;
}

function use(pluginCb) {
    pluginCb(this);
}

/**
 * Provides the set of created actions and stores for introspection
 */
/*eslint-disable no-underscore-dangle*/


// export in format that supports syntax: var Reflux = require('reflux-core');
exports.version = version;
exports.ActionMethods = ActionMethods;
exports.ListenerMethods = ListenerMethods;
exports.PublisherMethods = PublisherMethods;
exports.StoreMethods = StoreMethods;
exports.utils = utils;
exports.createAction = _createAction.createAction;
exports.createStore = _createStore.createStore;
exports.createActions = createActions;
exports.setEventEmitter = setEventEmitter;
exports.nextTick = nextTick;
exports.use = use;
exports.joinTrailing = joinTrailing;
exports.all = all;
exports.joinLeading = joinLeading;
exports.joinStrict = joinStrict;
exports.joinConcat = joinConcat;
exports.__keep = __keep;
/*eslint-enable no-underscore-dangle*/

// export in format that supports syntax: import Reflux from 'reflux-core';

Object.defineProperty(exports, "default", {
    get: function get() {
        return exports;
    }
});

/**
 * Warn if Function.prototype.bind not available
 */
if (!Function.prototype.bind) {
    console.error("Function.prototype.bind not available. " + "ES5 shim required. " + "https://github.com/spoike/refluxjs#es5");
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

// this needs to be set to true before Keep.js starts storing, done via useKeep
var use = false;

var createdStores = [];

var createdActions = [];

function useKeep() {
	var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}

function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}

function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}

function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}

exports.useKeep = useKeep;
exports.addStore = addStore;
exports.addAction = addAction;
exports.createdStores = createdStores;
exports.createdActions = createdActions;
exports.reset = reset;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * A module of methods for object that you want to be able to listen to.
 * This module is consumed by `createStore` and `createAction`
 */

/**
 * Hook used by the publisher that is invoked before emitting
 * and before `shouldEmit`. The arguments are the ones that the action
 * is invoked with. If this function returns something other than
 * undefined, that will be passed on as arguments for shouldEmit and
 * emission.
 */
var preEmit = exports.preEmit = function preEmit() {};

/**
 * Hook used by the publisher after `preEmit` to determine if the
 * event should be emitted with given arguments. This may be overridden
 * in your application, default implementation always returns true.
 *
 * @returns {Boolean} true if event should be emitted
 */
var shouldEmit = exports.shouldEmit = function shouldEmit() {
    return true;
};

/**
 * Subscribes the given callback for action triggered
 *
 * @param {Function} callback The callback to register as event handler
 * @param {Mixed} [optional] bindContext The context to bind the callback with
 * @returns {Function} Callback that unsubscribes the registered event handler
 */
var listen = exports.listen = function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
};

/**
 * Publishes an event using `this.emitter` (if `shouldEmit` agrees)
 */
var trigger = exports.trigger = function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
};

/**
 * Tries to publish the event on the next tick
 */
var triggerAsync = exports.triggerAsync = function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
};

/**
 * Wraps the trigger mechanism with a deferral function.
 *
 * @param {Function} callback the deferral function,
 *        first argument is the resolving function and the
 *        rest are the arguments provided from the previous
 *        trigger invocation
 */
var deferWith = exports.deferWith = function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(2),
    ListenerMethods = __webpack_require__(3);

/**
 * A module meant to be consumed as a mixin by a React component. Supplies the methods from
 * `ListenerMethods` mixin and takes care of teardown of subscriptions.
 * Note that if you're using the `connect` mixin you don't need this mixin, as connect will
 * import everything this mixin contains!
 */
module.exports = _.extend({

    /**
     * Cleans up all listener previously registered.
     */
    componentWillUnmount: ListenerMethods.stopListeningToAll

}, ListenerMethods);


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var Reflux = __webpack_require__(8);

Reflux.serverMode = typeof window !== 'object';

Reflux.connect = __webpack_require__(32);

Reflux.connectFilter = __webpack_require__(33);

Reflux.ListenerMixin = __webpack_require__(11);

Reflux.listenTo = __webpack_require__(34);

Reflux.listenToMany = __webpack_require__(35);

__webpack_require__(36);

module.exports = Reflux;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.staticJoinCreator = staticJoinCreator;
exports.instanceJoinCreator = instanceJoinCreator;

var _createStore = __webpack_require__(16);

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Internal module used to create static and instance join methods
 */

var slice = Array.prototype.slice,
    strategyMethodNames = {
    strict: "joinStrict",
    first: "joinLeading",
    last: "joinTrailing",
    all: "joinConcat"
};

/**
 * Used in `index.js` to create the static join methods
 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
 * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy
 */
function staticJoinCreator(strategy) {
    return function () /* listenables... */{
        var listenables = slice.call(arguments);
        return (0, _createStore.createStore)({
            init: function init() {
                this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
            }
        });
    };
}

/**
 * Used in `ListenerMethods.js` to create the instance join methods
 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
 * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy
 */
function instanceJoinCreator(strategy) {
    return function () /* listenables..., callback*/{
        _.throwIf(arguments.length < 2, "Cannot create a join with less than 2 listenables!");
        var listenables = slice.call(arguments),
            callback = listenables.pop(),
            numberOfListenables = listenables.length,
            join = {
            numberOfListenables: numberOfListenables,
            callback: this[callback] || callback,
            listener: this,
            strategy: strategy
        },
            i,
            cancels = [],
            subobj;
        for (i = 0; i < numberOfListenables; i++) {
            _.throwIf(this.validateListening(listenables[i]));
        }
        for (i = 0; i < numberOfListenables; i++) {
            cancels.push(listenables[i].listen(newListener(i, join), this));
        }
        reset(join);
        subobj = { listenable: listenables };
        subobj.stop = makeStopper(subobj, cancels, this);
        this.subscriptions = (this.subscriptions || []).concat(subobj);
        return subobj;
    };
}

// ---- internal join functions ----

function makeStopper(subobj, cancels, context) {
    return function () {
        var i,
            subs = context.subscriptions,
            index = subs ? subs.indexOf(subobj) : -1;
        _.throwIf(index === -1, "Tried to remove join already gone from subscriptions list!");
        for (i = 0; i < cancels.length; i++) {
            cancels[i]();
        }
        subs.splice(index, 1);
    };
}

function reset(join) {
    join.listenablesEmitted = new Array(join.numberOfListenables);
    join.args = new Array(join.numberOfListenables);
}

function newListener(i, join) {
    return function () {
        var callargs = slice.call(arguments);
        if (join.listenablesEmitted[i]) {
            switch (join.strategy) {
                case "strict":
                    throw new Error("Strict join failed because listener triggered twice.");
                case "last":
                    join.args[i] = callargs;break;
                case "all":
                    join.args[i].push(callargs);
            }
        } else {
            join.listenablesEmitted[i] = true;
            join.args[i] = join.strategy === "all" ? [callargs] : callargs;
        }
        emitIfAllListenablesEmitted(join);
    };
}

function emitIfAllListenablesEmitted(join) {
    for (var i = 0; i < join.numberOfListenables; i++) {
        if (!join.listenablesEmitted[i]) {
            return;
        }
    }
    join.callback.apply(join.listener, join.args);
    reset(join);
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStore = createStore;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _Keep = __webpack_require__(9);

var Keep = _interopRequireWildcard(_Keep);

var _mixer = __webpack_require__(29);

var _bindMethods = __webpack_require__(30);

var _StoreMethods = __webpack_require__(17);

var StoreMethods = _interopRequireWildcard(_StoreMethods);

var _PublisherMethods = __webpack_require__(10);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _ListenerMethods = __webpack_require__(3);

var ListenerMethods = _interopRequireWildcard(_ListenerMethods);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var allowed = { preEmit: 1, shouldEmit: 1 };

/**
 * Creates an event emitting Data Store. It is mixed in with functions
 * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`
 * and `shouldEmit` may be overridden in the definition object.
 *
 * @param {Object} definition The data store object definition
 * @returns {Store} A data store instance
 */
function createStore(definition) {

    definition = definition || {};

    for (var a in StoreMethods) {
        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {
            throw new Error("Cannot override API method " + a + " in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {
            throw new Error("Cannot override API method " + d + " in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    definition = (0, _mixer.mix)(definition);

    function Store() {
        var i = 0,
            arr;
        this.subscriptions = [];
        this.emitter = new _.EventEmitter();
        this.eventLabel = "change";
        (0, _bindMethods.bindMethods)(this, definition);
        if (this.init && _.isFunction(this.init)) {
            this.init();
        }
        if (this.listenables) {
            arr = [].concat(this.listenables);
            for (; i < arr.length; i++) {
                this.listenToMany(arr[i]);
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.addStore(store);

    return store;
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Reflux = __webpack_require__(13);

var BuilderActions = Reflux.createActions(['add', 'showEditForm', 'remove', 'saveData', 'save', 'move']);

module.exports = BuilderActions;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _editformControls = __webpack_require__(38);

var _radiogroup = __webpack_require__(22);

var _radiogroup2 = _interopRequireDefault(_radiogroup);

var _menugroup = __webpack_require__(52);

var _menugroup2 = _interopRequireDefault(_menugroup);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _gridview = __webpack_require__(23);

var _gridview2 = _interopRequireDefault(_gridview);

var _chartview = __webpack_require__(55);

var _chartview2 = _interopRequireDefault(_chartview);

var _workflowbar = __webpack_require__(56);

var _workflowbar2 = _interopRequireDefault(_workflowbar);

var _dictionary = __webpack_require__(57);

var _dictionary2 = _interopRequireDefault(_dictionary);

var _container = __webpack_require__(58);

var _container2 = _interopRequireDefault(_container);

var _staticcontent = __webpack_require__(59);

var _staticcontent2 = _interopRequireDefault(_staticcontent);

var _collectioneditor = __webpack_require__(7);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

var _controlbar = __webpack_require__(60);

var _controlbar2 = _interopRequireDefault(_controlbar);

var _dropdowntrigger = __webpack_require__(61);

var _dropdowntrigger2 = _interopRequireDefault(_dropdowntrigger);

var _semanticcontrol = __webpack_require__(62);

var _semanticcontrol2 = _interopRequireDefault(_semanticcontrol);

var _dropzone = __webpack_require__(63);

var _dropzone2 = _interopRequireDefault(_dropzone);

var _functionalfilter = __webpack_require__(24);

var _search = __webpack_require__(65);

var _search2 = _interopRequireDefault(_search);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//------DWKitFormControls-----------
var DWKitFormControls = {
    Items: [{ key: "sepContainers", title: 'Containers', isseparate: true, defaultopen: true }, { key: "container", title: 'DIV', control: _container2.default, editControl: _editformControls.ContainerEditControl }, { key: "form", title: 'Form', control: _semanticcontrol2.default, editControl: _editformControls.FormEditControl }, {
        key: "formgroup",
        title: 'Form Group',
        control: _semanticcontrol2.default,
        editControl: _editformControls.FormGroupEditControl,
        defaultValues: { widths: "equal" }
    }, {
        key: "menu", title: 'Menu', control: _menugroup2.default, editControl: _editformControls.MenuEditControl,
        defaultValues: {
            items: [{ target: 'menu1', title: 'Menu 1' }, { target: 'menu2', title: 'Menu 2' }, { target: 'menu3', title: 'Menu 3' }]
        }
    }, {
        key: "workflowbar",
        title: 'Workflow bar',
        control: _workflowbar2.default,
        editControl: _editformControls.WorkflowBarEditControl,
        defaultValues: {
            events: {
                onCommandClick: { active: true, actions: ["workflowExecuteCommand"] },
                onSetStateClick: { active: true, actions: ["workflowSetState"] }
            }
        }
    }, {
        key: "customblock",
        title: 'Custom block',
        control: undefined,
        editControl: _editformControls.CustomBlockEditControl,
        defaultValues: { sourceType: 'form' }
    }, { key: "sepCollection", title: 'Collections', isseparate: true }, {
        key: "gridview", title: 'GridView', control: _gridview2.default, editControl: _editformControls.GridEditControl, defaultValues: {
            columns: [{ key: 'id', name: 'ID' }, { key: 'title', name: 'Title' }, { key: 'count', name: 'Count' }]
        }
    }, {
        key: "collectioneditor",
        title: 'Collection Editor',
        control: _collectioneditor2.default,
        editControl: _editformControls.CollectionEditorEditControl,
        defaultValues: {
            idField: "Id",
            parentIdField: "ParentId",
            columns: [{ key: 'Id', name: 'ID' }, { key: 'Title', name: 'Title' }, { key: 'Count', name: 'Count' }]
        }
    }, { key: "sepControls", title: 'Controls', isseparate: true }, {
        key: "header",
        title: 'Header',
        control: _semanticcontrol2.default,
        editControl: _editformControls.HeaderEditControl,
        defaultValues: { content: "Header", size: "medium" }
    }, {
        key: "input",
        title: 'Input',
        control: _semanticcontrol2.default,
        editControl: _editformControls.InputEditControl,
        defaultValues: { label: "Input", fluid: true, onChangeTimeout: 200 }
    }, {
        key: "textarea",
        title: 'TextArea',
        control: _semanticcontrol2.default,
        editControl: _editformControls.TextAreaEditControl,
        defaultValues: { label: "TextArea", fluid: true }
    }, {
        key: "dictionary",
        title: 'Dictionary',
        control: _dictionary2.default,
        editControl: _editformControls.DictionaryEditControl,
        defaultValues: { label: "Dictionary", fluid: true, selection: true }
    }, {
        key: "dropdown",
        title: 'Dropdown',
        control: _semanticcontrol2.default,
        editControl: _editformControls.DropdownEditControl,
        defaultValues: {
            label: "Dropdown", fluid: true, selection: true,
            "data-elements": [{ key: 1, value: 1, text: 'Item 1' }, { key: 2, value: 2, text: 'Item 2' }, { key: 3, value: 3, text: 'Item 3' }]
        }
    }, {
        key: "checkbox",
        title: 'CheckBox',
        control: _semanticcontrol2.default,
        editControl: _editformControls.CheckboxEditControl,
        defaultValues: { label: "Checkbox" }
    }, {
        key: "radiogroup",
        title: 'Radio group',
        control: _radiogroup2.default,
        editControl: _editformControls.RadioGroupEditControl,
        defaultValues: {
            label: "Radio",
            "data-elements": [{ key: 1, value: 1, text: 'Item 1' }, { key: 2, value: 2, text: 'Item 2' }, { key: 3, value: 3, text: 'Item 3' }]
        }
    }, {
        key: "button",
        title: 'Button',
        control: _semanticcontrol2.default,
        editControl: _editformControls.ButtonEditControl,
        defaultValues: { content: "Button" }
    }, {
        key: "label",
        title: 'Label',
        control: _semanticcontrol2.default,
        editControl: _editformControls.LabelEditControl,
        defaultValues: { content: "Label" }
    }, {
        key: "message",
        title: 'Message',
        control: _semanticcontrol2.default,
        editControl: _editformControls.MessageEditControl,
        defaultValues: { header: "Message", content: "Description..." }
    }, {
        key: "image",
        title: 'Image',
        control: _semanticcontrol2.default,
        editControl: _editformControls.ImageEditControl,
        defaultValues: { src: '/images/unknown.png' }
    }, {
        key: "statistic", title: 'Statistic', control: _semanticcontrol2.default, editControl: _editformControls.StatisticEditControl,
        defaultValues: {
            "data-elements": [{ label: 'Score', value: '22,1%' }, { label: 'Views', value: '30,000' }, { label: 'Points', value: '500' }]
        }
    }, {
        key: "customcontrol",
        title: 'Custom control',
        control: undefined,
        editControl: _editformControls.CustomEditControl,
        defaultValues: { props: "{  }" }
    }, {
        key: "staticcontent",
        title: 'Static Content',
        control: _staticcontent2.default,
        editControl: _editformControls.StaticContentEditControl,
        defaultValues: { content: "Text..." }
    }, {
        key: "dropdowntrigger",
        title: 'Dropdown trigger',
        control: _dropdowntrigger2.default,
        editControl: _editformControls.DropdownTriggerEditControl,
        defaultValues: {
            defaultValue: "User",
            items: [{ target: '#1', title: 'Item 1' }, { target: '#2', title: 'Item 2' }, { target: '#3', title: 'Item 3' }]
        }
    }, {
        key: "dropzonecontrol",
        title: 'Dropzone',
        control: _dropzone2.default,
        editControl: _editformControls.DropzoneEditControl,
        defaultValues: {
            showFiletypeIcon: false,
            autoProcessQueue: true,
            addRemoveLinks: true,
            multile: true
        }
    }, {
        key: "breadcrumb",
        title: 'Breadcrumbs',
        control: _semanticcontrol2.default,
        editControl: _editformControls.BreadcrumbEditControl,
        defaultValues: {
            items: [{ "text": "Home", "url": "/" }, { "divider": "right angle", "text": "Page1", "url": "/page1" }, { "text": "Page2", "active": true }],
            events: {
                onItemClick: { active: true, actions: ["redirect"] }
            }
        }
    }, {
        key: "search",
        title: 'Search',
        control: _search2.default,
        editControl: _editformControls.SearchEditControl,
        defaultValues: {}
    }, { key: "sepCharts", title: 'Charts', isseparate: true }, {
        key: "barchart",
        title: 'Bar',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "bar", datasetLabel: "" }
    }, {
        key: "linechart",
        title: 'Line',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "line", datasetLabel: "" }
    }, {
        key: "scatterchart",
        title: 'Scatter',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "scatter", datasetLabel: "" }
    }, {
        key: "doughnutchart",
        title: 'Doughnut',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "doughnut", datasetLabel: "" }
    }, {
        key: "piechart",
        title: 'Pie',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "pie", datasetLabel: "" }
    }, {
        key: "radarchart",
        title: 'Radar',
        control: _chartview2.default,
        editControl: _editformControls.ChartEditControl,
        defaultValues: { chartType: "radar", datasetLabel: "" }
    }],

    createControls: function createControls(parentComponent, _ref) {
        var model = _ref.model,
            data = _ref.data,
            errors = _ref.errors,
            eventOnEdit = _ref.eventOnEdit,
            eventOnDelete = _ref.eventOnDelete,
            eventOnCopy = _ref.eventOnCopy,
            handleEvent = _ref.handleEvent,
            parentItem = _ref.parentItem,
            getFormFunc = _ref.getFormFunc,
            getAdditionalDataForControl = _ref.getAdditionalDataForControl,
            buildermode = _ref.buildermode,
            hideControls = _ref.hideControls,
            readOnlyControls = _ref.readOnlyControls,
            readOnly = _ref.readOnly,
            disableRefs = _ref.disableRefs,
            uploadUrl = _ref.uploadUrl,
            downloadUrl = _ref.downloadUrl,
            extendedData = _ref.extendedData,
            controlsToReplace = _ref.controlsToReplace,
            needCheckReplace = _ref.needCheckReplace,
            parentPlaceholder = _ref.parentPlaceholder,
            formItem = _ref.formItem,
            controlBarRight = _ref.controlBarRight;


        var res = [];
        if (model === null || model === undefined) return res;

        for (var i = 0; i < model.length; i++) {
            if (Array.isArray(hideControls) && hideControls.includes(model[i].key)) {
                continue;
            }

            var item = void 0;
            var dbtype = model[i]["data-buildertype"];
            if (dbtype === "customcontrol") {
                if (model[i].type === undefined || model[i].type === "") {
                    item = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-formbuilder-empty', key: model[i].key },
                        'Fill Type property for rendering the control.'
                    );
                } else {
                    var controlPropsInit = model[i].props === undefined ? {} : _json2.default.parse(model[i].props);
                    var controlProps = _extends({}, controlPropsInit, {
                        key: model[i].key,
                        name: model[i].key,
                        className: model[i]["style-customcss"],
                        style: this.getStyle(model[i], buildermode),
                        "data-buildertype": model[i]["data-buildertype"],
                        getAdditionalDataForControl: getAdditionalDataForControl,
                        uploadUrl: uploadUrl, downloadUrl: downloadUrl
                    });

                    if (readOnly || Array.isArray(readOnlyControls) && readOnlyControls.includes(controlProps.key)) controlProps.readOnly = true;

                    var children = model[i].children;
                    if (model[i].children !== undefined) {
                        try {
                            children = _json2.default.parse(model[i].children);
                        } catch (e) {}
                    }

                    if (children === undefined || Array.isArray(children) && children.length === 0) {
                        item = _react2.default.createElement(model[i].type, controlProps);
                    } else {
                        item = _react2.default.createElement(model[i].type, controlProps, children);
                    }
                }
            } else if (dbtype === "customblock") {
                var children_source = [];
                var renderempty = false;
                var cbbuildermode = false;
                var addDropZones = false;
                var newParentItem = model[i];
                var newParentPlaceholder = parentPlaceholder;
                var newFormItem = formItem;

                if (model[i].sourceType === 'form' || model[i].sourceType === undefined) {
                    if (model[i].children !== undefined && model[i].children !== "") {
                        children_source = model[i].children;
                    } else {
                        if (getFormFunc === undefined) {
                            console.error('Error: "getFormFunc" parameter is undefined!. Please, set "getFormFunc" parameter for DWKitBuilder or DWKitForm!');
                            continue;
                        }

                        if (model[i].formname !== undefined && model[i].formname !== "") {
                            children_source = getFormFunc(model[i].formname);
                        } else {
                            renderempty = true;
                        }
                    }
                } else if (model[i].sourceType === 'placeholder') {
                    cbbuildermode = eventOnEdit !== undefined;
                    addDropZones = eventOnEdit !== undefined;
                    newParentItem = parentItem;

                    if (newParentPlaceholder === undefined) newParentPlaceholder = model[i];

                    if (newFormItem === undefined) {
                        newFormItem = parentItem;
                    }

                    if (newFormItem !== undefined && newFormItem.placeholders !== undefined && newFormItem.placeholders[model[i].key] !== undefined) {

                        children_source = newFormItem.placeholders[model[i].key];
                    }
                } else {
                    if (model[i].source !== undefined && model[i].source !== "") children_source = _json2.default.parse(model[i].source);else renderempty = true;
                }

                if (renderempty) {
                    item = _react2.default.createElement(
                        'div',
                        { className: 'dwkit-formbuilder-empty', key: model[i].key },
                        'Set a form name or source in propepries.'
                    );
                } else {
                    var _children = this.createControls(parentComponent, {
                        model: children_source,
                        data: data,
                        errors: errors,
                        buildermode: cbbuildermode,
                        eventOnEdit: eventOnEdit,
                        eventOnDelete: eventOnDelete,
                        eventOnCopy: eventOnCopy,
                        parentItem: newParentItem,
                        handleEvent: handleEvent,
                        getFormFunc: getFormFunc,
                        getAdditionalDataForControl: getAdditionalDataForControl,
                        hideControls: hideControls,
                        readOnlyControls: readOnlyControls,
                        readOnly: readOnly,
                        disableRefs: disableRefs,
                        uploadUrl: uploadUrl, downloadUrl: downloadUrl, controlsToReplace: controlsToReplace, needCheckReplace: needCheckReplace,
                        parentPlaceholder: newParentPlaceholder,
                        formItem: newFormItem
                    });

                    var className = model[i]["style-customcss"];
                    if (buildermode) {
                        className = (className == undefined ? "" : className + " ") + "dwkit-formbuilder-item-container";
                    }

                    var formProps = {
                        key: model[i].key,
                        name: model[i].key,
                        className: className,
                        style: this.getStyle(model[i], buildermode),
                        "data-buildertype": model[i]["data-buildertype"]
                    };

                    if (addDropZones) {
                        if (_children === undefined) _children = [];

                        if (_children.length > 0) {
                            var dz_footer = DWKitFormControls.createBuilderDropzone(model[i].key + "_dropzone_footer", newFormItem === undefined ? undefined : newFormItem.key, //parentItem === undefined ? undefined : parentItem.key,
                            _children[_children.length - 1].key, model[i].key, model[i].key);
                            _children.push(dz_footer);
                        }

                        var dz = DWKitFormControls.createBuilderDropzone(model[i].key + "_dropzone_header", newFormItem === undefined ? undefined : newFormItem.key, //parentItem === undefined ? undefined : parentItem.key,
                        undefined, model[i].key, model[i].key);
                        _children.unshift(dz);
                    }

                    item = _react2.default.createElement('div', formProps, _children);
                }
            } else {
                var control = this.getControlByType(dbtype);
                if (control === null) {
                    item = _react2.default.createElement(
                        'div',
                        { key: model[i].key },
                        dbtype,
                        ' is unsupported'
                    );
                } else {
                    if (this.isContainer(dbtype)) {

                        var _newFormItem = formItem;
                        if (_newFormItem == undefined && parentItem != undefined && parentItem.sourceType == "form") {
                            _newFormItem = parentItem;
                        }

                        var isGorizontalGroup = buildermode && model[i]["data-buildertype"] === "formgroup" && model[i].orientation !== "grouped";
                        var _children2 = this.createControls(parentComponent, {
                            model: model[i].children,
                            data: data,
                            errors: errors,
                            buildermode: buildermode,
                            eventOnEdit: eventOnEdit,
                            eventOnDelete: eventOnDelete,
                            eventOnCopy: eventOnCopy,
                            parentItem: model[i],
                            handleEvent: handleEvent,
                            getFormFunc: getFormFunc,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            hideControls: hideControls,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            uploadUrl: uploadUrl, downloadUrl: downloadUrl, controlsToReplace: controlsToReplace, needCheckReplace: needCheckReplace,
                            parentPlaceholder: undefined,
                            formItem: _newFormItem,
                            controlBarRight: isGorizontalGroup
                        });
                        if (buildermode) {
                            if (_children2.length > 0) {
                                var _textDZ = isGorizontalGroup ? "..." : "... " + model[i].key + " down ...";
                                var dropzone_footer = this.createBuilderDropzone(model[i].key + "-dropzone_footer", model[i].key, undefined, _textDZ);
                                _children2.push(dropzone_footer);
                            }

                            var textDZ = isGorizontalGroup ? "..." : "... " + model[i].key + " up ...";
                            var dropzone_header = this.createBuilderDropzone(model[i].key + "-dropzone_header", model[i].key, undefined, textDZ);
                            _children2.unshift(dropzone_header);
                        }
                        item = this.createControl(parentComponent, control, {
                            model: model[i],
                            data: data,
                            errors: errors,
                            parentItem: parentItem,
                            buildermode: buildermode,
                            children: _children2,
                            handleEvent: handleEvent,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            parentPlaceholder: parentPlaceholder,
                            controlsToReplace: controlsToReplace,
                            needCheckReplace: needCheckReplace,
                            eventOnEdit: eventOnEdit, eventOnDelete: eventOnDelete, eventOnCopy: eventOnCopy
                        });
                    } else {
                        item = this.createControl(parentComponent, control, {
                            model: model[i],
                            data: data,
                            errors: errors,
                            parentItem: parentItem,
                            buildermode: buildermode,
                            handleEvent: handleEvent,
                            getAdditionalDataForControl: getAdditionalDataForControl,
                            readOnlyControls: readOnlyControls,
                            readOnly: readOnly,
                            disableRefs: disableRefs,
                            uploadUrl: uploadUrl,
                            downloadUrl: downloadUrl,
                            extendedData: extendedData,
                            parentPlaceholder: parentPlaceholder,
                            controlsToReplace: controlsToReplace,
                            needCheckReplace: needCheckReplace,
                            eventOnEdit: eventOnEdit, eventOnDelete: eventOnDelete, eventOnCopy: eventOnCopy
                        });
                    }
                }
            }

            if (buildermode) {
                if (i > 0 && i < model.length) {
                    var dropzone_bw = this.createBuilderDropzone(model[i].key + "-dropzone_bw", parentItem === undefined ? undefined : parentItem.key, model[i].key, "...", parentPlaceholder === undefined ? undefined : parentPlaceholder.key);
                    res.push(dropzone_bw);
                }

                var buildercontrol = _react2.default.createElement(_controlbar2.default, { key: model[i].key + "_controlbar",
                    text: model[i]["data-buildertype"],
                    model: model[i], parent: parentComponent,
                    onDelete: eventOnDelete, onEdit: eventOnEdit, onCopy: eventOnCopy,
                    isGroup: model[i]["data-buildertype"] === "formgroup",
                    controlOnRight: controlBarRight });

                if (controlBarRight) {
                    res.push(item);
                    res.push(buildercontrol);
                } else {
                    res.push(buildercontrol);
                    res.push(item);
                }
            } else {
                res.push(item);
            }
        }

        return res;
    },

    getControlByType: function getControlByType(buildertype) {
        var control = undefined;
        for (var i = 0; i < this.Items.length; i++) {
            if (this.Items[i].key === buildertype) {
                control = this.Items[i].control;
                break;
            }
        }
        return control;
    },
    getEditControlByType: function getEditControlByType(buildertype) {
        var control = undefined;
        for (var i = 0; i < this.Items.length; i++) {
            if (this.Items[i].key === buildertype) {
                control = this.Items[i].editControl;
                break;
            }
        }
        return control;
    },

    getStyle: function getStyle(model, buildermode) {
        var style = {
            marginTop: model["style-marginTop"],
            marginBottom: model["style-marginBottom"],
            marginLeft: model["style-marginLeft"],
            marginRight: model["style-marginRight"],
            width: model["style-width"],
            height: model["style-height"]
        };

        if (model["style-float"] !== undefined) {
            style.float = model["style-float"];
        }

        if (model["style-hidden"]) {
            if (buildermode) style.opacity = 0.2;else style.display = "none";
        }

        if (model["style-source"] !== undefined) {
            var properties = model["style-source"].split(';');
            properties.forEach(function (property) {
                var tup = property.split(':');
                if (tup.length === 2) {
                    var p = tup[0].replace(/^\s+|\s+$/g, '');
                    style[p] = tup[1].replace(/^\s+|\s+$/g, '');
                }
            });
        }

        if (model["style-font-size"] !== undefined) {
            style["font-size"] = model["style-font-size"];
        }

        return style;
    },


    regexForReplace: /{\S+}/gm,

    createControl: function createControl(parentComponent, control, _ref2) {
        var model = _ref2.model,
            data = _ref2.data,
            errors = _ref2.errors,
            parentItem = _ref2.parentItem,
            buildermode = _ref2.buildermode,
            children = _ref2.children,
            handleEvent = _ref2.handleEvent,
            getAdditionalDataForControl = _ref2.getAdditionalDataForControl,
            readOnlyControls = _ref2.readOnlyControls,
            readOnly = _ref2.readOnly,
            disableRefs = _ref2.disableRefs,
            uploadUrl = _ref2.uploadUrl,
            downloadUrl = _ref2.downloadUrl,
            extendedData = _ref2.extendedData,
            controlsToReplace = _ref2.controlsToReplace,
            needCheckReplace = _ref2.needCheckReplace,
            eventOnEdit = _ref2.eventOnEdit,
            eventOnDelete = _ref2.eventOnDelete,
            eventOnCopy = _ref2.eventOnCopy;


        var obj = void 0;
        var i = void 0;
        var res = undefined;
        var props = {
            key: model.key,
            name: model.key,
            className: model["style-customcss"],
            style: this.getStyle(model, buildermode),
            "data-buildertype": model["data-buildertype"]
        };
        var dataBuilderType = props["data-buildertype"];
        var needReplace = needCheckReplace || controlsToReplace.includes(model.key);

        if (buildermode && this.isContainer(props["data-buildertype"])) {
            props.className = (props.className == undefined ? "" : props.className + " ") + "dwkit-formbuilder-item-container";
        }

        if (!disableRefs) {
            props.ref = model.key;
        }

        if (model.readOnly !== undefined) {
            props.readOnly = model.readOnly;
        }

        if (readOnly || Array.isArray(readOnlyControls) && readOnlyControls.includes(model.key)) {
            props.readOnly = true;
        }
        var regexForReplace = this.regexForReplace;
        var replaceControlValue = function replaceControlValue(originalValue) {
            if (!needReplace || originalValue === undefined || originalValue === null) return originalValue;
            var replaceFromData = function replaceFromData(m) {
                if (data === undefined || data === null) return "";
                var value = data[m.slice(1, m.length - 1)];
                if (value === null || value === undefined) return "";
                return value;
            };
            if (Array.isArray(originalValue)) {
                var newValue = [];
                var needPushKey = false;
                originalValue.forEach(function (v) {
                    var newV = {};
                    for (var p in v) {
                        if (v.hasOwnProperty(p)) {
                            if (v[p] !== undefined && v[p] !== null && typeof v[p] === "string") {
                                newV[p] = v[p].replace(regexForReplace, function (m) {
                                    return replaceFromData(m);
                                });
                                if (!needPushKey && needCheckReplace && newV[p] !== v[p]) needPushKey = true;
                            } else if (Array.isArray(v[p])) {
                                newV[p] = replaceControlValue(v[p]);
                            } else {
                                newV[p] = v[p];
                            }
                        }
                    }
                    newValue.push(newV);
                });
                if (needPushKey) controlsToReplace.push(model.key);
                return newValue;
            } else {
                if (typeof originalValue !== "string") return originalValue;
                var _newValue = originalValue.replace(regexForReplace, function (m) {
                    return replaceFromData(m);
                });
                if (needCheckReplace && originalValue !== _newValue) {
                    controlsToReplace.push(model.key);
                }
                return _newValue;
            }
        };

        if (control === _semanticcontrol2.default) {
            if (dataBuilderType === "header") {
                props.content = replaceControlValue(model.content);
                props.subheader = replaceControlValue(model.subheader);
            } else if (dataBuilderType === "label") {
                props.content = replaceControlValue(model.content);
            } else if (dataBuilderType === "message") {
                props.content = replaceControlValue(model.content);
                props.header = replaceControlValue(model.header);
            } else if (dataBuilderType === "image") {
                props.src = replaceControlValue(model.src);
                props.href = replaceControlValue(model.href);
            } else if (dataBuilderType === "breadcrumb") {
                props.items = replaceControlValue(model.items);
            }

            res = _react2.default.createElement(_semanticcontrol2.default, _extends({}, props, { additionalParams: {
                    model: model, data: data, errors: errors, children: children, handleEvent: handleEvent, parentItem: parentItem, uploadUrl: uploadUrl, downloadUrl: downloadUrl
                } }));
        } else if (control === _dictionary2.default) {
            props.label = model.label;
            props.defaultValue = model.defaultvalue;
            props.placeholder = model.placeholder;
            props.loading = model.loading;
            props.error = model.error;
            props.disabled = model.disabled;
            props.fluid = model.fluid;
            props.selection = model.selection;
            props.multiple = model.multiple;
            props.search = model.search;
            props.dataModel = model.dataModel;
            props.clearable = model.clearable;
            props.columns = model.columns;
            props.paging = model.paging;
            props.pageSize = model.pageSize;
            props.getAdditionalDataForControl = getAdditionalDataForControl;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (handleEvent !== null) {
                props.onChange = function (e, _ref3) {
                    var name = _ref3.name,
                        value = _ref3.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            }
            props.parentIsForm = this.isForm(parentItem);

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_dictionary2.default, props);
        } else if (control === _dropdowntrigger2.default) {
            props.defaultValue = model.defaultValue;
            props.items = model.items;
            props.imageUrl = model.imageUrl;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_dropdowntrigger2.default, props);
        } else if (control === _search2.default) {
            props.url = model.url;
            props.category = model.category;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_search2.default, props);
        } else if (control === _radiogroup2.default) {
            var items = [];
            if (model["data-elements"] !== undefined) {
                if (Array.isArray(model["data-elements"])) {
                    items = model["data-elements"];
                } else {
                    items = _json2.default.parse(model["data-elements"]);
                }
            }

            if (handleEvent !== null) {
                props.onChange = function (e, _ref4) {
                    var name = _ref4.name,
                        value = _ref4.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            }

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_radiogroup2.default, _extends({}, props, {
                label: model.label,
                direction: model.direction,
                placeholder: model.placeholder,
                items: items }));
        } else if (control === _collectioneditor2.default) {
            props.columns = model.columns;
            props.draggable = model.draggable;
            props.hierarchical = model.hierarchical;
            props.parentIdField = model.parentIdField;
            props.idField = model.idField;
            props.childrenField = model.childrenField;
            props.collapseAll = model.collapseAll;
            props.disableAdd = model.disableAdd;
            props.placeholders = model.placeholders;
            if (props.placeholders != undefined) {
                props.getAdditionalDataForControl = getAdditionalDataForControl;
                props.createControl = function (parentControl, databuildertype, parameters) {
                    var control = DWKitFormControls.getControlByType(databuildertype);
                    if (control == undefined) {
                        console.error("Control is unsupported!", databuildertype, parentControl, parameters);
                        return;
                    }

                    var item = DWKitFormControls.createControl(parentControl, control, parameters);
                    var res = [];
                    if (parameters.buildermode) {
                        var buildercontrol = _react2.default.createElement(_controlbar2.default, { key: parameters.model.key + "_controlbar",
                            model: parameters.model, parent: parentComponent,
                            onDelete: eventOnDelete, onEdit: eventOnEdit, onCopy: eventOnCopy });
                        res.push(buildercontrol);
                        res.push(item);
                        return res;
                    }
                    return item;
                };
            }
            props.handleEvent = handleEvent;
            props.downloadUrl = downloadUrl;
            props.uploadUrl = uploadUrl;
            if (handleEvent !== null) {
                props.onChange = function (e, _ref5) {
                    var name = _ref5.name,
                        value = _ref5.value;

                    handleEvent({ syntheticEvent: e, key: props.key, eventName: "onChange", name: name, value: value });
                };
            } else if (buildermode) {
                props.onChange = function (e, _ref6) {
                    var name = _ref6.name,
                        value = _ref6.value;

                    props.value = value;
                };
            }

            if (data !== undefined) props.value = data[props.key];

            if (errors !== undefined) props.error = errors[props.key];

            if (buildermode && props.value === undefined && props.columns !== undefined) {
                props.buildermode = buildermode;
                props.createBuilderDropzone = function (columnName, value) {
                    return DWKitFormControls.createBuilderDropzone(props.key, props.key, undefined, columnName, columnName);
                };
                props.value = [];
                for (i = 0; i < 5; i++) {
                    props.value.push({});
                }

                if (Boolean(model.hierarchical) && model.parentIdField !== undefined && model.parentIdField !== "" && model.idField !== undefined && model.idField !== "") {
                    for (i = 1; i < 5; i++) {
                        var parent = props.value[i];
                        if (parent[model.idField] === undefined) {
                            parent[model.idField] = i;
                        }

                        for (var j = 0; j < 2; j++) {
                            var child = {};
                            child[model.parentIdField] = parent[model.idField];
                            props.value.push(child);
                        }
                    }
                }
            }

            res = _react2.default.createElement(_collectioneditor2.default, props);
        } else if (control === _gridview2.default) {
            props.columns = model.columns;
            props.multiselect = model.multiselect;
            props.rowKey = model.rowKey;
            props.editForm = model.editForm;
            props.editFlow = model.editFlow;
            props.editType = model.editType;
            props.pagerType = model.pagerType;
            props.pageSize = model.pageSize;
            props.rowHeight = model.rowHeight;
            props.minHeight = model.minHeight;
            props.autoHeight = model.autoHeight;
            props.offSet = model.offSet;
            props.disableSort = model.disableSort;
            props.resizeColumns = model.resizeColumns;
            props.editFormShowType = model.editFormShowType;
            props.getAdditionalDataForControl = getAdditionalDataForControl;
            props.handleEvent = handleEvent;
            props.defaultSort = model.defaultSort;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (data !== undefined) props.value = data[props.key];

            if (buildermode && props.value === undefined) {
                props.value = [];

                var _loop = function _loop() {
                    var obj = {};
                    props.columns.forEach(function (c) {
                        obj[c.key] = c.key + "_" + i;
                    });
                    props.value.push(obj);
                };

                for (i = 0; i < 30; i++) {
                    _loop();
                }
            }
            if (extendedData !== undefined && extendedData.filters !== undefined && extendedData.filters[props.key] !== undefined) {
                props.filter = new _functionalfilter.FunctionalFilter(extendedData.filters[props.key], props.columns.map(function (c) {
                    return c.key;
                }));
            }
            res = _react2.default.createElement(_gridview2.default, props);
        } else if (control === _menugroup2.default) {
            props["data-items"] = replaceControlValue(model.items);
            props.pointing = model.pointing;
            props.secondary = model.secondary;
            props.tabular = model.tabular;
            props.fluid = model.fluid;
            props.vertical = model.vertical;
            props.activeitem = model.activeitem;
            props.link = model.link;
            props.handleEvent = handleEvent;

            if (data !== undefined) props.value = data[props.key];

            res = _react2.default.createElement(_menugroup2.default, props);
        } else if (control === _chartview2.default) {
            props.chartType = model.chartType;
            props.responsive = model.responsive;
            props.legendPosition = model.legendPosition;
            props.title = model.title;
            props.titleSize = model.titleSize;
            props.datasetCustom = model.datasetCustom;
            props.dataLabels = model.dataLabels;
            props.datasetLabel = model.datasetLabel;
            props.datasetSteppedLine = model.datasetSteppedLine;
            props.datasetBorderColor = model.datasetBorderColor;
            props.datasetFill = model.datasetFill;
            props.datasetBorderWidth = model.datasetBorderWidth;
            props.datasetBackgroundColor = model.datasetBackgroundColor;

            if (buildermode) {
                if (props.datasetCustom) {
                    props.value = [1, 2, 3, 4, 3, 2, 1];
                } else {

                    var testData = props.chartType !== "scatter" ? [6, 23, 15, 3] : [{ x: 6, y: -12 }, { x: 11, y: 1 }, { x: 24, y: 5 }, { x: 40, y: 32 }];

                    props.value = {
                        labels: ["Q1", "Q2", "Q3", "Q4"],
                        datasets: [{
                            data: testData
                        }]
                    };
                }
            } else {
                if (data !== undefined) props.value = data[props.key];
            }

            res = _react2.default.createElement(_chartview2.default, props);
        } else if (control === _workflowbar2.default) {
            props.blockSetState = model.blockSetState;
            props.setStateButton = model.setStateButton;
            props.handleEvent = handleEvent;
            props.getAdditionalDataForControl = getAdditionalDataForControl;

            if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
                props.error = errors[model.key];
            }

            if (buildermode) {
                props.commands = [{ value: "approve", text: "Approve", type: 1 }, { value: "back", text: "Back", type: 2 }];

                props.states = [{ value: "draft", text: "Draft" }, { value: "state1", text: "State 1" }, { value: "state2", text: "State 2" }, { value: "state3", text: "State 3" }, { value: "finish", text: "Finish" }];
            }

            res = _react2.default.createElement(_workflowbar2.default, props);
        } else if (control === _container2.default) {
            res = _react2.default.createElement(_container2.default, _extends({}, props, { children: children }));
        } else if (control === _staticcontent2.default) {
            props.content = replaceControlValue(model.content);
            props.isHtml = model.isHtml;
            res = _react2.default.createElement(_staticcontent2.default, props);
        } else if (control === _dropzone2.default) {
            props.iconFiletypes = model.iconFiletypes;
            props.postUrl = uploadUrl;
            props.showFiletypeIcon = model.showFiletypeIcon;
            props.autoProcessQueue = model.autoProcessQueue;
            props.addRemoveLinks = model.addRemoveLinks;
            res = _react2.default.createElement(_dropzone2.default, _extends({}, props, {
                additionalParams: { model: model, data: data, errors: errors, children: children, handleEvent: handleEvent, parentItem: parentItem } }));
        } else {
            console.error("Control is unsupported!", control, model);
        }

        return res;
    },

    isContainer: function isContainer(key) {
        return key === 'form' || key === 'formgroup' || key === 'grid' || key === 'gridrow' || key === 'gridcolumn' || key === 'card' || key === 'cardcontent' || key === 'container' || key === 'div';
    },
    isForm: function isForm(model) {
        return model !== null && model !== undefined && (model["data-buildertype"] === "form" || model["data-buildertype"] === "formgroup");
    },
    createBuilderDropzone: function createBuilderDropzone(key, elementToInsert, elementafter, text, placeholderKey) {
        // if(text === undefined)
        text = "DROP ZONE";
        return _react2.default.createElement(
            'div',
            { name: key, key: key, elementafter: elementafter, elementtoinsert: elementToInsert, placeholderkey: placeholderKey, className: 'dwkit-formbuilder-zone' },
            text
        );
    },

    fillDefaultValues: function fillDefaultValues(model, defaultValues) {
        var control = undefined;
        for (var k in defaultValues) {
            if (model[k] === undefined) model[k] = defaultValues[k];
        }
        return model;
    }
};

module.exports = DWKitFormControls;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Upload = function (_React$Component) {
  _inherits(Upload, _React$Component);

  function Upload(props) {
    _classCallCheck(this, Upload);

    var _this = _possibleConstructorReturn(this, (Upload.__proto__ || Object.getPrototypeOf(Upload)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(Upload, [{
    key: "render",
    value: function render() {
      var type = this.props.type;
      var controls = [];
      var isForm = this.props.isForm;
      var token = this.props.value;

      if (token != undefined && token != null && token != "") {
        var downloadtext = "Download";
        var cleartext = "Clear";
        if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.button != undefined) {
          downloadtext = window.DWKitAdminLang.button.download;
          cleartext = window.DWKitAdminLang.button.clear;
        }

        var isHideClear = this.props.disabled || this.props.readOnly || this.props.hideClearButton;
        controls.push(_react2.default.createElement(
          "a",
          { key: "download", className: "ui button", target: "blank", href: this.props.downloadUrl + token },
          downloadtext
        ));

        if (!isHideClear) {
          controls.push(_react2.default.createElement(
            "span",
            { key: "sparator" },
            "\xA0\xA0"
          ));
          controls.push(_react2.default.createElement(
            "button",
            { key: "clear", className: "ui button", onClick: this.onClear.bind(this) },
            cleartext
          ));
        }
      } else {
        if (this.props.disabled || this.props.readOnly) controls.push(_react2.default.createElement("span", null));else controls.push(_react2.default.createElement("input", { key: "uploadcontrol", type: "file", name: this.props.name, onChange: this.onChange.bind(this) }));
      }

      var res = undefined;
      if (isForm) {
        res = _react2.default.createElement(
          "div",
          { className: "field" },
          this.props.label != undefined && _react2.default.createElement(
            "label",
            null,
            this.props.label
          ),
          _react2.default.createElement(
            "div",
            { "data-buildertype": type },
            controls
          )
        );
      } else {
        res = _react2.default.createElement(
          "div",
          { "data-buildertype": type },
          this.props.label != undefined && _react2.default.createElement(
            "div",
            { className: "ui label label" },
            this.props.label
          ),
          controls
        );
      }

      return res;
    }
  }, {
    key: "onChange",
    value: function onChange(e) {
      var me = this;
      var formdata = new FormData();
      formdata.append(me.props.name, e.target.files[0]);

      $.ajax({
        url: me.props.uploadUrl,
        type: 'POST',
        processData: false,
        contentType: false,
        dataType: 'json',
        data: formdata,
        success: function success(jsonData) {
          if (jsonData.success == true) {
            if (me.props.onChange != undefined) {
              me.props.onChange(e, { name: me.props.name, value: jsonData.message });
            }
          }
        }
      });
    }
  }, {
    key: "onClear",
    value: function onClear() {
      if (this.props.onChange != undefined) this.props.onChange(undefined, { name: this.props.name, value: null });
    }
  }]);

  return Upload;
}(_react2.default.Component);

exports.default = Upload;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDatepicker = __webpack_require__(39);

var _reactDatepicker2 = _interopRequireDefault(_reactDatepicker);

var _moment = __webpack_require__(12);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatePicker = function (_React$Component) {
  _inherits(DatePicker, _React$Component);

  function DatePicker(props) {
    _classCallCheck(this, DatePicker);

    var _this = _possibleConstructorReturn(this, (DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(DatePicker, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var type = this.props.type;
      var isForm = this.props.isForm;
      var date = this.props.value ? (0, _moment2.default)(this.props.value) : undefined;

      var controlProps = {};
      controlProps.readOnly = this.props.readOnly;

      if (type === "date") {
        if (window.DWKitLang !== undefined && window.DWKitLang.common != undefined && window.DWKitLang.common.dateFormat != undefined) {
          controlProps.dateFormat = window.DWKitLang.common.dateFormat;
        } else {
          controlProps.dateFormat = "DD.MM.YYYY";
        }
      } else if (type === "time") {
        controlProps.showTimeSelect = true;
        controlProps.showTimeSelectOnly = true;
        controlProps.timeIntervals = 10;
        if (window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.timeFormat != undefined) {
          controlProps.dateFormat = window.DWKitLang.common.timeFormat;
        } else {
          controlProps.dateFormat = "HH:mm";
          controlProps.timeFormat = "HH:mm";
        }
      } else if (type === "datetime") {
        controlProps.showTimeSelect = true;
        if (window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined) {
          controlProps.timeFormat = window.DWKitLang.common.timeFormat;
          controlProps.dateFormat = window.DWKitLang.common.dateFormat + " " + (window.DWKitLang.common.timeFormat == undefined ? "HH:ss" : window.DWKitLang.common.timeFormat);
        } else {
          controlProps.dateFormat = "DD.MM.YYYY HH:mm";
          controlProps.timeFormat = "HH:mm";
        }
      }

      if (this.props.dateFormat != undefined && this.props.dateFormat != "") controlProps.dateFormat;

      this.state.dateFormat = controlProps.dateFormat;

      var control = void 0;

      control = _react2.default.createElement(_reactDatepicker2.default, _extends({}, controlProps, {
        peekNextMonth: true,
        showMonthDropdown: true,
        showYearDropdown: true,
        dropdownMode: 'select',
        isClearable: !this.props.readOnly,
        placeholderText: this.placeholder,
        selected: date,
        onChange: this.onChange.bind(this),
        onChangeRaw: function onChangeRaw(event) {
          return _this2.handleChangeRaw(event.target.value);
        }
      }));

      var res = undefined;
      if (isForm) {
        var divClass = "field";
        if (this.props.error) divClass += " error";
        res = _react2.default.createElement(
          'div',
          { className: divClass },
          this.props.label != undefined && _react2.default.createElement(
            'label',
            null,
            this.props.label
          ),
          _react2.default.createElement(
            'div',
            { 'data-buildertype': type, className: 'ui fluid input' },
            control
          )
        );
      } else {
        var _divClass = "ui fluid labeled input";
        if (this.props.error) _divClass += " error";
        res = _react2.default.createElement(
          'div',
          { 'data-buildertype': type, className: _divClass },
          this.props.label != undefined && _react2.default.createElement(
            'div',
            { className: 'ui label label' },
            this.props.label
          ),
          control
        );
      }

      return res;
    }
  }, {
    key: 'handleChangeRaw',
    value: function handleChangeRaw(value) {
      var date = undefined;
      var type = this.props.type;
      date = (0, _moment2.default)(value, this.state.dateFormat);
      this.onChange(date);
    }
  }, {
    key: 'onChange',
    value: function onChange(date) {
      if (this.props.readOnly) return;

      if (this.props.onChange != undefined) {
        var value = null;
        if (date != null && date != undefined) {
          var type = this.props.type;
          var format = "";
          if (type === "date") {
            value = date.format("YYYY-MM-DD");
          } else {
            value = date.toJSON();
          }
        }

        this.props.onChange(null, { name: this.props.name, value: value });
      }
    }
  }]);

  return DatePicker;
}(_react2.default.Component);

exports.default = DatePicker;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioGroup = function (_React$Component) {
    _inherits(RadioGroup, _React$Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, (RadioGroup.__proto__ || Object.getPrototypeOf(RadioGroup)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(RadioGroup, [{
        key: 'onChange',
        value: function onChange(e, _ref) {
            var name = _ref.name,
                value = _ref.value;

            if (this.props.onChange != undefined) {
                this.props.onChange(e, { name: this.props.name, value: value });
            } else {
                console.error("Set onChange property for RadioGroup!");
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var me = this;
            var fields = this.props.items.map(function (item) {
                return _react2.default.createElement(
                    _semanticUiReact.Form.Field,
                    { key: item.key + "_formfield" },
                    _react2.default.createElement(_semanticUiReact.Form.Radio, {
                        key: item.key,
                        label: item.text,
                        name: me.props.name + '_radioGroup',
                        value: item.value,
                        readOnly: me.props.readOnly,
                        checked: me.props.value === item.value,
                        onChange: me.onChange.bind(this)
                    })
                );
            }, this);

            if (this.props.direction == 'v') {
                return _react2.default.createElement(
                    'div',
                    { className: 'ui form' },
                    _react2.default.createElement(
                        'label',
                        null,
                        this.props.label
                    ),
                    _react2.default.createElement(
                        _semanticUiReact.Form,
                        { className: this.props.className, style: this.props.style },
                        fields
                    )
                );
            }

            return _react2.default.createElement(
                'div',
                { className: 'ui form' },
                _react2.default.createElement(
                    'div',
                    { className: 'field' },
                    _react2.default.createElement(
                        'label',
                        null,
                        this.props.label
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: this.props.className, style: this.props.style },
                        _react2.default.createElement(
                            _semanticUiReact.Form.Group,
                            { key: 'group' },
                            fields
                        )
                    )
                )
            );
        }
    }]);

    return RadioGroup;
}(_react2.default.Component);

exports.default = RadioGroup;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _reactDataGrid = __webpack_require__(53);

var _reactDataGrid2 = _interopRequireDefault(_reactDataGrid);

var _functionalfilter = __webpack_require__(24);

var _moment = __webpack_require__(12);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Filter object structure:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               let filter = [
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {column: "Name" | "Name1,Name2,Name3" | "*",
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               value: value,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               term: ">" | "<" | "=" | ">=" | "<=" | "!=" | "like" | "like*" | "*like" | "*like*"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "*like*" === "like"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var CheckBoxFormatter = function (_React$Component) {
    _inherits(CheckBoxFormatter, _React$Component);

    function CheckBoxFormatter() {
        _classCallCheck(this, CheckBoxFormatter);

        return _possibleConstructorReturn(this, (CheckBoxFormatter.__proto__ || Object.getPrototypeOf(CheckBoxFormatter)).apply(this, arguments));
    }

    _createClass(CheckBoxFormatter, [{
        key: 'render',
        value: function render() {
            var value = Boolean(this.props.value);
            return _react2.default.createElement(_semanticUiReact.Checkbox, { checked: value, disabled: true });
        }
    }]);

    return CheckBoxFormatter;
}(_react2.default.Component);

var NumberFormatter = function (_React$Component2) {
    _inherits(NumberFormatter, _React$Component2);

    function NumberFormatter() {
        _classCallCheck(this, NumberFormatter);

        return _possibleConstructorReturn(this, (NumberFormatter.__proto__ || Object.getPrototypeOf(NumberFormatter)).apply(this, arguments));
    }

    _createClass(NumberFormatter, [{
        key: 'render',
        value: function render() {
            var value = this.props.value;
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: value },
                    value
                )
            );
        }
    }]);

    return NumberFormatter;
}(_react2.default.Component);

var DateFormatter = function (_React$Component3) {
    _inherits(DateFormatter, _React$Component3);

    function DateFormatter() {
        _classCallCheck(this, DateFormatter);

        return _possibleConstructorReturn(this, (DateFormatter.__proto__ || Object.getPrototypeOf(DateFormatter)).apply(this, arguments));
    }

    _createClass(DateFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined ? window.DWKitLang.common.dateFormat : "L";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return DateFormatter;
}(_react2.default.Component);

var DateTimeFormatter = function (_React$Component4) {
    _inherits(DateTimeFormatter, _React$Component4);

    function DateTimeFormatter() {
        _classCallCheck(this, DateTimeFormatter);

        return _possibleConstructorReturn(this, (DateTimeFormatter.__proto__ || Object.getPrototypeOf(DateTimeFormatter)).apply(this, arguments));
    }

    _createClass(DateTimeFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && DWKitLang.common !== undefined && window.DWKitLang.common.dateFormat != undefined ? window.DWKitLang.common.dateFormat + " " + (window.DWKitLang.common.timeFormat !== undefined ? window.DWKitLang.common.timeFormat : "HH:mm") : "DD.MM.YYYY HH:mm";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return DateTimeFormatter;
}(_react2.default.Component);

var TimeFormatter = function (_React$Component5) {
    _inherits(TimeFormatter, _React$Component5);

    function TimeFormatter() {
        _classCallCheck(this, TimeFormatter);

        return _possibleConstructorReturn(this, (TimeFormatter.__proto__ || Object.getPrototypeOf(TimeFormatter)).apply(this, arguments));
    }

    _createClass(TimeFormatter, [{
        key: 'render',
        value: function render() {
            var value = (0, _moment2.default)(this.props.value);
            var strValue = "";
            if (value.isValid()) {
                var format = window.DWKitLang !== undefined && window.DWKitLang.common !== undefined && window.DWKitLang.common.timeFormat != undefined ? window.DWKitLang.common.timeFormat : "HH:mm";
                strValue = value.format(format);
            }
            return _react2.default.createElement(
                'span',
                { style: { textAlign: 'right' } },
                _react2.default.createElement(
                    'div',
                    { title: strValue },
                    strValue
                )
            );
        }
    }]);

    return TimeFormatter;
}(_react2.default.Component);

var jsonEqual = function jsonEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
};

var GridView = function (_React$Component6) {
    _inherits(GridView, _React$Component6);

    function GridView(props) {
        _classCallCheck(this, GridView);

        var _this6 = _possibleConstructorReturn(this, (GridView.__proto__ || Object.getPrototypeOf(GridView)).call(this, props));

        _this6.state = {
            items: [],
            sort: "",
            defaultSort: props.defaultSort,
            filter: props.filter,
            pageSize: 20,
            selectedIndexes: [],
            rowsCount: GridView.staticIsServerMode(props) ? undefined : 0
        };
        return _this6;
    }

    _createClass(GridView, [{
        key: 'isEditFormModal',
        value: function isEditFormModal() {
            return this.props.editFormShowType === "modal";
        }
    }, {
        key: 'isServerMode',
        value: function isServerMode() {
            return GridView.staticIsServerMode(this.props);
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            if (this.isServerMode()) {
                this.setState({
                    items: [],
                    selectedIndexes: [],
                    rowsCount: undefined
                });
            } else {
                var newItems = Array.isArray(this.props.value) ? GridView.staticGetSortedAndFilteredItems(this.props.value, this.state.filter, this.state.sort, this.props.defaultSort) : [];
                this.setState({
                    items: newItems,
                    rowsCount: newItems.length,
                    selectedIndexes: [],
                    originalItems: this.props.value
                });
            }
        }
    }, {
        key: 'resetSelection',
        value: function resetSelection() {
            this.setState({
                selectedIndexes: []
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var className = this.props.className;
            var style = _extends({}, this.props.style);
            var gridProps = this.getGridPropsByPagerType(this.props.pagerType);
            gridProps.columns = this.getColumns();
            gridProps.rowKey = this.props.rowKey;

            if (this.props.rowHeight !== undefined && this.props.rowHeight !== "") gridProps.rowHeight = this.props.rowHeight;

            if (this.props.autoHeight) {
                style.minHeight = this.props.minHeight;
                if (this.props.offSet !== undefined && this.props.offSet !== "") {
                    style.height = 'calc(100vh - ' + this.props.offSet + ')';
                } else {
                    style.height = "100vh";
                }

                className = (className === undefined ? "" : className + " ") + "dwkit-gridview-autoHeight";
            } else {
                if (this.props.minHeight !== undefined && this.props.minHeight !== "") {
                    gridProps.minHeight = this.props.minHeight;
                }
            }

            // if (Boolean(this.props.filterRow)) {
            //     gridProps.toolbar = <Toolbar enableFilter={true}/>;
            //     gridProps.onAddFilter = this.handleFilterChange.bind(this);
            //     gridProps.onClearFilters = this.onClearFilters.bind(this);
            // }

            if (Boolean(this.props.multiselect)) {
                gridProps.rowSelection = {
                    onRowsSelected: this.onRowsSelected.bind(this),
                    onRowsDeselected: this.onRowsDeselected.bind(this),
                    selectBy: {
                        indexes: this.state.selectedIndexes
                    }
                };
            }

            return _react2.default.createElement(
                'div',
                { key: this.props.name, name: this.props.name, className: className, style: style },
                _react2.default.createElement(_reactDataGrid2.default, _extends({ key: 'grid'
                }, gridProps, {
                    rowsCount: this.state.rowsCount,
                    rowGetter: this.gridRowGetter.bind(this),
                    onRowClick: this.gridOnRowClick.bind(this),
                    onGridSort: this.handleGridSort.bind(this) }))
            );
        }
    }, {
        key: 'getColumns',
        value: function getColumns() {
            var me = this;
            var columns = void 0;
            if (this.props.columns === undefined) {
                columns = [];
            } else if (Array.isArray(this.props.columns)) {
                columns = this.props.columns;
            } else {
                columns = JSON.parse(this.props.columns);
            }

            columns.forEach(function (item) {
                if (item.width !== null && item.width !== "" && item.width !== undefined) {
                    item.width = Number(item.width);
                }

                if (item.sortable !== false) {
                    item.sortable = !Boolean(me.props.disableSort);
                }
                item.filterable = Boolean(me.props.filterRow);
                item.resizable = Boolean(item.resizable);

                if (item.type === "number") item.formatter = NumberFormatter;else if (item.type === "checkbox") {
                    item.formatter = CheckBoxFormatter;
                } else if (item.type === "date") {
                    item.formatter = DateFormatter;
                } else if (item.type === "time") {
                    item.formatter = TimeFormatter;
                } else if (item.type === "datetime") {
                    item.formatter = DateTimeFormatter;
                } else if (item.type === "custom") {
                    item.getRowMetaData = function (row) {
                        return row;
                    };
                    item.formatter = function (args) {
                        if (item.customFormatter == undefined || typeof item.customFormatter != "function") {
                            return "";
                        }
                        return item.customFormatter({
                            row: args.dependentValues,
                            value: args.value,
                            column: item
                        });
                    };
                }
            });
            return columns;
        }
    }, {
        key: 'getGridPropsByPagerType',
        value: function getGridPropsByPagerType() {
            var gridProps = {};

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                if (this.props.pageSize !== undefined) {
                    this.state.pageSize = this.props.pageSize;
                }
                gridProps.rowRenderer = RowLoadingRenderer;
                if (this.state.rowsCount === undefined) this.state.rowsCount = 1;
            } else {
                // if (Array.isArray(this.props.value)) {
                //     this.state.items = this.getSortedAndFilteredItems(this.props.value);
                // }
                //this.state.rowsCount = this.state.items.length;
            }
            return gridProps;
        }
    }, {
        key: 'getSeletedRowKeys',
        value: function getSeletedRowKeys() {
            var me = this;
            var selectedKeys = [];

            this.state.selectedIndexes.forEach(function (index) {
                var obj = me.gridRowGetter(index);
                if (obj !== undefined) {
                    selectedKeys.push(obj[me.props.rowKey]);
                }
            });
            return selectedKeys;
        }
    }, {
        key: 'gridRowGetter',
        value: function gridRowGetter(index) {
            if (index < 0) return undefined;

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                if (this.state.items[index] === undefined) {
                    var pageSize = this.state.pageSize;
                    this.loadPage(index, pageSize);
                }
            }

            if (pagerType === "server") {
                return this.state.items[index];
            } else {
                return _extends({}, this.state.items[index]); //DWKIT-115
            }
        }
    }, {
        key: 'loadPage',
        value: function loadPage(startIndex, pageSize) {
            var me = this;
            for (var i = 0; i < pageSize; i++) {
                this.state.items[i + startIndex] = { __loading: true };
            }

            if (this.props.getAdditionalDataForControl === undefined) {
                if (console !== undefined) console.log("GridView: For paging on server need to set getAdditionalDataForControl func!");
            } else {
                var sortString = this.state.sort;
                if (sortString === "" && this.props.defaultSort !== undefined) sortString = this.props.defaultSort;

                this.props.getAdditionalDataForControl(this, {
                    startIndex: startIndex,
                    pageSize: pageSize,
                    filters: this.state.filter !== undefined ? this.state.filter.GetFilterAsObjects() : [],
                    sort: sortString
                }, function (_ref) {
                    var sIndex = _ref.sIndex,
                        pSize = _ref.pSize,
                        rowsCount = _ref.rowsCount,
                        items = _ref.items;

                    if (rowsCount === undefined || items === undefined) {
                        me.state.rowsCount = 0;
                        me.setState({
                            rowsCount: 0,
                            items: []
                        });
                    } else {
                        me.state.rowsCount = rowsCount;
                        for (var _i = 0; _i < pSize; _i++) {
                            if (_i < items.length) {
                                me.state.items[sIndex + _i] = items[_i];
                            } else {
                                me.state.items[sIndex + _i] = undefined;
                            }
                        }
                        me.forceUpdate();
                    }
                });
            }
        }
    }, {
        key: 'gridOnRowClick',
        value: function gridOnRowClick(rowIdx, row) {
            if (row === undefined) return;

            var timenow = Date.now();
            if (this.rowClickTime !== undefined && this.rowClickTime.rowIdx === rowIdx && timenow - this.rowClickTime.time <= 1000) {
                this.rowClickTime = undefined;
                this.onRowDblClick(rowIdx, row);
            } else {
                this.rowClickTime = {
                    rowIdx: rowIdx,
                    time: timenow
                };

                if (this.props.handleEvent !== undefined) {
                    this.props.handleEvent({ key: this.props.name, eventName: "onRowClick", parameters: { rowIdx: rowIdx, row: row } });
                }
            }
        }
    }, {
        key: 'onRowDblClick',
        value: function onRowDblClick(rowIdx, row) {
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({ key: this.props.name, eventName: "onRowDblClick", parameters: { rowIdx: rowIdx, row: row } });
            }
        }
    }, {
        key: 'onRowsSelected',
        value: function onRowsSelected(rows) {
            this.state.selectedIndexes = this.state.selectedIndexes.concat(rows.map(function (r) {
                return r.rowIdx;
            }));
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({
                    key: this.props.name,
                    eventName: "onSelectionChanged",
                    parameters: { selectedIndexes: this.state.selectedIndexes }
                });
            }
            this.forceUpdate();
        }
    }, {
        key: 'onRowsDeselected',
        value: function onRowsDeselected(rows) {
            var rowIndexes = rows.map(function (r) {
                return r.rowIdx;
            });
            this.state.selectedIndexes = this.state.selectedIndexes.filter(function (i) {
                return rowIndexes.indexOf(i) === -1;
            });
            if (this.props.handleEvent !== undefined) {
                this.props.handleEvent({
                    key: this.props.name,
                    eventName: "onSelectionChanged",
                    parameters: { selectedIndexes: this.state.selectedIndexes }
                });
            }
            this.forceUpdate();
        }
    }, {
        key: 'handleGridSort',
        value: function handleGridSort(sortColumn, sortDirection) {
            var stateDelta = {};
            if (sortDirection === "NONE") stateDelta.sort = "";else stateDelta.sort = sortColumn + " " + sortDirection;

            var pagerType = this.props.pagerType;
            if (pagerType === "server") {
                stateDelta.items = [];
            } else {
                stateDelta.items = GridView.staticGetSortedAndFilteredItems(this.props.value, this.state.filter, stateDelta.sort, this.props.defaultSort);
            }

            stateDelta.selectedIndexes = [];
            this.setState(stateDelta);
        }
    }, {
        key: 'handleFilterChange',
        value: function handleFilterChange(filter) {
            var stateDelta = {};
            var key = filter.column.key;
            var id = "columnfilter_" + key;
            stateDelta.filter = this.state.filter !== undefined ? this.state.filter : new _functionalfilter.FunctionalFilter([], this.props.columns.map(function (c) {
                return c.key;
            }));
            stateDelta.filter.RemoveFilter({ name: key, id: id });
            if (filter.filterTerm !== "") {
                stateDelta.filter.AddFilter({ names: [key], expected: filter.filterTerm, term: _functionalfilter.FilterTerms.Like, id: id });
            }
            if (GridView.staticIsServerMode(this.props)) {
                stateDelta.items = [];
                stateDelta.selectedIndexes = [];
                stateDelta.rowsCount = undefined;
            } else {
                stateDelta.items = GridView.staticGetSortedAndFilteredItems(this.props.value, stateDelta.filter, this.state.sort, this.props.defaultSort);
                stateDelta.selectedIndexes = [];
                stateDelta.rowsCount = stateDelta.items.length;
            }
            this.setState(stateDelta);
        }
    }, {
        key: 'onClearFilters',
        value: function onClearFilters() {
            this.setState({ filter: this.props.filter });
        }
    }, {
        key: 'componentWillUnmount',


        ///----------
        ///Resize
        ///----------
        value: function componentWillUnmount() {
            this._isMounted = false;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._isMounted = true;
            this.recalcSizeParams();
        }
    }, {
        key: 'recalcSizeParams',
        value: function recalcSizeParams() {
            if (!this._isMounted) return;

            if (Boolean(this.props.autoHeight)) {
                var h = $(window).height();

                this.setState({
                    gridHeight: h - this.props.deltaHeight
                });
            }
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            var newState = null;
            if (!jsonEqual(prevState.filter, nextProps.filter)) {
                newState = { filter: nextProps.filter };
                if (!GridView.staticIsServerMode(nextProps)) {
                    var newItems = Array.isArray(nextProps.value) ? GridView.staticGetSortedAndFilteredItems(nextProps.value, nextProps.filter, prevState.sort, nextProps.defaultSort) : [];
                    newState.items = newItems;
                    newState.selectedIndexes = [];
                    newState.rowsCount = newItems.length;
                } else {
                    newState.items = [];
                    newState.selectedIndexes = [];
                    newState.rowsCount = undefined;
                }
            } else {
                if (!GridView.staticIsServerMode(nextProps) && prevState.originalItems !== nextProps.value) {
                    newState = {};
                    var _newItems = Array.isArray(nextProps.value) ? GridView.staticGetSortedAndFilteredItems(nextProps.value, prevState.filter, prevState.sort, nextProps.defaultSort) : [];

                    newState.items = _newItems;
                    newState.rowsCount = _newItems.length;
                    newState.selectedIndexes = [];
                    newState.originalItems = nextProps.value;
                }
            }
            return newState;
        }
    }, {
        key: 'staticIsServerMode',
        value: function staticIsServerMode(props) {
            return props.pagerType === "server";
        }
    }, {
        key: 'staticGetSortedAndFilteredItems',
        value: function staticGetSortedAndFilteredItems(array, filter, sort, defaultSort) {
            var items = [];
            if (array === undefined) return items;
            if (filter !== undefined) {
                items = array.filter(function (r) {
                    return filter.IsRowMatched(r);
                });
            } else {
                items = array;
            }

            var currentSort = sort;
            if (sort === 'NONE' || sort === "") {
                if (defaultSort === undefined) {
                    return items;
                }
                currentSort = defaultSort;
            }

            var indexSpace = currentSort.indexOf(" ");
            var sortColumn = currentSort.substring(0, indexSpace);
            var sortDirection = currentSort.substring(indexSpace + 1, currentSort.length);

            //Sorting
            var comparer = function comparer(a, b) {
                var aValue = a[sortColumn] !== undefined && a[sortColumn] !== null && a[sortColumn].toLowerCase !== undefined ? a[sortColumn].toLowerCase() : a[sortColumn];
                var bValue = b[sortColumn] !== undefined && b[sortColumn] !== null && b[sortColumn].toLowerCase !== undefined ? b[sortColumn].toLowerCase() : b[sortColumn];

                if (aValue === bValue) {
                    return 0;
                }
                if (aValue === null || aValue === undefined) {
                    return 1;
                }
                if (bValue === null || bValue === undefined) {
                    return -1;
                }
                if (sortDirection === 'ASC') {
                    return aValue > bValue ? 1 : -1;
                } else if (sortDirection === 'DESC') {
                    return aValue < bValue ? 1 : -1;
                }
            };
            return items.slice(0).sort(comparer);
        }
    }]);

    return GridView;
}(_react2.default.Component);

exports.default = GridView;

var RowLoadingRenderer = function (_React$Component7) {
    _inherits(RowLoadingRenderer, _React$Component7);

    function RowLoadingRenderer() {
        _classCallCheck(this, RowLoadingRenderer);

        return _possibleConstructorReturn(this, (RowLoadingRenderer.__proto__ || Object.getPrototypeOf(RowLoadingRenderer)).apply(this, arguments));
    }

    _createClass(RowLoadingRenderer, [{
        key: 'setScrollLeft',
        value: function setScrollLeft(scrollBy) {
            this.row.setScrollLeft(scrollBy);
        }
    }, {
        key: 'getClassName',
        value: function getClassName() {
            return this.props.row.__loading ? 'dwkit-gridview-rowloading' : "";
        }
    }, {
        key: 'render',
        value: function render() {
            var _this8 = this;

            return _react2.default.createElement(
                'div',
                { className: this.getClassName() },
                _react2.default.createElement(_reactDataGrid.Row, _extends({ ref: function ref(node) {
                        return _this8.row = node;
                    } }, this.props))
            );
        }
    }]);

    return RowLoadingRenderer;
}(_react2.default.Component);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FilterTerms = function () {
    function FilterTerms() {
        _classCallCheck(this, FilterTerms);
    }

    _createClass(FilterTerms, null, [{
        key: "IsGreater",
        value: function IsGreater(value) {
            return value === FilterTerms.Greater;
        }
    }, {
        key: "IsLess",
        value: function IsLess(value) {
            return value === FilterTerms.Less;
        }
    }, {
        key: "IsEqual",
        value: function IsEqual(value) {
            return value === FilterTerms.Equal;
        }
    }, {
        key: "IsGreaterOrEqual",
        value: function IsGreaterOrEqual(value) {
            return value === FilterTerms.GreaterOrEqual;
        }
    }, {
        key: "IsLessOrEqual",
        value: function IsLessOrEqual(value) {
            return value === FilterTerms.LessOrEqual;
        }
    }, {
        key: "IsNotEqual",
        value: function IsNotEqual(value) {
            return value === FilterTerms.NotEqual;
        }
    }, {
        key: "IsLike",
        value: function IsLike(value) {
            return value.toLowerCase() === FilterTerms.Like || value.toLowerCase() === "*like*";
        }
    }, {
        key: "IsStartsWith",
        value: function IsStartsWith(value) {
            return value.toLowerCase() === FilterTerms.StartsWith;
        }
    }, {
        key: "IsEndsWith",
        value: function IsEndsWith(value) {
            return value.toLowerCase() === FilterTerms.EndsWith;
        }
    }, {
        key: "Evaluate",
        value: function Evaluate(value, expected, term) {
            if (FilterTerms.IsGreater(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v > e;
                });
            }
            if (FilterTerms.IsLess(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v < e;
                });
            }
            if (FilterTerms.IsEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v === e;
                });
            }
            if (FilterTerms.IsGreaterOrEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v >= e;
                });
            }
            if (FilterTerms.IsLessOrEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v <= e;
                });
            }
            if (FilterTerms.IsNotEqual(term)) {
                return FilterTerms.compareWithTypeCheck(value, expected, function (v, e) {
                    return v !== e;
                });
            }
            if (FilterTerms.IsLike(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.indexOf(e) >= 0;
                });
            }
            if (FilterTerms.IsStartsWith(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.startsWith(e);
                });
            }
            if (FilterTerms.IsEndsWith(term)) {
                return FilterTerms.likeCompare(value, expected, function (v, e) {
                    return v.endsWith(e);
                });
            }

            throw "Unknown term " + term;
        }
    }, {
        key: "likeCompare",
        value: function likeCompare(value, expected, comparator) {
            if (value === null && expected === null) return true;

            if (value === undefined && expected === undefined) return true;

            if (value === null || value === undefined) return false;

            if (expected === null || expected === undefined) return false;
            return comparator(value.toString().toLowerCase(), expected.toString().toLowerCase());
        }
    }, {
        key: "compareWithTypeCheck",
        value: function compareWithTypeCheck(value, expected, comparator) {
            if (value === null && expected === null) return true;

            if (value === undefined && expected === undefined) return true;

            if (value === null || value === undefined) return false;

            if (expected === null || expected === undefined) return false;

            if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === (typeof expected === "undefined" ? "undefined" : _typeof(expected))) {
                return comparator(value, expected);
            } else if (typeof value === "number" && typeof expected === "string") {
                return comparator(value, parseFloat(expected));
            } else if (typeof value === "string" && typeof expected === "number") {
                return comparator(value, expected.toString());
            } else {
                return comparator(value, expected);
            }
        }
    }, {
        key: "Greater",
        get: function get() {
            return ">";
        }
    }, {
        key: "Less",
        get: function get() {
            return ">";
        }
    }, {
        key: "Equal",
        get: function get() {
            return "=";
        }
    }, {
        key: "GreaterOrEqual",
        get: function get() {
            return ">=";
        }
    }, {
        key: "LessOrEqual",
        get: function get() {
            return "<=";
        }
    }, {
        key: "NotEqual",
        get: function get() {
            return "!=";
        }
    }, {
        key: "Like",
        get: function get() {
            return "like";
        }
    }, {
        key: "StartsWith",
        get: function get() {
            return "like*";
        }
    }, {
        key: "EndsWith",
        get: function get() {
            return "*like";
        }
    }]);

    return FilterTerms;
}();

var FunctionalFilter = function () {
    function FunctionalFilter(objectFilter, columns) {
        var _this = this;

        _classCallCheck(this, FunctionalFilter);

        this._innerFilter = {};
        if (objectFilter === undefined || !Array.isArray(objectFilter)) return;
        if (columns === undefined || !Array.isArray(columns)) throw "columns must be array";

        objectFilter.forEach(function (el) {
            if (el === undefined) return;
            var applyToColumns = void 0;
            if (el.column === "*") {
                applyToColumns = columns;
            } else {
                applyToColumns = el.column.split(",").map(function (n) {
                    return n.trim();
                });
            }

            _this.AddFilter({ names: applyToColumns, expected: el.value, term: el.term });
        });
    }

    _createClass(FunctionalFilter, [{
        key: "AddFilter",
        value: function AddFilter(_ref) {
            var _this2 = this;

            var names = _ref.names,
                expected = _ref.expected,
                term = _ref.term,
                id = _ref.id;

            if (names.length < 1) return;

            var filterId = names.length === 1 ? names[0] : names.sort().join("_");
            var filter = void 0;
            if (!this._innerFilter.hasOwnProperty(filterId)) {
                filter = this._innerFilter[filterId] = {};
                filter.funcs = [];
                filter.items = [];
                filter.test = function (r) {
                    return _this2._innerFilter[filterId].funcs.every(function (f) {
                        return f(r);
                    });
                };
            } else {
                filter = this._innerFilter[filterId];
            }

            var compFunc = void 0;
            var singleCompFunc = function singleCompFunc(r, name) {
                var propName = Object.keys(r).find(function (k) {
                    return k.toString().toLowerCase() === name.toLowerCase();
                });
                if (propName !== undefined) {
                    var result = FilterTerms.Evaluate(r[propName], expected, term);
                    return result;
                } else return false;
            };

            if (names.length === 1) {
                compFunc = function compFunc(r) {
                    return singleCompFunc(r, names[0]);
                };
            } else {
                compFunc = function compFunc(r) {
                    return names.some(function (name) {
                        return singleCompFunc(r, name);
                    });
                };
            }
            filter.funcs.push(compFunc);
            filter.items.push({ expected: expected, term: term, id: id });
        }
    }, {
        key: "RemoveFilter",
        value: function RemoveFilter(_ref2) {
            var _this3 = this;

            var name = _ref2.name,
                id = _ref2.id;

            var filterId = void 0;
            var names = void 0;
            if (name !== undefined) {
                if (Array.isArray(name)) {
                    filterId = name.length === 1 ? name[0] : name.sort().join("_");
                    names = name;
                } else {
                    filterId = name;
                    names = [name];
                }
            }

            if (name !== undefined && id === undefined) {
                delete this._innerFilter[filterId];
            } else if (name === undefined && id === undefined) {
                this._innerFilter = {};
            } else {
                var recreateProperty = function recreateProperty(filterId, names, id) {
                    if (!_this3._innerFilter.hasOwnProperty(filterId)) return;
                    var newItems = _this3._innerFilter[filterId].items.filter(function (el) {
                        return el.id !== id;
                    });
                    if (newItems.length < _this3._innerFilter[filterId].items.length) {
                        delete _this3._innerFilter[filterId];
                        newItems.forEach(function (ni) {
                            _this3.AddFilter({ names: names, expected: ni.expected, term: ni.term, id: ni.id });
                        });
                    }
                };

                if (name !== undefined && id !== undefined) {
                    recreateProperty(filterId, names, id);
                } else {
                    var allFilterIds = Object.keys(this._innerFilter);
                    allFilterIds.forEach(function (filterId) {
                        recreateProperty(filterId, filterId.split("_"), id);
                    });
                }
            }
        }
    }, {
        key: "IsRowMatched",
        value: function IsRowMatched(row) {
            var allNames = Object.keys(this._innerFilter);
            if (allNames.length <= 0) return true;

            for (var i = 0; i < allNames.length; i++) {
                if (!this._innerFilter[allNames[i]].test(row)) return false;
            }

            return true;
        }
    }, {
        key: "GetFilterAsObjects",
        value: function GetFilterAsObjects() {
            var _this4 = this;

            if (this._innerFilter === undefined) return [];
            var result = [];
            var allNames = Object.keys(this._innerFilter);
            allNames.forEach(function (pn) {
                _this4._innerFilter[pn].items.forEach(function (i) {
                    result.push({ column: pn.replace(/_/g, ","), value: i.expected, term: i.term });
                });
            });
            return result;
        }
    }]);

    return FunctionalFilter;
}();

exports.FilterTerms = FilterTerms;
exports.FunctionalFilter = FunctionalFilter;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CollectionEditor = exports.GridView = exports.DWKitForm = undefined;

var _form = __webpack_require__(26);

var _form2 = _interopRequireDefault(_form);

var _gridview = __webpack_require__(23);

var _gridview2 = _interopRequireDefault(_gridview);

var _collectioneditor = __webpack_require__(7);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.DWKitForm = _form2.default;
exports.GridView = _gridview2.default;
exports.CollectionEditor = _collectioneditor2.default;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(6);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _store = __webpack_require__(27);

var _store2 = _interopRequireDefault(_store);

var _controls = __webpack_require__(19);

var _controls2 = _interopRequireDefault(_controls);

var _timeout = __webpack_require__(66);

var _timeout2 = _interopRequireDefault(_timeout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DWKitForm = function (_React$Component) {
    _inherits(DWKitForm, _React$Component);

    function DWKitForm(props) {
        _classCallCheck(this, DWKitForm);

        var _this = _possibleConstructorReturn(this, (DWKitForm.__proto__ || Object.getPrototypeOf(DWKitForm)).call(this, props));

        _this._asyncGetData = null;
        _this._asyncGetModel = null;

        _this.state = {
            data: props.data,
            model: props.model,
            extendedData: props.extendedData,
            controlsToReplace: null
        };
        // this.controlsToReplace = null;

        _this.checkLoadedState(_this.state.data, _this.state.model);
        return _this;
    }

    _createClass(DWKitForm, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.PrepareState();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this.PrepareState();
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._asyncGetData) {
                this._asyncGetData.abort();
            }
            if (this._asyncGetModel) {
                this._asyncGetModel.abort();
            }
        }
    }, {
        key: 'PrepareState',
        value: function PrepareState() {
            var me = this;
            if (this.state.needFetchModel) {
                me.setState({ needFetchModel: false });
                this._asyncGetModel = $.getJSON(this.state.modelurl).done(function (data) {
                    me._asyncGetModel = null;
                    me.modelChanged(data);
                }).fail(function (jqxhr, textStatus, error) {
                    me._asyncGetModel = null;
                    var err = textStatus + ", " + error;
                    me.handleErrEvent(err);
                });
            }

            if (this.state.needFetchData) {
                me.setState({ needFetchData: false });
                this._asyncGetData = $.getJSON(this.state.dataurl).done(function (data) {
                    me._asyncGetData = null;
                    me.dataChanged(data);
                }).fail(function (jqxhr, textStatus, error) {
                    me._asyncGetData = null;
                    var err = textStatus + ", " + error;
                    me.handleErrEvent(err);
                });
            }

            this.checkConditions(this.state.model);
            this.checkLoadedState(this.state.data, this.state.model);
        }
    }, {
        key: 'modelChanged',
        value: function modelChanged(model) {
            this.setState({
                model: model,
                controlsToReplace: null
            });

            this.checkConditions(model);
        }
    }, {
        key: 'dataChanged',
        value: function dataChanged(data) {
            this.setState({
                data: data
            });

            this.checkLoadedState(data, this.state.model);
        }
    }, {
        key: 'checkLoadedState',
        value: function checkLoadedState(data, model) {
            if (!this.state.isLoaded && data !== undefined && data !== null && model !== undefined && model !== null) {
                this.setState({ isLoaded: true });
                this.props.eventFunc({
                    key: undefined,
                    controlRef: this,
                    formName: this.props.formName,
                    component: this,
                    eventName: "init",
                    actions: ["initSystem", "init"],
                    parameters: undefined
                });
            }
        }
    }, {
        key: 'handleEvent',
        value: function handleEvent(_ref) {
            var e = _ref.e,
                key = _ref.key,
                eventName = _ref.eventName,
                parameters = _ref.parameters,
                name = _ref.name,
                value = _ref.value;

            var me = this;
            var isOnchange = eventName === "onChange";
            if (isOnchange) {
                if (!Boolean(this.props.onlyExternalDataChanged)) {
                    if (this.state.data === undefined) {
                        this.state.data = {};
                    }
                    var data = this.state.data;
                    data[key] = value;
                    this.setState({ data: data });
                }

                if (this.props.dataChanged !== undefined) this.props.dataChanged(this, { key: key, value: value });

                this.onConditions(key, eventName, parameters, name, value);
            }

            if (this.props.eventFunc === undefined) return;

            var item = this.findModelItembyKey(key);
            if (item === undefined) return;

            if (item.events !== undefined && item.events[eventName] !== undefined && item.events[eventName].active) {
                var event = item.events[eventName];

                var eventParameters = _extends({}, parameters);
                if (Array.isArray(event.parameters) && event.parameters.length > 0) {
                    event.parameters.forEach(function (p) {
                        eventParameters[p.name] = p.value;
                    });
                }
                var sourceControl = me.refs[key];
                var sourceControlValue = value;
                var fireEvent = void 0;
                if (Array.isArray(event.targets) && event.targets.length > 0) {

                    fireEvent = function fireEvent() {
                        return event.targets.forEach(function (t) {
                            me.props.eventFunc({
                                key: t,
                                sourceControlRef: sourceControl,
                                sourceControlValue: sourceControlValue,
                                controlRef: me.refs[t],
                                formName: me.props.formName,
                                component: me,
                                eventName: eventName,
                                actions: event.actions,
                                parameters: eventParameters
                            });
                        });
                    };
                } else {
                    fireEvent = function fireEvent() {
                        return me.props.eventFunc({
                            key: key,
                            sourceControlRef: sourceControl,
                            sourceControlValue: sourceControlValue,
                            controlRef: sourceControl,
                            formName: me.props.formName,
                            component: me,
                            eventName: eventName,
                            actions: event.actions,
                            parameters: eventParameters
                        });
                    };
                }
                if (!isOnchange || item.onChangeTimeout === undefined || item.onChangeTimeout === "" || Number(item.onChangeTimeout) < 1) {
                    fireEvent();
                } else {
                    _timeout2.default.Set(key, fireEvent, Number(item.onChangeTimeout));
                }
            }
        }
    }, {
        key: 'checkConditions',
        value: function checkConditions(model, child) {
            var enableCheckConditions = false;
            if (Array.isArray(model)) {
                for (var i = 0; i < model.length; i++) {
                    if (model[i]["other-visibleConition"] !== undefined && model[i]["other-visibleConition"] !== "" || model[i]["other-readOnlyConition"] !== undefined && model[i]["other-readOnlyConition"] !== "") {
                        enableCheckConditions = true;
                    }

                    if (Array.isArray(model[i].children)) {
                        enableCheckConditions = this.checkConditions(model[i].children, true);
                    }

                    if (enableCheckConditions) break;
                }
            }

            if (child) {
                return enableCheckConditions;
            }

            this.state.enableCheckConditions = enableCheckConditions;
        }
    }, {
        key: 'onConditions',
        value: function onConditions(key, eventName, parameters, name, value) {
            if (this.state.enableCheckConditions) {
                this.props.eventFunc({
                    key: key,
                    controlRef: this.refs[key],
                    formName: this.props.formName,
                    component: this,
                    eventName: eventName,
                    actions: ["checkConditions"],
                    parameters: parameters
                });
            }
        }
    }, {
        key: 'handleErrEvent',
        value: function handleErrEvent(message) {
            if (this.props.eventErrFunc) {
                this.props.eventErrFunc(this, message);
            }
        }
    }, {
        key: 'findModelItembyKey',
        value: function findModelItembyKey(key, array) {
            if (array === undefined) {
                array = this.state.model;
            }

            for (var i = 0; i < array.length; i++) {
                if (array[i].key === key) return array[i];

                if (array[i].children !== undefined) {
                    var item = this.findModelItembyKey(key, array[i].children);
                    if (item !== undefined) return item;
                }

                if (array[i].placeholders !== undefined) {
                    for (var ph in array[i].placeholders) {
                        var item = this.findModelItembyKey(key, array[i].placeholders[ph]);
                        if (item !== undefined) return item;
                    }
                }
            }
            return undefined;
        }
    }, {
        key: 'render',
        value: function render() {
            var controlsToReplace = [];
            var needCheckReplace = false;

            if (this.state.model !== null && this.state.model !== undefined) {
                controlsToReplace = this.state.controlsToReplace === null ? [] : this.state.controlsToReplace;
                needCheckReplace = this.state.controlsToReplace === null;
            }

            var items = _controls2.default.createControls(this, {
                model: this.state.model,
                data: this.state.data,
                errors: this.props.errors,
                handleEvent: this.handleEvent.bind(this),
                getFormFunc: this.props.getFormFunc,
                getAdditionalDataForControl: this.props.getAdditionalDataForControl,
                hideControls: this.props.hideControls,
                readOnlyControls: this.props.readOnlyControls,
                readOnly: this.props.readOnly,
                uploadUrl: this.props.uploadUrl,
                downloadUrl: this.props.downloadUrl,
                extendedData: this.props.extendedData,
                controlsToReplace: controlsToReplace,
                needCheckReplace: needCheckReplace
            });

            if (needCheckReplace) {
                this.state.controlsToReplace = controlsToReplace;
            }

            var className = "dwkit-form" + (this.props.className === undefined ? "" : " " + this.props.className);

            return _react2.default.createElement(
                'div',
                { className: className },
                items
            );
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            var stateDelta = {};
            if (nextProps.modelurl !== undefined && nextProps.modelurl !== "" && nextProps.modelurl !== prevState.modelurl) {
                stateDelta.modelurl = nextProps.modelurl;
                stateDelta.needFetchModel = true;
            }
            //TODO add json equal?
            if (nextProps.model !== undefined && nextProps.model !== prevState.model) {
                stateDelta.controlsToReplace = null;
                stateDelta.model = nextProps.model;
            }

            if (nextProps.dataurl !== undefined && nextProps.dataurl !== "" && nextProps.dataurl !== prevState.dataurl) {
                stateDelta.dataurl = nextProps.dataurl;
                stateDelta.needFetchData = true;
            }
            if (nextProps.data !== undefined) {
                stateDelta.data = nextProps.data;
            }

            return stateDelta;
        }
    }]);

    return DWKitForm;
}(_react2.default.Component);

exports.default = DWKitForm;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Reflux = __webpack_require__(13);
var BuilderActions = __webpack_require__(18);
var DWKitFormControls = __webpack_require__(19);

var _data;

var DWKitStore = Reflux.createStore({
  init: function init() {
    this.listenTo(BuilderActions.add, this.add);
    this.listenTo(BuilderActions.move, this.move);
    this.listenTo(BuilderActions.remove, this.remove);
    this.listenTo(BuilderActions.save, this.save);
    this.listenTo(BuilderActions.saveData, this._updateOrder);

    _data = [];
  },

  move: function move(key, el) {
    if (el == undefined) return;

    var item = this.findItemByKey(key, _data);
    var sortedArray = this._excludeItemByKey(key, _data);

    if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_footer') {
      sortedArray.push(item);
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_header') {
      sortedArray.unshift(item);
    } else if (el.attributes['elementtoinsert'] != undefined) {
      var parentControl;
      var insertIndex = 0;
      var parentKey = el.attributes['elementtoinsert'];

      if (parentKey != undefined) {
        parentControl = this.findItemByKey(parentKey.value, sortedArray);
      }

      if (parentControl != undefined) {
        var placeholderKey = el.attributes['placeholderkey'];
        var container = undefined;

        if (placeholderKey === undefined) {
          if (parentControl.children == undefined) parentControl.children = [];
          container = parentControl.children;
        } else {
          if (parentControl.placeholders === undefined) parentControl.placeholders = {};
          if (parentControl.placeholders[placeholderKey.value] == undefined) {
            parentControl.placeholders[placeholderKey.value] = [];
          }
          container = parentControl.placeholders[placeholderKey.value];
        }

        if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_footer')) {
          container.push(item);
        } else if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_header')) {
          container.unshift(item);
        } else {
          var afterKey = el.attributes['elementafter'];
          var afterControl;
          if (afterKey != undefined) {
            afterControl = this.findItemByKey(afterKey.value, container);
          }
          container.splice(container.indexOf(afterControl), 0, item);
        }
      } else {
        console.error("ERROR: element is not found", parentKey, item, el);
      }
    } else if (el.attributes['elementafter'] != undefined) {
      var control;
      var afterKey = el.attributes['elementafter'];
      if (afterKey != undefined) {
        control = this.findItemByKey(afterKey.value, sortedArray);
      }

      if (control != undefined) {
        sortedArray.splice(sortedArray.indexOf(control), 0, item);
      } else {
        console.error("ERROR: element is not found", afterKey, item, el);
      }
    }

    this.setData(sortedArray);
  },
  _excludeItemByKey: function _excludeItemByKey(key, data) {
    var sortedArray = [];
    for (var i = 0; i < data.length; i++) {
      if (data[i].key == key) continue;

      sortedArray.push(data[i]);

      if (data[i].children) {
        sortedArray[sortedArray.length - 1].children = this._excludeItemByKey(key, data[i].children);
      }

      if (data[i].placeholders != undefined) {
        for (var ph in data[i].placeholders) {
          if (Array.isArray(data[i].placeholders[ph])) {
            sortedArray[sortedArray.length - 1].placeholders[ph] = this._excludeItemByKey(key, data[i].placeholders[ph]);
          }
        }
      }
    }
    return sortedArray;
  },
  add: function add(item, el) {
    var res = DWKitFormControls.fillDefaultValues({
      key: this.getDefaultKey(item.key),
      "data-buildertype": item.builderType !== undefined ? item.builderType : item.key
    }, item.defaultValues);

    if (el == undefined) {
      if (_data.length > 0 && _data[_data.length - 1]["data-buildertype"] == 'form') {
        var p = _data[_data.length - 1];
        if (p.children == undefined) p.children = [];
        p.children.push(res);
      } else {
        _data.push(res);
      }
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_footer') {
      _data.push(res);
    } else if (el.attributes['name'] != undefined && el.attributes['name'].value == 'dropzone_header') {
      _data.unshift(res);
    } else if (el.attributes['elementtoinsert'] != undefined) {
      var parentControl;
      var insertIndex = 0;
      var parentKey = el.attributes['elementtoinsert'];

      if (parentKey != undefined) {
        parentControl = this.findItemByKey(parentKey.value, _data);
      }

      if (parentControl != undefined) {
        var placeholderKey = el.attributes['placeholderkey'];
        var container = undefined;

        if (placeholderKey === undefined) {
          if (parentControl.children == undefined) parentControl.children = [];
          container = parentControl.children;
        } else {
          if (parentControl.placeholders === undefined) {
            parentControl.placeholders = {};
          }
          if (parentControl.placeholders[placeholderKey.value] == undefined) {
            parentControl.placeholders[placeholderKey.value] = [];
          }
          container = parentControl.placeholders[placeholderKey.value];
        }

        if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_footer')) {
          container.push(res);
        } else if (el.attributes['name'] != undefined && el.attributes['name'].value.includes('dropzone_header')) {
          container.unshift(res);
        } else {
          var afterKey = el.attributes['elementafter'];
          var afterControl;
          if (afterKey != undefined) {
            afterControl = this.findItemByKey(afterKey.value, container);
          }
          container.splice(container.indexOf(afterControl), 0, res);
        }
      } else {
        console.error("ERROR: element is not found", parentKey, item, el);
      }
    } else if (el.attributes['elementafter'] != undefined) {
      var control;
      var afterKey = el.attributes['elementafter'];
      if (afterKey != undefined) {
        control = this.findItemByKey(afterKey.value, _data);
      }

      if (control != undefined) {
        _data.splice(_data.indexOf(control), 0, res);
      } else {
        console.error("ERROR: element is not found", afterKey, buildertype, title, el);
      }
    }

    this.trigger(_data);
  },

  remove: function remove(item) {
    this.removeItemByKey(item.key, _data);
    this.trigger(_data);
  },

  copy: function copy(item) {
    var newItem = this.copyObj(item);
    this.insertAfterKey(newItem, item.key, _data);
    this.makeUniqueKeys(newItem);
    this.trigger(_data);
  },

  getData: function getData() {
    return _data;
  },

  setData: function setData(data) {
    _data = data;
    this.trigger(_data);
  },

  _updateOrder: function _updateOrder(elements) {
    _data = elements;
    this.trigger(_data);
  },

  getDefaultKey: function getDefaultKey(name) {
    var index = 1;
    var tmp = name + '_' + index;

    var allKeys = this.getAllKeys(_data);
    for (var i = 0; i < allKeys.length; i++) {
      var item = allKeys[i];
      var tmp = name + '_' + index;
      if (item == tmp) {
        index++;
        i = -1;
      }
    }

    return tmp;
  },
  getAllKeys: function getAllKeys(items) {
    var res = [];
    if (items != undefined) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        res.push(item.key);
        if (item.children != undefined) {
          var childkeys = this.getAllKeys(item.children);
          res = res.concat(childkeys);
        } else if (item.placeholders != undefined) {
          for (var ph in item.placeholders) {
            if (Array.isArray(item.placeholders[ph])) {
              var phkeys = this.getAllKeys(item.placeholders[ph]);
              res = res.concat(phkeys);
            }
          }
        }
      }
    }

    return res;
  },
  getByKey: function getByKey(key) {
    return this.findItemByKey(key, _data);
  },
  findItemByKey: function findItemByKey(key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) return item;else if (item.children != undefined) {
        var res = this.findItemByKey(key, item.children);
        if (res != undefined) return res;
      } else if (item.placeholders != undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            var res = this.findItemByKey(key, item.placeholders[ph]);
            if (res != undefined) return res;
          }
        }
      }
    }
    return undefined;
  },
  insertAfterKey: function insertAfterKey(insertItem, key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) {
        items.splice(i + 1, 0, insertItem);
        return true;
      }

      if (item.children !== undefined) {
        if (this.insertAfterKey(insertItem, key, item.children)) {
          return true;
        }
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            if (this.insertAfterKey(insertItem, key, item.placeholders[ph])) {
              return true;
            }
          }
        }
      }
    }
    return undefined;
  },
  updateItemByKey: function updateItemByKey(key, item) {
    var data = this.getByKey(key);
    for (var i in item) {
      data[i] = item[i];
    }

    if (key != item.key) {
      this.replaceDepensKeys(key, item.key);
    }

    this.trigger(_data);
  },

  replaceDepensKeys: function replaceDepensKeys(oldKey, newKey, items) {
    if (items == undefined) items = _data;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (Array.isArray(item["events-onclick-targets"])) {
        var targets = item["events-onclick-targets"];
        for (var j = 0; j < targets.length; j++) {
          if (targets[j] == oldKey) targets[j] = newKey;
        }
      }

      if (item.children != undefined) {
        this.replaceDepensKeys(oldKey, newKey, item.children);
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            this.replaceDepensKeys(oldKey, newKey, item.placeholders[ph]);
          }
        }
      }
    }
  },
  removeItemByKey: function removeItemByKey(key, items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (item.key == key) {
        items.splice(i, 1);
        break;
      }

      if (item.children != undefined) {
        this.removeItemByKey(key, item.children);
      }

      if (item.placeholders !== undefined) {
        for (var ph in item.placeholders) {
          if (Array.isArray(item.placeholders[ph])) {
            this.removeItemByKey(key, item.placeholders[ph]);
          }
        }
      }
    }
  },
  copyObj: function copyObj(obj) {
    if (null == obj || "object" != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;
    var copy = obj.constructor();

    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) copy[attr] = this.copyObj(obj[attr]);
    }
    return copy;
  },
  makeUniqueKeys: function makeUniqueKeys(obj) {
    var me = this;
    var buildertype = obj["data-buildertype"];
    if (buildertype != undefined) {
      obj.key = this.getDefaultKey(buildertype);
    }

    if (Array.isArray(obj.children)) {
      obj.children.forEach(function (c) {
        me.makeUniqueKeys(c);
      });
    }

    if (obj.placeholders !== undefined) {
      for (var ph in obj.placeholders) {
        if (Array.isArray(obj.placeholders[ph])) {
          obj.placeholders[ph].forEach(function (c) {
            me.makeUniqueKeys(c);
          });
        }
      }
    }
  }
});

module.exports = DWKitStore;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

//
// We store our EE objects in a plain object whose properties are event names.
// If `Object.create(null)` is not supported we prefix the event names with a
// `~` to make sure that the built-in object properties are not overridden or
// used as an attack vector.
// We also assume that `Object.create(null)` is available when the event name
// is an ES6 Symbol.
//
var prefix = typeof Object.create !== 'function' ? '~' : false;

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} [once=false] Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Hold the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @param {Boolean} exists We only need to know if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events && this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} [context=this] The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Mixed} context Only remove listeners matching this context.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once && !listeners.once)
        || (context && listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i < length; i++) {
        if (
             listeners[i].fn !== fn
          || (once && !listeners[i].once)
          || (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mix = mix;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mix(def) {
    var composed = {
        init: [],
        preEmit: [],
        shouldEmit: []
    };

    var updated = function mixDef(mixin) {
        var mixed = {};
        if (mixin.mixins) {
            mixin.mixins.forEach(function (subMixin) {
                _.extend(mixed, mixDef(subMixin));
            });
        }
        _.extend(mixed, mixin);
        Object.keys(composed).forEach(function (composable) {
            if (mixin.hasOwnProperty(composable)) {
                composed[composable].push(mixin[composable]);
            }
        });
        return mixed;
    }(def);

    if (composed.init.length > 1) {
        updated.init = function () {
            var args = arguments;
            composed.init.forEach(function (init) {
                init.apply(this, args);
            }, this);
        };
    }
    if (composed.preEmit.length > 1) {
        updated.preEmit = function () {
            return composed.preEmit.reduce(function (args, preEmit) {
                var newValue = preEmit.apply(this, args);
                return newValue === undefined ? args : [newValue];
            }.bind(this), arguments);
        };
    }
    if (composed.shouldEmit.length > 1) {
        updated.shouldEmit = function () {
            var args = arguments;
            return !composed.shouldEmit.some(function (shouldEmit) {
                return !shouldEmit.apply(this, args);
            }, this);
        };
    }
    Object.keys(composed).forEach(function (composable) {
        if (composed[composable].length === 1) {
            updated[composable] = composed[composable][0];
        }
    });

    return updated;
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bindMethods = bindMethods;
function bindMethods(store, definition) {
    for (var name in definition) {
        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);

            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== "function" || !definition.hasOwnProperty(name)) {
                continue;
            }

            store[name] = definition[name].bind(store);
        } else {
            var property = definition[name];

            if (typeof property !== "function" || !definition.hasOwnProperty(name)) {
                continue;
            }

            store[name] = property.bind(store);
        }
    }

    return store;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAction = createAction;

var _utils = __webpack_require__(2);

var _ = _interopRequireWildcard(_utils);

var _ActionMethods = __webpack_require__(14);

var ActionMethods = _interopRequireWildcard(_ActionMethods);

var _PublisherMethods = __webpack_require__(10);

var PublisherMethods = _interopRequireWildcard(_PublisherMethods);

var _Keep = __webpack_require__(9);

var Keep = _interopRequireWildcard(_Keep);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var allowed = { preEmit: 1, shouldEmit: 1 };

/**
 * Creates an action functor object. It is mixed in with functions
 * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may
 * be overridden in the definition object.
 *
 * @param {Object} definition The action object definition
 */
function createAction(definition) {

    definition = definition || {};
    if (!_.isObject(definition)) {
        definition = { actionName: definition };
    }

    for (var a in ActionMethods) {
        if (!allowed[a] && PublisherMethods[a]) {
            throw new Error("Cannot override API method " + a + " in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] && PublisherMethods[d]) {
            throw new Error("Cannot override API method " + d + " in action creation. Use another method name or override it on Reflux.PublisherMethods instead.");
        }
    }

    definition.children = definition.children || [];
    if (definition.asyncResult) {
        definition.children = definition.children.concat(["completed", "failed"]);
    }

    var i = 0,
        childActions = {};
    for (; i < definition.children.length; i++) {
        var chDef = definition.children[i];
        var chName = typeof chDef === "string" ? chDef : chDef.actionName;
        childActions[chName] = createAction(chDef);
    }

    var context = _.extend({
        eventLabel: "action",
        emitter: new _.EventEmitter(),
        _isAction: true
    }, PublisherMethods, ActionMethods, definition);

    var functor = function functor() {
        var hasChildActions = false;
        /* eslint no-unused-vars:0 */
        for (var ignore in functor.childActions) {
            hasChildActions = true;break;
        }
        var async = !functor.sync && typeof functor.sync !== "undefined" || hasChildActions;
        var triggerType = async ? "triggerAsync" : "trigger";
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.addAction(functor);

    return functor;
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3),
    ListenerMixin = __webpack_require__(11),
    _ = __webpack_require__(2);

module.exports = function(listenable, key) {

    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            return _.object([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
            var me = this;

            _.extend(me, ListenerMethods);

            this.listenTo(listenable, function(v) {
                me.setState(_.object([key],[v]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3),
    ListenerMixin = __webpack_require__(11),
    _ = __webpack_require__(2);

module.exports = function(listenable, key, filterFunc) {

    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            // Filter initial payload from store.
            var result = filterFunc.call(this, listenable.getInitialState());
            if (typeof(result) !== 'undefined') {
                return _.object([key], [result]);
            } else {
                return {};
            }
        },
        componentDidMount: function() {
            var me = this;

            _.extend(this, ListenerMethods);

            this.listenTo(listenable, function(value) {
                var result = filterFunc.call(me, value);
                me.setState(_.object([key], [result]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3);

/**
 * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,
 * without having to manually set listeners in the `componentDidMount` method.
 *
 * @param {Action|Store} listenable An Action or Store that should be
 *  listened to.
 * @param {Function|String} callback The callback to register as event handler
 * @param {Function|String} defaultCallback The callback to register as default handler
 * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.
 */
module.exports = function(listenable,callback,initial){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenTo!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenTo(listenable,callback,initial);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var ListenerMethods = __webpack_require__(3);

/**
 * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,
 * without having to manually set listeners in the `componentDidMount` method. This version is used
 * to automatically set up a `listenToMany` call.
 *
 * @param {Object} listenables An object of listenables
 * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.
 */
module.exports = function(listenables){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenToMany!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenToMany(listenables);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {


/* globals React: false */

var Reflux = __webpack_require__(8);
Reflux.defineReact = __webpack_require__(37);

// useful utility for ES6 work, mimics the ability to extend
Reflux.utils.inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}
	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
};

// first try to see if there's a global React var and use it
if (typeof React !== 'undefined' && React) {
	Reflux.defineReact(React);
// otherwise we're gonna resort to 'try' stuff in case of other environments
} else {
	try {
		var R = __webpack_require__(0); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck for in node
		Reflux.defineReact(R);
	} catch (e) {}
}


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* globals React: false */

var Reflux = __webpack_require__(8);

/**
 * Reflux.defineReact function where you can manually supply
 * the React object in order to create in case Reflux needs to load before
 * React or there is a modular environment where there won't be a global
 * React variable.
 * @note The third param is for internal usage only.
 */
var _react, _defined = false;
function defineReact(react, noLongerUsed, extend)
{
	var proto, _extend;
	
	// if no Reflux object is yet available then return and just wait until defineReact is called manually with it
	try {
		_react  = react  || _react  || React;
		_extend = extend || _react.Component;
	} catch (e) {
		return;
	}
	
	// if Reflux and React aren't present then ignore, wait until they are properly present
	// also ignore if it's been called before UNLESS there's manual extending happening
	if (!_react || !_extend || (_defined && !extend)) {
		return;
	}
	
	// ----------- BEGIN Reflux.Component ------------
	/**
	 * Reflux.Component:
	 * An implementation for idiomatic React.js classes that mix with
	 * Reflux stores. To utilize extend Reflux.Component instead of
	 * React.Component. Then you may hook any Reflux store that has a
	 * `this.state` property containing its state values to the component
	 * via `this.store` or an Array of Reflux stores via `this.stores` in
	 * the component's constructor (similar to how you assign initial state
	 * in the constructor in ES6 style React). The default values of the
	 * stores will automatically reflect in the component's state, and any
	 * further `trigger` calls from that store will update properties passed
	 * in the trigger into the component automatically.
	 */
	var RefluxComponent = function(props, context, updater) {
		_extend.call(this, props, context, updater);
	};
	
	// equivalent of `extends React.Component` or other class if provided via `extend` param
	Reflux.utils.inherits(RefluxComponent, _extend);
	
	proto = RefluxComponent.prototype;
	
	/**
	 * this.storeKeys
	 * When this is a falsey value (null by default) the component mixes in
	 * all properties from the stores attached to it and updates on changes
	 * from all of them. When set to an array of string keys it will only
	 * utilized state property names of those keys in any store attached. This
	 * lets you choose which parts of stores update the component on a component-
	 * by-component basis. If using this it is best set in the constructor.
	 */
	proto.storeKeys = null;
	
	// on the mounting of the component that is where the store/stores are attached and initialized if needed
	proto.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i < ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId && Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j<jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	};
	
	// on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean
	proto.componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	};
	
	/**
	 * this.mapStoreToState
	 * This function allow you to supply map the state of a store to the
	 * state of this component manually via your own logic. This method
	 * is completely separate from this.store/this.stores and/or this.storeKeys.
	 * Call this function with an ES6 store (class or singleton instance) as the
	 * first argument and your filter function as the second. Your filter function
	 * will receive an object of the parts of the ES6 store being updated every
	 * time its setState is called. Your filter function then returns an object
	 * which will be merged with the component state (IF it has any properties at all,
	 * should you return a blank object the component will not rerender).
	 */
	proto.mapStoreToState = function(store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object 
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	};
	
	/**
	 * Reflux.Component.extend(OtherClass)
	 * This allows you to get classes that extend off of another React.Component
	 * inheriting class. For example if you're using a third party that uses
	 * components that allow `class MyComponent extends LibComponent` (where LibComponent
	 * itself extends React.Component) and you want to use that component with ES6 then
	 * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`
	 * then you can use `class MyComponent extends MyDualComponent` to get the benefits
	 * of both libraries.
	 */
	RefluxComponent.extend = function(clss) {
		return defineReact(null, null, clss);
	};
	
	// if is being manually called with an `extend` argument present then just return the created class
	if (extend) {
		return RefluxComponent;
	}
	
	// otherwise set as Reflux.Component and continue with other normal definitions
	Reflux.Component = RefluxComponent;
	
	// also set Reflux.PureComponent (if it exists) using the .extend feature
	if (_react.PureComponent) {
		Reflux.PureComponent = RefluxComponent.extend(_react.PureComponent);
	}
	
	// ------------ END Reflux.Component ------------
	
	// --------- BEGIN Reflux.Store ------------
	/**
	 * Reflux.Store:
	 * Also implements optional Reflux.Store class that is idiomatic with
	 * the React ES6 style. You extend Reflux.Store and then the rest works
	 * the same as createStore, except the constructor instead of init, and
	 * it holds state in a state property, and a .setState method is available
	 * which automatically updates state and does a trigger. Then when using
	 * with this.store or this.stores in an ES6 component just plass the class,
	 * it will deal with a singleton instantiation of the class automatically.
	 */
	var RefluxStore = function() {
		// extending doesn't really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	};
	
	proto = RefluxStore.prototype;
	
	// this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store
	// it is essentially a shortcut to the `listenToMany` method
	Object.defineProperty(proto, "listenables", {
		get: function () {
			return this.__listenables__;
		},
		set: function (v) {
			var Combined = {};
			if (Array.isArray(v)){
				v.forEach(function(obj) {
					for (var key in obj) {
						Combined[key] = obj[key];
					}
				});
			} else {
				Combined = v;
			}
			this.__listenables__ = Combined;
			this.listenToMany(Combined);
		},
		enumerable: true,
		configurable: true
	});
	
	// allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update
	// components that it is attached to in a simple way that is idiomatic with React
	proto.setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	};
	
	// this is a static property so that other code can identify that this is a Reflux.Store class
	// has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet
	Object.defineProperty(RefluxStore, "isES6Store", {
		get: function () {
			return true;
		},
		enumerable: true,
		configurable: true
	});
	
	// allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)
	Object.defineProperty(RefluxStore, "state", {
		get: function () {
			if (!this.singleton) {
				throw new Error('Reflux.Store.state is inaccessible before the store has been initialized.');
			}
			return this.singleton.state;
		},
		enumerable: true,
		configurable: true
	});
	
	/* NOTE:
	If a Reflux.Store definition is given a static id property and used
	properly within a Reflux.Component or with Reflux.initStore then
	it will be added to the Reflux.GlobalState object which automatically tracks the
	current state of all such defined stores in the program. */
	
	Reflux.Store = RefluxStore;
	// ----------- END Reflux.Store -------------
	
	// --------- BEGIN Reflux Static Props/Methods ------------
	/**
	 * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's
	 * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id "MyStore" and
	 * a state {"color":"red"} will end up with a Reflux.GlobalState of {"MyStore":{"color":"red"}}
	 * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you
	 * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component
	 * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global
	 * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will
	 * not continue to mutate as Reflux.GlobalState continues to mutate.
	 */
	Reflux.GlobalState = Reflux.GlobalState || {};
	
	/**
	 * Reflux.stores
	 * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.
	 */
	Reflux.stores = {};
	
	/**
	 * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState 
	 * which will not continue to mutate as Reflux.GlobalState does. It can essentially store
	 * snapshots of the global state as the program goes for saving or for in-app time travel.
	 */
	Reflux.getGlobalState = function() {
		return clone(Reflux.GlobalState);
	};
	
	/**
	 * Reflux.setGlobalState takes one argument that is a representation of the a possible
	 * global state. It updates all stores in the program to represent data in that given state.
	 * This includes triggering those stores so that that state is represented in any Reflux.Component
	 * instances they are attached to. Partial states may be given to it, and only the represented
	 * stores/state values will be updated.
	 */
	Reflux.setGlobalState = function(obj) {
		for (var storeID in obj) {
			if (Reflux.stores[storeID]) {
				Reflux.stores[storeID].setState(obj[storeID]);
			} else {
				Reflux.GlobalState[storeID] = obj[storeID];
			}
		}
	};
	
	/**
	 * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton
	 * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to
	 * this.store or this.stores during the mounting phase of a component without having to actually attach the
	 * store to a component in order to work properly with the global state.
	 */
	// Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is
	// now for more broad instantiation of globally stored AND non-globally stored classes
	Reflux.initializeGlobalStore = Reflux.initStore = function(str) {
		var storeId = str.id;
		// if they're initializing something twice then we're done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it's easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class's singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	};
	// --------- END Reflux Static Props/Methods ------------
	
	// so it knows not to redefine Reflux static stuff and stores if called again
	_defined = true;
}

// filters a state object by storeKeys array (if it exists)
// if filtering and obj contains no properties to use, returns false to let the component know not to update
function filterByStoreKeys(storeKeys, obj)
{
	// if there are not storeKeys defined then simply return the whole original object
	if (!storeKeys) {
		return obj;
	}
	// otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none
	var doUpdate = false;
	var updateObj = {};
	for (var i = 0, ii = storeKeys.length; i < ii; i++) {
		var prop = storeKeys[i];
		if (obj.hasOwnProperty(prop)) {
			doUpdate = true;
			updateObj[prop] = obj[prop];
		}
	}
	return doUpdate ? updateObj : false;
}

// this is utilized by some of the global state functionality in order to get a clone that will
// not continue to be modified as the GlobalState mutates
function clone(frm, to) {
	if (frm === null || typeof frm !== "object") {
		return frm;
	}
	if (frm.constructor !== Object && frm.constructor !== Array) {
		return frm;
	}
	if (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function ||
		frm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {
		return new frm.constructor(frm);
	}
	to = to || new frm.constructor();
	for (var name in frm) {
		to[name] = typeof to[name] === "undefined" ? clone(frm[name], null) : to[name];
	}
	return to;
}

module.exports = defineReact;



/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _collectioneditor = __webpack_require__(7);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _eventseditor = __webpack_require__(51);

var _eventseditor2 = _interopRequireDefault(_eventseditor);

var _radiogroup = __webpack_require__(22);

var _radiogroup2 = _interopRequireDefault(_radiogroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//------Edit Form-------------------
var BaseEditControl = function (_React$Component) {
  _inherits(BaseEditControl, _React$Component);

  function BaseEditControl(props) {
    _classCallCheck(this, BaseEditControl);

    var _this = _possibleConstructorReturn(this, (BaseEditControl.__proto__ || Object.getPrototypeOf(BaseEditControl)).call(this, props));

    _this.state = {
      activeItem: 'general'
    };

    _this.menuItems = [{ key: 'general', name: 'general', content: _this.getLocalValue('generaltab', 'General'), active: true, onClick: _this.handleItemClick.bind(_this) }, { key: 'style', name: 'style', content: _this.getLocalValue('styletab', 'Style'), active: false, onClick: _this.handleItemClick.bind(_this) }, { key: 'events', name: 'events', content: _this.getLocalValue('eventstab', 'Events'), active: false, onClick: _this.handleItemClick.bind(_this) }, { key: 'other', name: 'other', content: _this.getLocalValue('othertab', 'Other'), active: false, onClick: _this.handleItemClick.bind(_this) }];
    return _this;
  }

  _createClass(BaseEditControl, [{
    key: 'getLocalValue',
    value: function getLocalValue(key, defaultvalue, formname) {
      var local = this.props.localization;
      var block = formname != undefined ? formname : "base";

      if (local == undefined || local[block] == undefined || local[block][key] == undefined) return defaultvalue;
      return local[block][key];
    }
  }, {
    key: 'handleItemClick',
    value: function handleItemClick(e, _ref) {
      var name = _ref.name;

      this.setState({ activeItem: name });
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      var activeItem = this.state.activeItem;

      this.menuItems.forEach(function (item) {
        item.active = item.name === activeItem;
      });

      return _react2.default.createElement(
        _semanticUiReact.Modal.Description,
        null,
        _react2.default.createElement(_semanticUiReact.Menu, { key: 'descriptionMenu', pointing: true, secondary: true, items: this.menuItems }),
        this.getDetailDescription(activeItem)
      );
    }
  }, {
    key: 'getDetailDescription',
    value: function getDetailDescription(activeItem) {
      var segment;

      if (activeItem === 'general') segment = this.getGeneralDescription();else if (activeItem === 'style') segment = this.getStyleDescription();else if (activeItem === 'events') segment = this.getEventsDescription();else if (activeItem === 'other') segment = this.getOtherDescription();

      return segment;
    }
  }, {
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'generalDescriptionForm' },
        _react2.default.createElement(_semanticUiReact.Form.Input, { key: 'name', label: 'Name', name: 'key', value: data.key, onChange: handleChange })
      );
    }
  }, {
    key: 'getStyleDescription',
    value: function getStyleDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var stylesource_ps = "/*** Example Code ***/\ncolor:red;\npaddingTop:5px;";
      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'styleDescriptionForm' },
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-width', label: this.getLocalValue('widthfield', 'Width'), placeholder: '100px', value: data["style-width"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-height', label: this.getLocalValue('heightfield', 'Height'), placeholder: '100px', value: data["style-height"], onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginTop', label: this.getLocalValue('margintopfield', 'Margin Top'), placeholder: '0px', value: data["style-marginTop"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginBottom', label: this.getLocalValue('marginbottomfield', 'Margin Bottom'), placeholder: '0px', value: data["style-marginBottom"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginLeft', label: this.getLocalValue('marginleftfield', 'Margin Left'), placeholder: '0px', value: data["style-marginLeft"], onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-marginRight', label: this.getLocalValue('marginrightfield', 'Margin Right'), placeholder: '0px', value: data["style-marginRight"], onChange: handleChange })
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-customcss', label: this.getLocalValue('customcssclassfield', 'Custom CSS class'), placeholder: 'dwkit-application-css (without \'.\')', value: data["style-customcss"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'style-source', label: this.getLocalValue('stylefield', 'Style'), placeholder: stylesource_ps, value: data["style-source"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'style-hidden', label: this.getLocalValue('hiddenfield', 'Hidden'), checked: data["style-hidden"], onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return [];
    }
  }, {
    key: 'getEventsDescription',
    value: function getEventsDescription() {
      var me = this;
      var data = this.props.data;
      if (data.events == undefined) data.events = {};

      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      var actions = this.props.actions;
      var events = this.getEventsList();
      var content;
      if (!Array.isArray(events) || events.length == 0) {
        content = _react2.default.createElement(
          _semanticUiReact.Message,
          { icon: true },
          _react2.default.createElement(_semanticUiReact.Image, { src: '/images/dwkitbuilder-info.png', height: '32px' }),
          _react2.default.createElement(
            _semanticUiReact.Message.Content,
            null,
            this.getLocalValue('controlhasnoeventsmsg', 'This control has no events.')
          )
        );
      } else {
        var controlsOnForm = this.props.parent.getControlsList();
        var listControls = [];
        for (var i = 0; i < controlsOnForm.length; i++) {
          if (data.key == controlsOnForm[i]) continue;
          listControls.push({ text: controlsOnForm[i], value: controlsOnForm[i] });
        }
        content = _react2.default.createElement(_eventseditor2.default, {
          key: 'events', name: 'events',
          data: data.events,
          events: events,
          actions: actions,
          targets: listControls,
          onAdditionActions: this.handleAdditionActions.bind(this),
          onChange: handleChange });
      }
      var timeot = null;
      if (events.includes("onChange")) {
        timeot = _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'onChangeTimeout',
          style: { width: 100 },
          placeholder: "0",
          type: "number",
          label: this.getLocalValue("onchangetimeout", "onChange timeout"),
          value: data.onChangeTimeout, onChange: handleChange });
      }

      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'eventsDescriptionForm' },
        _react2.default.createElement(
          _semanticUiReact.Message,
          { icon: true },
          _react2.default.createElement(_semanticUiReact.Image, { src: '/images/dwkitbuilder-info.png', height: '32px' }),
          _react2.default.createElement(
            _semanticUiReact.Message.Content,
            null,
            this.getLocalValue('eventsinfomsg', 'These flags enable processing from this element.')
          )
        ),
        timeot,
        content
      );
    }
  }, {
    key: 'getOtherDescription',
    value: function getOtherDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var customvalidation_ps = "/*** Example Code ***/\nvalue > 10 ? true : 'Must be more 10'";
      var visibleconition_ps = "/*** Example Code ***/\ndata.type == 1 ? true : false";
      var readOnlyconition_ps = "/*** Example Code ***/\ndata.type == 1 ? true : false";

      return _react2.default.createElement(
        _semanticUiReact.Form,
        { key: 'otherDescriptionForm' },
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'other-required', label: this.getLocalValue('requiredfield', 'Required'), checked: data["other-required"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultValue', label: this.getLocalValue('defaultvaluefield', 'Default value'), value: data["defaultValue"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-customValidation', label: this.getLocalValue('customvalidationfield', 'Custom Validation'), placeholder: customvalidation_ps, value: data["other-customValidation"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-visibleConition', label: this.getLocalValue('visibleconditionfield', 'Visible condition'), placeholder: visibleconition_ps, value: data["other-visibleConition"], onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'other-readOnlyConition', label: this.getLocalValue('readonlyconditionfield', 'ReadOnly condition'), placeholder: readOnlyconition_ps, value: data["other-readOnlyConition"], onChange: handleChange })
      );
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        _semanticUiReact.Modal,
        { dimmer: 'inverted', open: this.props.open, onClose: this.props.onClose.bind(this.props.parent) },
        _react2.default.createElement(
          _semanticUiReact.Modal.Content,
          null,
          _react2.default.createElement(
            _semanticUiReact.Modal.Description,
            null,
            this.getDescription()
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Modal.Actions,
          null,
          _react2.default.createElement(
            _semanticUiReact.Button,
            { className: 'buttontype1', onClick: this.props.onSave.bind(this.props.parent) },
            this.getLocalValue('savebutton', 'Save')
          ),
          _react2.default.createElement(
            _semanticUiReact.Button,
            { className: 'buttontype2', onClick: this.props.onClose.bind(this.props.parent) },
            this.getLocalValue('cancelbutton', 'Cancel')
          )
        )
      );
    }
  }, {
    key: 'checkActionsList',
    value: function checkActionsList(value) {
      var isExists = false;

      for (var i = 0; i < this.props.actions.length; i++) {
        if (this.props.actions[i] == value) {
          isExists = true;
          break;
        }
      }

      if (!isExists) {
        this.props.actions.push({ text: value, value: value });
      }
    }
  }, {
    key: 'handleAdditionActions',
    value: function handleAdditionActions(e, _ref2) {
      var value = _ref2.value;

      this.checkActionsList(value);
      this.forceUpdate();
    }
  }]);

  return BaseEditControl;
}(_react2.default.Component);

var HeaderEditControl = function (_BaseEditControl) {
  _inherits(HeaderEditControl, _BaseEditControl);

  function HeaderEditControl(props) {
    _classCallCheck(this, HeaderEditControl);

    return _possibleConstructorReturn(this, (HeaderEditControl.__proto__ || Object.getPrototypeOf(HeaderEditControl)).call(this, props));
  }

  _createClass(HeaderEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "headerform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "header"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "headerform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('textalignfield', 'Text Align', "headerform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textalignleft', 'Left', "headerform"), value: 'left', checked: data.textAlign === 'left', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textaligncenter', 'Center', "headerform"), value: 'center', checked: data.textAlign === 'center', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'textAlign', label: this.getLocalValue('textalignright', 'Right', "headerform"), value: 'right', checked: data.textAlign === 'right', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'subheader', label: this.getLocalValue('subheaderfield', 'Subheader', "headerform"), value: data.subheader, onChange: handleChange })
      );
    }
  }]);

  return HeaderEditControl;
}(BaseEditControl);

var ButtonEditControl = function (_BaseEditControl2) {
  _inherits(ButtonEditControl, _BaseEditControl2);

  function ButtonEditControl(props) {
    _classCallCheck(this, ButtonEditControl);

    return _possibleConstructorReturn(this, (ButtonEditControl.__proto__ || Object.getPrototypeOf(ButtonEditControl)).call(this, props));
  }

  _createClass(ButtonEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizebig', 'Big'), value: 'big' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }, { text: this.getLocalValue('sizemassive', 'Massive'), value: 'massive' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "buttonform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'buttonType', label: this.getLocalValue('typenonefield', 'None', "buttonform"), value: '', checked: data.buttonType === '' || data.buttonType === undefined, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'buttonType', label: this.getLocalValue('typesubmitfield', 'Submit', "buttonform"), value: 'submit', checked: data.buttonType === 'submit', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "buttonform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "buttonform"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'basic', label: this.getLocalValue('basicfield', 'Basic', "buttonform"), checked: data.basic, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'circular', label: this.getLocalValue('circularfield', 'Circular', "buttonform"), checked: data.circular, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'compact', label: this.getLocalValue('compactfield', 'Compact', "buttonform"), checked: data.compact, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "buttonform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "buttonform"), checked: data.fluid, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "buttonform"), checked: data.inverted, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "buttonform"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'primary', label: this.getLocalValue('primaryfield', 'Primary', "buttonform"), checked: data.primary, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'secondary', label: this.getLocalValue('secondaryfield', 'Secondary', "buttonform"), checked: data.secondary, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'toggle', label: this.getLocalValue('togglefield', 'Toggle', "buttonform"), checked: data.toggle, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('floatedfield', 'Floated', "buttonform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floateddefaultfield', 'Default', "buttonform"), value: '', checked: data.floated === undefined || data.floated === '', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedleftfield', 'Left', "buttonform"), value: 'left', checked: data.floated === 'left', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedrightfield', 'Right', "buttonform"), value: 'right', checked: data.floated === 'right', onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick"];
    }
  }]);

  return ButtonEditControl;
}(BaseEditControl);

var LabelEditControl = function (_BaseEditControl3) {
  _inherits(LabelEditControl, _BaseEditControl3);

  function LabelEditControl(props) {
    _classCallCheck(this, LabelEditControl);

    return _possibleConstructorReturn(this, (LabelEditControl.__proto__ || Object.getPrototypeOf(LabelEditControl)).call(this, props));
  }

  _createClass(LabelEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      var attacheddata = [{ text: this.getLocalValue('attachednone', 'None'), value: '' }, { text: this.getLocalValue('attachedtop', 'Top'), value: 'top' }, { text: this.getLocalValue('attachedbottom', 'Bottom'), value: 'bottom' }, { text: this.getLocalValue('attachedtopright', 'Top right'), value: 'top right' }, { text: this.getLocalValue('attachedtopleft', 'Top left'), value: 'top left' }, { text: this.getLocalValue('attachedbottomleft', 'Bottom left'), value: 'bottom left' }, { text: this.getLocalValue('attachedbottomright', 'Bottom right'), value: 'bottom right' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "labelform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'attached', selection: true, fluid: true, options: attacheddata, placeholder: attacheddata[0].text, label: this.getLocalValue('attachedfield', 'Attached', "labelform"), value: data.attached, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "labelform"), value: data.content, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: 'Default', label: this.getLocalValue('sizefield', 'Size', "labelform"), value: data.size, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "labelform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'basic', label: this.getLocalValue('basicfield', 'Basic', "labelform"), checked: data.basic, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'circular', label: this.getLocalValue('circularfield', 'Circular', "labelform"), checked: data.circular, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'corner', label: this.getLocalValue('cornerfield', 'Corner', "labelform"), checked: data.corner, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floating', label: this.getLocalValue('floatingfield', 'Floating', "labelform"), checked: data.floating, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'horizontal', label: this.getLocalValue('horizontalfield', 'Horizontal', "labelform"), checked: data.horizontal, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'pointing', label: this.getLocalValue('pointingfield', 'Pointing', "labelform"), checked: data.pointing, onChange: handleChange })
            )
          )
        )
      );
    }
  }]);

  return LabelEditControl;
}(BaseEditControl);

var StaticContentEditControl = function (_BaseEditControl4) {
  _inherits(StaticContentEditControl, _BaseEditControl4);

  function StaticContentEditControl(props) {
    _classCallCheck(this, StaticContentEditControl);

    return _possibleConstructorReturn(this, (StaticContentEditControl.__proto__ || Object.getPrototypeOf(StaticContentEditControl)).call(this, props));
  }

  _createClass(StaticContentEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "staticcontentform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'style-font-size', placeholder: '20px', label: this.getLocalValue('fontsizefield', 'Font size', "staticcontentform"), value: data["style-font-size"], onChange: handleChange })
        ),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'isHtml', label: this.getLocalValue('allowhtmlfield', 'Allow HTML', "staticcontentform"), checked: data.isHtml, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.TextArea, { rows: 6, autoHeight: true, name: 'content', label: this.getLocalValue('contentfield', 'Content', "staticcontentform"), value: data.content, onChange: handleChange })
      );
    }
  }]);

  return StaticContentEditControl;
}(BaseEditControl);

var MessageEditControl = function (_BaseEditControl5) {
  _inherits(MessageEditControl, _BaseEditControl5);

  function MessageEditControl(props) {
    _classCallCheck(this, MessageEditControl);

    return _possibleConstructorReturn(this, (MessageEditControl.__proto__ || Object.getPrototypeOf(MessageEditControl)).call(this, props));
  }

  _createClass(MessageEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "messageform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'header', label: this.getLocalValue('headerfield', 'Header', "messageform"), value: data.header, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "messageform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'compact', label: this.getLocalValue('compactfield', 'Compact', "messageform"), checked: data.compact, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "messageform"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floating', label: this.getLocalValue('floatingfield', 'Floating', "messageform"), checked: data.floating, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'info', label: this.getLocalValue('infofield', 'Info', "messageform"), checked: data.info, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'negative', label: this.getLocalValue('negativefield', 'Negative', "messageform"), checked: data.negative, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'positive', label: this.getLocalValue('positivefield', 'Positive', "messageform"), checked: data.positive, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'success', label: this.getLocalValue('successfield', 'Success', "messageform"), checked: data.success, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'warning', label: this.getLocalValue('warningfield', 'Warning', "messageform"), checked: data.warning, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { name: 'content', label: this.getLocalValue('contentfield', 'Content', "messageform"), value: data.content, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "messageform"), value: data.size, onChange: handleChange })
        )
      );
    }
  }]);

  return MessageEditControl;
}(BaseEditControl);

var InputEditControl = function (_BaseEditControl6) {
  _inherits(InputEditControl, _BaseEditControl6);

  function InputEditControl(props) {
    _classCallCheck(this, InputEditControl);

    return _possibleConstructorReturn(this, (InputEditControl.__proto__ || Object.getPrototypeOf(InputEditControl)).call(this, props));
  }

  _createClass(InputEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }, { text: this.getLocalValue('sizemassive', 'Massive'), value: 'massive' }];

      var labelPositions = [{ text: this.getLocalValue('labeldefault', 'Default'), value: '' }, { text: this.getLocalValue('labelleft', 'Left'), value: 'left' }, { text: this.getLocalValue('labelright', 'Right'), value: 'right' }, { text: this.getLocalValue('labelleftcorner', 'Left corner'), value: 'left corner' }, { text: this.getLocalValue('labelrightcorner', 'Right corner'), value: 'right corner' }];

      var disableDateFormat = data.type !== "date" && data.type !== "datetime" && data.type !== "time";

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "inputform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "inputform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "inputform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typetext', 'Text', "inputform"), value: 'text', checked: data.type == undefined || data.type == 'text', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typenumber', 'Number', "inputform"), value: 'number', checked: data.type === 'number', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typepasswod', 'Password', "inputform"), value: 'password', checked: data.type === 'password', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typefile', 'File', "inputform"), value: 'file', checked: data.type === 'file', onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typedate', 'Date', "inputform"), value: 'date', checked: data.type === 'date', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typetime', 'Time', "inputform"), value: 'time', checked: data.type === 'time', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'type', label: this.getLocalValue('typedatetime', 'Date & Time', "inputform"), value: 'datetime', checked: data.type === 'datetime', onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'labelPosition', selection: true, fluid: true, placeholder: labelPositions[0].text, options: labelPositions, label: this.getLocalValue('labelpositionfield', 'Label position', "inputform"), value: data.labelPosition, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "inputform"), value: data.placeholder, onChange: handleChange })
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "inputform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "inputform"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "inputform"), checked: data.inverted, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "inputform"), checked: data.error, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "inputform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'transparent', label: this.getLocalValue('transparentfield', 'Transparent', "inputform"), checked: data.transparent, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "inputform"), checked: data.fluid, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "inputform"), checked: data.readOnly, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "inputform"), value: data.size, onChange: handleChange })
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return InputEditControl;
}(BaseEditControl);

var TextAreaEditControl = function (_BaseEditControl7) {
  _inherits(TextAreaEditControl, _BaseEditControl7);

  function TextAreaEditControl(props) {
    _classCallCheck(this, TextAreaEditControl);

    return _possibleConstructorReturn(this, (TextAreaEditControl.__proto__ || Object.getPrototypeOf(TextAreaEditControl)).call(this, props));
  }

  _createClass(TextAreaEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "textareaform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "textareaform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rows', placeholder: '3', type: 'number', label: this.getLocalValue('rowsfield', 'Rows', "textareaform"), value: data.rows, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "textareaform"), value: data.placeholder, onChange: handleChange }),
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('placeholderfield', 'Options', "textareaform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoHeight', label: this.getLocalValue('autoheightfield', 'Auto height', "textareaform"), checked: data.autoHeight, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "textareaform"), checked: data.readOnly, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return TextAreaEditControl;
}(BaseEditControl);

var SearchEditControl = function (_BaseEditControl8) {
  _inherits(SearchEditControl, _BaseEditControl8);

  function SearchEditControl(props) {
    _classCallCheck(this, SearchEditControl);

    return _possibleConstructorReturn(this, (SearchEditControl.__proto__ || Object.getPrototypeOf(SearchEditControl)).call(this, props));
  }

  _createClass(SearchEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "searchform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'url', label: this.getLocalValue('urlfield', 'Url', "searchform"), value: data.url, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'category', label: this.getLocalValue('categoryfield', 'Enable Categories', "searchform"), checked: Boolean(data.category), onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onSelect"];
    }
  }]);

  return SearchEditControl;
}(BaseEditControl);

var CheckboxEditControl = function (_BaseEditControl9) {
  _inherits(CheckboxEditControl, _BaseEditControl9);

  function CheckboxEditControl(props) {
    _classCallCheck(this, CheckboxEditControl);

    return _possibleConstructorReturn(this, (CheckboxEditControl.__proto__ || Object.getPrototypeOf(CheckboxEditControl)).call(this, props));
  }

  _createClass(CheckboxEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "checkboxform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "checkboxform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "checkboxform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fitted', label: this.getLocalValue('fittedfield', 'Fitted', "checkboxform"), checked: data.fitted, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'indeterminate', label: this.getLocalValue('indeterminatefield', 'Indeterminate', "checkboxform"), checked: data.indeterminate, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'ReadOnly', "checkboxform"), checked: data.readOnly, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "checkboxform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'slider', label: this.getLocalValue('sliderfield', 'Slider', "checkboxform"), checked: data.slider, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'toggle', label: this.getLocalValue('togglefield', 'Toggle', "checkboxform"), checked: data.toggle, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return CheckboxEditControl;
}(BaseEditControl);

var DropdownEditControl = function (_BaseEditControl10) {
  _inherits(DropdownEditControl, _BaseEditControl10);

  function DropdownEditControl(props) {
    _classCallCheck(this, DropdownEditControl);

    return _possibleConstructorReturn(this, (DropdownEditControl.__proto__ || Object.getPrototypeOf(DropdownEditControl)).call(this, props));
  }

  _createClass(DropdownEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var labelPositions = [{ text: this.getLocalValue('labeldefault', 'Default'), value: '' }, { text: this.getLocalValue('labelleft', 'Left'), value: 'left' }, { text: this.getLocalValue('labelright', 'Right'), value: 'right' }, { text: this.getLocalValue('labelleftcorner', 'Left corner'), value: 'left corner' }, { text: this.getLocalValue('labelrightcorner', 'Right corner'), value: 'right corner' }];

      var dataColumns = [{ key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "dropdownform") }, { key: 'text', name: this.getLocalValue('datatextcolumn', 'Text', "dropdownform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dropdownform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "dropdownform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            draggable: true,
            columns: dataColumns,
            label: this.getLocalValue('datafield', 'Data', "dropdownform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: 'Placeholder', value: data.placeholder, onChange: handleChange }),
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('optionsfield', 'Options', "dropdownform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "dropdownform"), checked: data.loading, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "dropdownform"), checked: data.error, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "dropdownform"), checked: data.disabled, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "dropdownform"), checked: data.fluid, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiple', label: this.getLocalValue('multiplefield', 'Multiple', "dropdownform"), checked: data.multiple, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'search', label: this.getLocalValue('searchfield', 'Search', "dropdownform"), checked: data.search, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'selection', label: this.getLocalValue('selectionfield', 'Selection', "dropdownform"), checked: data.selection, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "dropdownform"), checked: data.readOnly, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'allowAddItems', label: this.getLocalValue('allowAddItemsfield', 'Allow add items', "dropdownform"), disabled: !(data.search && data.multiple), checked: data.allowAddItems, onChange: handleChange })
              )
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return DropdownEditControl;
}(BaseEditControl);

var DictionaryEditControl = function (_BaseEditControl11) {
  _inherits(DictionaryEditControl, _BaseEditControl11);

  function DictionaryEditControl(props) {
    _classCallCheck(this, DictionaryEditControl);

    return _possibleConstructorReturn(this, (DictionaryEditControl.__proto__ || Object.getPrototypeOf(DictionaryEditControl)).call(this, props));
  }

  _createClass(DictionaryEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dictionaryform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "dictionaryform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'dataModel', label: this.getLocalValue('datamodelfield', 'Data model', "dictionaryform"), value: data.dataModel, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'placeholder', label: this.getLocalValue('placeholderfield', 'Placeholder', "dictionaryform"), value: data.placeholder, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'columns', label: this.getLocalValue('columnsfield', 'Columns (Name ASC, Email)', "dictionaryform"), value: data.columns, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'pageSize', label: this.getLocalValue('pagesizefield', 'Page Size', "dictionaryform"), disabled: !Boolean(data.paging), value: data.pageSize, placeholder: '100', onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "dictionaryform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'paging', label: this.getLocalValue('pagingfield', 'Server pagination', "dictionaryform"), checked: data.paging, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'search', label: this.getLocalValue('searchfield', 'Search', "dictionaryform"), checked: data.search, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiple', label: this.getLocalValue('multiplefield', 'Multiple', "dictionaryform"), checked: data.multiple, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "dictionaryform"), checked: data.readOnly, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "dictionaryform"), checked: data.disabled, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'clearable', label: this.getLocalValue('clearablefield', 'Clearable', "dictionaryform"), checked: data.clearable, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'selection', label: this.getLocalValue('selectionfield', 'Selection', "dictionaryform"), checked: data.selection, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "dictionaryform"), checked: data.fluid, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "dictionaryform"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "dictionaryform"), checked: data.loading, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onChange"];
    }
  }]);

  return DictionaryEditControl;
}(BaseEditControl);

var RadioGroupEditControl = function (_BaseEditControl12) {
  _inherits(RadioGroupEditControl, _BaseEditControl12);

  function RadioGroupEditControl(props) {
    _classCallCheck(this, RadioGroupEditControl);

    return _possibleConstructorReturn(this, (RadioGroupEditControl.__proto__ || Object.getPrototypeOf(RadioGroupEditControl)).call(this, props));
  }

  _createClass(RadioGroupEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var dataColumns = [{ key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "radiogroupform") }, { key: 'text', name: this.getLocalValue('datatextcolumn', 'Text', "radiogroupform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "radiogroupform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'label', label: this.getLocalValue('labelfield', 'Label', "radiogroupform"), value: data.label, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            draggable: true,
            columns: dataColumns,
            label: this.getLocalValue('datafield', 'Data', "radiogroupform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('groupdirectfield', 'Group direct', "radiogroupform")
            ),
            _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'direction', label: this.getLocalValue('directiongorizontalfield', 'Gorizontal', "radiogroupform"), value: 'g', checked: data.direction === undefined || data.direction === 'g', onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'direction', label: this.getLocalValue('directionverticalfield', 'Vertical', "radiogroupform"), value: 'v', checked: data.direction === 'v', onChange: handleChange }),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'Read only', "radiogroupform"), checked: data.readOnly, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onClick", "onChange"];
    }
  }]);

  return RadioGroupEditControl;
}(BaseEditControl);

var FormEditControl = function (_BaseEditControl13) {
  _inherits(FormEditControl, _BaseEditControl13);

  function FormEditControl(props) {
    _classCallCheck(this, FormEditControl);

    return _possibleConstructorReturn(this, (FormEditControl.__proto__ || Object.getPrototypeOf(FormEditControl)).call(this, props));
  }

  _createClass(FormEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "form"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "form"), value: data.size, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "form")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'loading', label: this.getLocalValue('loadingfield', 'Loading', "form"), checked: data.loading, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'error', label: this.getLocalValue('errorfield', 'Error', "form"), checked: data.error, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inverted', label: this.getLocalValue('invertedfield', 'Inverted', "form"), checked: data.inverted, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'reply', label: this.getLocalValue('replyfield', 'Reply', "form"), checked: data.reply, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'success', label: this.getLocalValue('successfield', 'Success', "form"), checked: data.success, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'warning', label: this.getLocalValue('warningfield', 'Warning', "form"), checked: data.warning, onChange: handleChange })
            )
          )
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onSubmit"];
    }
  }]);

  return FormEditControl;
}(BaseEditControl);

var FormGroupEditControl = function (_BaseEditControl14) {
  _inherits(FormGroupEditControl, _BaseEditControl14);

  function FormGroupEditControl(props) {
    _classCallCheck(this, FormGroupEditControl);

    return _possibleConstructorReturn(this, (FormGroupEditControl.__proto__ || Object.getPrototypeOf(FormGroupEditControl)).call(this, props));
  }

  _createClass(FormGroupEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "formgroupform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('widthsfield', 'Widths', "formgroupform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthsdefaultfield', 'Default', "formgroupform"), checked: data.widths === undefined, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthsequalfield', 'Equal', "formgroupform"), value: 'equal', checked: data.widths === 'equal', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'widths', label: this.getLocalValue('widthscustomfield', 'Custom (1 - 16)', "formgroupform"), value: 'custom', checked: data.widths === 'custom', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: '2' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('typefield', 'Type', "formgroupform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { inline: true },
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'orientation', label: this.getLocalValue('orientationcolumnsfield', 'Columns', "formgroupform"), value: 'inline', checked: data.orientation === undefined || data.orientation === 'inline', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'orientation', label: this.getLocalValue('orientationrowsfield', 'Rows', "formgroupform"), value: 'grouped', checked: data.orientation === "grouped", onChange: handleChange })
            )
          ),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'widthsCustom', disabled: data.widths !== 'custom', placeholder: '2', value: data.widthsCustom, onChange: handleChange })
        )
      );
    }
  }]);

  return FormGroupEditControl;
}(BaseEditControl);

var ContainerEditControl = function (_BaseEditControl15) {
  _inherits(ContainerEditControl, _BaseEditControl15);

  function ContainerEditControl(props) {
    _classCallCheck(this, ContainerEditControl);

    return _possibleConstructorReturn(this, (ContainerEditControl.__proto__ || Object.getPrototypeOf(ContainerEditControl)).call(this, props));
  }

  _createClass(ContainerEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var floatdata = [{ text: this.getLocalValue('floatnonefield', 'None', "containerform"), value: '' }, { text: this.getLocalValue('floatleftfield', 'Left', "containerform"), value: 'left' }, { text: this.getLocalValue('floatrightfield', 'Right', "containerform"), value: 'right' }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "containerform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'style-float', selection: true, fluid: true, options: floatdata, placeholder: floatdata[0].text, label: this.getLocalValue('floatfield', 'Float', "containerform"), value: data["style-float"], onChange: handleChange })
        )
      );
    }
  }]);

  return ContainerEditControl;
}(BaseEditControl);

var ImageEditControl = function (_BaseEditControl16) {
  _inherits(ImageEditControl, _BaseEditControl16);

  function ImageEditControl(props) {
    _classCallCheck(this, ImageEditControl);

    return _possibleConstructorReturn(this, (ImageEditControl.__proto__ || Object.getPrototypeOf(ImageEditControl)).call(this, props));
  }

  _createClass(ImageEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "imageform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'src', label: this.getLocalValue('srcfield', 'Src', "imageform"), value: data.src, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'href', label: this.getLocalValue('hreffield', 'Href', "imageform"), value: data.href, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('optionsfield', 'Options', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'avatar', label: this.getLocalValue('avatarfield', 'Avatar', "imageform"), checked: data.avatar, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'bordered', label: this.getLocalValue('borderedfield', 'Bordered', "imageform"), checked: data.bordered, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'centered', label: this.getLocalValue('centeredfield', 'Centered', "imageform"), checked: data.centered, onChange: handleChange })
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disabled', label: this.getLocalValue('disabledfield', 'Disabled', "imageform"), checked: data.disabled, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'inline', label: this.getLocalValue('inlinefield', 'Inline', "imageform"), checked: data.inline, onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'spaced', label: this.getLocalValue('spacedfield', 'Spaced', "imageform"), checked: data.spaced, onChange: handleChange })
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'field' },
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('floatedfield', 'Floated', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedleftfield', 'Left', "imageform"), value: 'left', checked: data.floated === 'left' || data.floated === '', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'floated', label: this.getLocalValue('floatedrightfield', 'Right', "imageform"), value: 'right', checked: data.floated === 'right', onChange: handleChange })
              ),
              _react2.default.createElement(
                'label',
                null,
                this.getLocalValue('verticalalignfield', 'Vertical align', "imageform")
              ),
              _react2.default.createElement(
                _semanticUiReact.Form.Group,
                null,
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalaligntopfield', 'Top', "imageform"), value: 'top', checked: data.verticalAlign === 'top', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalalignmiddlefield', 'Middle', "imageform"), value: 'middle', checked: data.verticalAlign === 'middle', onChange: handleChange }),
                _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'verticalAlign', label: this.getLocalValue('verticalalignbottomfield', 'Bottom', "imageform"), value: 'bottom', checked: data.verticalAlign === 'bottom', onChange: handleChange })
              )
            )
          )
        )
      );
    }
  }]);

  return ImageEditControl;
}(BaseEditControl);

var StatisticEditControl = function (_BaseEditControl17) {
  _inherits(StatisticEditControl, _BaseEditControl17);

  function StatisticEditControl(props) {
    _classCallCheck(this, StatisticEditControl);

    return _possibleConstructorReturn(this, (StatisticEditControl.__proto__ || Object.getPrototypeOf(StatisticEditControl)).call(this, props));
  }

  _createClass(StatisticEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var sizedata = [{ text: this.getLocalValue('sizedefault', 'Default'), value: '' }, { text: this.getLocalValue('sizemini', 'Mini'), value: 'mini' }, { text: this.getLocalValue('sizetiny', 'Tiny'), value: 'tiny' }, { text: this.getLocalValue('sizesmall', 'Small'), value: 'small' }, { text: this.getLocalValue('sizemedium', 'Medium'), value: 'medium' }, { text: this.getLocalValue('sizelarge', 'Large'), value: 'large' }, { text: this.getLocalValue('sizehuge', 'Huge'), value: 'huge' }];

      var datacolumns = [{ key: 'label', name: this.getLocalValue('datakeycolumn', 'Label', "statisticform") }, { key: 'value', name: this.getLocalValue('datavaluecolumn', 'Value', "statisticform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "statisticform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "statisticform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'floated', label: this.getLocalValue('floatedfield', 'Floated', "statisticform"), checked: data.floated, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'horizontal', label: this.getLocalValue('horizontalfield', 'Horizontal', "statisticform"), checked: data.horizontal, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'data-elements',
            columns: datacolumns,
            label: this.getLocalValue('datafield', 'Data', "statisticform"),
            name: 'data-elements',
            value: data["data-elements"],
            onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'size', selection: true, fluid: true, options: sizedata, placeholder: sizedata[0].text, label: this.getLocalValue('sizefield', 'Size', "statisticform"), value: data.size, onChange: handleChange })
        )
      );
    }
  }]);

  return StatisticEditControl;
}(BaseEditControl);

var GridEditControl = function (_BaseEditControl18) {
  _inherits(GridEditControl, _BaseEditControl18);

  function GridEditControl(props) {
    _classCallCheck(this, GridEditControl);

    return _possibleConstructorReturn(this, (GridEditControl.__proto__ || Object.getPrototypeOf(GridEditControl)).call(this, props));
  }

  _createClass(GridEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var pagertype = [{ value: "", text: this.getLocalValue('pagertypenonefield', 'None', "gridform") }, { value: "server", text: this.getLocalValue('pagertypeserverfield', 'Server', "gridform") }];

      var editformtype = [{ value: "", text: this.getLocalValue('editformtypedefaultfield', 'Default', "gridform") }];

      var columns = [{ key: 'key', name: this.getLocalValue('keycolumn', 'Key', "gridform") }, { key: 'name', name: this.getLocalValue('namecolumn', 'Name', "gridform") }, { key: 'type', name: this.getLocalValue('typecolumn', 'Type', "gridform"), dataList: ["", "number", "checkbox", "date", "datetime", "time", "custom"] }, { key: 'width', name: this.getLocalValue('widthcolumn', 'Width', "gridform"), control: 'number' }, { key: 'resizable', name: this.getLocalValue('resizablecolumn', 'Resizable', "gridform"), control: "checkbox" }];

      var editTypeItems = [{ key: "form", text: "Form", value: undefined }, { key: "flow", text: "Flow", value: "flow" }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "gridform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "gridform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'multiselect', label: this.getLocalValue('multiselectfield', 'Multiselect', "gridform"), checked: data.multiselect, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disableSort', label: this.getLocalValue('disablesortfield', 'Disable sorting', "gridform"), checked: data.disableSort, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_radiogroup2.default, {
                name: 'editType',
                label: this.getLocalValue('edittypefield', 'Edit type', "gridform"),
                items: editTypeItems,
                value: data.editType,
                onChange: handleChange }),
              data.editType != "flow" && _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'editForm', label: this.getLocalValue('editformfield', 'Edit form', "gridform"), disabled: data.inline == true, value: data.editForm, onChange: handleChange }),
              data.editType == "flow" && _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'editFlow', label: this.getLocalValue('editflowfield', 'Edit flow', "gridform"), disabled: data.inline == true, value: data.editFlow, onChange: handleChange })
            ),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rowKey', label: this.getLocalValue('rowkeyfield', 'Row key', "gridform"), value: data.rowKey, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'pageSize', label: this.getLocalValue('pagesizefield', 'Page size', "gridform"), value: data.pageSize, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultSort', label: this.getLocalValue('defaultsortfield', 'Default sort', "gridform"), placeholder: 'Name ASC', value: data.defaultSort, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'editFormShowType', selection: true, fluid: true, label: this.getLocalValue('editformshowtypefield', 'Edit form show type', "gridform"), placeholder: editformtype[0].text, options: editformtype, value: data.editFormShowType, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'pagerType', selection: true, fluid: true, label: this.getLocalValue('pagertypefield', 'Pagination type', "gridform"), placeholder: 'None', options: pagertype, value: data.pagerType, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'rowHeight', label: this.getLocalValue('rowheightfield', 'Row height', "gridform"), value: data.rowHeight, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'minHeight', label: this.getLocalValue('minheightfield', 'Min height', "gridform"), value: data.minHeight, onChange: handleChange }),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              { widths: 'equal' },
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoHeight', label: this.getLocalValue('autoheightfield', 'Auto Height', "gridform"), checked: Boolean(data.autoHeight), onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'offSet', label: this.getLocalValue('offsetfield', 'OffSet', "gridform"), disabled: !Boolean(data.autoHeight), value: data.offSet, onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'field' },
          _react2.default.createElement(_collectioneditor2.default, { key: 'columns',
            draggable: true,
            columns: columns,
            label: this.getLocalValue('columnsfield', 'Columns', "gridform"),
            name: 'columns',
            value: data["columns"],
            onChange: handleChange })
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onRowClick", "onRowDblClick", "onSelectionChanged"];
    }
  }]);

  return GridEditControl;
}(BaseEditControl);

var CollectionEditorEditControl = function (_BaseEditControl19) {
  _inherits(CollectionEditorEditControl, _BaseEditControl19);

  function CollectionEditorEditControl(props) {
    _classCallCheck(this, CollectionEditorEditControl);

    return _possibleConstructorReturn(this, (CollectionEditorEditControl.__proto__ || Object.getPrototypeOf(CollectionEditorEditControl)).call(this, props));
  }

  _createClass(CollectionEditorEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var me = this;
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'key', name: this.getLocalValue('keycolumn', 'Key', "collectioneditorform") }, { key: 'name', name: this.getLocalValue('namecolumn', 'Name', "collectioneditorform") }, { key: 'control', name: this.getLocalValue('controlcolumn', 'Control', "collectioneditorform"), dataList: ["input", "checkbox", "span", "number", "file", "date", "datetime", "custom"] }, { key: 'width', name: this.getLocalValue('widthcolumn', 'Width', "collectioneditorform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "collectioneditorform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'idField', label: this.getLocalValue('idfield', 'Id field', "collectioneditorform"), disabled: data.hierarchical != true, value: data.idField, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('optionsfield', 'Options', "collectioneditorform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'readOnly', label: this.getLocalValue('readonlyfield', 'ReadOnly', "collectioneditorform"), checked: data.readOnly, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'draggable', label: this.getLocalValue('draggablefield', 'Draggable', "collectioneditorform"), checked: data.draggable, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'hierarchical', label: this.getLocalValue('hierarchicalfield', 'Hierarchical', "collectioneditorform"), checked: data.hierarchical, onChange: handleChange })
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'disableAdd', label: this.getLocalValue('disableAdd', 'Disable Add', "collectioneditorform"), checked: data.disableAdd, onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'collapseAll', label: this.getLocalValue('collapseallfield', 'Collapse all', "collectioneditorform"), disabled: data.hierarchical != true, checked: data.collapseAll, onChange: handleChange })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'parentIdField', label: this.getLocalValue('parentidfield', 'ParentId field', "collectioneditorform"), disabled: data.hierarchical != true, value: data.parentIdField, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'childrenField', label: this.getLocalValue('childrenField', 'Children field', "collectioneditorform"), disabled: data.hierarchical != true || data.parentIdField !== undefined && data.parentIdField !== "", value: data.childrenField, onChange: handleChange })
          )
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'columns',
          columns: columns,
          label: this.getLocalValue('columnsfield', 'Columns', "collectioneditorform"),
          name: 'columns',
          value: data["columns"],
          height: '200px',
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onChange", "onAdd", "onDelete"];
    }
  }]);

  return CollectionEditorEditControl;
}(BaseEditControl);

var CustomEditControl = function (_BaseEditControl20) {
  _inherits(CustomEditControl, _BaseEditControl20);

  function CustomEditControl(props) {
    _classCallCheck(this, CustomEditControl);

    return _possibleConstructorReturn(this, (CustomEditControl.__proto__ || Object.getPrototypeOf(CustomEditControl)).call(this, props));
  }

  _createClass(CustomEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "customform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'type', label: this.getLocalValue('typefield', 'Type control', "customform"), value: data.type, onChange: handleChange })
        ),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'props', label: this.getLocalValue('propsfield', 'Props', "customform"), name: 'props',
            value: data["props"],
            onChange: handleChange,
            rows: 5 }),
          _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'children', label: this.getLocalValue('childrenfield', 'Children', "customform"), name: 'children',
            value: data["children"],
            onChange: handleChange,
            rows: 5 })
        )
      );
    }
  }]);

  return CustomEditControl;
}(BaseEditControl);

var CustomBlockEditControl = function (_BaseEditControl21) {
  _inherits(CustomBlockEditControl, _BaseEditControl21);

  function CustomBlockEditControl(props) {
    _classCallCheck(this, CustomBlockEditControl);

    return _possibleConstructorReturn(this, (CustomBlockEditControl.__proto__ || Object.getPrototypeOf(CustomBlockEditControl)).call(this, props));
  }

  _createClass(CustomBlockEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "customblockform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(
              'label',
              null,
              this.getLocalValue('sourcetypefield', 'Source type', "customblockform")
            ),
            _react2.default.createElement(
              _semanticUiReact.Form.Group,
              null,
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('sourcetypeformfield', 'Form name', "customblockform"), value: 'form', checked: data.sourceType === undefined || data.sourceType == 'form', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('sourcetypejsonfield', 'JSON source', "customblockform"), value: 'source', checked: data.sourceType === 'source', onChange: handleChange }),
              _react2.default.createElement(_semanticUiReact.Form.Radio, { name: 'sourceType', label: this.getLocalValue('placeholderfield', 'Placeholder', "customblockform"), value: 'placeholder', checked: data.sourceType === 'placeholder', onChange: handleChange })
            )
          )
        ),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'formname', label: this.getLocalValue('formnamefield', 'Form name', "customblockform"), value: data.formname, onChange: handleChange,
          disabled: data.sourceType != undefined && data.sourceType != 'form' }),
        _react2.default.createElement(_semanticUiReact.Form.TextArea, { key: 'source', label: this.getLocalValue('sourcefield', 'JSON source', "customblockform"), name: 'source',
          value: data["source"], onChange: handleChange, rows: 10,
          disabled: data.sourceType != 'source' })
      );
    }
  }]);

  return CustomBlockEditControl;
}(BaseEditControl);

var MenuEditControl = function (_BaseEditControl22) {
  _inherits(MenuEditControl, _BaseEditControl22);

  function MenuEditControl(props) {
    _classCallCheck(this, MenuEditControl);

    return _possibleConstructorReturn(this, (MenuEditControl.__proto__ || Object.getPrototypeOf(MenuEditControl)).call(this, props));
  }

  _createClass(MenuEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'target', name: this.getLocalValue('itemstargetcolumn', 'Target', "menuform"), width: 150 }, { key: 'title', name: this.getLocalValue('itemstitlecolumn', 'Title', "menuform") }, { key: 'visibleCondition', name: this.getLocalValue('visibleConditioncolumn', 'Visible Condition', "menuform") }];
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "menuform"), value: data.key, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'activeItem', label: this.getLocalValue('activeitemfield', 'Active Item', "menuform"), value: data.activeItem, onChange: handleChange })
        ),
        _react2.default.createElement(
          'div',
          { className: 'field' },
          _react2.default.createElement(
            'label',
            null,
            this.getLocalValue('optionsfield', 'Options', "menuform")
          ),
          _react2.default.createElement(
            _semanticUiReact.Form.Group,
            null,
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'pointing', label: this.getLocalValue('pointingfield', 'Pointing', "menuform"), checked: data.pointing, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'secondary', label: this.getLocalValue('secondaryfield', 'Secondary', "menuform"), checked: data.secondary, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'tabular', label: this.getLocalValue('tabularfield', 'Tabular', "menuform"), checked: data.tabular, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'fluid', label: this.getLocalValue('fluidfield', 'Fluid', "menuform"), checked: data.fluid, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'vertical', label: this.getLocalValue('verticalfield', 'Vertical', "menuform"), checked: data.vertical, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'link', label: this.getLocalValue('linkfield', 'Link', "menuform"), checked: data.link, onChange: handleChange })
          )
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          hierarchical: true,
          childrenField: 'children',
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "menuform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return MenuEditControl;
}(BaseEditControl);

var BreadcrumbEditControl = function (_BaseEditControl23) {
  _inherits(BreadcrumbEditControl, _BaseEditControl23);

  function BreadcrumbEditControl(props) {
    _classCallCheck(this, BreadcrumbEditControl);

    return _possibleConstructorReturn(this, (BreadcrumbEditControl.__proto__ || Object.getPrototypeOf(BreadcrumbEditControl)).call(this, props));
  }

  _createClass(BreadcrumbEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'text', name: this.getLocalValue('itemstextcolumn', 'Text', "breadcrumbform") }, { key: 'url', name: this.getLocalValue('itemsurlcolumn', 'Url', "breadcrumbform") }, { key: 'active', control: 'checkbox', name: this.getLocalValue('itemsactivecolumn', 'Active', "breadcrumbform") }, { key: 'divider', name: this.getLocalValue('itemsiconcolumn', 'Divider Icon', "breadcrumbform"), dataList: ["right angle", "right chevron"] }];
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "breadcrumbform"), value: data.key, onChange: handleChange })
        ),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "breadcrumbform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return BreadcrumbEditControl;
}(BaseEditControl);

var DropdownTriggerEditControl = function (_BaseEditControl24) {
  _inherits(DropdownTriggerEditControl, _BaseEditControl24);

  function DropdownTriggerEditControl(props) {
    _classCallCheck(this, DropdownTriggerEditControl);

    return _possibleConstructorReturn(this, (DropdownTriggerEditControl.__proto__ || Object.getPrototypeOf(DropdownTriggerEditControl)).call(this, props));
  }

  _createClass(DropdownTriggerEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      var columns = [{ key: 'target', name: this.getLocalValue('itemstargetcolumn', 'Target', "dropdowntriggerform") }, { key: 'title', name: this.getLocalValue('itemstitlecolumn', 'Title', "dropdowntriggerform") }, { key: 'visibleCondition', name: this.getLocalValue('itemsvisibleconditioncolumn', 'Visible Condition', "dropdowntriggerform") }];

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "dropdowntriggerform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'defaultValue', label: this.getLocalValue('defaultvaluefield', 'Default Value', "dropdowntriggerform"), value: data.defaultValue == undefined ? "" : data.defaultValue, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'imageUrl', label: this.getLocalValue('imageurlfield', 'ImageUrl', "dropdowntriggerform"), value: data.imageUrl == undefined ? "" : data.imageUrl, onChange: handleChange }),
        _react2.default.createElement(_collectioneditor2.default, { key: 'items',
          draggable: true,
          columns: columns,
          label: this.getLocalValue('itemsfield', 'Items', "dropdowntriggerform"),
          name: 'items',
          value: data["items"],
          onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onItemClick"];
    }
  }]);

  return DropdownTriggerEditControl;
}(BaseEditControl);

var DropzoneEditControl = function (_BaseEditControl25) {
  _inherits(DropzoneEditControl, _BaseEditControl25);

  function DropzoneEditControl(props) {
    _classCallCheck(this, DropzoneEditControl);

    return _possibleConstructorReturn(this, (DropzoneEditControl.__proto__ || Object.getPrototypeOf(DropzoneEditControl)).call(this, props));
  }

  _createClass(DropzoneEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);
      var data = this.props.data;

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "uploadform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'iconFiletypes', label: this.getLocalValue('iconFiletypes', 'Icon file types', "uploadform"), placeholder: '*.png, *.jpg, *.gif', value: data.iconFiletypes == undefined ? "" : data.iconFiletypes, onChange: handleChange }),
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          null,
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'showFiletypeIcon', label: this.getLocalValue('showFiletypeIcon', 'Show file type icon', "uploadform"), checked: data.showFiletypeIcon, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'autoProcessQueue', label: this.getLocalValue('autoProcessQueue', 'Auto process queue', "uploadform"), checked: data.autoProcessQueue, onChange: handleChange }),
          _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'addRemoveLinks', label: this.getLocalValue('addRemoveLinks', 'Add remove links', "uploadform"), checked: data.addRemoveLinks, onChange: handleChange })
        )
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["success"];
    }
  }]);

  return DropzoneEditControl;
}(BaseEditControl);

//----------
//Chart
//----------


var ChartEditControl = function (_BaseEditControl26) {
  _inherits(ChartEditControl, _BaseEditControl26);

  function ChartEditControl(props) {
    _classCallCheck(this, ChartEditControl);

    return _possibleConstructorReturn(this, (ChartEditControl.__proto__ || Object.getPrototypeOf(ChartEditControl)).call(this, props));
  }

  _createClass(ChartEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      var legendPositionOptions = [{ value: "", text: this.getLocalValue('legendpositiondefaultfield', 'Default', "chartform") }, { value: "top", text: this.getLocalValue('legendpositiontopfield', 'Top', "chartform") }, { value: "left", text: this.getLocalValue('legendpositionleftfield', 'Left', "chartform") }, { value: "bottom", text: this.getLocalValue('legendpositionbottomfield', 'Bottom', "chartform") }, { value: "right", text: this.getLocalValue('legendpositionrightfield', 'Right', "chartform") }];

      var disableCustom = data.datasetCustom == "" || data.datasetCustom == undefined;
      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          { widths: 'equal' },
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "chartform"), value: data.key, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'title', label: this.getLocalValue('titlefield', 'Title', "chartform"), value: data.title, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'titleSize', label: this.getLocalValue('titlesizefield', 'Title size', "chartform"), value: data.titleSize, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { name: 'legendPosition', selection: true, fluid: true, label: this.getLocalValue('legendpositionfield', 'Legend position', "chartform"), placeholder: legendPositionOptions[0].text, options: legendPositionOptions, value: data.legendPosition, onChange: handleChange })
          ),
          _react2.default.createElement(
            'div',
            { className: 'field' },
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'responsive', label: this.getLocalValue('responsivefield', 'Responsive', "chartform"), checked: data.responsive, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'datasetCustom', label: this.getLocalValue('datasetcustomfield', 'Dataset custom', "chartform"), checked: data.datasetCustom, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'dataLabels', style: { paddingTop: "5px" }, disabled: disableCustom, placeholder: this.getLocalValue('datalabelsplaceholder', 'Q1, Q2, Q3, Q4', "chartform"),
              label: this.getLocalValue('datalabelsfield', 'Data labels', "chartform"), value: data.dataLabels, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'datasetLabel', disabled: disableCustom, label: this.getLocalValue('datasetlabelfield', 'Dataset Label', "chartform"), value: data.datasetLabel, onChange: handleChange }),
            _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'datasetBackgroundColor', disabled: disableCustom, label: this.getLocalValue('datasetbackgroundcolorfield', 'Dataset BackgroundColor', "chartform"), value: data.datasetBackgroundColor, onChange: handleChange })
          )
        )
      );
    }
  }]);

  return ChartEditControl;
}(BaseEditControl);

//----------
//Workflow
//----------


var WorkflowBarEditControl = function (_BaseEditControl27) {
  _inherits(WorkflowBarEditControl, _BaseEditControl27);

  function WorkflowBarEditControl(props) {
    _classCallCheck(this, WorkflowBarEditControl);

    return _possibleConstructorReturn(this, (WorkflowBarEditControl.__proto__ || Object.getPrototypeOf(WorkflowBarEditControl)).call(this, props));
  }

  _createClass(WorkflowBarEditControl, [{
    key: 'getGeneralDescription',
    value: function getGeneralDescription() {
      var data = this.props.data;
      var handleChange = this.props.parent.handleChange.bind(this.props.parent);

      return _react2.default.createElement(
        _semanticUiReact.Form,
        null,
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'key', label: this.getLocalValue('namefield', 'Name', "workflowform"), value: data.key, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Input, { name: 'setStateButton', label: this.getLocalValue('setstatebuttonfield', 'Set state button', "workflowform"), value: data.setStateButton, onChange: handleChange }),
        _react2.default.createElement(_semanticUiReact.Form.Checkbox, { name: 'blockSetState', label: this.getLocalValue('blocksetstatefield', 'Block SetState', "workflowform"), checked: Boolean(data.blockSetState), onChange: handleChange })
      );
    }
  }, {
    key: 'getEventsList',
    value: function getEventsList() {
      return ["onCommandClick", "onSetStateClick", "onReceivedCommands"];
    }
  }]);

  return WorkflowBarEditControl;
}(BaseEditControl);

module.exports = {
  BaseEditControl: BaseEditControl,
  HeaderEditControl: HeaderEditControl,
  ButtonEditControl: ButtonEditControl,
  LabelEditControl: LabelEditControl,
  MessageEditControl: MessageEditControl,
  InputEditControl: InputEditControl,
  TextAreaEditControl: TextAreaEditControl,
  DropdownEditControl: DropdownEditControl,
  DictionaryEditControl: DictionaryEditControl,
  RadioGroupEditControl: RadioGroupEditControl,
  CheckboxEditControl: CheckboxEditControl,
  FormEditControl: FormEditControl,
  FormGroupEditControl: FormGroupEditControl,
  ImageEditControl: ImageEditControl,
  StatisticEditControl: StatisticEditControl,
  GridEditControl: GridEditControl,
  CustomEditControl: CustomEditControl,
  MenuEditControl: MenuEditControl,
  ChartEditControl: ChartEditControl,
  WorkflowBarEditControl: WorkflowBarEditControl,
  ContainerEditControl: ContainerEditControl,
  StaticContentEditControl: StaticContentEditControl,
  CollectionEditorEditControl: CollectionEditorEditControl,
  CustomBlockEditControl: CustomBlockEditControl,
  DropdownTriggerEditControl: DropdownTriggerEditControl,
  DropzoneEditControl: DropzoneEditControl,
  BreadcrumbEditControl: BreadcrumbEditControl,
  SearchEditControl: SearchEditControl
};

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CalendarContainer", function() { return CalendarContainer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_classnames__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_react_popper__ = __webpack_require__(44);







var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};









var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function generateYears(year, noOfYear, minDate, maxDate) {
  var list = [];
  for (var i = 0; i < 2 * noOfYear + 1; i++) {
    var newYear = year + noOfYear - i;
    var isInRange = true;

    if (minDate) {
      isInRange = minDate.year() <= newYear;
    }

    if (maxDate && isInRange) {
      isInRange = maxDate.year() >= newYear;
    }

    if (isInRange) {
      list.push(newYear);
    }
  }

  return list;
}

var YearDropdownOptions = function (_React$Component) {
  inherits(YearDropdownOptions, _React$Component);

  function YearDropdownOptions(props) {
    classCallCheck(this, YearDropdownOptions);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.renderOptions = function () {
      var selectedYear = _this.props.year;
      var options = _this.state.yearsList.map(function (year) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: selectedYear === year ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
            key: year,
            ref: year,
            onClick: _this.onChange.bind(_this, year)
          },
          selectedYear === year ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__year-option--selected" },
            "\u2713"
          ) : "",
          year
        );
      });

      var minYear = _this.props.minDate ? _this.props.minDate.year() : null;
      var maxYear = _this.props.maxDate ? _this.props.maxDate.year() : null;

      if (!maxYear || !_this.state.yearsList.find(function (year) {
        return year === maxYear;
      })) {
        options.unshift(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: "react-datepicker__year-option",
            ref: "upcoming",
            key: "upcoming",
            onClick: _this.incrementYears
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" })
        ));
      }

      if (!minYear || !_this.state.yearsList.find(function (year) {
        return year === minYear;
      })) {
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: "react-datepicker__year-option",
            ref: "previous",
            key: "previous",
            onClick: _this.decrementYears
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" })
        ));
      }

      return options;
    };

    _this.onChange = function (year) {
      _this.props.onChange(year);
    };

    _this.handleClickOutside = function () {
      _this.props.onCancel();
    };

    _this.shiftYears = function (amount) {
      var years = _this.state.yearsList.map(function (year) {
        return year + amount;
      });

      _this.setState({
        yearsList: years
      });
    };

    _this.incrementYears = function () {
      return _this.shiftYears(1);
    };

    _this.decrementYears = function () {
      return _this.shiftYears(-1);
    };

    var yearDropdownItemNumber = props.yearDropdownItemNumber,
        scrollableYearDropdown = props.scrollableYearDropdown;

    var noOfYear = yearDropdownItemNumber || (scrollableYearDropdown ? 10 : 5);

    _this.state = {
      yearsList: generateYears(_this.props.year, noOfYear, _this.props.minDate, _this.props.maxDate)
    };
    return _this;
  }

  YearDropdownOptions.prototype.render = function render() {
    var dropdownClass = __WEBPACK_IMPORTED_MODULE_2_classnames___default()({
      "react-datepicker__year-dropdown": true,
      "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
    });

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: dropdownClass },
      this.renderOptions()
    );
  };

  return YearDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

YearDropdownOptions.propTypes = {
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  year: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var dayOfWeekCodes = {
  1: "mon",
  2: "tue",
  3: "wed",
  4: "thu",
  5: "fri",
  6: "sat",
  7: "sun"
};

// These functions are not exported so
// that we avoid magic strings like 'days'
function set$1(date, unit, to) {
  return date.set(unit, to);
}

function add(date, amount, unit) {
  return date.add(amount, unit);
}

function subtract(date, amount, unit) {
  return date.subtract(amount, unit);
}

function get$1(date, unit) {
  return date.get(unit);
}

function getStartOf(date, unit) {
  return date.startOf(unit);
}

// ** Date Constructors **

function newDate(point) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default()(point);
}

function newDateWithOffset(utcOffset) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default()().utc().utcOffset(utcOffset);
}

function now(maybeFixedUtcOffset) {
  if (maybeFixedUtcOffset == null) {
    return newDate();
  }
  return newDateWithOffset(maybeFixedUtcOffset);
}

function cloneDate(date) {
  return date.clone();
}

function parseDate(value, _ref) {
  var dateFormat = _ref.dateFormat,
      locale = _ref.locale;

  var m = __WEBPACK_IMPORTED_MODULE_4_moment___default()(value, dateFormat, locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale(), true);
  return m.isValid() ? m : null;
}

// ** Date "Reflection" **

function isMoment(date) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.isMoment(date);
}

function isDate(date) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.isDate(date);
}

// ** Date Formatting **

function formatDate(date, format) {
  return date.format(format);
}

function safeDateFormat(date, _ref2) {
  var dateFormat = _ref2.dateFormat,
      locale = _ref2.locale;

  return date && date.clone().locale(locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale()).format(Array.isArray(dateFormat) ? dateFormat[0] : dateFormat) || "";
}

// ** Date Setters **

function setTime(date, _ref3) {
  var hour = _ref3.hour,
      minute = _ref3.minute,
      second = _ref3.second;

  date.set({ hour: hour, minute: minute, second: second });
  return date;
}

function setMonth(date, month) {
  return set$1(date, "month", month);
}

function setYear(date, year) {
  return set$1(date, "year", year);
}



// ** Date Getters **

function getSecond(date) {
  return get$1(date, "second");
}

function getMinute(date) {
  return get$1(date, "minute");
}

function getHour(date) {
  return get$1(date, "hour");
}

// Returns day of week
function getDay(date) {
  return get$1(date, "day");
}

function getWeek(date) {
  return get$1(date, "week");
}

function getMonth(date) {
  return get$1(date, "month");
}

function getYear(date) {
  return get$1(date, "year");
}

// Returns day of month
function getDate(date) {
  return get$1(date, "date");
}



function getDayOfWeekCode(day) {
  return dayOfWeekCodes[day.isoWeekday()];
}

// *** Start of ***

function getStartOfDay(date) {
  return getStartOf(date, "day");
}

function getStartOfWeek(date) {
  return getStartOf(date, "week");
}
function getStartOfMonth(date) {
  return getStartOf(date, "month");
}

function getStartOfDate(date) {
  return getStartOf(date, "date");
}

// *** End of ***





// ** Date Math **

// *** Addition ***

function addMinutes(date, amount) {
  return add(date, amount, "minutes");
}

function addHours(date, amount) {
  return add(date, amount, "hours");
}

function addDays(date, amount) {
  return add(date, amount, "days");
}

function addWeeks(date, amount) {
  return add(date, amount, "weeks");
}

function addMonths(date, amount) {
  return add(date, amount, "months");
}

function addYears(date, amount) {
  return add(date, amount, "years");
}

// *** Subtraction ***
function subtractDays(date, amount) {
  return subtract(date, amount, "days");
}

function subtractWeeks(date, amount) {
  return subtract(date, amount, "weeks");
}

function subtractMonths(date, amount) {
  return subtract(date, amount, "months");
}

function subtractYears(date, amount) {
  return subtract(date, amount, "years");
}

// ** Date Comparison **

function isBefore(date1, date2) {
  return date1.isBefore(date2);
}

function isAfter(date1, date2) {
  return date1.isAfter(date2);
}

function equals(date1, date2) {
  return date1.isSame(date2);
}

function isSameYear(date1, date2) {
  if (date1 && date2) {
    return date1.isSame(date2, "year");
  } else {
    return !date1 && !date2;
  }
}

function isSameMonth(date1, date2) {
  if (date1 && date2) {
    return date1.isSame(date2, "month");
  } else {
    return !date1 && !date2;
  }
}

function isSameDay(moment1, moment2) {
  if (moment1 && moment2) {
    return moment1.isSame(moment2, "day");
  } else {
    return !moment1 && !moment2;
  }
}



function isDayInRange(day, startDate, endDate) {
  var before = startDate.clone().startOf("day").subtract(1, "seconds");
  var after = endDate.clone().startOf("day").add(1, "seconds");
  return day.clone().startOf("day").isBetween(before, after);
}

// *** Diffing ***



// ** Date Localization **

function localizeDate(date, locale) {
  return date.clone().locale(locale || __WEBPACK_IMPORTED_MODULE_4_moment___default.a.locale());
}







function getLocaleData(date) {
  return date.localeData();
}

function getLocaleDataForLocale(locale) {
  return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.localeData(locale);
}

function getFormattedWeekdayInLocale(locale, date, formatFunc) {
  return formatFunc(locale.weekdays(date));
}

function getWeekdayMinInLocale(locale, date) {
  return locale.weekdaysMin(date);
}

function getWeekdayShortInLocale(locale, date) {
  return locale.weekdaysShort(date);
}

// TODO what is this format exactly?
function getMonthInLocale(locale, date, format) {
  return locale.months(date, format);
}

function getMonthShortInLocale(locale, date) {
  return locale.monthsShort(date);
}

// ** Utils for some components **

function isDayDisabled(day) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      minDate = _ref4.minDate,
      maxDate = _ref4.maxDate,
      excludeDates = _ref4.excludeDates,
      includeDates = _ref4.includeDates,
      filterDate = _ref4.filterDate;

  return minDate && day.isBefore(minDate, "day") || maxDate && day.isAfter(maxDate, "day") || excludeDates && excludeDates.some(function (excludeDate) {
    return isSameDay(day, excludeDate);
  }) || includeDates && !includeDates.some(function (includeDate) {
    return isSameDay(day, includeDate);
  }) || filterDate && !filterDate(day.clone()) || false;
}

function isTimeDisabled(time, disabledTimes) {
  var l = disabledTimes.length;
  for (var i = 0; i < l; i++) {
    if (disabledTimes[i].get("hours") === time.get("hours") && disabledTimes[i].get("minutes") === time.get("minutes")) {
      return true;
    }
  }

  return false;
}

function isTimeInDisabledRange(time, _ref5) {
  var minTime = _ref5.minTime,
      maxTime = _ref5.maxTime;

  if (!minTime || !maxTime) {
    throw new Error("Both minTime and maxTime props required");
  }

  var base = __WEBPACK_IMPORTED_MODULE_4_moment___default()().hours(0).minutes(0).seconds(0);
  var baseTime = base.clone().hours(time.get("hours")).minutes(time.get("minutes"));
  var min = base.clone().hours(minTime.get("hours")).minutes(minTime.get("minutes"));
  var max = base.clone().hours(maxTime.get("hours")).minutes(maxTime.get("minutes"));

  return !(baseTime.isSameOrAfter(min) && baseTime.isSameOrBefore(max));
}

function allDaysDisabledBefore(day, unit) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      minDate = _ref6.minDate,
      includeDates = _ref6.includeDates;

  var dateBefore = day.clone().subtract(1, unit);
  return minDate && dateBefore.isBefore(minDate, unit) || includeDates && includeDates.every(function (includeDate) {
    return dateBefore.isBefore(includeDate, unit);
  }) || false;
}

function allDaysDisabledAfter(day, unit) {
  var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      maxDate = _ref7.maxDate,
      includeDates = _ref7.includeDates;

  var dateAfter = day.clone().add(1, unit);
  return maxDate && dateAfter.isAfter(maxDate, unit) || includeDates && includeDates.every(function (includeDate) {
    return dateAfter.isAfter(includeDate, unit);
  }) || false;
}

function getEffectiveMinDate(_ref8) {
  var minDate = _ref8.minDate,
      includeDates = _ref8.includeDates;

  if (includeDates && minDate) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.min(includeDates.filter(function (includeDate) {
      return minDate.isSameOrBefore(includeDate, "day");
    }));
  } else if (includeDates) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.min(includeDates);
  } else {
    return minDate;
  }
}

function getEffectiveMaxDate(_ref9) {
  var maxDate = _ref9.maxDate,
      includeDates = _ref9.includeDates;

  if (includeDates && maxDate) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.max(includeDates.filter(function (includeDate) {
      return maxDate.isSameOrAfter(includeDate, "day");
    }));
  } else if (includeDates) {
    return __WEBPACK_IMPORTED_MODULE_4_moment___default.a.max(includeDates);
  } else {
    return maxDate;
  }
}

function getHightLightDaysMap() {
  var highlightDates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var defaultClassName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "react-datepicker__day--highlighted";

  var dateClasses = new Map();
  for (var i = 0, len = highlightDates.length; i < len; i++) {
    var obj = highlightDates[i];
    if (isMoment(obj)) {
      var key = obj.format("MM.DD.YYYY");
      var classNamesArr = dateClasses.get(key) || [];
      if (!classNamesArr.includes(defaultClassName)) {
        classNamesArr.push(defaultClassName);
        dateClasses.set(key, classNamesArr);
      }
    } else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object") {
      var keys = Object.keys(obj);
      var className = keys[0];
      var arrOfMoments = obj[keys[0]];
      if (typeof className === "string" && arrOfMoments.constructor === Array) {
        for (var k = 0, _len = arrOfMoments.length; k < _len; k++) {
          var _key = arrOfMoments[k].format("MM.DD.YYYY");
          var _classNamesArr = dateClasses.get(_key) || [];
          if (!_classNamesArr.includes(className)) {
            _classNamesArr.push(className);
            dateClasses.set(_key, _classNamesArr);
          }
        }
      }
    }
  }

  return dateClasses;
}

function timesToInjectAfter(startOfDay, currentTime, currentMultiplier, intervals, injectedTimes) {
  var l = injectedTimes.length;
  var times = [];
  for (var i = 0; i < l; i++) {
    var injectedTime = addMinutes(addHours(cloneDate(startOfDay), getHour(injectedTimes[i])), getMinute(injectedTimes[i]));
    var nextTime = addMinutes(cloneDate(startOfDay), (currentMultiplier + 1) * intervals);

    if (injectedTime.isBetween(currentTime, nextTime)) {
      times.push(injectedTimes[i]);
    }
  }

  return times;
}

var WrappedYearDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(YearDropdownOptions);

var YearDropdown = function (_React$Component) {
  inherits(YearDropdown, _React$Component);

  function YearDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, YearDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function () {
      var minYear = _this.props.minDate ? getYear(_this.props.minDate) : 1900;
      var maxYear = _this.props.maxDate ? getYear(_this.props.maxDate) : 2100;

      var options = [];
      for (var i = minYear; i <= maxYear; i++) {
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: i, value: i },
          i
        ));
      }
      return options;
    }, _this.onSelectChange = function (e) {
      _this.onChange(e.target.value);
    }, _this.renderSelectMode = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: _this.props.year,
          className: "react-datepicker__year-select",
          onChange: _this.onSelectChange
        },
        _this.renderSelectOptions()
      );
    }, _this.renderReadView = function (visible) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__year-read-view",
          onClick: function onClick(event) {
            return _this.toggleDropdown(event);
          }
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__year-read-view--selected-year" },
          _this.props.year
        )
      );
    }, _this.renderDropdown = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedYearDropdownOptions, {
        key: "dropdown",
        ref: "options",
        year: _this.props.year,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        scrollableYearDropdown: _this.props.scrollableYearDropdown,
        yearDropdownItemNumber: _this.props.yearDropdownItemNumber
      });
    }, _this.renderScrollMode = function () {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    }, _this.onChange = function (year) {
      _this.toggleDropdown();
      if (year === _this.props.year) return;
      _this.props.onChange(year);
    }, _this.toggleDropdown = function (event) {
      _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      }, function () {
        if (_this.props.adjustDateOnChange) {
          _this.handleYearChange(_this.props.date, event);
        }
      });
    }, _this.handleYearChange = function (date, event) {
      _this.onSelect(date, event);
      _this.setOpen();
    }, _this.onSelect = function (date, event) {
      if (_this.props.onSelect) {
        _this.props.onSelect(date, event);
      }
    }, _this.setOpen = function () {
      if (_this.props.setOpen) {
        _this.props.setOpen(true);
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  YearDropdown.prototype.render = function render() {
    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return YearDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

YearDropdown.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  year: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  setOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var MonthDropdownOptions = function (_React$Component) {
  inherits(MonthDropdownOptions, _React$Component);

  function MonthDropdownOptions() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthDropdownOptions);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.renderOptions = function () {
      return _this.props.monthNames.map(function (month, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: _this.props.month === i ? "react-datepicker__month-option --selected_month" : "react-datepicker__month-option",
            key: month,
            ref: month,
            onClick: _this.onChange.bind(_this, i)
          },
          _this.props.month === i ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__month-option--selected" },
            "\u2713"
          ) : "",
          month
        );
      });
    }, _this.onChange = function (month) {
      return _this.props.onChange(month);
    }, _this.handleClickOutside = function () {
      return _this.props.onCancel();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthDropdownOptions.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "react-datepicker__month-dropdown" },
      this.renderOptions()
    );
  };

  return MonthDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthDropdownOptions.propTypes = {
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  monthNames: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired).isRequired
};

var WrappedMonthDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(MonthDropdownOptions);

var MonthDropdown = function (_React$Component) {
  inherits(MonthDropdown, _React$Component);

  function MonthDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function (monthNames) {
      return monthNames.map(function (M, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: i, value: i },
          M
        );
      });
    }, _this.renderSelectMode = function (monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: _this.props.month,
          className: "react-datepicker__month-select",
          onChange: function onChange(e) {
            return _this.onChange(e.target.value);
          }
        },
        _this.renderSelectOptions(monthNames)
      );
    }, _this.renderReadView = function (visible, monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__month-read-view",
          onClick: _this.toggleDropdown
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__month-read-view--selected-month" },
          monthNames[_this.props.month]
        )
      );
    }, _this.renderDropdown = function (monthNames) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedMonthDropdownOptions, {
        key: "dropdown",
        ref: "options",
        month: _this.props.month,
        monthNames: monthNames,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown
      });
    }, _this.renderScrollMode = function (monthNames) {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible, monthNames)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown(monthNames));
      }
      return result;
    }, _this.onChange = function (month) {
      _this.toggleDropdown();
      if (month !== _this.props.month) {
        _this.props.onChange(month);
      }
    }, _this.toggleDropdown = function () {
      return _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthDropdown.prototype.render = function render() {
    var _this2 = this;

    var localeData = getLocaleDataForLocale(this.props.locale);
    var monthNames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function (M) {
      return getMonthShortInLocale(localeData, newDate({ M: M }));
    } : function (M) {
      return getMonthInLocale(localeData, newDate({ M: M }), _this2.props.dateFormat);
    });

    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode(monthNames);
        break;
      case "select":
        renderedDropdown = this.renderSelectMode(monthNames);
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return MonthDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthDropdown.propTypes = {
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool
};

function generateMonthYears(minDate, maxDate) {
  var list = [];

  var currDate = getStartOfMonth(cloneDate(minDate));
  var lastDate = getStartOfMonth(cloneDate(maxDate));

  while (!isAfter(currDate, lastDate)) {
    list.push(cloneDate(currDate));

    addMonths(currDate, 1);
  }

  return list;
}

var MonthYearDropdownOptions = function (_React$Component) {
  inherits(MonthYearDropdownOptions, _React$Component);

  function MonthYearDropdownOptions(props) {
    classCallCheck(this, MonthYearDropdownOptions);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.renderOptions = function () {
      return _this.state.monthYearsList.map(function (monthYear) {
        var monthYearPoint = monthYear.valueOf();

        var isSameMonthYear = isSameYear(_this.props.date, monthYear) && isSameMonth(_this.props.date, monthYear);

        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            className: isSameMonthYear ? "react-datepicker__month-year-option --selected_month-year" : "react-datepicker__month-year-option",
            key: monthYearPoint,
            ref: monthYearPoint,
            onClick: _this.onChange.bind(_this, monthYearPoint)
          },
          isSameMonthYear ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "span",
            { className: "react-datepicker__month-year-option--selected" },
            "\u2713"
          ) : "",
          formatDate(monthYear, _this.props.dateFormat)
        );
      });
    };

    _this.onChange = function (monthYear) {
      return _this.props.onChange(monthYear);
    };

    _this.handleClickOutside = function () {
      _this.props.onCancel();
    };

    _this.state = {
      monthYearsList: generateMonthYears(_this.props.minDate, _this.props.maxDate)
    };
    return _this;
  }

  MonthYearDropdownOptions.prototype.render = function render() {
    var dropdownClass = __WEBPACK_IMPORTED_MODULE_2_classnames___default()({
      "react-datepicker__month-year-dropdown": true,
      "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
    });

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: dropdownClass },
      this.renderOptions()
    );
  };

  return MonthYearDropdownOptions;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthYearDropdownOptions.propTypes = {
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  onCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired
};

var WrappedMonthYearDropdownOptions = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(MonthYearDropdownOptions);

var MonthYearDropdown = function (_React$Component) {
  inherits(MonthYearDropdown, _React$Component);

  function MonthYearDropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, MonthYearDropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      dropdownVisible: false
    }, _this.renderSelectOptions = function () {
      var currDate = getStartOfMonth(localizeDate(_this.props.minDate, _this.props.locale));
      var lastDate = getStartOfMonth(localizeDate(_this.props.maxDate, _this.props.locale));

      var options = [];

      while (!isAfter(currDate, lastDate)) {
        var timepoint = currDate.valueOf();
        options.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "option",
          { key: timepoint, value: timepoint },
          formatDate(currDate, _this.props.dateFormat)
        ));

        addMonths(currDate, 1);
      }

      return options;
    }, _this.onSelectChange = function (e) {
      _this.onChange(e.target.value);
    }, _this.renderSelectMode = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "select",
        {
          value: getStartOfMonth(_this.props.date).valueOf(),
          className: "react-datepicker__month-year-select",
          onChange: _this.onSelectChange
        },
        _this.renderSelectOptions()
      );
    }, _this.renderReadView = function (visible) {
      var yearMonth = formatDate(localizeDate(newDate(_this.props.date), _this.props.locale), _this.props.dateFormat);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          key: "read",
          style: { visibility: visible ? "visible" : "hidden" },
          className: "react-datepicker__month-year-read-view",
          onClick: function onClick(event) {
            return _this.toggleDropdown(event);
          }
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "span",
          { className: "react-datepicker__month-year-read-view--selected-month-year" },
          yearMonth
        )
      );
    }, _this.renderDropdown = function () {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedMonthYearDropdownOptions, {
        key: "dropdown",
        ref: "options",
        date: _this.props.date,
        dateFormat: _this.props.dateFormat,
        onChange: _this.onChange,
        onCancel: _this.toggleDropdown,
        minDate: localizeDate(_this.props.minDate, _this.props.locale),
        maxDate: localizeDate(_this.props.maxDate, _this.props.locale),
        scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown
      });
    }, _this.renderScrollMode = function () {
      var dropdownVisible = _this.state.dropdownVisible;

      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    }, _this.onChange = function (monthYearPoint) {
      _this.toggleDropdown();

      var changedDate = newDate(parseInt(monthYearPoint));

      if (isSameYear(_this.props.date, changedDate) && isSameMonth(_this.props.date, changedDate)) {
        return;
      }

      _this.props.onChange(changedDate);
    }, _this.toggleDropdown = function () {
      return _this.setState({
        dropdownVisible: !_this.state.dropdownVisible
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  MonthYearDropdown.prototype.render = function render() {
    var renderedDropdown = void 0;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--" + this.props.dropdownMode
      },
      renderedDropdown
    );
  };

  return MonthYearDropdown;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

MonthYearDropdown.propTypes = {
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  date: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool
};

var Day = function (_React$Component) {
  inherits(Day, _React$Component);

  function Day() {
    var _temp, _this, _ret;

    classCallCheck(this, Day);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (!_this.isDisabled() && _this.props.onClick) {
        _this.props.onClick(event);
      }
    }, _this.handleMouseEnter = function (event) {
      if (!_this.isDisabled() && _this.props.onMouseEnter) {
        _this.props.onMouseEnter(event);
      }
    }, _this.isSameDay = function (other) {
      return isSameDay(_this.props.day, other);
    }, _this.isKeyboardSelected = function () {
      return !_this.props.inline && !_this.isSameDay(_this.props.selected) && _this.isSameDay(_this.props.preSelection);
    }, _this.isDisabled = function () {
      return isDayDisabled(_this.props.day, _this.props);
    }, _this.getHighLightedClass = function (defaultClassName) {
      var _this$props = _this.props,
          day = _this$props.day,
          highlightDates = _this$props.highlightDates;


      if (!highlightDates) {
        return false;
      }

      // Looking for className in the Map of {'day string, 'className'}
      var dayStr = day.format("MM.DD.YYYY");
      return highlightDates.get(dayStr);
    }, _this.isInRange = function () {
      var _this$props2 = _this.props,
          day = _this$props2.day,
          startDate = _this$props2.startDate,
          endDate = _this$props2.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isDayInRange(day, startDate, endDate);
    }, _this.isInSelectingRange = function () {
      var _this$props3 = _this.props,
          day = _this$props3.day,
          selectsStart = _this$props3.selectsStart,
          selectsEnd = _this$props3.selectsEnd,
          selectingDate = _this$props3.selectingDate,
          startDate = _this$props3.startDate,
          endDate = _this$props3.endDate;


      if (!(selectsStart || selectsEnd) || !selectingDate || _this.isDisabled()) {
        return false;
      }

      if (selectsStart && endDate && selectingDate.isSameOrBefore(endDate)) {
        return isDayInRange(day, selectingDate, endDate);
      }

      if (selectsEnd && startDate && selectingDate.isSameOrAfter(startDate)) {
        return isDayInRange(day, startDate, selectingDate);
      }

      return false;
    }, _this.isSelectingRangeStart = function () {
      if (!_this.isInSelectingRange()) {
        return false;
      }

      var _this$props4 = _this.props,
          day = _this$props4.day,
          selectingDate = _this$props4.selectingDate,
          startDate = _this$props4.startDate,
          selectsStart = _this$props4.selectsStart;


      if (selectsStart) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, startDate);
      }
    }, _this.isSelectingRangeEnd = function () {
      if (!_this.isInSelectingRange()) {
        return false;
      }

      var _this$props5 = _this.props,
          day = _this$props5.day,
          selectingDate = _this$props5.selectingDate,
          endDate = _this$props5.endDate,
          selectsEnd = _this$props5.selectsEnd;


      if (selectsEnd) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, endDate);
      }
    }, _this.isRangeStart = function () {
      var _this$props6 = _this.props,
          day = _this$props6.day,
          startDate = _this$props6.startDate,
          endDate = _this$props6.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(startDate, day);
    }, _this.isRangeEnd = function () {
      var _this$props7 = _this.props,
          day = _this$props7.day,
          startDate = _this$props7.startDate,
          endDate = _this$props7.endDate;

      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(endDate, day);
    }, _this.isWeekend = function () {
      var weekday = getDay(_this.props.day);
      return weekday === 0 || weekday === 6;
    }, _this.isOutsideMonth = function () {
      return _this.props.month !== undefined && _this.props.month !== getMonth(_this.props.day);
    }, _this.getClassNames = function (date) {
      var dayClassName = _this.props.dayClassName ? _this.props.dayClassName(date) : undefined;
      return __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker__day", dayClassName, "react-datepicker__day--" + getDayOfWeekCode(_this.props.day), {
        "react-datepicker__day--disabled": _this.isDisabled(),
        "react-datepicker__day--selected": _this.isSameDay(_this.props.selected),
        "react-datepicker__day--keyboard-selected": _this.isKeyboardSelected(),
        "react-datepicker__day--range-start": _this.isRangeStart(),
        "react-datepicker__day--range-end": _this.isRangeEnd(),
        "react-datepicker__day--in-range": _this.isInRange(),
        "react-datepicker__day--in-selecting-range": _this.isInSelectingRange(),
        "react-datepicker__day--selecting-range-start": _this.isSelectingRangeStart(),
        "react-datepicker__day--selecting-range-end": _this.isSelectingRangeEnd(),
        "react-datepicker__day--today": _this.isSameDay(now(_this.props.utcOffset)),
        "react-datepicker__day--weekend": _this.isWeekend(),
        "react-datepicker__day--outside-month": _this.isOutsideMonth()
      }, _this.getHighLightedClass("react-datepicker__day--highlighted"));
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Day.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: this.getClassNames(this.props.day),
        onClick: this.handleClick,
        onMouseEnter: this.handleMouseEnter,
        "aria-label": "day-" + getDate(this.props.day),
        role: "option"
      },
      getDate(this.props.day)
    );
  };

  return Day;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Day.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var WeekNumber = function (_React$Component) {
  inherits(WeekNumber, _React$Component);

  function WeekNumber() {
    var _temp, _this, _ret;

    classCallCheck(this, WeekNumber);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  WeekNumber.prototype.render = function render() {
    var weekNumberClasses = {
      "react-datepicker__week-number": true,
      "react-datepicker__week-number--clickable": !!this.props.onClick
    };
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: __WEBPACK_IMPORTED_MODULE_2_classnames___default()(weekNumberClasses),
        "aria-label": "week-" + this.props.weekNumber,
        onClick: this.handleClick
      },
      this.props.weekNumber
    );
  };

  return WeekNumber;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

WeekNumber.propTypes = {
  weekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var Week = function (_React$Component) {
  inherits(Week, _React$Component);

  function Week() {
    var _temp, _this, _ret;

    classCallCheck(this, Week);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleDayClick = function (day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    }, _this.handleDayMouseEnter = function (day) {
      if (_this.props.onDayMouseEnter) {
        _this.props.onDayMouseEnter(day);
      }
    }, _this.handleWeekClick = function (day, weekNumber, event) {
      if (typeof _this.props.onWeekSelect === "function") {
        _this.props.onWeekSelect(day, weekNumber, event);
      }
    }, _this.formatWeekNumber = function (startOfWeek) {
      if (_this.props.formatWeekNumber) {
        return _this.props.formatWeekNumber(startOfWeek);
      }
      return getWeek(startOfWeek);
    }, _this.renderDays = function () {
      var startOfWeek = getStartOfWeek(cloneDate(_this.props.day));
      var days = [];
      var weekNumber = _this.formatWeekNumber(startOfWeek);
      if (_this.props.showWeekNumber) {
        var onClickAction = _this.props.onWeekSelect ? _this.handleWeekClick.bind(_this, startOfWeek, weekNumber) : undefined;
        days.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WeekNumber, { key: "W", weekNumber: weekNumber, onClick: onClickAction }));
      }
      return days.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {
        var day = addDays(cloneDate(startOfWeek), offset);
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Day, {
          key: offset,
          day: day,
          month: _this.props.month,
          onClick: _this.handleDayClick.bind(_this, day),
          onMouseEnter: _this.handleDayMouseEnter.bind(_this, day),
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          excludeDates: _this.props.excludeDates,
          includeDates: _this.props.includeDates,
          inline: _this.props.inline,
          highlightDates: _this.props.highlightDates,
          selectingDate: _this.props.selectingDate,
          filterDate: _this.props.filterDate,
          preSelection: _this.props.preSelection,
          selected: _this.props.selected,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          dayClassName: _this.props.dayClassName,
          utcOffset: _this.props.utcOffset
        });
      }));
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Week.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "react-datepicker__week" },
      this.renderDays()
    );
  };

  return Week;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Week.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  month: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onDayClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onDayMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6;

var Month = function (_React$Component) {
  inherits(Month, _React$Component);

  function Month() {
    var _temp, _this, _ret;

    classCallCheck(this, Month);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleDayClick = function (day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    }, _this.handleDayMouseEnter = function (day) {
      if (_this.props.onDayMouseEnter) {
        _this.props.onDayMouseEnter(day);
      }
    }, _this.handleMouseLeave = function () {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave();
      }
    }, _this.isWeekInMonth = function (startOfWeek) {
      var day = _this.props.day;
      var endOfWeek = addDays(cloneDate(startOfWeek), 6);
      return isSameMonth(startOfWeek, day) || isSameMonth(endOfWeek, day);
    }, _this.renderWeeks = function () {
      var weeks = [];
      var isFixedHeight = _this.props.fixedHeight;
      var currentWeekStart = getStartOfWeek(getStartOfMonth(cloneDate(_this.props.day)));
      var i = 0;
      var breakAfterNextPush = false;

      while (true) {
        weeks.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Week, {
          key: i,
          day: currentWeekStart,
          month: getMonth(_this.props.day),
          onDayClick: _this.handleDayClick,
          onDayMouseEnter: _this.handleDayMouseEnter,
          onWeekSelect: _this.props.onWeekSelect,
          formatWeekNumber: _this.props.formatWeekNumber,
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          excludeDates: _this.props.excludeDates,
          includeDates: _this.props.includeDates,
          inline: _this.props.inline,
          highlightDates: _this.props.highlightDates,
          selectingDate: _this.props.selectingDate,
          filterDate: _this.props.filterDate,
          preSelection: _this.props.preSelection,
          selected: _this.props.selected,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          showWeekNumber: _this.props.showWeekNumbers,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          dayClassName: _this.props.dayClassName,
          utcOffset: _this.props.utcOffset
        }));

        if (breakAfterNextPush) break;

        i++;
        currentWeekStart = addWeeks(cloneDate(currentWeekStart), 1);

        // If one of these conditions is true, we will either break on this week
        // or break on the next week
        var isFixedAndFinalWeek = isFixedHeight && i >= FIXED_HEIGHT_STANDARD_WEEK_COUNT;
        var isNonFixedAndOutOfMonth = !isFixedHeight && !_this.isWeekInMonth(currentWeekStart);

        if (isFixedAndFinalWeek || isNonFixedAndOutOfMonth) {
          if (_this.props.peekNextMonth) {
            breakAfterNextPush = true;
          } else {
            break;
          }
        }
      }

      return weeks;
    }, _this.getClassNames = function () {
      var _this$props = _this.props,
          selectingDate = _this$props.selectingDate,
          selectsStart = _this$props.selectsStart,
          selectsEnd = _this$props.selectsEnd;

      return __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker__month", {
        "react-datepicker__month--selecting-range": selectingDate && (selectsStart || selectsEnd)
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Month.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: this.getClassNames(),
        onMouseLeave: this.handleMouseLeave,
        role: "listbox"
      },
      this.renderWeeks()
    );
  };

  return Month;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Month.propTypes = {
  day: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onDayClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onDayMouseEnter: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMouseLeave: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectingDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number
};

var Time = function (_React$Component) {
  inherits(Time, _React$Component);

  function Time() {
    var _temp, _this, _ret;

    classCallCheck(this, Time);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (time) {
      if ((_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || _this.props.excludeTimes && isTimeDisabled(time, _this.props.excludeTimes) || _this.props.includeTimes && !isTimeDisabled(time, _this.props.includeTimes)) {
        return;
      }

      _this.props.onChange(time);
    }, _this.liClasses = function (time, currH, currM) {
      var classes = ["react-datepicker__time-list-item"];

      if (currH === getHour(time) && currM === getMinute(time)) {
        classes.push("react-datepicker__time-list-item--selected");
      }
      if ((_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || _this.props.excludeTimes && isTimeDisabled(time, _this.props.excludeTimes) || _this.props.includeTimes && !isTimeDisabled(time, _this.props.includeTimes)) {
        classes.push("react-datepicker__time-list-item--disabled");
      }
      if (_this.props.injectTimes && (getHour(time) * 60 + getMinute(time)) % _this.props.intervals !== 0) {
        classes.push("react-datepicker__time-list-item--injected");
      }

      return classes.join(" ");
    }, _this.renderTimes = function () {
      var times = [];
      var format = _this.props.format ? _this.props.format : "hh:mm A";
      var intervals = _this.props.intervals;
      var activeTime = _this.props.selected ? _this.props.selected : newDate();
      var currH = getHour(activeTime);
      var currM = getMinute(activeTime);
      var base = getStartOfDay(newDate());
      var multiplier = 1440 / intervals;
      var sortedInjectTimes = _this.props.injectTimes && _this.props.injectTimes.sort(function (a, b) {
        return a - b;
      });
      for (var i = 0; i < multiplier; i++) {
        var currentTime = addMinutes(cloneDate(base), i * intervals);
        times.push(currentTime);

        if (sortedInjectTimes) {
          var timesToInject = timesToInjectAfter(base, currentTime, i, intervals, sortedInjectTimes);
          times = times.concat(timesToInject);
        }
      }

      return times.map(function (time, i) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "li",
          {
            key: i,
            onClick: _this.handleClick.bind(_this, time),
            className: _this.liClasses(time, currH, currM)
          },
          formatDate(time, format)
        );
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Time.prototype.componentDidMount = function componentDidMount() {
    // code to ensure selected time will always be in focus within time window when it first appears
    var multiplier = 60 / this.props.intervals;
    var currH = this.props.selected ? getHour(this.props.selected) : getHour(newDate());
    this.list.scrollTop = 30 * (multiplier * currH);
  };

  Time.prototype.render = function render() {
    var _this2 = this;

    var height = null;
    if (this.props.monthRef) {
      height = this.props.monthRef.clientHeight - 39;
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "react-datepicker__time-container " + (this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "")
      },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__header react-datepicker__header--time" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker-time__header" },
          this.props.timeCaption
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__time" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__time-box" },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "ul",
            {
              className: "react-datepicker__time-list",
              ref: function ref(list) {
                _this2.list = list;
              },
              style: height ? { height: height } : {}
            },
            this.renderTimes.bind(this)()
          )
        )
      )
    );
  };

  createClass(Time, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        intervals: 30,
        onTimeChange: function onTimeChange() {},
        todayButton: null,
        timeCaption: "Time"
      };
    }
  }]);
  return Time;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Time.propTypes = {
  format: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  intervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  monthRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array
};

function CalendarContainer(_ref) {
  var className = _ref.className,
      children = _ref.children;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: className },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", { className: "react-datepicker__triangle" }),
    children
  );
}

CalendarContainer.propTypes = {
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node
};

var DROPDOWN_FOCUS_CLASSNAMES = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"];

var isDropdownSelect = function isDropdownSelect() {
  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var classNames = (element.className || "").split(/\s+/);
  return DROPDOWN_FOCUS_CLASSNAMES.some(function (testClassname) {
    return classNames.indexOf(testClassname) >= 0;
  });
};

var Calendar = function (_React$Component) {
  inherits(Calendar, _React$Component);
  createClass(Calendar, null, [{
    key: "defaultProps",
    get: function get$$1() {
      var _ref;

      return _ref = {
        onDropdownFocus: function onDropdownFocus() {},
        monthsShown: 1,
        forceShowMonthNavigation: false,
        timeCaption: "Time",
        previousMonthButtonLabel: "Previous Month"
      }, _ref["previousMonthButtonLabel"] = "Next Month", _ref;
    }
  }]);

  function Calendar(props) {
    classCallCheck(this, Calendar);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.handleClickOutside = function (event) {
      _this.props.onClickOutside(event);
    };

    _this.handleDropdownFocus = function (event) {
      if (isDropdownSelect(event.target)) {
        _this.props.onDropdownFocus();
      }
    };

    _this.getDateInView = function () {
      var _this$props = _this.props,
          preSelection = _this$props.preSelection,
          selected = _this$props.selected,
          openToDate = _this$props.openToDate,
          utcOffset = _this$props.utcOffset;

      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var current = now(utcOffset);
      var initialDate = openToDate || selected || preSelection;
      if (initialDate) {
        return initialDate;
      } else {
        if (minDate && isBefore(current, minDate)) {
          return minDate;
        } else if (maxDate && isAfter(current, maxDate)) {
          return maxDate;
        }
      }
      return current;
    };

    _this.localizeDate = function (date) {
      return localizeDate(date, _this.props.locale);
    };

    _this.increaseMonth = function () {
      _this.setState({
        date: addMonths(cloneDate(_this.state.date), 1)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.decreaseMonth = function () {
      _this.setState({
        date: subtractMonths(cloneDate(_this.state.date), 1)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.handleDayClick = function (day, event) {
      return _this.props.onSelect(day, event);
    };

    _this.handleDayMouseEnter = function (day) {
      return _this.setState({ selectingDate: day });
    };

    _this.handleMonthMouseLeave = function () {
      return _this.setState({ selectingDate: null });
    };

    _this.handleYearChange = function (date) {
      if (_this.props.onYearChange) {
        _this.props.onYearChange(date);
      }
    };

    _this.handleMonthChange = function (date) {
      if (_this.props.onMonthChange) {
        _this.props.onMonthChange(date);
      }
      if (_this.props.adjustDateOnChange) {
        if (_this.props.onSelect) {
          _this.props.onSelect(date);
        }
        if (_this.props.setOpen) {
          _this.props.setOpen(true);
        }
      }
    };

    _this.handleMonthYearChange = function (date) {
      _this.handleYearChange(date);
      _this.handleMonthChange(date);
    };

    _this.changeYear = function (year) {
      _this.setState({
        date: setYear(cloneDate(_this.state.date), year)
      }, function () {
        return _this.handleYearChange(_this.state.date);
      });
    };

    _this.changeMonth = function (month) {
      _this.setState({
        date: setMonth(cloneDate(_this.state.date), month)
      }, function () {
        return _this.handleMonthChange(_this.state.date);
      });
    };

    _this.changeMonthYear = function (monthYear) {
      _this.setState({
        date: setYear(setMonth(cloneDate(_this.state.date), getMonth(monthYear)), getYear(monthYear))
      }, function () {
        return _this.handleMonthYearChange(_this.state.date);
      });
    };

    _this.header = function () {
      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.date;

      var startOfWeek = getStartOfWeek(cloneDate(date));
      var dayNames = [];
      if (_this.props.showWeekNumbers) {
        dayNames.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { key: "W", className: "react-datepicker__day-name" },
          _this.props.weekLabel || "#"
        ));
      }
      return dayNames.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {
        var day = addDays(cloneDate(startOfWeek), offset);
        var localeData = getLocaleData(day);
        var weekDayName = _this.formatWeekday(localeData, day);

        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { key: offset, className: "react-datepicker__day-name" },
          weekDayName
        );
      }));
    };

    _this.formatWeekday = function (localeData, day) {
      if (_this.props.formatWeekDay) {
        return getFormattedWeekdayInLocale(localeData, day, _this.props.formatWeekDay);
      }
      return _this.props.useWeekdaysShort ? getWeekdayShortInLocale(localeData, day) : getWeekdayMinInLocale(localeData, day);
    };

    _this.renderPreviousMonthButton = function () {
      var allPrevDaysDisabled = allDaysDisabledBefore(_this.state.date, "month", _this.props);

      if (!_this.props.forceShowMonthNavigation && !_this.props.showDisabledMonthNavigation && allPrevDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }

      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--previous"];

      var clickHandler = _this.decreaseMonth;

      if (allPrevDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--previous--disabled");
        clickHandler = null;
      }

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "button",
        {
          type: "button",
          className: classes.join(" "),
          onClick: clickHandler
        },
        _this.props.previousMonthButtonLabel
      );
    };

    _this.renderNextMonthButton = function () {
      var allNextDaysDisabled = allDaysDisabledAfter(_this.state.date, "month", _this.props);

      if (!_this.props.forceShowMonthNavigation && !_this.props.showDisabledMonthNavigation && allNextDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }

      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
      if (_this.props.showTimeSelect) {
        classes.push("react-datepicker__navigation--next--with-time");
      }
      if (_this.props.todayButton) {
        classes.push("react-datepicker__navigation--next--with-today-button");
      }

      var clickHandler = _this.increaseMonth;

      if (allNextDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--next--disabled");
        clickHandler = null;
      }

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "button",
        {
          type: "button",
          className: classes.join(" "),
          onClick: clickHandler
        },
        _this.props.nextMonthButtonLabel
      );
    };

    _this.renderCurrentMonth = function () {
      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.date;

      var classes = ["react-datepicker__current-month"];

      if (_this.props.showYearDropdown) {
        classes.push("react-datepicker__current-month--hasYearDropdown");
      }
      if (_this.props.showMonthDropdown) {
        classes.push("react-datepicker__current-month--hasMonthDropdown");
      }
      if (_this.props.showMonthYearDropdown) {
        classes.push("react-datepicker__current-month--hasMonthYearDropdown");
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: classes.join(" ") },
        formatDate(date, _this.props.dateFormat)
      );
    };

    _this.renderYearDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showYearDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(YearDropdown, {
        adjustDateOnChange: _this.props.adjustDateOnChange,
        date: _this.state.date,
        onSelect: _this.props.onSelect,
        setOpen: _this.props.setOpen,
        dropdownMode: _this.props.dropdownMode,
        onChange: _this.changeYear,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        year: getYear(_this.state.date),
        scrollableYearDropdown: _this.props.scrollableYearDropdown,
        yearDropdownItemNumber: _this.props.yearDropdownItemNumber
      });
    };

    _this.renderMonthDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showMonthDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(MonthDropdown, {
        dropdownMode: _this.props.dropdownMode,
        locale: _this.props.locale,
        dateFormat: _this.props.dateFormat,
        onChange: _this.changeMonth,
        month: getMonth(_this.state.date),
        useShortMonthInDropdown: _this.props.useShortMonthInDropdown
      });
    };

    _this.renderMonthYearDropdown = function () {
      var overrideHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!_this.props.showMonthYearDropdown || overrideHide) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(MonthYearDropdown, {
        dropdownMode: _this.props.dropdownMode,
        locale: _this.props.locale,
        dateFormat: _this.props.dateFormat,
        onChange: _this.changeMonthYear,
        minDate: _this.props.minDate,
        maxDate: _this.props.maxDate,
        date: _this.state.date,
        scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown
      });
    };

    _this.renderTodayButton = function () {
      if (!_this.props.todayButton || _this.props.showTimeSelectOnly) {
        return;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          className: "react-datepicker__today-button",
          onClick: function onClick(e) {
            return _this.props.onSelect(getStartOfDate(now(_this.props.utcOffset)), e);
          }
        },
        _this.props.todayButton
      );
    };

    _this.renderMonths = function () {
      if (_this.props.showTimeSelectOnly) {
        return;
      }

      var monthList = [];
      for (var i = 0; i < _this.props.monthsShown; ++i) {
        var monthDate = addMonths(cloneDate(_this.state.date), i);
        var monthKey = "month-" + i;
        monthList.push(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          {
            key: monthKey,
            ref: function ref(div) {
              _this.monthContainer = div;
            },
            className: "react-datepicker__month-container"
          },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "div",
            { className: "react-datepicker__header" },
            _this.renderCurrentMonth(monthDate),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
              "div",
              {
                className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--" + _this.props.dropdownMode,
                onFocus: _this.handleDropdownFocus
              },
              _this.renderMonthDropdown(i !== 0),
              _this.renderMonthYearDropdown(i !== 0),
              _this.renderYearDropdown(i !== 0)
            ),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
              "div",
              { className: "react-datepicker__day-names" },
              _this.header(monthDate)
            )
          ),
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Month, {
            day: monthDate,
            dayClassName: _this.props.dayClassName,
            onDayClick: _this.handleDayClick,
            onDayMouseEnter: _this.handleDayMouseEnter,
            onMouseLeave: _this.handleMonthMouseLeave,
            onWeekSelect: _this.props.onWeekSelect,
            formatWeekNumber: _this.props.formatWeekNumber,
            minDate: _this.props.minDate,
            maxDate: _this.props.maxDate,
            excludeDates: _this.props.excludeDates,
            highlightDates: _this.props.highlightDates,
            selectingDate: _this.state.selectingDate,
            includeDates: _this.props.includeDates,
            inline: _this.props.inline,
            fixedHeight: _this.props.fixedHeight,
            filterDate: _this.props.filterDate,
            preSelection: _this.props.preSelection,
            selected: _this.props.selected,
            selectsStart: _this.props.selectsStart,
            selectsEnd: _this.props.selectsEnd,
            showWeekNumbers: _this.props.showWeekNumbers,
            startDate: _this.props.startDate,
            endDate: _this.props.endDate,
            peekNextMonth: _this.props.peekNextMonth,
            utcOffset: _this.props.utcOffset
          })
        ));
      }
      return monthList;
    };

    _this.renderTimeSection = function () {
      if (_this.props.showTimeSelect) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Time, {
          selected: _this.props.selected,
          onChange: _this.props.onTimeChange,
          format: _this.props.timeFormat,
          includeTimes: _this.props.includeTimes,
          intervals: _this.props.timeIntervals,
          minTime: _this.props.minTime,
          maxTime: _this.props.maxTime,
          excludeTimes: _this.props.excludeTimes,
          timeCaption: _this.props.timeCaption,
          todayButton: _this.props.todayButton,
          showMonthDropdown: _this.props.showMonthDropdown,
          showMonthYearDropdown: _this.props.showMonthYearDropdown,
          showYearDropdown: _this.props.showYearDropdown,
          withPortal: _this.props.withPortal,
          monthRef: _this.state.monthContainer,
          injectTimes: _this.props.injectTimes
        });
      }
    };

    _this.state = {
      date: _this.localizeDate(_this.getDateInView()),
      selectingDate: null,
      monthContainer: _this.monthContainer
    };
    return _this;
  }

  Calendar.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    // monthContainer height is needed in time component
    // to determine the height for the ul in the time component
    // setState here so height is given after final component
    // layout is rendered
    if (this.props.showTimeSelect) {
      this.assignMonthContainer = function () {
        _this2.setState({ monthContainer: _this2.monthContainer });
      }();
    }
  };

  Calendar.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.preSelection && !isSameDay(this.props.preSelection, prevProps.preSelection)) {
      this.setState({
        date: this.localizeDate(this.props.preSelection)
      });
    } else if (this.props.openToDate && !isSameDay(this.props.openToDate, prevProps.openToDate)) {
      this.setState({
        date: this.localizeDate(this.props.openToDate)
      });
    }
  };

  Calendar.prototype.render = function render() {
    var Container = this.props.container || CalendarContainer;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      Container,
      {
        className: __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker", this.props.className, {
          "react-datepicker--time-only": this.props.showTimeSelectOnly
        })
      },
      this.renderPreviousMonthButton(),
      this.renderNextMonthButton(),
      this.renderMonths(),
      this.renderTodayButton(),
      this.renderTimeSection(),
      this.props.children
    );
  };

  return Calendar;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Calendar.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  container: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array]).isRequired,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]),
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(Map),
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  monthsShown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onClickOutside: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onMonthChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onYearChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  forceShowMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  onDropdownFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  showTimeSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelectOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  timeFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  timeIntervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  onTimeChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  openToDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  preSelection: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  useWeekdaysShort: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  withPortal: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  weekLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  setOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showDisabledMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  previousMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  nextMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string
};

var popperPlacementPositions = ["auto", "auto-left", "auto-right", "bottom", "bottom-end", "bottom-start", "left", "left-end", "left-start", "right", "right-end", "right-start", "top", "top-end", "top-start"];

var PopperComponent = function (_React$Component) {
  inherits(PopperComponent, _React$Component);

  function PopperComponent() {
    classCallCheck(this, PopperComponent);
    return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  PopperComponent.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        hidePopper = _props.hidePopper,
        popperComponent = _props.popperComponent,
        popperModifiers = _props.popperModifiers,
        popperPlacement = _props.popperPlacement,
        targetComponent = _props.targetComponent;


    var popper = void 0;

    if (!hidePopper) {
      var classes = __WEBPACK_IMPORTED_MODULE_2_classnames___default()("react-datepicker-popper", className);
      popper = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_5_react_popper__["b" /* Popper */],
        {
          className: classes,
          modifiers: popperModifiers,
          placement: popperPlacement
        },
        popperComponent
      );
    }

    if (this.props.popperContainer) {
      popper = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(this.props.popperContainer, {}, popper);
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      __WEBPACK_IMPORTED_MODULE_5_react_popper__["a" /* Manager */],
      null,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        __WEBPACK_IMPORTED_MODULE_5_react_popper__["c" /* Target */],
        { className: "react-datepicker-wrapper" },
        targetComponent
      ),
      popper
    );
  };

  createClass(PopperComponent, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        hidePopper: true,
        popperModifiers: {
          preventOverflow: {
            enabled: true,
            escapeWithReference: true,
            boundariesElement: "viewport"
          }
        },
        popperPlacement: "bottom-start"
      };
    }
  }]);
  return PopperComponent;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

PopperComponent.propTypes = {
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  hidePopper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  popperComponent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,
  popperModifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // <datepicker/> props
  popperPlacement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(popperPlacementPositions), // <datepicker/> props
  popperContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  targetComponent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element
};

var outsideClickIgnoreClass = "react-datepicker-ignore-onclickoutside";
var WrappedCalendar = Object(__WEBPACK_IMPORTED_MODULE_3_react_onclickoutside__["a" /* default */])(Calendar);

// Compares dates year+month combinations
function hasPreSelectionChanged(date1, date2) {
  if (date1 && date2) {
    return getMonth(date1) !== getMonth(date2) || getYear(date1) !== getYear(date2);
  }

  return date1 !== date2;
}

function hasSelectionChanged(date1, date2) {
  if (date1 && date2) {
    return !equals(date1, date2);
  }

  return false;
}

/**
 * General datepicker component.
 */

var DatePicker = function (_React$Component) {
  inherits(DatePicker, _React$Component);
  createClass(DatePicker, null, [{
    key: "defaultProps",
    get: function get$$1() {
      return {
        allowSameDay: false,
        dateFormat: "L",
        dateFormatCalendar: "MMMM YYYY",
        onChange: function onChange() {},

        disabled: false,
        disabledKeyboardNavigation: false,
        dropdownMode: "scroll",
        onFocus: function onFocus() {},
        onBlur: function onBlur() {},
        onKeyDown: function onKeyDown() {},
        onSelect: function onSelect() {},
        onClickOutside: function onClickOutside$$1() {},
        onMonthChange: function onMonthChange() {},

        preventOpenOnFocus: false,
        onYearChange: function onYearChange() {},

        monthsShown: 1,
        readOnly: false,
        withPortal: false,
        shouldCloseOnSelect: true,
        showTimeSelect: false,
        timeIntervals: 30,
        timeCaption: "Time",
        previousMonthButtonLabel: "Previous Month",
        nextMonthButtonLabel: "Next month"
      };
    }
  }]);

  function DatePicker(props) {
    classCallCheck(this, DatePicker);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.getPreSelection = function () {
      return _this.props.openToDate ? newDate(_this.props.openToDate) : _this.props.selectsEnd && _this.props.startDate ? newDate(_this.props.startDate) : _this.props.selectsStart && _this.props.endDate ? newDate(_this.props.endDate) : now(_this.props.utcOffset);
    };

    _this.calcInitialState = function () {
      var defaultPreSelection = _this.getPreSelection();
      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var boundedPreSelection = minDate && isBefore(defaultPreSelection, minDate) ? minDate : maxDate && isAfter(defaultPreSelection, maxDate) ? maxDate : defaultPreSelection;
      return {
        open: _this.props.startOpen || false,
        preventFocus: false,
        preSelection: _this.props.selected ? newDate(_this.props.selected) : boundedPreSelection,
        // transforming highlighted days (perhaps nested array)
        // to flat Map for faster access in day.jsx
        highlightDates: getHightLightDaysMap(_this.props.highlightDates),
        focused: false
      };
    };

    _this.clearPreventFocusTimeout = function () {
      if (_this.preventFocusTimeout) {
        clearTimeout(_this.preventFocusTimeout);
      }
    };

    _this.setFocus = function () {
      if (_this.input && _this.input.focus) {
        _this.input.focus();
      }
    };

    _this.setOpen = function (open) {
      _this.setState({
        open: open,
        preSelection: open && _this.state.open ? _this.state.preSelection : _this.calcInitialState().preSelection,
        lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE
      });
    };

    _this.handleFocus = function (event) {
      if (!_this.state.preventFocus) {
        _this.props.onFocus(event);
        if (!_this.props.preventOpenOnFocus && !_this.props.readOnly) {
          _this.setOpen(true);
        }
      }
      _this.setState({ focused: true });
    };

    _this.cancelFocusInput = function () {
      clearTimeout(_this.inputFocusTimeout);
      _this.inputFocusTimeout = null;
    };

    _this.deferFocusInput = function () {
      _this.cancelFocusInput();
      _this.inputFocusTimeout = setTimeout(function () {
        return _this.setFocus();
      }, 1);
    };

    _this.handleDropdownFocus = function () {
      _this.cancelFocusInput();
    };

    _this.handleBlur = function (event) {
      if (_this.state.open && !_this.props.withPortal) {
        _this.deferFocusInput();
      } else {
        _this.props.onBlur(event);
      }
      _this.setState({ focused: false });
    };

    _this.handleCalendarClickOutside = function (event) {
      if (!_this.props.inline) {
        _this.setOpen(false);
      }
      _this.props.onClickOutside(event);
      if (_this.props.withPortal) {
        event.preventDefault();
      }
    };

    _this.handleChange = function () {
      for (var _len = arguments.length, allArgs = Array(_len), _key = 0; _key < _len; _key++) {
        allArgs[_key] = arguments[_key];
      }

      var event = allArgs[0];
      if (_this.props.onChangeRaw) {
        _this.props.onChangeRaw.apply(_this, allArgs);
        if (typeof event.isDefaultPrevented !== "function" || event.isDefaultPrevented()) {
          return;
        }
      }
      _this.setState({
        inputValue: event.target.value,
        lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT
      });
      var date = parseDate(event.target.value, _this.props);
      if (date || !event.target.value) {
        _this.setSelected(date, event, true);
      }
    };

    _this.handleSelect = function (date, event) {
      // Preventing onFocus event to fix issue
      // https://github.com/Hacker0x01/react-datepicker/issues/628
      _this.setState({ preventFocus: true }, function () {
        _this.preventFocusTimeout = setTimeout(function () {
          return _this.setState({ preventFocus: false });
        }, 50);
        return _this.preventFocusTimeout;
      });
      _this.setSelected(date, event);
      if (!_this.props.shouldCloseOnSelect || _this.props.showTimeSelect) {
        _this.setPreSelection(date);
      } else if (!_this.props.inline) {
        _this.setOpen(false);
      }
    };

    _this.setSelected = function (date, event, keepInput) {
      var changedDate = date;

      if (changedDate !== null && isDayDisabled(changedDate, _this.props)) {
        return;
      }

      if (!isSameDay(_this.props.selected, changedDate) || _this.props.allowSameDay) {
        if (changedDate !== null) {
          if (_this.props.selected) {
            var selected = _this.props.selected;
            if (keepInput) selected = newDate(changedDate);
            changedDate = setTime(newDate(changedDate), {
              hour: getHour(selected),
              minute: getMinute(selected),
              second: getSecond(selected)
            });
          }
          if (!_this.props.inline) {
            _this.setState({
              preSelection: changedDate
            });
          }
        }
        _this.props.onChange(changedDate, event);
      }

      _this.props.onSelect(changedDate, event);

      if (!keepInput) {
        _this.setState({ inputValue: null });
      }
    };

    _this.setPreSelection = function (date) {
      var isDateRangePresent = typeof _this.props.minDate !== "undefined" && typeof _this.props.maxDate !== "undefined";
      var isValidDateSelection = isDateRangePresent && date ? isDayInRange(date, _this.props.minDate, _this.props.maxDate) : true;
      if (isValidDateSelection) {
        _this.setState({
          preSelection: date
        });
      }
    };

    _this.handleTimeChange = function (time) {
      var selected = _this.props.selected ? _this.props.selected : _this.getPreSelection();
      var changedDate = setTime(cloneDate(selected), {
        hour: getHour(time),
        minute: getMinute(time)
      });

      _this.setState({
        preSelection: changedDate
      });

      _this.props.onChange(changedDate);
      _this.setOpen(false);
      _this.setState({ inputValue: null });
    };

    _this.onInputClick = function () {
      if (!_this.props.disabled && !_this.props.readOnly) {
        _this.setOpen(true);
      }
    };

    _this.onInputKeyDown = function (event) {
      _this.props.onKeyDown(event);
      var eventKey = event.key;
      if (!_this.state.open && !_this.props.inline && !_this.props.preventOpenOnFocus) {
        if (eventKey === "ArrowDown" || eventKey === "ArrowUp") {
          _this.onInputClick();
        }
        return;
      }
      var copy = newDate(_this.state.preSelection);
      if (eventKey === "Enter") {
        event.preventDefault();
        if ((isMoment(_this.state.preSelection) || isDate(_this.state.preSelection)) && _this.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE) {
          _this.handleSelect(copy, event);
          !_this.props.shouldCloseOnSelect && _this.setPreSelection(copy);
        } else {
          _this.setOpen(false);
        }
      } else if (eventKey === "Escape") {
        event.preventDefault();
        _this.setOpen(false);
      } else if (eventKey === "Tab") {
        _this.setOpen(false);
      } else if (!_this.props.disabledKeyboardNavigation) {
        var newSelection = void 0;
        switch (eventKey) {
          case "ArrowLeft":
            newSelection = subtractDays(copy, 1);
            break;
          case "ArrowRight":
            newSelection = addDays(copy, 1);
            break;
          case "ArrowUp":
            newSelection = subtractWeeks(copy, 1);
            break;
          case "ArrowDown":
            newSelection = addWeeks(copy, 1);
            break;
          case "PageUp":
            newSelection = subtractMonths(copy, 1);
            break;
          case "PageDown":
            newSelection = addMonths(copy, 1);
            break;
          case "Home":
            newSelection = subtractYears(copy, 1);
            break;
          case "End":
            newSelection = addYears(copy, 1);
            break;
        }
        if (!newSelection) return; // Let the input component handle this keydown
        event.preventDefault();
        _this.setState({ lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE });
        if (_this.props.adjustDateOnChange) {
          _this.setSelected(newSelection);
        }
        _this.setPreSelection(newSelection);
      }
    };

    _this.onClearClick = function (event) {
      if (event) {
        if (event.preventDefault) {
          event.preventDefault();
        }
      }
      _this.props.onChange(null, event);
      _this.setState({ inputValue: null });
    };

    _this.clear = function () {
      _this.onClearClick();
    };

    _this.renderCalendar = function () {
      if (!_this.props.inline && (!_this.state.open || _this.props.disabled || _this.props.readOnly)) {
        return null;
      }
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        WrappedCalendar,
        {
          ref: function ref(elem) {
            _this.calendar = elem;
          },
          locale: _this.props.locale,
          adjustDateOnChange: _this.props.adjustDateOnChange,
          setOpen: _this.setOpen,
          dateFormat: _this.props.dateFormatCalendar,
          useWeekdaysShort: _this.props.useWeekdaysShort,
          formatWeekDay: _this.props.formatWeekDay,
          dropdownMode: _this.props.dropdownMode,
          selected: _this.props.selected,
          preSelection: _this.state.preSelection,
          onSelect: _this.handleSelect,
          onWeekSelect: _this.props.onWeekSelect,
          openToDate: _this.props.openToDate,
          minDate: _this.props.minDate,
          maxDate: _this.props.maxDate,
          selectsStart: _this.props.selectsStart,
          selectsEnd: _this.props.selectsEnd,
          startDate: _this.props.startDate,
          endDate: _this.props.endDate,
          excludeDates: _this.props.excludeDates,
          filterDate: _this.props.filterDate,
          onClickOutside: _this.handleCalendarClickOutside,
          formatWeekNumber: _this.props.formatWeekNumber,
          highlightDates: _this.state.highlightDates,
          includeDates: _this.props.includeDates,
          includeTimes: _this.props.includeTimes,
          injectTimes: _this.props.injectTimes,
          inline: _this.props.inline,
          peekNextMonth: _this.props.peekNextMonth,
          showMonthDropdown: _this.props.showMonthDropdown,
          useShortMonthInDropdown: _this.props.useShortMonthInDropdown,
          showMonthYearDropdown: _this.props.showMonthYearDropdown,
          showWeekNumbers: _this.props.showWeekNumbers,
          showYearDropdown: _this.props.showYearDropdown,
          withPortal: _this.props.withPortal,
          forceShowMonthNavigation: _this.props.forceShowMonthNavigation,
          showDisabledMonthNavigation: _this.props.showDisabledMonthNavigation,
          scrollableYearDropdown: _this.props.scrollableYearDropdown,
          scrollableMonthYearDropdown: _this.props.scrollableMonthYearDropdown,
          todayButton: _this.props.todayButton,
          weekLabel: _this.props.weekLabel,
          utcOffset: _this.props.utcOffset,
          outsideClickIgnoreClass: outsideClickIgnoreClass,
          fixedHeight: _this.props.fixedHeight,
          monthsShown: _this.props.monthsShown,
          onDropdownFocus: _this.handleDropdownFocus,
          onMonthChange: _this.props.onMonthChange,
          onYearChange: _this.props.onYearChange,
          dayClassName: _this.props.dayClassName,
          showTimeSelect: _this.props.showTimeSelect,
          showTimeSelectOnly: _this.props.showTimeSelectOnly,
          onTimeChange: _this.handleTimeChange,
          timeFormat: _this.props.timeFormat,
          timeIntervals: _this.props.timeIntervals,
          minTime: _this.props.minTime,
          maxTime: _this.props.maxTime,
          excludeTimes: _this.props.excludeTimes,
          timeCaption: _this.props.timeCaption,
          className: _this.props.calendarClassName,
          container: _this.props.calendarContainer,
          yearDropdownItemNumber: _this.props.yearDropdownItemNumber,
          previousMonthButtonLabel: _this.props.previousMonthButtonLabel,
          nextMonthButtonLabel: _this.props.nextMonthButtonLabel
        },
        _this.props.children
      );
    };

    _this.renderDateInput = function () {
      var _classnames, _React$cloneElement;

      var className = __WEBPACK_IMPORTED_MODULE_2_classnames___default()(_this.props.className, (_classnames = {}, _classnames[outsideClickIgnoreClass] = _this.state.open, _classnames));

      var customInput = _this.props.customInput || __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("input", { type: "text" });
      var customInputRef = _this.props.customInputRef || "ref";
      var inputValue = typeof _this.props.value === "string" ? _this.props.value : typeof _this.state.inputValue === "string" ? _this.state.inputValue : safeDateFormat(_this.props.selected, _this.props);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(customInput, (_React$cloneElement = {}, _React$cloneElement[customInputRef] = function (input) {
        _this.input = input;
      }, _React$cloneElement.value = inputValue, _React$cloneElement.onBlur = _this.handleBlur, _React$cloneElement.onChange = _this.handleChange, _React$cloneElement.onClick = _this.onInputClick, _React$cloneElement.onFocus = _this.handleFocus, _React$cloneElement.onKeyDown = _this.onInputKeyDown, _React$cloneElement.id = _this.props.id, _React$cloneElement.name = _this.props.name, _React$cloneElement.autoFocus = _this.props.autoFocus, _React$cloneElement.placeholder = _this.props.placeholderText, _React$cloneElement.disabled = _this.props.disabled, _React$cloneElement.autoComplete = _this.props.autoComplete, _React$cloneElement.className = className, _React$cloneElement.title = _this.props.title, _React$cloneElement.readOnly = _this.props.readOnly, _React$cloneElement.required = _this.props.required, _React$cloneElement.tabIndex = _this.props.tabIndex, _React$cloneElement));
    };

    _this.renderClearButton = function () {
      if (_this.props.isClearable && _this.props.selected != null) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("button", {
          type: "button",
          className: "react-datepicker__close-icon",
          onClick: _this.onClearClick,
          title: _this.props.clearButtonTitle,
          tabIndex: -1
        });
      } else {
        return null;
      }
    };

    _this.state = _this.calcInitialState();
    return _this;
  }

  DatePicker.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.inline && hasPreSelectionChanged(prevProps.selected, this.props.selected)) {
      this.setPreSelection(this.props.selected);
    }
    if (prevProps.highlightDates !== this.props.highlightDates) {
      this.setState({
        highlightDates: getHightLightDaysMap(this.props.highlightDates)
      });
    }
    if (!prevState.focused && hasSelectionChanged(prevProps.selected, this.props.selected)) {
      this.setState({ inputValue: null });
    }
  };

  DatePicker.prototype.componentWillUnmount = function componentWillUnmount() {
    this.clearPreventFocusTimeout();
  };

  DatePicker.prototype.render = function render() {
    var calendar = this.renderCalendar();

    if (this.props.inline && !this.props.withPortal) {
      return calendar;
    }

    if (this.props.withPortal) {
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        null,
        !this.props.inline ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__input-container" },
          this.renderDateInput(),
          this.renderClearButton()
        ) : null,
        this.state.open || this.props.inline ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "react-datepicker__portal" },
          calendar
        ) : null
      );
    }

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(PopperComponent, {
      className: this.props.popperClassName,
      hidePopper: !this.state.open || this.props.disabled || this.props.readOnly,
      popperModifiers: this.props.popperModifiers,
      targetComponent: __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "react-datepicker__input-container" },
        this.renderDateInput(),
        this.renderClearButton()
      ),
      popperContainer: this.props.popperContainer,
      popperComponent: calendar,
      popperPlacement: this.props.popperPlacement
    });
  };

  return DatePicker;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

DatePicker.propTypes = {
  adjustDateOnChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  allowSameDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  autoComplete: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  autoFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  calendarClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  calendarContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  customInput: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,
  customInputRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  // eslint-disable-next-line react/no-unused-prop-types
  dateFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array]),
  dateFormatCalendar: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  dayClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  disabled: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  disabledKeyboardNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  dropdownMode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["scroll", "select"]).isRequired,
  endDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  filterDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  fixedHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  highlightDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  includeDates: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  includeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  injectTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  inline: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  isClearable: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  locale: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  maxDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  minDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  monthsShown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  name: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  onBlur: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onWeekSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onClickOutside: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onChangeRaw: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onKeyDown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMonthChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onYearChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  openToDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  peekNextMonth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  placeholderText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  popperContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  popperClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, // <PopperComponent/> props
  popperModifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // <PopperComponent/> props
  popperPlacement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(popperPlacementPositions), // <PopperComponent/> props
  preventOpenOnFocus: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  readOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  required: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  scrollableMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selected: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  selectsEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  selectsStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showMonthYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showWeekNumbers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showYearDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  forceShowMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showDisabledMonthNavigation: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  startDate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  startOpen: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  tabIndex: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  timeCaption: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  title: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  todayButton: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  useWeekdaysShort: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  formatWeekDay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  utcOffset: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  value: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  weekLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  withPortal: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  yearDropdownItemNumber: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  shouldCloseOnSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  showTimeSelectOnly: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  timeFormat: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  timeIntervals: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  minTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  maxTime: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  excludeTimes: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.array,
  useShortMonthInDropdown: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  clearButtonTitle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  previousMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  nextMonthButtonLabel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string
};
var PRESELECT_CHANGE_VIA_INPUT = "input";
var PRESELECT_CHANGE_VIA_NAVIGATE = "navigate";


/* harmony default export */ __webpack_exports__["default"] = (DatePicker);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(41);

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IGNORE_CLASS_NAME */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);



function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Check whether some DOM node is our Component's node.
 */
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  } // SVG <use/> elements do not technically reside in the rendered DOM, so
  // they do not have classList directly, but they offer a link to their
  // corresponding element, which can have classList. This extra check is for
  // that case.
  // See: http://www.w3.org/TR/SVG11/struct.html#InterfaceSVGUseElement
  // Discussion: https://github.com/Pomax/react-onclickoutside/pull/17


  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }

  return current.classList.contains(ignoreClass);
}
/**
 * Try to find our node in a hierarchy of nodes, returning the document
 * node as highest node if our node is not found in the path up.
 */

function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  } // If source=local then this event came from 'somewhere'
  // inside and should be ignored. We could handle this with
  // a layered approach, too, but that requires going back to
  // thinking in terms of Dom node nesting, running counter
  // to React's 'you shouldn't care about the DOM' philosophy.


  while (current.parentNode) {
    if (isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }

    current = current.parentNode;
  }

  return current;
}
/**
 * Check if the browser scrollbar was clicked
 */

function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}

// ideally will get replaced with external dep
// when rafrex/detect-passive-events#4 and rafrex/detect-passive-events#5 get merged in
var testPassiveEventSupport = function testPassiveEventSupport() {
  if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
    return;
  }

  var passive = false;
  var options = Object.defineProperty({}, 'passive', {
    get: function get() {
      passive = true;
    }
  });

  var noop = function noop() {};

  window.addEventListener('testPassiveEventSupport', noop, options);
  window.removeEventListener('testPassiveEventSupport', noop, options);
  return passive;
};

function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }

  return function () {
    return ++seed;
  };
}

var uid = autoInc();

var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ['touchstart', 'touchmove'];
var IGNORE_CLASS_NAME = 'ignore-react-onclickoutside';
/**
 * Options for addEventHandler and removeEventHandler
 */

function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = null;
  var isTouchEvent = touchEvents.indexOf(eventName) !== -1;

  if (isTouchEvent && passiveEventSupport) {
    handlerOptions = {
      passive: !instance.props.preventDefault
    };
  }

  return handlerOptions;
}
/**
 * This function generates the HOC function that you'll use
 * in order to impart onOutsideClick listening to an
 * arbitrary component. It gets called at the end of the
 * bootstrapping code to yield an instance of the
 * onClickOutsideHOC function defined inside setupHOC().
 */


function onClickOutsideHOC(WrappedComponent, config) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(onClickOutside, _Component);

    function onClickOutside(props) {
      var _this;

      _this = _Component.call(this, props) || this;

      _this.__outsideClickHandler = function (event) {
        if (typeof _this.__clickOutsideHandlerProp === 'function') {
          _this.__clickOutsideHandlerProp(event);

          return;
        }

        var instance = _this.getInstance();

        if (typeof instance.props.handleClickOutside === 'function') {
          instance.props.handleClickOutside(event);
          return;
        }

        if (typeof instance.handleClickOutside === 'function') {
          instance.handleClickOutside(event);
          return;
        }

        throw new Error('WrappedComponent lacks a handleClickOutside(event) function for processing outside click events.');
      };

      _this.enableOnClickOutside = function () {
        if (typeof document === 'undefined' || enabledInstances[_this._uid]) {
          return;
        }

        if (typeof passiveEventSupport === 'undefined') {
          passiveEventSupport = testPassiveEventSupport();
        }

        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;

        if (!events.forEach) {
          events = [events];
        }

        handlersMap[_this._uid] = function (event) {
          if (_this.props.disableOnClickOutside) return;
          if (_this.componentNode === null) return;

          if (_this.props.preventDefault) {
            event.preventDefault();
          }

          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }

          if (_this.props.excludeScrollbar && clickedScrollbar(event)) return;
          var current = event.target;

          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }

          _this.__outsideClickHandler(event);
        };

        events.forEach(function (eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_this, eventName));
        });
      };

      _this.disableOnClickOutside = function () {
        delete enabledInstances[_this._uid];
        var fn = handlersMap[_this._uid];

        if (fn && typeof document !== 'undefined') {
          var events = _this.props.eventTypes;

          if (!events.forEach) {
            events = [events];
          }

          events.forEach(function (eventName) {
            return document.removeEventListener(eventName, fn, getEventHandlerOptions(_this, eventName));
          });
          delete handlersMap[_this._uid];
        }
      };

      _this.getRef = function (ref) {
        return _this.instanceRef = ref;
      };

      _this._uid = uid();
      return _this;
    }
    /**
     * Access the WrappedComponent's instance.
     */


    var _proto = onClickOutside.prototype;

    _proto.getInstance = function getInstance() {
      if (!WrappedComponent.prototype.isReactComponent) {
        return this;
      }

      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };

    /**
     * Add click listeners to the current document,
     * linked to this component's state.
     */
    _proto.componentDidMount = function componentDidMount() {
      // If we are in an environment without a DOM such
      // as shallow rendering or snapshots then we exit
      // early to prevent any unhandled errors being thrown.
      if (typeof document === 'undefined' || !document.createElement) {
        return;
      }

      var instance = this.getInstance();

      if (config && typeof config.handleClickOutside === 'function') {
        this.__clickOutsideHandlerProp = config.handleClickOutside(instance);

        if (typeof this.__clickOutsideHandlerProp !== 'function') {
          throw new Error('WrappedComponent lacks a function for processing outside click events specified by the handleClickOutside config option.');
        }
      }

      this.componentNode = Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__["findDOMNode"])(this.getInstance());
      this.enableOnClickOutside();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__["findDOMNode"])(this.getInstance());
    };
    /**
     * Remove all document's event listeners for this component
     */


    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    /**
     * Can be called to explicitly enable event listening
     * for clicks and touches outside of this element.
     */


    /**
     * Pass-through render
     */
    _proto.render = function render() {
      // eslint-disable-next-line no-unused-vars
      var _props = this.props,
          excludeScrollbar = _props.excludeScrollbar,
          props = _objectWithoutProperties(_props, ["excludeScrollbar"]);

      if (WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }

      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(WrappedComponent, props);
    };

    return onClickOutside;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]), _class.displayName = "OnClickOutside(" + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ")", _class.defaultProps = {
    eventTypes: ['mousedown', 'touchstart'],
    excludeScrollbar: config && config.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function () {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}


/* harmony default export */ __webpack_exports__["a"] = (onClickOutsideHOC);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Manager__ = __webpack_require__(45);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__Manager__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Target__ = __webpack_require__(46);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__Target__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Popper__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_2__Popper__["a"]; });
/* unused harmony reexport placements */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Arrow__ = __webpack_require__(50);
/* unused harmony reexport Arrow */





/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Manager = function (_Component) {
  _inherits(Manager, _Component);

  function Manager() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Manager);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Manager.__proto__ || Object.getPrototypeOf(Manager)).call.apply(_ref, [this].concat(args))), _this), _this._setTargetNode = function (node) {
      _this._targetNode = node;
    }, _this._getTargetNode = function () {
      return _this._targetNode;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Manager, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        popperManager: {
          setTargetNode: this._setTargetNode,
          getTargetNode: this._getTargetNode
        }
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          tag = _props.tag,
          children = _props.children,
          restProps = _objectWithoutProperties(_props, ['tag', 'children']);

      if (tag !== false) {
        return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(tag, restProps, children);
      } else {
        return children;
      }
    }
  }]);

  return Manager;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

Manager.childContextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};
Manager.propTypes = {
  tag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Manager.defaultProps = {
  tag: 'div'
};


/* harmony default export */ __webpack_exports__["a"] = (Manager);

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }




var Target = function Target(props, context) {
  var _props$component = props.component,
      component = _props$component === undefined ? 'div' : _props$component,
      innerRef = props.innerRef,
      children = props.children,
      restProps = _objectWithoutProperties(props, ['component', 'innerRef', 'children']);

  var popperManager = context.popperManager;

  var targetRef = function targetRef(node) {
    popperManager.setTargetNode(node);
    if (typeof innerRef === 'function') {
      innerRef(node);
    }
  };

  if (typeof children === 'function') {
    var targetProps = { ref: targetRef };
    return children({ targetProps: targetProps, restProps: restProps });
  }

  var componentProps = _extends({}, restProps);

  if (typeof component === 'string') {
    componentProps.ref = targetRef;
  } else {
    componentProps.innerRef = targetRef;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
};

Target.contextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};

Target.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};

/* harmony default export */ __webpack_exports__["a"] = (Target);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export placements */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_popper_js__ = __webpack_require__(48);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var placements = __WEBPACK_IMPORTED_MODULE_2_popper_js__["a" /* default */].placements;

var Popper = function (_Component) {
  _inherits(Popper, _Component);

  function Popper() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Popper);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popper.__proto__ || Object.getPrototypeOf(Popper)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this._setArrowNode = function (node) {
      _this._arrowNode = node;
    }, _this._getTargetNode = function () {
      if (_this.props.target) {
        return _this.props.target;
      } else if (!_this.context.popperManager || !_this.context.popperManager.getTargetNode()) {
        throw new Error('Target missing. Popper must be given a target from the Popper Manager, or as a prop.');
      }
      return _this.context.popperManager.getTargetNode();
    }, _this._getOffsets = function (data) {
      return Object.keys(data.offsets).map(function (key) {
        return data.offsets[key];
      });
    }, _this._isDataDirty = function (data) {
      if (_this.state.data) {
        return JSON.stringify(_this._getOffsets(_this.state.data)) !== JSON.stringify(_this._getOffsets(data));
      } else {
        return true;
      }
    }, _this._updateStateModifier = {
      enabled: true,
      order: 900,
      fn: function fn(data) {
        if (_this._isDataDirty(data)) {
          _this.setState({ data: data });
        }
        return data;
      }
    }, _this._getPopperStyle = function () {
      var data = _this.state.data;


      if (!_this._popper || !data) {
        return {
          position: 'absolute',
          pointerEvents: 'none',
          opacity: 0
        };
      }

      return _extends({
        position: data.offsets.popper.position
      }, data.styles);
    }, _this._getPopperPlacement = function () {
      return _this.state.data ? _this.state.data.placement : undefined;
    }, _this._getPopperHide = function () {
      return !!_this.state.data && _this.state.data.hide ? '' : undefined;
    }, _this._getArrowStyle = function () {
      if (!_this.state.data || !_this.state.data.offsets.arrow) {
        return {};
      } else {
        var _this$state$data$offs = _this.state.data.offsets.arrow,
            top = _this$state$data$offs.top,
            left = _this$state$data$offs.left;

        return { top: top, left: left };
      }
    }, _this._handlePopperRef = function (node) {
      _this._popperNode = node;
      if (node) {
        _this._createPopper();
      } else {
        _this._destroyPopper();
      }
      if (_this.props.innerRef) {
        _this.props.innerRef(node);
      }
    }, _this._scheduleUpdate = function () {
      _this._popper && _this._popper.scheduleUpdate();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Popper, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        popper: {
          setArrowNode: this._setArrowNode,
          getArrowStyle: this._getArrowStyle
        }
      };
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(lastProps) {
      if (lastProps.placement !== this.props.placement || lastProps.eventsEnabled !== this.props.eventsEnabled || lastProps.target !== this.props.target) {
        this._destroyPopper();
        this._createPopper();
      }
      if (lastProps.children !== this.props.children) {
        this._scheduleUpdate();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._destroyPopper();
    }
  }, {
    key: '_createPopper',
    value: function _createPopper() {
      var _this2 = this;

      var _props = this.props,
          placement = _props.placement,
          eventsEnabled = _props.eventsEnabled;

      var modifiers = _extends({}, this.props.modifiers, {
        applyStyle: { enabled: false },
        updateState: this._updateStateModifier
      });
      if (this._arrowNode) {
        modifiers.arrow = _extends({}, this.props.modifiers.arrow || {}, {
          element: this._arrowNode
        });
      }
      this._popper = new __WEBPACK_IMPORTED_MODULE_2_popper_js__["a" /* default */](this._getTargetNode(), this._popperNode, {
        placement: placement,
        eventsEnabled: eventsEnabled,
        modifiers: modifiers
      });

      // TODO: look into setTimeout scheduleUpdate call, without it, the popper will not position properly on creation
      setTimeout(function () {
        return _this2._scheduleUpdate();
      });
    }
  }, {
    key: '_destroyPopper',
    value: function _destroyPopper() {
      if (this._popper) {
        this._popper.destroy();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          component = _props2.component,
          innerRef = _props2.innerRef,
          placement = _props2.placement,
          eventsEnabled = _props2.eventsEnabled,
          modifiers = _props2.modifiers,
          children = _props2.children,
          restProps = _objectWithoutProperties(_props2, ['component', 'innerRef', 'placement', 'eventsEnabled', 'modifiers', 'children']);

      var popperStyle = this._getPopperStyle();
      var popperPlacement = this._getPopperPlacement();
      var popperHide = this._getPopperHide();

      if (typeof children === 'function') {
        var popperProps = {
          ref: this._handlePopperRef,
          style: popperStyle,
          'data-placement': popperPlacement,
          'data-x-out-of-boundaries': popperHide
        };
        return children({
          popperProps: popperProps,
          restProps: restProps,
          scheduleUpdate: this._scheduleUpdate
        });
      }

      var componentProps = _extends({}, restProps, {
        style: _extends({}, restProps.style, popperStyle),
        'data-placement': popperPlacement,
        'data-x-out-of-boundaries': popperHide
      });

      if (typeof component === 'string') {
        componentProps.ref = this._handlePopperRef;
      } else {
        componentProps.innerRef = this._handlePopperRef;
      }

      return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
    }
  }]);

  return Popper;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

Popper.contextTypes = {
  popperManager: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};
Popper.childContextTypes = {
  popper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};
Popper.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  placement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(placements),
  eventsEnabled: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  modifiers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([
  // the following check is needed for SSR
  __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(typeof Element !== 'undefined' ? Element : Object), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    getBoundingClientRect: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
    clientWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
    clientHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired
  })])
};
Popper.defaultProps = {
  component: 'div',
  placement: 'bottom',
  eventsEnabled: true,
  modifiers: {}
};


/* harmony default export */ __webpack_exports__["a"] = (Popper);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.6
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;


  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthOddness = reference.width % 2 === popper.width % 2;
  var bothOddWidth = reference.width % 2 === 1 && popper.width % 2 === 1;
  var noRound = function noRound(v) {
    return v;
  };

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthOddness ? Math.round : Math.floor;
  var verticalToInteger = !shouldRound ? noRound : Math.round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["a"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(49)))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }




var Arrow = function Arrow(props, context) {
  var _props$component = props.component,
      component = _props$component === undefined ? 'span' : _props$component,
      innerRef = props.innerRef,
      children = props.children,
      restProps = _objectWithoutProperties(props, ['component', 'innerRef', 'children']);

  var popper = context.popper;

  var arrowRef = function arrowRef(node) {
    popper.setArrowNode(node);
    if (typeof innerRef === 'function') {
      innerRef(node);
    }
  };
  var arrowStyle = popper.getArrowStyle();

  if (typeof children === 'function') {
    var arrowProps = {
      ref: arrowRef,
      style: arrowStyle
    };
    return children({ arrowProps: arrowProps, restProps: restProps });
  }

  var componentProps = _extends({}, restProps, {
    style: _extends({}, arrowStyle, restProps.style)
  });

  if (typeof component === 'string') {
    componentProps.ref = arrowRef;
  } else {
    componentProps.innerRef = arrowRef;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(component, componentProps, children);
};

Arrow.contextTypes = {
  popper: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
};

Arrow.propTypes = {
  component: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func]),
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};

/* unused harmony default export */ var _unused_webpack_default_export = (Arrow);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _collectioneditor = __webpack_require__(7);

var _collectioneditor2 = _interopRequireDefault(_collectioneditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventsEditor = function (_React$Component) {
    _inherits(EventsEditor, _React$Component);

    function EventsEditor(props) {
        _classCallCheck(this, EventsEditor);

        var _this = _possibleConstructorReturn(this, (EventsEditor.__proto__ || Object.getPrototypeOf(EventsEditor)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(EventsEditor, [{
        key: 'render',
        value: function render() {
            var me = this;
            var data = this.props.data;
            var events = this.props.events;
            var actionOptions = [];
            if (Array.isArray(this.props.actions)) {
                this.props.actions.forEach(function (a) {
                    actionOptions.push({ text: a, value: a });
                });
            }
            var targetOptions = [].concat(_toConsumableArray(this.props.targets));

            var res = [];
            events.forEach(function (e) {
                var key = e + "_events";
                var event = data != undefined ? data[e] : undefined;
                if (event == undefined) {
                    event = {};
                }

                if (event.actions == undefined) event.actions = [];
                if (event.targets == undefined) event.targets = [];
                if (event.parameters == undefined) event.parameters = [];

                if (Array.isArray(event.actions)) {
                    event.actions.forEach(function (a) {
                        var isFind = false;
                        for (var i = 0; i < actionOptions.length; i++) {
                            if (a == actionOptions[i].value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            actionOptions.push({ text: a, value: a });
                        }
                    });
                }

                if (Array.isArray(event.targets)) {
                    event.targets.forEach(function (a) {
                        var isFind = false;
                        for (var i = 0; i < targetOptions.length; i++) {
                            if (a == targetOptions[i].value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            targetOptions.push({ text: a, value: a });
                        }
                    });
                }

                res.push(_react2.default.createElement(
                    'div',
                    { key: key },
                    _react2.default.createElement(_semanticUiReact.Form.Checkbox, { width: 3, key: 'active', label: e, name: 'active', checked: event.active, onChange: me.handleChange.bind(me, e) }),
                    _react2.default.createElement(
                        'div',
                        { key: 'divGroup', style: event.active ? {} : { display: 'none' } },
                        _react2.default.createElement(
                            _semanticUiReact.Form.Group,
                            { key: 'Group' },
                            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { key: 'actions', label: 'Actions', multiple: true, search: true, selection: true, allowAdditions: true,
                                name: 'actions', options: actionOptions, value: event.actions,
                                onAddItem: me.actionsOnAddItem.bind(me), onChange: me.handleChange.bind(me, e) }),
                            _react2.default.createElement(_collectioneditor2.default, { key: 'parameters',
                                columns: ['name', 'value'],
                                label: 'Parameters',
                                name: 'parameters',
                                value: event.parameters,
                                onChange: me.handleChange.bind(me, e) }),
                            _react2.default.createElement(_semanticUiReact.Form.Dropdown, { key: 'targets', label: 'Targets', multiple: true, search: true, selection: true,
                                name: 'targets', options: targetOptions, value: event.targets,
                                onChange: me.handleChange.bind(me, e) })
                        )
                    )
                ));
            });

            return _react2.default.createElement(
                'div',
                null,
                res
            );
        }
    }, {
        key: 'handleChange',
        value: function handleChange(eventName, e, _ref) {
            var name = _ref.name,
                value = _ref.value,
                checked = _ref.checked;

            var event = this.props.data[eventName];
            if (event == undefined) {
                event = {};
                this.props.data[eventName] = event;
            }

            if (value == undefined && checked != undefined) {
                event[name] = checked;
            } else {
                event[name] = value;

                if (value != undefined && value != "") {
                    event.active = true;
                }
            }
            if (this.props.onChange != undefined) this.props.onChange(e, { name: this.props.name, value: this.props.data });
        }
    }, {
        key: 'actionsOnAddItem',
        value: function actionsOnAddItem(e, _ref2) {
            var value = _ref2.value;

            if (this.props.onAdditionActions != undefined) this.props.onAdditionActions(e, { value: value });
        }
    }]);

    return EventsEditor;
}(_react2.default.Component);

exports.default = EventsEditor;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MenuGroup = function (_React$Component) {
    _inherits(MenuGroup, _React$Component);

    function MenuGroup(props) {
        _classCallCheck(this, MenuGroup);

        var _this = _possibleConstructorReturn(this, (MenuGroup.__proto__ || Object.getPrototypeOf(MenuGroup)).call(this, props));

        _this.state = {};

        if (props.value != undefined) {
            _this.state.activeitem = props.value;
        } else if (props.activeitem != null) {
            _this.state.activeitem = props.activeitem;
        }
        return _this;
    }

    _createClass(MenuGroup, [{
        key: 'handleItemClick',
        value: function handleItemClick(e, _ref) {
            var name = _ref.name;

            if (this.props.handleEvent != undefined) {
                var res = this.props.handleEvent({
                    e: e,
                    key: this.props.name,
                    eventName: "onItemClick",
                    parameters: { target: name }
                });
                if (res != false) {
                    this.setState({ activeitem: name });
                }
            }
        }
    }, {
        key: 'handleItemClick2',
        value: function handleItemClick2(p, e) {
            this.handleItemClick(e, p);
            e.preventDefault();
        }
    }, {
        key: 'render',
        value: function render() {
            var items = this.props["data-items"];
            if (items == undefined || items == "") {
                items = [];
            } else if (!Array.isArray(items)) {
                items = _json2.default.parse(items);
            }

            var children = this.renderItems(items);

            var controlProps = {};
            for (var p in this.props) {
                if (p == "data-items" || p == 'activeitem' || p == 'handleEvent' || p == 'link') continue;
                controlProps[p] = this.props[p];
            }

            return _react2.default.createElement(
                _semanticUiReact.Menu,
                controlProps,
                children
            );
        }
    }, {
        key: 'renderItems',
        value: function renderItems(items, keyPrefix) {
            var children = [];
            if (keyPrefix === undefined) keyPrefix = "";

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                if (item.visibleCondition !== undefined && item.visibleCondition !== null && item.visibleCondition !== "") {
                    var args = '';
                    var body = 'return ' + item.visibleCondition;
                    try {
                        if (!new Function(args, body)()) {
                            continue;
                        }
                    } catch (e) {};
                }

                var key = String(keyPrefix) + String(i);
                var titleSpan = _react2.default.createElement('span', { dangerouslySetInnerHTML: { __html: item.title } });
                if (Array.isArray(item.children) && item.children.length > 0) {
                    children.push(_react2.default.createElement(
                        _semanticUiReact.Menu.Item,
                        null,
                        _react2.default.createElement(
                            _semanticUiReact.Menu.Header,
                            null,
                            titleSpan
                        ),
                        _react2.default.createElement(
                            _semanticUiReact.Menu.Menu,
                            null,
                            this.renderItems(item.children, key + "_")
                        )
                    ));
                } else {
                    var content = this.props.link ? _react2.default.createElement(
                        'a',
                        { style: { color: "inherit" }, href: item.target, onClick: this.handleItemClick2.bind(this, { name: item.target }) },
                        titleSpan
                    ) : titleSpan;

                    children.push(_react2.default.createElement(
                        _semanticUiReact.Menu.Item,
                        {
                            key: key,
                            name: item.target,
                            active: this.state.activeitem === item.target,
                            onClick: this.handleItemClick.bind(this) },
                        content
                    ));
                }
            }
            return children;
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (prevState.activeitem !== nextProps.value) {
                return { activeitem: nextProps.value };
            }

            return null;
        }
    }]);

    return MenuGroup;
}(_react2.default.Component);

exports.default = MenuGroup;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(0), __webpack_require__(6));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDataGrid"] = factory(require("react"), require("react-dom"));
	else
		root["ReactDataGrid"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(130);


/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	if (false) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(147)();
	}


/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = {
	  getColumn: function getColumn(columns, idx) {
	    if (Array.isArray(columns)) {
	      return columns[idx];
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.get(idx);
	    }
	  },
	  spliceColumn: function spliceColumn(metrics, idx, column) {
	    if (Array.isArray(metrics.columns)) {
	      metrics.columns.splice(idx, 1, column);
	    } else if (typeof Immutable !== 'undefined') {
	      metrics.columns = metrics.columns.splice(idx, 1, column);
	    }
	    return metrics;
	  },
	  getSize: function getSize(columns) {
	    if (Array.isArray(columns)) {
	      return columns.length;
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.size;
	    }
	  },


	  // Logic extented to allow for functions to be passed down in column.editable
	  // this allows us to deicde whether we can be edting from a cell level
	  canEdit: function canEdit(col, rowData, enableCellSelect) {
	    if (!col) return false;
	    if (col.editable != null && typeof col.editable === 'function') {
	      return enableCellSelect === true && col.editable(rowData);
	    }
	    return enableCellSelect === true && (!!col.editor || !!col.editable);
	  },
	  getValue: function getValue(column, property) {
	    var value = void 0;
	    if (column.toJSON && column.get) {
	      value = column.get(property);
	    } else {
	      value = column[property];
	    }
	    return value;
	  }
	};

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = {
	  selected: _propTypes2['default'].object.isRequired,
	  copied: _propTypes2['default'].object,
	  dragged: _propTypes2['default'].object,
	  onCellClick: _propTypes2['default'].func.isRequired,
	  onCellDoubleClick: _propTypes2['default'].func.isRequired,
	  onCommit: _propTypes2['default'].func.isRequired,
	  onCommitCancel: _propTypes2['default'].func.isRequired,
	  handleDragEnterRow: _propTypes2['default'].func.isRequired,
	  handleTerminateDrag: _propTypes2['default'].func.isRequired,
	  getCellActions: _propTypes2['default'].func
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var ExcelColumnShape = {
	  name: _propTypes2['default'].node.isRequired,
	  key: _propTypes2['default'].string.isRequired,
	  width: _propTypes2['default'].number.isRequired,
	  filterable: _propTypes2['default'].bool
	};

	module.exports = ExcelColumnShape;

/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports) {

	"use strict";

	function createObjectWithProperties(originalObj, properties) {
	  var result = {};
	  for (var _iterator = properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var property = _ref;

	    if (property in originalObj) {
	      result[property] = originalObj[property];
	    }
	  }
	  return result;
	}

	module.exports = createObjectWithProperties;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(141);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-header.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-header.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	'use strict';

	var isFunction = function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	};

	module.exports = isFunction;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(140);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-core.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-core.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-row.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-row.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _keymirror = __webpack_require__(145);

	var _keymirror2 = _interopRequireDefault(_keymirror);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var constants = {
	  UpdateActions: (0, _keymirror2['default'])({
	    CELL_UPDATE: null,
	    COLUMN_FILL: null,
	    COPY_PASTE: null,
	    CELL_DRAG: null
	  }),
	  DragItemTypes: {
	    Column: 'column'
	  },
	  CellExpand: {
	    DOWN_TRIANGLE: String.fromCharCode('9660'),
	    RIGHT_TRIANGLE: String.fromCharCode('9654')
	  }
	};

	module.exports = constants;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var shallowCloneObject = __webpack_require__(52);
	var sameColumn = __webpack_require__(108);
	var ColumnUtils = __webpack_require__(6);
	var getScrollbarSize = __webpack_require__(32);
	var isColumnsImmutable = __webpack_require__(54);

	function setColumnWidths(columns, totalWidth) {
	  return columns.map(function (column) {
	    var colInfo = Object.assign({}, column);
	    if (column.width) {
	      if (/^([0-9]+)%$/.exec(column.width.toString())) {
	        colInfo.width = Math.floor(column.width / 100 * totalWidth);
	      }
	    }
	    return colInfo;
	  });
	}

	function setDefferedColumnWidths(columns, unallocatedWidth, minColumnWidth) {
	  var defferedColumns = columns.filter(function (c) {
	    return !c.width;
	  });
	  return columns.map(function (column) {
	    if (!column.width && column.width !== 0) {
	      if (unallocatedWidth <= 0) {
	        column.width = minColumnWidth;
	      } else {
	        var columnWidth = Math.floor(unallocatedWidth / ColumnUtils.getSize(defferedColumns));
	        if (columnWidth < minColumnWidth) {
	          column.width = minColumnWidth;
	        } else {
	          column.width = columnWidth;
	        }
	      }
	    }
	    return column;
	  });
	}

	function setColumnOffsets(columns) {
	  var left = 0;
	  return columns.map(function (column) {
	    column.left = left;
	    left += column.width;
	    return column;
	  });
	}

	/**
	 * Update column metrics calculation.
	 *
	 * @param {ColumnMetricsType} metrics
	 */
	function recalculate(metrics) {
	  // compute width for columns which specify width
	  var columns = setColumnWidths(metrics.columns, metrics.totalWidth);

	  var unallocatedWidth = columns.filter(function (c) {
	    return c.width;
	  }).reduce(function (w, column) {
	    return w - column.width;
	  }, metrics.totalWidth);
	  unallocatedWidth -= getScrollbarSize();

	  var width = columns.filter(function (c) {
	    return c.width;
	  }).reduce(function (w, column) {
	    return w + column.width;
	  }, 0);

	  // compute width for columns which doesn't specify width
	  columns = setDefferedColumnWidths(columns, unallocatedWidth, metrics.minColumnWidth);

	  // compute left offset
	  columns = setColumnOffsets(columns);

	  return {
	    columns: columns,
	    width: width,
	    totalWidth: metrics.totalWidth,
	    minColumnWidth: metrics.minColumnWidth
	  };
	}

	/**
	 * Update column metrics calculation by resizing a column.
	 *
	 * @param {ColumnMetricsType} metrics
	 * @param {Column} column
	 * @param {number} width
	 */
	function resizeColumn(metrics, index, width) {
	  var column = ColumnUtils.getColumn(metrics.columns, index);
	  var metricsClone = shallowCloneObject(metrics);
	  metricsClone.columns = metrics.columns.slice(0);

	  var updatedColumn = shallowCloneObject(column);
	  updatedColumn.width = Math.max(width, metricsClone.minColumnWidth);

	  metricsClone = ColumnUtils.spliceColumn(metricsClone, index, updatedColumn);

	  return recalculate(metricsClone);
	}

	function areColumnsImmutable(prevColumns, nextColumns) {
	  return isColumnsImmutable(prevColumns) && isColumnsImmutable(nextColumns);
	}

	function compareEachColumn(prevColumns, nextColumns, isSameColumn) {
	  var i = void 0;
	  var len = void 0;
	  var column = void 0;
	  var prevColumnsByKey = {};
	  var nextColumnsByKey = {};

	  if (ColumnUtils.getSize(prevColumns) !== ColumnUtils.getSize(nextColumns)) {
	    return false;
	  }

	  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
	    column = prevColumns[i];
	    prevColumnsByKey[column.key] = column;
	  }

	  for (i = 0, len = ColumnUtils.getSize(nextColumns); i < len; i++) {
	    column = nextColumns[i];
	    nextColumnsByKey[column.key] = column;
	    var prevColumn = prevColumnsByKey[column.key];
	    if (prevColumn === undefined || !isSameColumn(prevColumn, column)) {
	      return false;
	    }
	  }

	  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
	    column = prevColumns[i];
	    var nextColumn = nextColumnsByKey[column.key];
	    if (nextColumn === undefined) {
	      return false;
	    }
	  }
	  return true;
	}

	function sameColumns(prevColumns, nextColumns, isSameColumn) {
	  if (areColumnsImmutable(prevColumns, nextColumns)) {
	    return prevColumns === nextColumns;
	  }

	  return compareEachColumn(prevColumns, nextColumns, isSameColumn);
	}

	module.exports = { recalculate: recalculate, resizeColumn: resizeColumn, sameColumn: sameColumn, sameColumns: sameColumns };

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';

	var size = void 0;

	function getScrollbarSize() {
	  if (size === undefined) {
	    var outer = document.createElement('div');
	    outer.style.width = '50px';
	    outer.style.height = '50px';
	    outer.style.position = 'absolute';
	    outer.style.top = '-200px';
	    outer.style.left = '-200px';

	    var inner = document.createElement('div');
	    inner.style.height = '100px';
	    inner.style.width = '100%';

	    outer.appendChild(inner);
	    document.body.appendChild(outer);

	    var outerWidth = outer.clientWidth;
	    outer.style.overflowY = 'scroll';
	    var innerWidth = inner.clientWidth;

	    document.body.removeChild(outer);

	    size = outerWidth - innerWidth;
	  }

	  return size;
	}

	module.exports = getScrollbarSize;

/***/ }),
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(138);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-cell.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-cell.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _underscore = __webpack_require__(78);

	var _underscore2 = _interopRequireDefault(_underscore);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _CellAction = __webpack_require__(105);

	var _CellAction2 = _interopRequireDefault(_CellAction);

	var _CellExpand = __webpack_require__(106);

	var _CellExpand2 = _interopRequireDefault(_CellExpand);

	var _ChildRowDeleteButton = __webpack_require__(107);

	var _ChildRowDeleteButton2 = _interopRequireDefault(_ChildRowDeleteButton);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var EditorContainer = __webpack_require__(124);
	var ExcelColumn = __webpack_require__(12);
	var isFunction = __webpack_require__(19);
	var CellMetaDataShape = __webpack_require__(11);
	var SimpleCellFormatter = __webpack_require__(51);
	var ColumnUtils = __webpack_require__(6);
	var createObjectWithProperties = __webpack_require__(14);

	__webpack_require__(37);

	// The list of the propTypes that we want to include in the Cell div
	var knownDivPropertyKeys = ['height', 'tabIndex', 'value'];

	var Cell = function (_React$Component) {
	  _inherits(Cell, _React$Component);

	  function Cell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Cell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      isCellValueChanging: false,
	      isLockChanging: false
	    }, _this.onCellClick = function (e) {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellClick && typeof meta.onCellClick === 'function') {
	        meta.onCellClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
	      }
	    }, _this.onCellFocus = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellFocus && typeof meta.onCellFocus === 'function') {
	        meta.onCellFocus({ rowIdx: _this.props.rowIdx, idx: _this.props.idx });
	      }
	    }, _this.onCellContextMenu = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellContextMenu && typeof meta.onCellContextMenu === 'function') {
	        meta.onCellContextMenu({ rowIdx: _this.props.rowIdx, idx: _this.props.idx });
	      }
	    }, _this.onCellDoubleClick = function (e) {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellDoubleClick && typeof meta.onCellDoubleClick === 'function') {
	        meta.onCellDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
	      }
	    }, _this.onCellExpand = function (e) {
	      e.stopPropagation();
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onCellExpand != null) {
	        meta.onCellExpand({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
	      }
	    }, _this.onCellKeyDown = function (e) {
	      if (_this.canExpand() && e.key === 'Enter') {
	        _this.onCellExpand(e);
	      }
	    }, _this.onDeleteSubRow = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onDeleteSubRow != null) {
	        meta.onDeleteSubRow({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
	      }
	    }, _this.onDragHandleDoubleClick = function (e) {
	      e.stopPropagation();
	      var meta = _this.props.cellMetaData;
	      if (meta != null && meta.onDragHandleDoubleClick && typeof meta.onDragHandleDoubleClick === 'function') {
	        meta.onDragHandleDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.getRowData(), e: e });
	      }
	    }, _this.onDragOver = function (e) {
	      e.preventDefault();
	    }, _this.getStyle = function () {
	      var style = {
	        position: 'absolute',
	        width: _this.props.column.width,
	        height: _this.props.height,
	        left: _this.props.column.left
	      };
	      return style;
	    }, _this.getFormatter = function () {
	      var col = _this.props.column;
	      if (_this.isActive()) {
	        return React.createElement(EditorContainer, { rowData: _this.getRowData(), rowIdx: _this.props.rowIdx, value: _this.props.value, idx: _this.props.idx, cellMetaData: _this.props.cellMetaData, column: col, height: _this.props.height });
	      }

	      return _this.props.column.formatter;
	    }, _this.getRowData = function () {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;

	      return props.rowData.toJSON ? props.rowData.toJSON() : props.rowData;
	    }, _this.getFormatterDependencies = function () {
	      // convention based method to get corresponding Id or Name of any Name or Id property
	      if (typeof _this.props.column.getRowMetaData === 'function') {
	        return _this.props.column.getRowMetaData(_this.getRowData(), _this.props.column);
	      }
	    }, _this.getCellClass = function () {
	      var className = joinClasses(_this.props.column.cellClass, 'react-grid-Cell', _this.props.className, _this.props.column.locked ? 'react-grid-Cell--locked' : null);
	      var extraClasses = joinClasses({
	        'row-selected': _this.props.isRowSelected,
	        editing: _this.isActive(),
	        copied: _this.isCopied() || _this.wasDraggedOver() || _this.isDraggedOverUpwards() || _this.isDraggedOverDownwards(),
	        'is-dragged-over-up': _this.isDraggedOverUpwards(),
	        'is-dragged-over-down': _this.isDraggedOverDownwards(),
	        'was-dragged-over': _this.wasDraggedOver(),
	        'cell-tooltip': _this.props.tooltip ? true : false,
	        'rdg-child-cell': _this.props.expandableOptions && _this.props.expandableOptions.subRowDetails && _this.props.expandableOptions.treeDepth > 0,
	        'last-column': _this.props.column.isLastColumn
	      });
	      return joinClasses(className, extraClasses);
	    }, _this.getUpdateCellClass = function () {
	      return _this.props.column.getUpdateCellClass ? _this.props.column.getUpdateCellClass(_this.props.selectedColumn, _this.props.column, _this.state.isCellValueChanging) : '';
	    }, _this.isColumnSelected = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }

	      return meta.selected && meta.selected.idx === _this.props.idx;
	    }, _this.isSelected = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }

	      return meta.selected && meta.selected.rowIdx === _this.props.rowIdx && meta.selected.idx === _this.props.idx;
	    }, _this.isActive = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      return _this.isSelected() && meta.selected.active === true;
	    }, _this.isCellSelectionChanging = function (nextProps) {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      var nextSelected = nextProps.cellMetaData.selected;
	      if (meta.selected && nextSelected) {
	        return _this.props.idx === nextSelected.idx || _this.props.idx === meta.selected.idx;
	      }

	      return true;
	    }, _this.isCellSelectEnabled = function () {
	      var meta = _this.props.cellMetaData;
	      if (meta == null) {
	        return false;
	      }
	      return meta.enableCellSelect;
	    }, _this.hasChangedDependentValues = function (nextProps) {
	      var currentColumn = _this.props.column;
	      var hasChangedDependentValues = false;

	      if (currentColumn.getRowMetaData) {
	        var currentRowMetaData = currentColumn.getRowMetaData(_this.getRowData(), currentColumn);
	        var nextColumn = nextProps.column;
	        var nextRowMetaData = nextColumn.getRowMetaData(_this.getRowData(nextProps), nextColumn);

	        hasChangedDependentValues = !_underscore2['default'].isEqual(currentRowMetaData, nextRowMetaData);
	      }

	      return hasChangedDependentValues;
	    }, _this.applyUpdateClass = function () {
	      var updateCellClass = _this.getUpdateCellClass();
	      // -> removing the class
	      if (updateCellClass != null && updateCellClass !== '') {
	        var cellDOMNode = _this.node;
	        if (cellDOMNode.classList) {
	          cellDOMNode.classList.remove(updateCellClass);
	          // -> and re-adding the class
	          cellDOMNode.classList.add(updateCellClass);
	        } else if (cellDOMNode.className.indexOf(updateCellClass) === -1) {
	          // IE9 doesn't support classList, nor (I think) altering element.className
	          // without replacing it wholesale.
	          cellDOMNode.className = cellDOMNode.className + ' ' + updateCellClass;
	        }
	      }
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = _this.node;
	      if (node) {
	        var transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	        node.style.webkitTransform = transform;
	        node.style.transform = transform;
	      }
	    }, _this.removeScroll = function () {
	      var node = _this.node;
	      if (node) {
	        node.style.webkitTransform = null;
	        node.style.transform = null;
	      }
	    }, _this.isCopied = function () {
	      var copied = _this.props.cellMetaData.copied;
	      return copied && copied.rowIdx === _this.props.rowIdx && copied.idx === _this.props.idx;
	    }, _this.isDraggedOver = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return dragged && dragged.overRowIdx === _this.props.rowIdx && dragged.idx === _this.props.idx;
	    }, _this.wasDraggedOver = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return dragged && (dragged.overRowIdx < _this.props.rowIdx && _this.props.rowIdx < dragged.rowIdx || dragged.overRowIdx > _this.props.rowIdx && _this.props.rowIdx > dragged.rowIdx) && dragged.idx === _this.props.idx;
	    }, _this.isDraggedCellChanging = function (nextProps) {
	      var isChanging = void 0;
	      var dragged = _this.props.cellMetaData.dragged;
	      var nextDragged = nextProps.cellMetaData.dragged;
	      if (dragged) {
	        isChanging = nextDragged && _this.props.idx === nextDragged.idx || dragged && _this.props.idx === dragged.idx;
	        return isChanging;
	      }

	      return false;
	    }, _this.isCopyCellChanging = function (nextProps) {
	      var isChanging = void 0;
	      var copied = _this.props.cellMetaData.copied;
	      var nextCopied = nextProps.cellMetaData.copied;
	      if (copied) {
	        isChanging = nextCopied && _this.props.idx === nextCopied.idx || copied && _this.props.idx === copied.idx;
	        return isChanging;
	      }
	      return false;
	    }, _this.isDraggedOverUpwards = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx < dragged.rowIdx;
	    }, _this.isDraggedOverDownwards = function () {
	      var dragged = _this.props.cellMetaData.dragged;
	      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx > dragged.rowIdx;
	    }, _this.isFocusedOnBody = function () {
	      return document.activeElement == null || document.activeElement.nodeName && typeof document.activeElement.nodeName === 'string' && document.activeElement.nodeName.toLowerCase() === 'body';
	    }, _this.isFocusedOnCell = function () {
	      return document.activeElement && document.activeElement.className.indexOf('react-grid-Cell') !== -1;
	    }, _this.checkFocus = function () {
	      if (_this.isSelected() && !_this.isActive()) {
	        if (_this.props.isScrolling && !_this.props.cellMetaData.isScrollingVerticallyWithKeyboard && !_this.props.cellMetaData.isScrollingHorizontallyWithKeyboard) {
	          return;
	        }
	        // If the enableCellAutoFocus is set in the ReactDataGrid props, it will allow the cell to take focus when the browser is focused on the body.
	        // Otherwise, only focus to the current cell if the currently active node in the document is within the data grid.
	        // Meaning focus should not be stolen from elements that the grid doesnt control.
	        var cellAutoFocusEnabled = _this.props.cellMetaData && _this.props.cellMetaData.enableCellAutoFocus;
	        var dataGridDOMNode = _this.props.cellMetaData && _this.props.cellMetaData.getDataGridDOMNode ? _this.props.cellMetaData.getDataGridDOMNode() : null;
	        if (_this.isFocusedOnCell() || cellAutoFocusEnabled && _this.isFocusedOnBody() || dataGridDOMNode && dataGridDOMNode.contains(document.activeElement)) {
	          var cellDOMNode = _this.node;
	          if (cellDOMNode) {
	            cellDOMNode.focus();
	          }
	        }
	      }
	    }, _this.canEdit = function () {
	      return _this.props.column.editor != null || _this.props.column.editable;
	    }, _this.canExpand = function () {
	      return _this.props.expandableOptions && _this.props.expandableOptions.canExpand;
	    }, _this.createColumEventCallBack = function (onColumnEvent, info) {
	      return function (e) {
	        onColumnEvent(e, info);
	      };
	    }, _this.createCellEventCallBack = function (gridEvent, columnEvent) {
	      return function (e) {
	        gridEvent(e);
	        columnEvent(e);
	      };
	    }, _this.createEventDTO = function (gridEvents, columnEvents, onColumnEvent) {
	      var allEvents = Object.assign({}, gridEvents);

	      for (var eventKey in columnEvents) {
	        if (columnEvents.hasOwnProperty(eventKey)) {
	          var event = columnEvents[event];
	          var eventInfo = { idx: _this.props.idx, rowIdx: _this.props.rowIdx, rowId: _this.props.rowData[_this.props.cellMetaData.rowKey], name: eventKey };
	          var eventCallback = _this.createColumEventCallBack(onColumnEvent, eventInfo);

	          if (allEvents.hasOwnProperty(eventKey)) {
	            var currentEvent = allEvents[eventKey];
	            allEvents[eventKey] = _this.createCellEventCallBack(currentEvent, eventCallback);
	          } else {
	            allEvents[eventKey] = eventCallback;
	          }
	        }
	      }

	      return allEvents;
	    }, _this.getEvents = function () {
	      var columnEvents = _this.props.column ? Object.assign({}, _this.props.column.events) : undefined;
	      var onColumnEvent = _this.props.cellMetaData ? _this.props.cellMetaData.onColumnEvent : undefined;
	      var gridEvents = {
	        onClick: _this.onCellClick,
	        onFocus: _this.onCellFocus,
	        onDoubleClick: _this.onCellDoubleClick,
	        onContextMenu: _this.onCellContextMenu,
	        onDragOver: _this.onDragOver
	      };

	      if (!columnEvents || !onColumnEvent) {
	        return gridEvents;
	      }

	      return _this.createEventDTO(gridEvents, columnEvents, onColumnEvent);
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _this.renderCellContent = function (props) {
	      var CellContent = void 0;
	      var Formatter = _this.getFormatter();
	      if (React.isValidElement(Formatter)) {
	        props.dependentValues = _this.getFormatterDependencies();
	        CellContent = React.cloneElement(Formatter, props);
	      } else if (isFunction(Formatter)) {
	        CellContent = React.createElement(Formatter, { value: _this.props.value, dependentValues: _this.getFormatterDependencies() });
	      } else {
	        CellContent = React.createElement(SimpleCellFormatter, { value: _this.props.value });
	      }
	      var isExpandCell = _this.props.expandableOptions ? _this.props.expandableOptions.field === _this.props.column.key : false;
	      var treeDepth = _this.props.expandableOptions ? _this.props.expandableOptions.treeDepth : 0;
	      var marginLeft = _this.props.expandableOptions && isExpandCell ? _this.props.expandableOptions.treeDepth * 30 : 0;
	      var cellExpander = void 0;
	      var cellDeleter = void 0;
	      if (_this.canExpand()) {
	        cellExpander = React.createElement(_CellExpand2['default'], { expandableOptions: _this.props.expandableOptions, onCellExpand: _this.onCellExpand });
	      }

	      var isDeleteSubRowEnabled = _this.props.cellMetaData.onDeleteSubRow ? true : false;

	      if (treeDepth > 0 && isExpandCell) {
	        cellDeleter = React.createElement(_ChildRowDeleteButton2['default'], { treeDepth: treeDepth, cellHeight: _this.props.height, siblingIndex: _this.props.expandableOptions.subRowDetails.siblingIndex, numberSiblings: _this.props.expandableOptions.subRowDetails.numberSiblings, onDeleteSubRow: _this.onDeleteSubRow, isDeleteSubRowEnabled: isDeleteSubRowEnabled });
	      }
	      return React.createElement(
	        'div',
	        { className: 'react-grid-Cell__value' },
	        cellDeleter,
	        React.createElement(
	          'div',
	          { style: { marginLeft: marginLeft } },
	          React.createElement(
	            'span',
	            null,
	            CellContent
	          ),
	          ' ',
	          _this.props.cellControls,
	          ' ',
	          cellExpander
	        )
	      );
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Cell.prototype.componentDidMount = function componentDidMount() {
	    this.checkFocus();
	  };

	  Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    this.setState({
	      isCellValueChanging: this.props.isCellValueChanging(this.props.value, nextProps.value),
	      isLockChanging: this.props.column.locked !== nextProps.column.locked
	    });
	  };

	  Cell.prototype.componentDidUpdate = function componentDidUpdate() {
	    this.checkFocus();
	    var dragged = this.props.cellMetaData.dragged;
	    if (dragged && dragged.complete === true) {
	      this.props.cellMetaData.handleTerminateDrag();
	    }
	    if (this.state.isCellValueChanging && this.props.selectedColumn != null) {
	      this.applyUpdateClass();
	    }
	    if (this.state.isLockChanging && !this.props.column.locked) {
	      this.removeScroll();
	    }
	  };

	  Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    var shouldUpdate = this.props.column.width !== nextProps.column.width || this.props.column.left !== nextProps.column.left || this.props.column.cellClass !== nextProps.column.cellClass || this.props.height !== nextProps.height || this.props.rowIdx !== nextProps.rowIdx || this.isCellSelectionChanging(nextProps) || this.isDraggedCellChanging(nextProps) || this.isCopyCellChanging(nextProps) || this.props.isRowSelected !== nextProps.isRowSelected || this.isSelected() || this.props.isCellValueChanging(this.props.value, nextProps.value) || this.props.forceUpdate === true || this.props.className !== nextProps.className || this.props.expandableOptions !== nextProps.expandableOptions || this.hasChangedDependentValues(nextProps) || this.props.column.locked !== nextProps.column.locked;
	    return shouldUpdate;
	  };

	  Cell.prototype.getCellActions = function getCellActions() {
	    var _props = this.props,
	        cellMetaData = _props.cellMetaData,
	        column = _props.column,
	        rowData = _props.rowData;

	    if (cellMetaData && cellMetaData.getCellActions) {
	      var cellActions = cellMetaData.getCellActions(column, rowData);
	      if (cellActions && cellActions.length) {
	        return cellActions.map(function (action, index) {
	          return React.createElement(_CellAction2['default'], { key: index, action: action, isFirst: index === 0 });
	        });
	      }
	      return null;
	    }
	    return null;
	  };

	  Cell.prototype.render = function render() {
	    var _this2 = this;

	    if (this.props.column.hidden) {
	      return null;
	    }

	    var style = this.getStyle();

	    var className = this.getCellClass();

	    var cellActions = this.getCellActions();

	    var cellContent = this.props.children || this.renderCellContent({
	      value: this.props.value,
	      column: this.props.column,
	      rowIdx: this.props.rowIdx,
	      isExpanded: this.props.isExpanded
	    });

	    var dragHandle = !this.isActive() && ColumnUtils.canEdit(this.props.column, this.props.rowData, this.props.cellMetaData.enableCellSelect) ? React.createElement(
	      'div',
	      { className: 'drag-handle', draggable: 'true', onDoubleClick: this.onDragHandleDoubleClick },
	      React.createElement('span', { style: { display: 'none' } })
	    ) : null;
	    var events = this.getEvents();
	    var tooltip = this.props.tooltip ? React.createElement(
	      'span',
	      { className: 'cell-tooltip-text' },
	      this.props.tooltip
	    ) : null;

	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: className, style: style }, events, { ref: function ref(node) {
	          _this2.node = node;
	        } }),
	      cellActions,
	      cellContent,
	      dragHandle,
	      tooltip
	    );
	  };

	  return Cell;
	}(React.Component);

	Cell.propTypes = {
	  rowIdx: _propTypes2['default'].number.isRequired,
	  idx: _propTypes2['default'].number.isRequired,
	  selected: _propTypes2['default'].shape({
	    idx: _propTypes2['default'].number.isRequired
	  }),
	  selectedColumn: _propTypes2['default'].object,
	  height: _propTypes2['default'].number,
	  tabIndex: _propTypes2['default'].number,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]),
	  isExpanded: _propTypes2['default'].bool,
	  isRowSelected: _propTypes2['default'].bool,
	  cellMetaData: _propTypes2['default'].shape(CellMetaDataShape).isRequired,
	  handleDragStart: _propTypes2['default'].func,
	  className: _propTypes2['default'].string,
	  cellControls: _propTypes2['default'].any,
	  rowData: _propTypes2['default'].object.isRequired,
	  forceUpdate: _propTypes2['default'].bool,
	  expandableOptions: _propTypes2['default'].object.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired,
	  tooltip: _propTypes2['default'].string,
	  isCellValueChanging: _propTypes2['default'].func,
	  children: _propTypes2['default'].oneOfType([_propTypes2['default'].arrayOf(_propTypes2['default'].node), _propTypes2['default'].node])
	};
	Cell.defaultProps = {
	  tabIndex: 0,
	  isExpanded: false,
	  value: '',
	  isCellValueChanging: function isCellValueChanging(value, nextValue) {
	    return value !== nextValue;
	  }
	};


	module.exports = Cell;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var joinClasses = __webpack_require__(5);
	var ExcelColumn = __webpack_require__(12);
	var ResizeHandle = __webpack_require__(120);
	__webpack_require__(15);

	function simpleCellRenderer(objArgs) {
	  var headerText = objArgs.column.rowType === 'header' ? objArgs.column.name : '';
	  return React.createElement(
	    'div',
	    { className: 'widget-HeaderCell__value' },
	    headerText
	  );
	}

	var HeaderCell = function (_React$Component) {
	  _inherits(HeaderCell, _React$Component);

	  function HeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, HeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: false }, _this.onDragStart = function (e) {
	      _this.setState({ resizing: true });
	      // need to set dummy data for FF
	      if (e && e.dataTransfer && e.dataTransfer.setData) e.dataTransfer.setData('text/plain', 'dummy');
	    }, _this.onDrag = function (e) {
	      var resize = _this.props.onResize || null; // for flows sake, doesnt recognise a null check direct
	      if (resize) {
	        var _width = _this.getWidthFromMouseEvent(e);
	        if (_width > 0) {
	          resize(_this.props.column, _width);
	        }
	      }
	    }, _this.onDragEnd = function (e) {
	      var width = _this.getWidthFromMouseEvent(e);
	      _this.props.onResizeEnd(_this.props.column, width);
	      _this.setState({ resizing: false });
	    }, _this.getWidthFromMouseEvent = function (e) {
	      var right = e.pageX || e.touches && e.touches[0] && e.touches[0].pageX || e.changedTouches && e.changedTouches[e.changedTouches.length - 1].pageX;
	      var left = ReactDOM.findDOMNode(_this).getBoundingClientRect().left;
	      return right - left;
	    }, _this.getCell = function () {
	      if (React.isValidElement(_this.props.renderer)) {
	        // if it is a string, it's an HTML element, and column is not a valid property, so only pass height
	        if (typeof _this.props.renderer.type === 'string') {
	          return React.cloneElement(_this.props.renderer, { height: _this.props.height });
	        }
	        return React.cloneElement(_this.props.renderer, { column: _this.props.column, height: _this.props.height });
	      }
	      return _this.props.renderer({ column: _this.props.column });
	    }, _this.getStyle = function () {
	      return {
	        width: _this.props.column.width,
	        left: _this.props.column.left,
	        display: 'inline-block',
	        position: 'absolute',
	        height: _this.props.height,
	        margin: 0,
	        textOverflow: 'ellipsis',
	        whiteSpace: 'nowrap'
	      };
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = ReactDOM.findDOMNode(_this);
	      node.style.webkitTransform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	      node.style.transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	    }, _this.removeScroll = function () {
	      var node = ReactDOM.findDOMNode(_this);
	      if (node) {
	        var transform = 'none';
	        node.style.webkitTransform = transform;
	        node.style.transform = transform;
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  HeaderCell.prototype.render = function render() {
	    var resizeHandle = void 0;
	    if (this.props.column.resizable) {
	      resizeHandle = React.createElement(ResizeHandle, {
	        onDrag: this.onDrag,
	        onDragStart: this.onDragStart,
	        onDragEnd: this.onDragEnd
	      });
	    }
	    var className = joinClasses({
	      'react-grid-HeaderCell': true,
	      'react-grid-HeaderCell--resizing': this.state.resizing,
	      'react-grid-HeaderCell--locked': this.props.column.locked
	    });
	    className = joinClasses(className, this.props.className, this.props.column.cellClass);
	    var cell = this.getCell();
	    return React.createElement(
	      'div',
	      { className: className, style: this.getStyle() },
	      cell,
	      resizeHandle
	    );
	  };

	  return HeaderCell;
	}(React.Component);

	HeaderCell.propTypes = {
	  renderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]).isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  onResize: _propTypes2['default'].func.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  onResizeEnd: _propTypes2['default'].func.isRequired,
	  className: _propTypes2['default'].string
	};
	HeaderCell.defaultProps = {
	  renderer: simpleCellRenderer
	};


	module.exports = HeaderCell;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _OverflowCell = __webpack_require__(116);

	var _OverflowCell2 = _interopRequireDefault(_OverflowCell);

	var _RowComparer = __webpack_require__(43);

	var _RowComparer2 = _interopRequireDefault(_RowComparer);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var Cell = __webpack_require__(40);
	var columnUtils = __webpack_require__(6);
	var cellMetaDataShape = __webpack_require__(11);
	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(29);

	var CellExpander = function (_React$Component) {
	  _inherits(CellExpander, _React$Component);

	  function CellExpander() {
	    _classCallCheck(this, CellExpander);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  CellExpander.prototype.render = function render() {
	    return React.createElement(Cell, this.props);
	  };

	  return CellExpander;
	}(React.Component);

	// The list of the propTypes that we want to include in the Row div


	var knownDivPropertyKeys = ['height'];

	var Row = function (_React$Component2) {
	  _inherits(Row, _React$Component2);

	  function Row() {
	    var _temp, _this2, _ret;

	    _classCallCheck(this, Row);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this2), _this2.handleDragEnter = function () {
	      var handleDragEnterRow = _this2.props.cellMetaData.handleDragEnterRow;
	      if (handleDragEnterRow) {
	        handleDragEnterRow(_this2.props.idx);
	      }
	    }, _this2.getSelectedColumn = function () {
	      if (_this2.props.cellMetaData) {
	        var selected = _this2.props.cellMetaData.selected;
	        if (selected && selected.idx) {
	          return columnUtils.getColumn(_this2.props.columns, selected.idx);
	        }
	      }
	    }, _this2.getCellRenderer = function (columnKey) {
	      var CellRenderer = _this2.props.cellRenderer;
	      if (_this2.props.subRowDetails && _this2.props.subRowDetails.field === columnKey) {
	        return CellExpander;
	      }
	      return CellRenderer;
	    }, _this2.getCell = function (column, i, selectedColumn) {
	      var CellRenderer = _this2.props.cellRenderer;
	      var _this2$props = _this2.props,
	          colVisibleStart = _this2$props.colVisibleStart,
	          colVisibleEnd = _this2$props.colVisibleEnd,
	          idx = _this2$props.idx,
	          cellMetaData = _this2$props.cellMetaData;
	      var key = column.key,
	          formatter = column.formatter,
	          locked = column.locked;

	      var baseCellProps = { key: key + '-' + idx, idx: i, rowIdx: idx, height: _this2.getRowHeight(), column: column, cellMetaData: cellMetaData };

	      if ((i < colVisibleStart || i > colVisibleEnd) && !locked) {
	        return React.createElement(_OverflowCell2['default'], _extends({ ref: function ref(node) {
	            return _this2[key] = node;
	          } }, baseCellProps));
	      }

	      var _this2$props2 = _this2.props,
	          row = _this2$props2.row,
	          isSelected = _this2$props2.isSelected;

	      var cellProps = {
	        ref: function ref(node) {
	          return _this2[key] = node;
	        },
	        value: _this2.getCellValue(key || i),
	        rowData: row,
	        isRowSelected: isSelected,
	        expandableOptions: _this2.getExpandableOptions(key),
	        selectedColumn: selectedColumn,
	        formatter: formatter,
	        isScrolling: _this2.props.isScrolling
	      };

	      return React.createElement(CellRenderer, _extends({}, baseCellProps, cellProps));
	    }, _this2.getCells = function () {
	      var cells = [];
	      var lockedCells = [];
	      var selectedColumn = _this2.getSelectedColumn();
	      var lastColumnIdx = _this2.props.columns.size - 1;
	      if (_this2.props.columns) {
	        _this2.props.columns.forEach(function (column, i) {
	          if (i === lastColumnIdx) {
	            column.isLastColumn = true;
	          }
	          var cell = _this2.getCell(column, i, selectedColumn);
	          if (column.locked) {
	            lockedCells.push(cell);
	          } else {
	            cells.push(cell);
	          }
	        });
	      }

	      return cells.concat(lockedCells);
	    }, _this2.getRowHeight = function () {
	      var rows = _this2.props.expandedRows || null;
	      if (rows && _this2.props.idx) {
	        var row = rows[_this2.props.idx] || null;
	        if (row) {
	          return row.height;
	        }
	      }
	      return _this2.props.height;
	    }, _this2.getCellValue = function (key) {
	      var val = void 0;
	      if (key === 'select-row') {
	        return _this2.props.isSelected;
	      } else if (typeof _this2.props.row.get === 'function') {
	        val = _this2.props.row.get(key);
	      } else {
	        val = _this2.props.row[key];
	      }
	      return val;
	    }, _this2.isContextMenuDisplayed = function () {
	      if (_this2.props.cellMetaData) {
	        var selected = _this2.props.cellMetaData.selected;
	        if (selected && selected.contextMenuDisplayed && selected.rowIdx === _this2.props.idx) {
	          return true;
	        }
	      }
	      return false;
	    }, _this2.getExpandableOptions = function (columnKey) {
	      var subRowDetails = _this2.props.subRowDetails;
	      if (subRowDetails) {
	        return { canExpand: subRowDetails && subRowDetails.field === columnKey && (subRowDetails.children && subRowDetails.children.length > 0 || subRowDetails.group === true), field: subRowDetails.field, expanded: subRowDetails && subRowDetails.expanded, children: subRowDetails && subRowDetails.children, treeDepth: subRowDetails ? subRowDetails.treeDepth : 0, subRowDetails: subRowDetails };
	      }
	      return {};
	    }, _this2.setScrollLeft = function (scrollLeft) {
	      _this2.props.columns.forEach(function (column) {
	        if (column.locked) {
	          if (!_this2[column.key]) return;
	          _this2[column.key].setScrollLeft(scrollLeft);
	        }
	      });
	    }, _this2.getKnownDivProps = function () {
	      return createObjectWithProperties(_this2.props, knownDivPropertyKeys);
	    }, _this2.renderCell = function (props) {
	      if (typeof _this2.props.cellRenderer === 'function') {
	        _this2.props.cellRenderer.call(_this2, props);
	      }
	      if (React.isValidElement(_this2.props.cellRenderer)) {
	        return React.cloneElement(_this2.props.cellRenderer, props);
	      }

	      return _this2.props.cellRenderer(props);
	    }, _temp), _possibleConstructorReturn(_this2, _ret);
	  }

	  Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return (0, _RowComparer2['default'])(nextProps, this.props);
	  };

	  Row.prototype.render = function render() {
	    var className = joinClasses('react-grid-Row', 'react-grid-Row--' + (this.props.idx % 2 === 0 ? 'even' : 'odd'), {
	      'row-selected': this.props.isSelected,
	      'row-context-menu': this.isContextMenuDisplayed()
	    }, this.props.extraClasses);

	    var style = {
	      height: this.getRowHeight(this.props),
	      overflow: 'hidden'
	    };

	    var cells = this.getCells();
	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: className, style: style, onDragEnter: this.handleDragEnter }),
	      React.isValidElement(this.props.row) ? this.props.row : cells
	    );
	  };

	  return Row;
	}(React.Component);

	Row.displayName = 'Row';
	Row.propTypes = {
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  row: _propTypes2['default'].any.isRequired,
	  cellRenderer: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  isSelected: _propTypes2['default'].bool,
	  idx: _propTypes2['default'].number.isRequired,
	  expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
	  extraClasses: _propTypes2['default'].string,
	  forceUpdate: _propTypes2['default'].bool,
	  subRowDetails: _propTypes2['default'].object,
	  isRowHovered: _propTypes2['default'].bool,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired
	};
	Row.defaultProps = {
	  cellRenderer: Cell,
	  isSelected: false,
	  height: 35
	};


	module.exports = Row;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.shouldRowUpdate = undefined;

	var _ColumnMetrics = __webpack_require__(31);

	var _ColumnMetrics2 = _interopRequireDefault(_ColumnMetrics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function doesRowContainSelectedCell(props) {
	  var selected = props.cellMetaData.selected;
	  if (selected && selected.rowIdx === props.idx) {
	    return true;
	  }
	  return false;
	}

	function willRowBeDraggedOver(props) {
	  var dragged = props.cellMetaData.dragged;
	  return dragged != null && (dragged.rowIdx >= 0 || dragged.complete === true);
	}

	function hasRowBeenCopied(props) {
	  var copied = props.cellMetaData.copied;
	  return copied != null && copied.rowIdx === props.idx;
	}

	var shouldRowUpdate = exports.shouldRowUpdate = function shouldRowUpdate(nextProps, currentProps) {
	  return !_ColumnMetrics2['default'].sameColumns(currentProps.columns, nextProps.columns, _ColumnMetrics2['default'].sameColumn) || doesRowContainSelectedCell(currentProps) || doesRowContainSelectedCell(nextProps) || willRowBeDraggedOver(nextProps) || nextProps.row !== currentProps.row || currentProps.colDisplayStart !== nextProps.colDisplayStart || currentProps.colDisplayEnd !== nextProps.colDisplayEnd || currentProps.colVisibleStart !== nextProps.colVisibleStart || currentProps.colVisibleEnd !== nextProps.colVisibleEnd || hasRowBeenCopied(currentProps) || currentProps.isSelected !== nextProps.isSelected || nextProps.height !== currentProps.height || currentProps.isOver !== nextProps.isOver || currentProps.expandedRows !== nextProps.expandedRows || currentProps.canDrop !== nextProps.canDrop || currentProps.forceUpdate === true || currentProps.extraClasses !== nextProps.extraClasses;
	};

	exports['default'] = shouldRowUpdate;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	'use strict';

	var RowUtils = {
	  get: function get(row, property) {
	    if (typeof row.get === 'function') {
	      return row.get(property);
	    }

	    return row[property];
	  },
	  isRowSelected: function isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx) {
	    if (indexes && Object.prototype.toString.call(indexes) === '[object Array]') {
	      return indexes.indexOf(rowIdx) > -1;
	    } else if (keys && keys.rowKey && keys.values && Object.prototype.toString.call(keys.values) === '[object Array]') {
	      return keys.values.indexOf(rowData[keys.rowKey]) > -1;
	    } else if (isSelectedKey && rowData && typeof isSelectedKey === 'string') {
	      return rowData[isSelectedKey];
	    }
	    return false;
	  }
	};

	module.exports = RowUtils;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.SimpleRowsContainer = exports.getNewContextMenuProps = exports.DEFAULT_CONTEXT_MENU_ID = undefined;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DEFAULT_CONTEXT_MENU_ID = exports.DEFAULT_CONTEXT_MENU_ID = 'rgdContextMenu';

	var SimpleRowsContainer = function SimpleRowsContainer(props) {
	  return _react2['default'].createElement(
	    'div',
	    { key: 'rows-container' },
	    props.rows
	  );
	};

	SimpleRowsContainer.propTypes = {
	  width: _propTypes2['default'].number,
	  rows: _propTypes2['default'].array
	};

	var getNewContextMenuProps = exports.getNewContextMenuProps = function getNewContextMenuProps(_ref) {
	  var contextMenu = _ref.contextMenu,
	      rowIdx = _ref.rowIdx,
	      idx = _ref.idx;
	  return {
	    rowIdx: rowIdx, idx: idx, id: contextMenu.props.id || DEFAULT_CONTEXT_MENU_ID
	  };
	};

	var RowsContainer = function (_React$Component) {
	  _inherits(RowsContainer, _React$Component);

	  function RowsContainer(props) {
	    _classCallCheck(this, RowsContainer);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.plugins = props.window ? props.window.ReactDataGridPlugins : window.ReactDataGridPlugins;
	    return _this;
	  }

	  RowsContainer.prototype.validatePlugin = function validatePlugin() {
	    if (!this.plugins) {
	      throw new Error('You need to include ReactDataGrid UiPlugins in order to initialise context menu');
	    }
	  };

	  RowsContainer.prototype.hasContextMenu = function hasContextMenu() {
	    return this.props.contextMenu && _react2['default'].isValidElement(this.props.contextMenu);
	  };

	  RowsContainer.prototype.renderRowsWithContextMenu = function renderRowsWithContextMenu() {
	    var ContextMenuTrigger = this.plugins.Menu.ContextMenuTrigger;

	    var newProps = getNewContextMenuProps(this.props);
	    var contextMenu = _react2['default'].cloneElement(this.props.contextMenu, newProps);
	    // Initialise the context menu if it is available
	    return _react2['default'].createElement(
	      'div',
	      null,
	      _react2['default'].createElement(
	        ContextMenuTrigger,
	        { id: newProps.id },
	        _react2['default'].createElement(SimpleRowsContainer, this.props)
	      ),
	      contextMenu
	    );
	  };

	  RowsContainer.prototype.render = function render() {
	    if (this.hasContextMenu()) {
	      this.validatePlugin();
	      return this.renderRowsWithContextMenu();
	    }

	    return _react2['default'].createElement(SimpleRowsContainer, this.props);
	  };

	  return RowsContainer;
	}(_react2['default'].Component);

	RowsContainer.propTypes = {
	  contextMenu: _propTypes2['default'].element,
	  rowIdx: _propTypes2['default'].number,
	  idx: _propTypes2['default'].number,
	  window: _propTypes2['default'].object
	};

	exports['default'] = RowsContainer;
	exports.SimpleRowsContainer = SimpleRowsContainer;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var DEFINE_SORT = {
	  ASC: 'ASC',
	  DESC: 'DESC',
	  NONE: 'NONE'
	};

	var SortableHeaderCell = function (_React$Component) {
	  _inherits(SortableHeaderCell, _React$Component);

	  function SortableHeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, SortableHeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function () {
	      var direction = void 0;
	      var _this$props = _this.props,
	          sortDirection = _this$props.sortDirection,
	          sortDescendingFirst = _this$props.sortDescendingFirst;

	      switch (sortDirection) {
	        default:
	        case null:
	        case undefined:
	        case DEFINE_SORT.NONE:
	          direction = sortDescendingFirst ? DEFINE_SORT.DESC : DEFINE_SORT.ASC;
	          break;
	        case DEFINE_SORT.ASC:
	          direction = sortDescendingFirst ? DEFINE_SORT.NONE : DEFINE_SORT.DESC;
	          break;
	        case DEFINE_SORT.DESC:
	          direction = sortDescendingFirst ? DEFINE_SORT.ASC : DEFINE_SORT.NONE;
	          break;
	      }
	      _this.props.onSort(_this.props.columnKey, direction);
	    }, _this.getSortByText = function () {
	      var unicodeKeys = {
	        ASC: '9650',
	        DESC: '9660'
	      };
	      return _this.props.sortDirection === 'NONE' ? '' : String.fromCharCode(unicodeKeys[_this.props.sortDirection]);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  SortableHeaderCell.prototype.render = function render() {
	    var className = joinClasses({
	      'react-grid-HeaderCell-sortable': true,
	      'react-grid-HeaderCell-sortable--ascending': this.props.sortDirection === 'ASC',
	      'react-grid-HeaderCell-sortable--descending': this.props.sortDirection === 'DESC'
	    });
	    var content = this.props.headerRenderer ? this.props.headerRenderer : this.props.column.name;
	    return React.createElement(
	      'div',
	      { className: className,
	        onClick: this.onClick,
	        style: { cursor: 'pointer' } },
	      React.createElement(
	        'span',
	        { className: 'pull-right' },
	        this.getSortByText()
	      ),
	      content
	    );
	  };

	  return SortableHeaderCell;
	}(React.Component);

	SortableHeaderCell.propTypes = {
	  columnKey: _propTypes2['default'].string.isRequired,
	  column: _propTypes2['default'].shape({ name: _propTypes2['default'].node }),
	  onSort: _propTypes2['default'].func.isRequired,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(DEFINE_SORT)),
	  headerRenderer: _propTypes2['default'].node,
	  sortDescendingFirst: _propTypes2['default'].bool
	};


	module.exports = SortableHeaderCell;
	module.exports.DEFINE_SORT = DEFINE_SORT;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	__webpack_require__(70);

	var CheckboxEditor = function (_React$Component) {
	  _inherits(CheckboxEditor, _React$Component);

	  function CheckboxEditor() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, CheckboxEditor);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleChange = function (e) {
	      _this.props.column.onCellChange(_this.props.rowIdx, _this.props.column.key, _this.props.dependentValues, e);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  CheckboxEditor.prototype.render = function render() {
	    var checked = this.props.value != null ? this.props.value : false;
	    var checkboxName = 'checkbox' + this.props.rowIdx;
	    return React.createElement(
	      'div',
	      { className: 'react-grid-checkbox-container checkbox-align', onClick: this.handleChange },
	      React.createElement('input', { className: 'react-grid-checkbox', type: 'checkbox', name: checkboxName, checked: checked }),
	      React.createElement('label', { htmlFor: checkboxName, className: 'react-grid-checkbox-label' })
	    );
	  };

	  return CheckboxEditor;
	}(React.Component);

	CheckboxEditor.propTypes = {
	  value: _propTypes2['default'].bool,
	  rowIdx: _propTypes2['default'].number,
	  column: _propTypes2['default'].shape({
	    key: _propTypes2['default'].string,
	    onCellChange: _propTypes2['default'].func
	  }),
	  dependentValues: _propTypes2['default'].object
	};


	module.exports = CheckboxEditor;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var ExcelColumn = __webpack_require__(12);

	var EditorBase = function (_React$Component) {
	  _inherits(EditorBase, _React$Component);

	  function EditorBase() {
	    _classCallCheck(this, EditorBase);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  EditorBase.prototype.getStyle = function getStyle() {
	    return {
	      width: '100%'
	    };
	  };

	  EditorBase.prototype.getValue = function getValue() {
	    var updated = {};
	    updated[this.props.column.key] = this.getInputNode().value;
	    return updated;
	  };

	  EditorBase.prototype.getInputNode = function getInputNode() {
	    var domNode = ReactDOM.findDOMNode(this);
	    if (domNode.tagName === 'INPUT') {
	      return domNode;
	    }

	    return domNode.querySelector('input:not([type=hidden])');
	  };

	  EditorBase.prototype.inheritContainerStyles = function inheritContainerStyles() {
	    return true;
	  };

	  return EditorBase;
	}(React.Component);

	EditorBase.propTypes = {
	  onKeyDown: _propTypes2['default'].func.isRequired,
	  value: _propTypes2['default'].any.isRequired,
	  onBlur: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
	  commit: _propTypes2['default'].func.isRequired
	};

	module.exports = EditorBase;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var EditorBase = __webpack_require__(48);

	var SimpleTextEditor = function (_EditorBase) {
	  _inherits(SimpleTextEditor, _EditorBase);

	  function SimpleTextEditor() {
	    _classCallCheck(this, SimpleTextEditor);

	    return _possibleConstructorReturn(this, _EditorBase.apply(this, arguments));
	  }

	  SimpleTextEditor.prototype.render = function render() {
	    var _this2 = this;

	    return React.createElement('input', { ref: function ref(node) {
	        return _this2.input = node;
	      }, type: 'text', onBlur: this.props.onBlur, className: 'form-control', defaultValue: this.props.value });
	  };

	  return SimpleTextEditor;
	}(EditorBase);

	module.exports = SimpleTextEditor;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var SelectAll = function SelectAll(props) {
	  return _react2['default'].createElement(
	    'div',
	    { className: 'react-grid-checkbox-container checkbox-align' },
	    _react2['default'].createElement('input', {
	      className: 'react-grid-checkbox',
	      type: 'checkbox',
	      name: 'select-all-checkbox',
	      id: 'select-all-checkbox',
	      ref: props.inputRef,
	      onChange: props.onChange
	    }),
	    _react2['default'].createElement('label', { htmlFor: 'select-all-checkbox', className: 'react-grid-checkbox-label' })
	  );
	};

	SelectAll.propTypes = {
	  onChange: _propTypes2['default'].func,
	  inputRef: _propTypes2['default'].func
	};

	exports['default'] = SelectAll;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var SimpleCellFormatter = function (_React$Component) {
	  _inherits(SimpleCellFormatter, _React$Component);

	  function SimpleCellFormatter() {
	    _classCallCheck(this, SimpleCellFormatter);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  SimpleCellFormatter.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return nextProps.value !== this.props.value;
	  };

	  SimpleCellFormatter.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      { title: this.props.value },
	      this.props.value
	    );
	  };

	  return SimpleCellFormatter;
	}(React.Component);

	SimpleCellFormatter.propTypes = {
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired
	};


	module.exports = SimpleCellFormatter;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	"use strict";

	function shallowCloneObject(obj) {
	  var result = {};
	  for (var k in obj) {
	    if (obj.hasOwnProperty(k)) {
	      result[k] = obj[k];
	    }
	  }
	  return result;
	}

	module.exports = shallowCloneObject;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _immutable = __webpack_require__(18);

	module.exports = {
	  isEmptyArray: __webpack_require__(131),
	  isEmptyObject: __webpack_require__(132),
	  isFunction: __webpack_require__(19),
	  isImmutableCollection: __webpack_require__(133),
	  getMixedTypeValueRetriever: __webpack_require__(135),
	  isColumnsImmutable: __webpack_require__(54),
	  isImmutableMap: __webpack_require__(134),
	  last: function last(arrayOrList) {
	    if (arrayOrList == null) {
	      throw new Error('arrayOrCollection is null');
	    }

	    if (_immutable.List.isList(arrayOrList)) {
	      return arrayOrList.last();
	    }

	    if (Array.isArray(arrayOrList)) {
	      return arrayOrList[arrayOrList.length - 1];
	    }

	    throw new Error('Cant get last of: ' + (typeof arrayOrList === 'undefined' ? 'undefined' : _typeof(arrayOrList)));
	  }
	};

/***/ }),
/* 54 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function isColumnsImmutable(columns) {
	  return typeof Immutable !== 'undefined' && columns instanceof Immutable.List;
	};

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	function isKeyPrintable(keycode) {
	  var valid = keycode > 47 && keycode < 58 || // number keys
	  keycode === 32 || keycode === 13 || // spacebar & return key(s) (if you want to allow carriage returns)
	  keycode > 64 && keycode < 91 || // letter keys
	  keycode > 95 && keycode < 112 || // numpad keys
	  keycode > 185 && keycode < 193 || // ;=,-./` (in order)
	  keycode > 218 && keycode < 223; // [\]' (in order)

	  return valid;
	}

	function isCtrlKeyHeldDown(e) {
	  return (e.ctrlKey === true || e.metaKey === true) && e.key !== 'Control';
	}

	exports.isKeyPrintable = isKeyPrintable;
	exports.isCtrlKeyHeldDown = isCtrlKeyHeldDown;

/***/ }),
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */
/***/ (function(module, exports) {

	module.exports = function shallowEqual(objA, objB, compare, compareContext) {

	    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

	    if(ret !== void 0) {
	        return !!ret;
	    }

	    if(objA === objB) {
	        return true;
	    }

	    if(typeof objA !== 'object' || !objA ||
	       typeof objB !== 'object' || !objB) {
	        return false;
	    }

	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);

	    if(keysA.length !== keysB.length) {
	        return false;
	    }

	    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

	    // Test for A's keys different from B.
	    for(var idx = 0; idx < keysA.length; idx++) {

	        var key = keysA[idx];

	        if(!bHasOwnProperty(key)) {
	            return false;
	        }

	        var valueA = objA[key];
	        var valueB = objB[key];

	        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

	        if(ret === false ||
	           ret === void 0 && valueA !== valueB) {
	            return false;
	        }

	    }

	    return true;

	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(139);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!./react-data-grid-checkbox.css", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!./react-data-grid-checkbox.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ }),
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _scrollUtils = __webpack_require__(136);

	var _shallowequal = __webpack_require__(69);

	var _shallowequal2 = _interopRequireDefault(_shallowequal);

	var _RowsContainer = __webpack_require__(45);

	var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

	var _RowGroup = __webpack_require__(121);

	var _RowGroup2 = _interopRequireDefault(_RowGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var joinClasses = __webpack_require__(5);

	var Row = __webpack_require__(42);
	var cellMetaDataShape = __webpack_require__(11);
	var RowUtils = __webpack_require__(44);

	__webpack_require__(20);

	var Canvas = function (_React$Component) {
	  _inherits(Canvas, _React$Component);

	  function Canvas() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Canvas);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      displayStart: _this.props.displayStart,
	      displayEnd: _this.props.displayEnd,
	      scrollingTimeout: null
	    }, _this._currentRowsLength = 0, _this._currentRowsRange = { start: 0, end: 0 }, _this._scroll = { scrollTop: 0, scrollLeft: 0 }, _this.appendScrollShim = function () {
	      if (!_this._scrollShim) {
	        var size = _this._scrollShimSize();
	        var shim = (0, _scrollUtils.createScrollShim)(size);
	        _this.canvas.appendChild(shim);
	        _this._scrollShim = shim;
	      }
	      _this._scheduleRemoveScrollShim();
	    }, _this._scrollShimSize = function () {
	      return {
	        width: _this.props.width,
	        height: _this.props.length * _this.props.rowHeight
	      };
	    }, _this._scheduleRemoveScrollShim = function () {
	      if (_this._scheduleRemoveScrollShimTimer) {
	        clearTimeout(_this._scheduleRemoveScrollShimTimer);
	      }
	      _this._scheduleRemoveScrollShimTimer = setTimeout(_this._removeScrollShim, 200);
	    }, _this._removeScrollShim = function () {
	      if (_this._scrollShim) {
	        _this._scrollShim.parentNode.removeChild(_this._scrollShim);
	        _this._scrollShim = undefined;
	      }
	    }, _this.onRows = function () {
	      if (_this._currentRowsRange !== { start: 0, end: 0 }) {
	        _this.props.onRows(_this._currentRowsRange);
	        _this._currentRowsRange = { start: 0, end: 0 };
	      }
	    }, _this.onScroll = function (e) {
	      if (_this.canvas !== e.target) {
	        return;
	      }
	      _this.appendScrollShim();
	      var scrollLeft = e.target.scrollLeft;
	      var scrollTop = e.target.scrollTop;
	      var scroll = { scrollTop: scrollTop, scrollLeft: scrollLeft };
	      _this._scroll = scroll;
	      _this.props.onScroll(scroll);
	    }, _this.getRows = function (displayStart, displayEnd) {
	      _this._currentRowsRange = { start: displayStart, end: displayEnd };
	      if (Array.isArray(_this.props.rowGetter)) {
	        return _this.props.rowGetter.slice(displayStart, displayEnd);
	      }
	      var rows = [];
	      var i = displayStart;
	      while (i < displayEnd) {
	        var row = _this.props.rowGetter(i);
	        var subRowDetails = {};
	        if (_this.props.getSubRowDetails) {
	          subRowDetails = _this.props.getSubRowDetails(row);
	        }
	        rows.push({ row: row, subRowDetails: subRowDetails });
	        i++;
	      }
	      return rows;
	    }, _this.getScrollbarWidth = function () {
	      // Get the scrollbar width
	      var scrollbarWidth = _this.canvas.offsetWidth - _this.canvas.clientWidth;
	      return scrollbarWidth;
	    }, _this.getScroll = function () {
	      var _this$canvas = _this.canvas,
	          scrollTop = _this$canvas.scrollTop,
	          scrollLeft = _this$canvas.scrollLeft;

	      return { scrollTop: scrollTop, scrollLeft: scrollLeft };
	    }, _this.isRowSelected = function (idx, row) {
	      // Use selectedRows if set
	      if (_this.props.selectedRows !== null) {
	        var selectedRows = _this.props.selectedRows.filter(function (r) {
	          var rowKeyValue = row.get ? row.get(_this.props.rowKey) : row[_this.props.rowKey];
	          return r[_this.props.rowKey] === rowKeyValue;
	        });
	        return selectedRows.length > 0 && selectedRows[0].isSelected;
	      }

	      // Else use new rowSelection props
	      if (_this.props.rowSelection) {
	        var _this$props$rowSelect = _this.props.rowSelection,
	            keys = _this$props$rowSelect.keys,
	            indexes = _this$props$rowSelect.indexes,
	            isSelectedKey = _this$props$rowSelect.isSelectedKey;

	        return RowUtils.isRowSelected(keys, indexes, isSelectedKey, row, idx);
	      }

	      return false;
	    }, _this.setScrollLeft = function (scrollLeft) {
	      if (_this._currentRowsLength !== 0) {
	        if (!_this.rows) return;
	        for (var i = 0, len = _this._currentRowsLength; i < len; i++) {
	          if (_this.rows[i]) {
	            var row = _this.getRowByRef(i);
	            if (row && row.setScrollLeft) {
	              row.setScrollLeft(scrollLeft);
	            }
	          }
	        }
	      }
	    }, _this.getRowByRef = function (i) {
	      // check if wrapped with React DND drop target
	      var wrappedRow = _this.rows[i].getDecoratedComponentInstance ? _this.rows[i].getDecoratedComponentInstance(i) : null;
	      if (wrappedRow) {
	        return wrappedRow.row;
	      }
	      return _this.rows[i];
	    }, _this.renderRow = function (props) {
	      var row = props.row;
	      if (row.__metaData && row.__metaData.getRowRenderer) {
	        return row.__metaData.getRowRenderer(_this.props, props.idx);
	      }
	      if (row.__metaData && row.__metaData.isGroup) {
	        return React.createElement(_RowGroup2['default'], _extends({}, props, row.__metaData, {
	          name: row.name,
	          renderer: _this.props.rowGroupRenderer }));
	      }
	      var RowsRenderer = _this.props.rowRenderer;
	      if (typeof RowsRenderer === 'function') {
	        return React.createElement(RowsRenderer, props);
	      }

	      if (React.isValidElement(_this.props.rowRenderer)) {
	        return React.cloneElement(_this.props.rowRenderer, props);
	      }
	    }, _this.renderPlaceholder = function (key, height) {
	      // just renders empty cells
	      // if we wanted to show gridlines, we'd need classes and position as with renderScrollingPlaceholder
	      return React.createElement(
	        'div',
	        { key: key, style: { height: height } },
	        _this.props.columns.map(function (column, idx) {
	          return React.createElement('div', { style: { width: column.width }, key: idx });
	        })
	      );
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Canvas.prototype.componentWillMount = function componentWillMount() {
	    this.rows = [];
	    this._currentRowsLength = 0;
	    this._currentRowsRange = { start: 0, end: 0 };
	    this._scroll = { scrollTop: 0, scrollLeft: 0 };
	  };

	  Canvas.prototype.componentDidMount = function componentDidMount() {
	    this.onRows();
	  };

	  Canvas.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.displayStart !== this.state.displayStart || nextProps.displayEnd !== this.state.displayEnd) {
	      this.setState({
	        displayStart: nextProps.displayStart,
	        displayEnd: nextProps.displayEnd
	      });
	    }
	  };

	  Canvas.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	    var shouldUpdate = nextState.displayStart !== this.state.displayStart || nextState.displayEnd !== this.state.displayEnd || nextState.scrollingTimeout !== this.state.scrollingTimeout || this.props.scrollToRowIndex !== nextProps.scrollToRowIndex || nextProps.rowsCount !== this.props.rowsCount || nextProps.rowHeight !== this.props.rowHeight || nextProps.columns !== this.props.columns || nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.cellMetaData !== this.props.cellMetaData || this.props.colDisplayStart !== nextProps.colDisplayStart || this.props.colDisplayEnd !== nextProps.colDisplayEnd || this.props.colVisibleStart !== nextProps.colVisibleStart || this.props.colVisibleEnd !== nextProps.colVisibleEnd || !(0, _shallowequal2['default'])(nextProps.style, this.props.style) || this.props.isScrolling !== nextProps.isScrolling;
	    return shouldUpdate;
	  };

	  Canvas.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._currentRowsLength = 0;
	    this._currentRowsRange = { start: 0, end: 0 };
	    this._scroll = { scrollTop: 0, scrollLeft: 0 };
	  };

	  Canvas.prototype.componentDidUpdate = function componentDidUpdate() {
	    if (this._scroll.scrollTop !== 0 && this._scroll.scrollLeft !== 0) {
	      this.setScrollLeft(this._scroll.scrollLeft);
	    }
	    if (this.props.scrollToRowIndex !== 0) {
	      this.canvas.scrollTop = Math.min(this.props.scrollToRowIndex * this.props.rowHeight, this.props.rowsCount * this.props.rowHeight - this.props.height);
	    }
	    this.onRows();
	  };

	  Canvas.prototype.render = function render() {
	    var _this2 = this;

	    var _state = this.state,
	        displayStart = _state.displayStart,
	        displayEnd = _state.displayEnd;
	    var _props = this.props,
	        rowHeight = _props.rowHeight,
	        rowsCount = _props.rowsCount;


	    var rows = this.getRows(displayStart, displayEnd).map(function (r, idx) {
	      return _this2.renderRow({
	        key: 'row-' + (displayStart + idx),
	        ref: function ref(node) {
	          return _this2.rows[idx] = node;
	        },
	        idx: displayStart + idx,
	        visibleStart: _this2.props.visibleStart,
	        visibleEnd: _this2.props.visibleEnd,
	        row: r.row,
	        height: rowHeight,
	        onMouseOver: _this2.onMouseOver,
	        columns: _this2.props.columns,
	        isSelected: _this2.isRowSelected(displayStart + idx, r.row, displayStart, displayEnd),
	        expandedRows: _this2.props.expandedRows,
	        cellMetaData: _this2.props.cellMetaData,
	        subRowDetails: r.subRowDetails,
	        colVisibleStart: _this2.props.colVisibleStart,
	        colVisibleEnd: _this2.props.colVisibleEnd,
	        colDisplayStart: _this2.props.colDisplayStart,
	        colDisplayEnd: _this2.props.colDisplayEnd,
	        isScrolling: _this2.props.isScrolling
	      });
	    });

	    this._currentRowsLength = rows.length;

	    if (displayStart > 0) {
	      rows.unshift(this.renderPlaceholder('top', displayStart * rowHeight));
	    }

	    if (rowsCount - displayEnd > 0) {
	      rows.push(this.renderPlaceholder('bottom', (rowsCount - displayEnd) * rowHeight));
	    }

	    var style = {
	      position: 'absolute',
	      top: 0,
	      left: 0,
	      overflowX: 'auto',
	      overflowY: 'scroll',
	      width: this.props.totalWidth,
	      height: this.props.height
	    };

	    return React.createElement(
	      'div',
	      {
	        ref: function ref(div) {
	          _this2.canvas = div;
	        },
	        style: style,
	        onScroll: this.onScroll,
	        className: joinClasses('react-grid-Canvas', this.props.className, { opaque: this.props.cellMetaData.selected && this.props.cellMetaData.selected.active }) },
	      React.createElement(_RowsContainer2['default'], {
	        width: this.props.width,
	        rows: rows,
	        contextMenu: this.props.contextMenu,
	        rowIdx: this.props.cellMetaData.selected.rowIdx,
	        idx: this.props.cellMetaData.selected.idx })
	    );
	  };

	  return Canvas;
	}(React.Component);

	Canvas.displayName = 'Canvas';
	Canvas.propTypes = {
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]),
	  rowHeight: _propTypes2['default'].number.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  width: _propTypes2['default'].number,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  style: _propTypes2['default'].string,
	  className: _propTypes2['default'].string,
	  displayStart: _propTypes2['default'].number.isRequired,
	  displayEnd: _propTypes2['default'].number.isRequired,
	  visibleStart: _propTypes2['default'].number.isRequired,
	  visibleEnd: _propTypes2['default'].number.isRequired,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  rowsCount: _propTypes2['default'].number.isRequired,
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].func.isRequired, _propTypes2['default'].array.isRequired]),
	  expandedRows: _propTypes2['default'].array,
	  onRows: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape).isRequired,
	  selectedRows: _propTypes2['default'].array,
	  rowKey: _propTypes2['default'].string,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  rowGroupRenderer: _propTypes2['default'].func,
	  isScrolling: _propTypes2['default'].bool,
	  length: _propTypes2['default'].number
	};
	Canvas.defaultProps = {
	  rowRenderer: Row,
	  onRows: function onRows() {},
	  selectedRows: [],
	  rowScrollTimeout: 0
	};


	module.exports = Canvas;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _CellActionShape = __webpack_require__(117);

	var _CellActionShape2 = _interopRequireDefault(_CellActionShape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellAction = function (_React$Component) {
	  _inherits(CellAction, _React$Component);

	  function CellAction() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, CellAction);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { isMenuOpen: false }, _this.onToggleMenu = function () {
	      _this.setState(function (prevState) {
	        return { isMenuOpen: !prevState.isMenuOpen };
	      });
	    }, _this.onHideMenu = function () {
	      _this.setState({ isMenuOpen: false });
	    }, _this.onGetMenuOptions = function () {
	      return _this.props.action.actions.map(function (action, index) {
	        return _react2['default'].createElement(
	          'span',
	          { key: index, onClick: action.callback },
	          action.text
	        );
	      });
	    }, _this.isActionMenu = function () {
	      return !_this.props.action.callback && _this.props.action.actions && _this.props.action.actions.length;
	    }, _this.onActionButtonBlur = function () {
	      if (_this.isActionMenu()) {
	        _this.onHideMenu();
	      }
	    }, _this.onActionIconClick = function () {
	      if (!_this.isActionMenu()) {
	        _this.props.action.callback();
	      } else if (_this.props.action.actions && _this.props.action.actions.length) {
	        _this.onToggleMenu();
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  CellAction.prototype.render = function render() {
	    var isActionMenu = this.isActionMenu();

	    var cellActionClasses = (0, _classnames2['default'])('rdg-cell-action', {
	      'rdg-cell-action-last': this.props.isFirst
	    });

	    var actionButtonClasses = (0, _classnames2['default'])('rdg-cell-action-button', {
	      'rdg-cell-action-button-toggled': this.state.isMenuOpen
	    });

	    return _react2['default'].createElement(
	      'div',
	      { className: cellActionClasses, onMouseLeave: this.onActionButtonBlur },
	      _react2['default'].createElement(
	        'div',
	        { className: actionButtonClasses, onClick: this.onActionIconClick },
	        _react2['default'].createElement('span', { className: this.props.action.icon })
	      ),
	      isActionMenu && this.state.isMenuOpen && _react2['default'].createElement(
	        'div',
	        { className: 'rdg-cell-action-menu' },
	        this.onGetMenuOptions()
	      )
	    );
	  };

	  return CellAction;
	}(_react2['default'].Component);

	CellAction.propTypes = {
	  action: _propTypes2['default'].shape(_CellActionShape2['default']).isRequired,
	  isFirst: _propTypes2['default'].bool.isRequired
	};
	exports['default'] = CellAction;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _AppConstants = __webpack_require__(30);

	var _AppConstants2 = _interopRequireDefault(_AppConstants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellExpand = function (_React$Component) {
	  _inherits(CellExpand, _React$Component);

	  function CellExpand(props) {
	    _classCallCheck(this, CellExpand);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.onCellExpand = function (e) {
	      _this.setState({ expanded: !_this.state.expanded });
	      _this.props.onCellExpand(e);
	    };

	    var expanded = props.expandableOptions && props.expandableOptions.expanded;
	    _this.state = { expanded: expanded };
	    return _this;
	  }

	  CellExpand.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    var expanded = nextProps.expandableOptions && nextProps.expandableOptions.expanded;
	    if (this.state.expanded !== expanded) {
	      this.setState({ expanded: expanded });
	    }
	  };

	  CellExpand.prototype.render = function render() {
	    return _react2['default'].createElement(
	      'span',
	      { className: 'rdg-cell-expand', onClick: this.onCellExpand },
	      this.state.expanded ? _AppConstants2['default'].CellExpand.DOWN_TRIANGLE : _AppConstants2['default'].CellExpand.RIGHT_TRIANGLE
	    );
	  };

	  return CellExpand;
	}(_react2['default'].Component);

	CellExpand.propTypes = {
	  expandableOptions: _propTypes2['default'].object.isRequired,
	  onCellExpand: _propTypes2['default'].func.isRequired
	};
	exports['default'] = CellExpand;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var ChildRowDeleteButton = function ChildRowDeleteButton(_ref) {
	  var treeDepth = _ref.treeDepth,
	      cellHeight = _ref.cellHeight,
	      siblingIndex = _ref.siblingIndex,
	      numberSiblings = _ref.numberSiblings,
	      onDeleteSubRow = _ref.onDeleteSubRow,
	      isDeleteSubRowEnabled = _ref.isDeleteSubRowEnabled,
	      _ref$allowAddChildRow = _ref.allowAddChildRow,
	      allowAddChildRow = _ref$allowAddChildRow === undefined ? true : _ref$allowAddChildRow;

	  var lastSibling = siblingIndex === numberSiblings - 1;
	  var className = (0, _classnames2['default'])({ 'rdg-child-row-action-cross': allowAddChildRow === true || !lastSibling }, { 'rdg-child-row-action-cross-last': allowAddChildRow === false && (lastSibling || numberSiblings === 1) });
	  var height = 12;
	  var width = 12;
	  var left = treeDepth * 15;
	  var top = (cellHeight - 12) / 2;
	  return _react2['default'].createElement(
	    'div',
	    null,
	    _react2['default'].createElement('div', { className: className }),
	    isDeleteSubRowEnabled && _react2['default'].createElement(
	      'div',
	      { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: onDeleteSubRow },
	      _react2['default'].createElement('div', { className: 'glyphicon glyphicon-remove-sign' })
	    )
	  );
	};

	exports['default'] = ChildRowDeleteButton;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var isValidElement = __webpack_require__(2).isValidElement;

	module.exports = function sameColumn(a, b) {
	  var k = void 0;

	  for (k in a) {
	    if (a.hasOwnProperty(k)) {
	      if (typeof a[k] === 'function' && typeof b[k] === 'function' || isValidElement(a[k]) && isValidElement(b[k])) {
	        continue;
	      }
	      if (!b.hasOwnProperty(k) || a[k] !== b[k]) {
	        return false;
	      }
	    }
	  }

	  for (k in b) {
	    if (b.hasOwnProperty(k) && !a.hasOwnProperty(k)) {
	      return false;
	    }
	  }

	  return true;
	};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(15);

	// The list of the propTypes that we want to include in the Draggable div
	var knownDivPropertyKeys = ['onDragStart', 'onDragEnd', 'onDrag', 'style'];

	var Draggable = function (_React$Component) {
	  _inherits(Draggable, _React$Component);

	  function Draggable() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Draggable);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      drag: null
	    }, _this.onMouseDown = function (e) {
	      var drag = _this.props.onDragStart(e);
	      if (e.preventDefault) {
	        e.preventDefault();
	      }

	      if (drag === null && e.button !== 0) {
	        return;
	      }

	      window.addEventListener('mouseup', _this.onMouseUp);
	      window.addEventListener('mousemove', _this.onMouseMove);
	      window.addEventListener('touchend', _this.onMouseUp);
	      window.addEventListener('touchmove', _this.onMouseMove);

	      _this.setState({ drag: drag });
	    }, _this.onMouseMove = function (e) {
	      if (_this.state.drag === null) {
	        return;
	      }

	      if (e.preventDefault) {
	        e.preventDefault();
	      }

	      _this.props.onDrag(e);
	    }, _this.onMouseUp = function (e) {
	      _this.cleanUp();
	      _this.props.onDragEnd(e, _this.state.drag);
	      _this.setState({ drag: null });
	    }, _this.cleanUp = function () {
	      window.removeEventListener('mouseup', _this.onMouseUp);
	      window.removeEventListener('mousemove', _this.onMouseMove);
	      window.removeEventListener('touchend', _this.onMouseUp);
	      window.removeEventListener('touchmove', _this.onMouseMove);
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Draggable.prototype.componentWillUnmount = function componentWillUnmount() {
	    this.cleanUp();
	  };

	  Draggable.prototype.render = function render() {
	    return React.createElement('div', _extends({}, this.getKnownDivProps(), {
	      onMouseDown: this.onMouseDown,
	      onTouchStart: this.onMouseDown,
	      className: 'react-grid-HeaderCell__draggable' }));
	  };

	  return Draggable;
	}(React.Component);

	Draggable.propTypes = {
	  onDragStart: _propTypes2['default'].func,
	  onDragEnd: _propTypes2['default'].func,
	  onDrag: _propTypes2['default'].func,
	  component: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].constructor]),
	  style: _propTypes2['default'].object
	};
	Draggable.defaultProps = {
	  onDragStart: function onDragStart() {
	    return true;
	  },
	  onDragEnd: function onDragEnd() {},
	  onDrag: function onDrag() {}
	};


	module.exports = Draggable;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EmptyChildRow = function (_React$Component) {
	  _inherits(EmptyChildRow, _React$Component);

	  function EmptyChildRow() {
	    _classCallCheck(this, EmptyChildRow);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this));

	    _this.onAddSubRow = _this.onAddSubRow.bind(_this);
	    return _this;
	  }

	  EmptyChildRow.prototype.onAddSubRow = function onAddSubRow() {
	    this.props.onAddSubRow(this.props.parentRowId);
	  };

	  EmptyChildRow.prototype.getFixedColumnsWidth = function getFixedColumnsWidth() {
	    var fixedWidth = 0;
	    var size = _ColumnUtils2['default'].getSize(this.props.columns);
	    for (var i = 0; i < size; i++) {
	      var column = _ColumnUtils2['default'].getColumn(this.props.columns, i);
	      if (column) {
	        if (_ColumnUtils2['default'].getValue(column, 'locked')) {
	          fixedWidth += _ColumnUtils2['default'].getValue(column, 'width');
	        }
	      }
	    }
	    return fixedWidth;
	  };

	  EmptyChildRow.prototype.render = function render() {
	    var _this2 = this;

	    var _props = this.props,
	        cellHeight = _props.cellHeight,
	        treeDepth = _props.treeDepth;

	    var height = 12;
	    var width = 12;
	    var left = treeDepth * 15;
	    var top = (cellHeight - 12) / 2;
	    var style = {
	      height: cellHeight,
	      borderBottom: '1px solid #dddddd'
	    };
	    var expandColumn = _ColumnUtils2['default'].getColumn(this.props.columns.filter(function (c) {
	      return c.key === _this2.props.expandColumnKey;
	    }), 0);

	    var cellLeft = expandColumn ? expandColumn.left : 0;
	    return _react2['default'].createElement(
	      'div',
	      { className: 'react-grid-Row rdg-add-child-row-container', style: style },
	      _react2['default'].createElement(
	        'div',
	        { className: 'react-grid-Cell', style: { position: 'absolute', height: cellHeight, width: '100%', left: cellLeft } },
	        _react2['default'].createElement(
	          'div',
	          { className: 'rdg-empty-child-row', style: { marginLeft: '30px', lineHeight: cellHeight + 'px' } },
	          _react2['default'].createElement('div', { className: '\'rdg-child-row-action-cross rdg-child-row-action-cross-last' }),
	          _react2['default'].createElement(
	            'div',
	            { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: this.onAddSubRow },
	            _react2['default'].createElement('div', { className: 'glyphicon glyphicon-plus-sign' })
	          )
	        )
	      )
	    );
	  };

	  return EmptyChildRow;
	}(_react2['default'].Component);

	EmptyChildRow.propTypes = {
	  treeDepth: _propTypes2['default'].number.isRequired,
	  cellHeight: _propTypes2['default'].number.isRequired,
	  onAddSubRow: _propTypes2['default'].func.isRequired,
	  parentRowId: _propTypes2['default'].number,
	  columns: _propTypes2['default'].array.isRequired,
	  expandColumnKey: _propTypes2['default'].string.isRequired
	};

	exports['default'] = EmptyChildRow;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);

	var Header = __webpack_require__(112);
	var Viewport = __webpack_require__(122);
	var cellMetaDataShape = __webpack_require__(11);
	__webpack_require__(20);

	var Grid = function (_React$Component) {
	  _inherits(Grid, _React$Component);

	  function Grid() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Grid);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getStyle = function () {
	      return {
	        overflow: 'hidden',
	        outline: 0,
	        position: 'relative',
	        minHeight: _this.props.minHeight
	      };
	    }, _this._onScroll = function () {
	      if (_this._scrollLeft !== undefined) {
	        _this.header.setScrollLeft(_this._scrollLeft);
	        if (_this.viewport) {
	          _this.viewport.setScrollLeft(_this._scrollLeft);
	        }
	      }
	    }, _this.onScroll = function (props) {
	      if (_this._scrollLeft !== props.scrollLeft) {
	        _this._scrollLeft = props.scrollLeft;
	        _this._onScroll();
	      }
	    }, _this.onHeaderScroll = function (e) {
	      var scrollLeft = e.target.scrollLeft;
	      if (_this._scrollLeft !== scrollLeft) {
	        _this._scrollLeft = scrollLeft;
	        _this.header.setScrollLeft(scrollLeft);
	        var canvas = ReactDOM.findDOMNode(_this.viewport.canvas);
	        canvas.scrollLeft = scrollLeft;
	        _this.viewport.canvas.setScrollLeft(scrollLeft);
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Grid.prototype.componentDidMount = function componentDidMount() {
	    this._scrollLeft = this.viewport ? this.viewport.getScroll().scrollLeft : 0;
	    this._onScroll();
	  };

	  Grid.prototype.componentDidUpdate = function componentDidUpdate() {
	    this._onScroll();
	  };

	  Grid.prototype.componentWillMount = function componentWillMount() {
	    this._scrollLeft = undefined;
	  };

	  Grid.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._scrollLeft = undefined;
	  };

	  Grid.prototype.render = function render() {
	    var _this2 = this;

	    var headerRows = this.props.headerRows || [{ ref: function ref(node) {
	        return _this2.row = node;
	      } }];
	    var EmptyRowsView = this.props.emptyRowsView;

	    return React.createElement(
	      'div',
	      { style: this.getStyle(), className: 'react-grid-Grid' },
	      React.createElement(Header, {
	        ref: function ref(input) {
	          _this2.header = input;
	        },
	        columnMetrics: this.props.columnMetrics,
	        onColumnResize: this.props.onColumnResize,
	        height: this.props.rowHeight,
	        totalWidth: this.props.totalWidth,
	        headerRows: headerRows,
	        sortColumn: this.props.sortColumn,
	        sortDirection: this.props.sortDirection,
	        draggableHeaderCell: this.props.draggableHeaderCell,
	        onSort: this.props.onSort,
	        onHeaderDrop: this.props.onHeaderDrop,
	        onScroll: this.onHeaderScroll,
	        getValidFilterValues: this.props.getValidFilterValues,
	        cellMetaData: this.props.cellMetaData
	      }),
	      this.props.rowsCount >= 1 || this.props.rowsCount === 0 && !this.props.emptyRowsView ? React.createElement(
	        'div',
	        {
	          ref: function ref(node) {
	            _this2.viewPortContainer = node;
	          },
	          tabIndex: this.props.tabIndex,
	          onKeyDown: this.props.onViewportKeydown,
	          onKeyUp: this.props.onViewportKeyup,
	          onClick: this.props.onViewportClick,
	          onDoubleClick: this.props.onViewportDoubleClick,
	          onDragStart: this.props.onViewportDragStart,
	          onDragEnd: this.props.onViewportDragEnd },
	        React.createElement(Viewport, {
	          ref: function ref(node) {
	            _this2.viewport = node;
	          },
	          rowKey: this.props.rowKey,
	          width: this.props.columnMetrics.width,
	          rowHeight: this.props.rowHeight,
	          rowRenderer: this.props.rowRenderer,
	          rowGetter: this.props.rowGetter,
	          rowsCount: this.props.rowsCount,
	          selectedRows: this.props.selectedRows,
	          expandedRows: this.props.expandedRows,
	          columnMetrics: this.props.columnMetrics,
	          totalWidth: this.props.totalWidth,
	          onScroll: this.onScroll,
	          onRows: this.props.onRows,
	          cellMetaData: this.props.cellMetaData,
	          rowOffsetHeight: this.props.rowOffsetHeight || this.props.rowHeight * headerRows.length,
	          minHeight: this.props.minHeight,
	          rowScrollTimeout: this.props.rowScrollTimeout,
	          scrollToRowIndex: this.props.scrollToRowIndex,
	          contextMenu: this.props.contextMenu,
	          rowSelection: this.props.rowSelection,
	          getSubRowDetails: this.props.getSubRowDetails,
	          rowGroupRenderer: this.props.rowGroupRenderer,
	          overScan: this.props.overScan
	        })
	      ) : React.createElement(
	        'div',
	        { ref: function ref(node) {
	            _this2.emptyView = node;
	          }, className: 'react-grid-Empty' },
	        React.createElement(EmptyRowsView, null)
	      )
	    );
	  };

	  return Grid;
	}(React.Component);

	Grid.displayName = 'Grid';
	Grid.propTypes = {
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]),
	  tabIndex: _propTypes2['default'].number,
	  columnMetrics: _propTypes2['default'].object,
	  minHeight: _propTypes2['default'].number,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  headerRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  rowHeight: _propTypes2['default'].number,
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
	  emptyRowsView: _propTypes2['default'].func,
	  expandedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  selectedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  rowsCount: _propTypes2['default'].number,
	  onRows: _propTypes2['default'].func,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
	  rowOffsetHeight: _propTypes2['default'].number.isRequired,
	  onViewportKeydown: _propTypes2['default'].func.isRequired,
	  onViewportKeyup: _propTypes2['default'].func,
	  onViewportDragStart: _propTypes2['default'].func.isRequired,
	  onViewportDragEnd: _propTypes2['default'].func.isRequired,
	  onViewportClick: _propTypes2['default'].func.isRequired,
	  onViewportDoubleClick: _propTypes2['default'].func.isRequired,
	  onColumnResize: _propTypes2['default'].func,
	  onSort: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  rowKey: _propTypes2['default'].string.isRequired,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func,
	  overScan: _propTypes2['default'].object
	};
	Grid.defaultProps = {
	  rowHeight: 35,
	  minHeight: 350,
	  tabIndex: 0
	};


	module.exports = Grid;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(9);
	var joinClasses = __webpack_require__(5);
	var shallowCloneObject = __webpack_require__(52);
	var ColumnMetrics = __webpack_require__(31);
	var ColumnUtils = __webpack_require__(6);
	var HeaderRow = __webpack_require__(114);
	var getScrollbarSize = __webpack_require__(32);

	var createObjectWithProperties = __webpack_require__(14);
	var cellMetaDataShape = __webpack_require__(11);
	__webpack_require__(15);

	// The list of the propTypes that we want to include in the Header div
	var knownDivPropertyKeys = ['height', 'onScroll'];

	var Header = function (_React$Component) {
	  _inherits(Header, _React$Component);

	  function Header() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Header);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: null }, _this.onColumnResize = function (column, width) {
	      var state = _this.state.resizing || _this.props;

	      var pos = _this.getColumnPosition(column);

	      if (pos != null) {
	        var _resizing = {
	          columnMetrics: shallowCloneObject(state.columnMetrics)
	        };
	        _resizing.columnMetrics = ColumnMetrics.resizeColumn(_resizing.columnMetrics, pos, width);

	        // we don't want to influence scrollLeft while resizing
	        if (_resizing.columnMetrics.totalWidth < state.columnMetrics.totalWidth) {
	          _resizing.columnMetrics.totalWidth = state.columnMetrics.totalWidth;
	        }

	        _resizing.column = ColumnUtils.getColumn(_resizing.columnMetrics.columns, pos);
	        _this.setState({ resizing: _resizing });
	      }
	    }, _this.onColumnResizeEnd = function (column, width) {
	      var pos = _this.getColumnPosition(column);
	      if (pos !== null && _this.props.onColumnResize) {
	        _this.props.onColumnResize(pos, width || column.width);
	      }
	    }, _this.getHeaderRows = function () {
	      var columnMetrics = _this.getColumnMetrics();
	      var resizeColumn = void 0;
	      if (_this.state.resizing) {
	        resizeColumn = _this.state.resizing.column;
	      }
	      var headerRows = [];
	      _this.props.headerRows.forEach(function (row, index) {
	        // To allow header filters to be visible
	        var rowHeight = 'auto';
	        if (row.rowType === 'filter') {
	          rowHeight = '500px';
	        }
	        var scrollbarSize = getScrollbarSize() > 0 ? getScrollbarSize() : 0;
	        var updatedWidth = isNaN(_this.props.totalWidth - scrollbarSize) ? _this.props.totalWidth : _this.props.totalWidth - scrollbarSize;
	        var headerRowStyle = {
	          position: 'absolute',
	          top: _this.getCombinedHeaderHeights(index),
	          left: 0,
	          width: updatedWidth,
	          overflowX: 'hidden',
	          minHeight: rowHeight
	        };

	        headerRows.push(React.createElement(HeaderRow, {
	          key: row.ref,
	          ref: function ref(node) {
	            return row.rowType === 'filter' ? _this.filterRow = node : _this.row = node;
	          },
	          rowType: row.rowType,
	          style: headerRowStyle,
	          onColumnResize: _this.onColumnResize,
	          onColumnResizeEnd: _this.onColumnResizeEnd,
	          width: columnMetrics.width,
	          height: row.height || _this.props.height,
	          columns: columnMetrics.columns,
	          resizing: resizeColumn,
	          draggableHeaderCell: _this.props.draggableHeaderCell,
	          filterable: row.filterable,
	          onFilterChange: row.onFilterChange,
	          onHeaderDrop: _this.props.onHeaderDrop,
	          sortColumn: _this.props.sortColumn,
	          sortDirection: _this.props.sortDirection,
	          onSort: _this.props.onSort,
	          onScroll: _this.props.onScroll,
	          getValidFilterValues: _this.props.getValidFilterValues
	        }));
	      });
	      return headerRows;
	    }, _this.getColumnMetrics = function () {
	      var columnMetrics = void 0;
	      if (_this.state.resizing) {
	        columnMetrics = _this.state.resizing.columnMetrics;
	      } else {
	        columnMetrics = _this.props.columnMetrics;
	      }
	      return columnMetrics;
	    }, _this.getColumnPosition = function (column) {
	      var columnMetrics = _this.getColumnMetrics();
	      var pos = -1;
	      columnMetrics.columns.forEach(function (c, idx) {
	        if (c.key === column.key) {
	          pos = idx;
	        }
	      });
	      return pos === -1 ? null : pos;
	    }, _this.getCombinedHeaderHeights = function (until) {
	      var stopAt = _this.props.headerRows.length;
	      if (typeof until !== 'undefined') {
	        stopAt = until;
	      }

	      var height = 0;
	      for (var index = 0; index < stopAt; index++) {
	        height += _this.props.headerRows[index].height || _this.props.height;
	      }
	      return height;
	    }, _this.getStyle = function () {
	      return {
	        position: 'relative',
	        height: _this.getCombinedHeaderHeights()
	      };
	    }, _this.setScrollLeft = function (scrollLeft) {
	      var node = ReactDOM.findDOMNode(_this.row);
	      node.scrollLeft = scrollLeft;
	      _this.row.setScrollLeft(scrollLeft);
	      if (_this.filterRow) {
	        var nodeFilters = ReactDOM.findDOMNode(_this.filterRow);
	        nodeFilters.scrollLeft = scrollLeft;
	        _this.filterRow.setScrollLeft(scrollLeft);
	      }
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _this.onHeaderClick = function () {
	      _this.props.cellMetaData.onCellClick({ rowIdx: -1, idx: -1 });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Header.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
	    this.setState({ resizing: null });
	  };

	  Header.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	    var update = !ColumnMetrics.sameColumns(this.props.columnMetrics.columns, nextProps.columnMetrics.columns, ColumnMetrics.sameColumn) || this.props.totalWidth !== nextProps.totalWidth || this.props.headerRows.length !== nextProps.headerRows.length || this.state.resizing !== nextState.resizing || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
	    return update;
	  };

	  // Set the cell selection to -1 x -1 when clicking on the header


	  Header.prototype.render = function render() {
	    var className = joinClasses({
	      'react-grid-Header': true,
	      'react-grid-Header--resizing': !!this.state.resizing
	    });
	    var headerRows = this.getHeaderRows();

	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { style: this.getStyle(), className: className, onClick: this.onHeaderClick }),
	      headerRows
	    );
	  };

	  return Header;
	}(React.Component);

	Header.propTypes = {
	  columnMetrics: _propTypes2['default'].shape({ width: _propTypes2['default'].number.isRequired, columns: _propTypes2['default'].any }).isRequired,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number.isRequired,
	  headerRows: _propTypes2['default'].array.isRequired,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
	  onSort: _propTypes2['default'].func,
	  onColumnResize: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape)
	};


	module.exports = Header;

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";

	var HeaderCellType = {
	  SORTABLE: 0,
	  FILTERABLE: 1,
	  NONE: 2,
	  CHECKBOX: 3
	};

	module.exports = HeaderCellType;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var shallowEqual = __webpack_require__(69);
	var BaseHeaderCell = __webpack_require__(41);
	var getScrollbarSize = __webpack_require__(32);
	var ExcelColumn = __webpack_require__(12);
	var columnUtils = __webpack_require__(6);
	var SortableHeaderCell = __webpack_require__(46);
	var FilterableHeaderCell = __webpack_require__(123);
	var HeaderCellType = __webpack_require__(113);
	var createObjectWithProperties = __webpack_require__(14);
	__webpack_require__(15);

	var HeaderRowStyle = {
	  overflow: _propTypes2['default'].string,
	  width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number,
	  position: _propTypes2['default'].string
	};

	// The list of the propTypes that we want to include in the HeaderRow div
	var knownDivPropertyKeys = ['width', 'height', 'style', 'onScroll'];

	var HeaderRow = function (_React$Component) {
	  _inherits(HeaderRow, _React$Component);

	  function HeaderRow() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, HeaderRow);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.getHeaderCellType = function (column) {
	      if (column.filterable) {
	        if (_this.props.filterable) return HeaderCellType.FILTERABLE;
	      }

	      if (column.sortable && column.rowType !== 'filter') return HeaderCellType.SORTABLE;

	      return HeaderCellType.NONE;
	    }, _this.getFilterableHeaderCell = function (column) {
	      var FilterRenderer = FilterableHeaderCell;
	      if (column.filterRenderer !== undefined) {
	        FilterRenderer = column.filterRenderer;
	      }
	      return React.createElement(FilterRenderer, _extends({}, _this.props, { onChange: _this.props.onFilterChange }));
	    }, _this.getSortableHeaderCell = function (column) {
	      var sortDirection = _this.props.sortColumn === column.key ? _this.props.sortDirection : SortableHeaderCell.DEFINE_SORT.NONE;
	      var sortDescendingFirst = column.sortDescendingFirst === undefined ? false : column.sortDescendingFirst;
	      return React.createElement(SortableHeaderCell, { columnKey: column.key, onSort: _this.props.onSort, sortDirection: sortDirection, sortDescendingFirst: sortDescendingFirst, headerRenderer: column.headerRenderer });
	    }, _this.getHeaderRenderer = function (column) {
	      var renderer = void 0;
	      if (column.headerRenderer && !column.sortable && !_this.props.filterable) {
	        renderer = column.headerRenderer;
	      } else {
	        var headerCellType = _this.getHeaderCellType(column);
	        switch (headerCellType) {
	          case HeaderCellType.SORTABLE:
	            renderer = _this.getSortableHeaderCell(column);
	            break;
	          case HeaderCellType.FILTERABLE:
	            renderer = _this.getFilterableHeaderCell(column);
	            break;
	          default:
	            break;
	        }
	      }
	      return renderer;
	    }, _this.getStyle = function () {
	      return {
	        overflow: 'hidden',
	        width: '100%',
	        height: _this.props.height,
	        position: 'absolute'
	      };
	    }, _this.getCells = function () {
	      var cells = [];
	      var lockedCells = [];

	      var _loop = function _loop(i, len) {
	        var column = Object.assign({ rowType: _this.props.rowType }, columnUtils.getColumn(_this.props.columns, i));
	        var _renderer = _this.getHeaderRenderer(column);
	        if (column.key === 'select-row' && _this.props.rowType === 'filter') {
	          _renderer = React.createElement('div', null);
	        }
	        var HeaderCell = column.draggable ? _this.props.draggableHeaderCell : BaseHeaderCell;
	        var cell = React.createElement(HeaderCell, {
	          ref: function ref(node) {
	            return _this.cells[i] = node;
	          },
	          key: i,
	          height: _this.props.height,
	          column: column,
	          renderer: _renderer,
	          resizing: _this.props.resizing === column,
	          onResize: _this.props.onColumnResize,
	          onResizeEnd: _this.props.onColumnResizeEnd,
	          onHeaderDrop: _this.props.onHeaderDrop
	        });
	        if (column.locked) {
	          lockedCells.push(cell);
	        } else {
	          cells.push(cell);
	        }
	      };

	      for (var i = 0, len = columnUtils.getSize(_this.props.columns); i < len; i++) {
	        _loop(i, len);
	      }

	      return cells.concat(lockedCells);
	    }, _this.setScrollLeft = function (scrollLeft) {
	      _this.props.columns.forEach(function (column, i) {
	        if (column.locked) {
	          _this.cells[i].setScrollLeft(scrollLeft);
	        } else {
	          if (_this.cells[i] && _this.cells[i].removeScroll) {
	            _this.cells[i].removeScroll();
	          }
	        }
	      });
	    }, _this.getKnownDivProps = function () {
	      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  HeaderRow.prototype.componentWillMount = function componentWillMount() {
	    this.cells = [];
	  };

	  HeaderRow.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.columns !== this.props.columns || !shallowEqual(nextProps.style, this.props.style) || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
	  };

	  HeaderRow.prototype.render = function render() {
	    var cellsStyle = {
	      width: this.props.width ? this.props.width + getScrollbarSize() : '100%',
	      height: this.props.height,
	      whiteSpace: 'nowrap',
	      overflowX: 'hidden',
	      overflowY: 'hidden'
	    };

	    var cells = this.getCells();
	    return React.createElement(
	      'div',
	      _extends({}, this.getKnownDivProps(), { className: 'react-grid-HeaderRow' }),
	      React.createElement(
	        'div',
	        { style: cellsStyle },
	        cells
	      )
	    );
	  };

	  return HeaderRow;
	}(React.Component);

	HeaderRow.displayName = 'HeaderRow';
	HeaderRow.propTypes = {
	  width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]).isRequired,
	  onColumnResize: _propTypes2['default'].func,
	  onSort: _propTypes2['default'].func.isRequired,
	  onColumnResizeEnd: _propTypes2['default'].func,
	  style: _propTypes2['default'].shape(HeaderRowStyle),
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(SortableHeaderCell.DEFINE_SORT)),
	  cellRenderer: _propTypes2['default'].func,
	  headerCellRenderer: _propTypes2['default'].func,
	  filterable: _propTypes2['default'].bool,
	  onFilterChange: _propTypes2['default'].func,
	  resizing: _propTypes2['default'].object,
	  onScroll: _propTypes2['default'].func,
	  rowType: _propTypes2['default'].string,
	  draggableHeaderCell: _propTypes2['default'].func,
	  onHeaderDrop: _propTypes2['default'].func
	};


	module.exports = HeaderRow;

/***/ }),
/* 115 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	  Backspace: 8,
	  Tab: 9,
	  Enter: 13,
	  Shift: 16,
	  Ctrl: 17,
	  Alt: 18,
	  PauseBreak: 19,
	  CapsLock: 20,
	  Escape: 27,
	  PageUp: 33,
	  PageDown: 34,
	  End: 35,
	  Home: 36,
	  LeftArrow: 37,
	  UpArrow: 38,
	  RightArrow: 39,
	  DownArrow: 40,
	  Insert: 45,
	  Delete: 46,
	  0: 48,
	  1: 49,
	  2: 50,
	  3: 51,
	  4: 52,
	  5: 53,
	  6: 54,
	  7: 55,
	  8: 56,
	  9: 57,
	  a: 65,
	  b: 66,
	  c: 67,
	  d: 68,
	  e: 69,
	  f: 70,
	  g: 71,
	  h: 72,
	  i: 73,
	  j: 74,
	  k: 75,
	  l: 76,
	  m: 77,
	  n: 78,
	  o: 79,
	  p: 80,
	  q: 81,
	  r: 82,
	  s: 83,
	  t: 84,
	  u: 85,
	  v: 86,
	  w: 87,
	  x: 88,
	  y: 89,
	  z: 90,
	  LeftWindowKey: 91,
	  RightWindowKey: 92,
	  SelectKey: 93,
	  NumPad0: 96,
	  NumPad1: 97,
	  NumPad2: 98,
	  NumPad3: 99,
	  NumPad4: 100,
	  NumPad5: 101,
	  NumPad6: 102,
	  NumPad7: 103,
	  NumPad8: 104,
	  NumPad9: 105,
	  Multiply: 106,
	  Add: 107,
	  Subtract: 109,
	  DecimalPoint: 110,
	  Divide: 111,
	  F1: 112,
	  F2: 113,
	  F3: 114,
	  F4: 115,
	  F5: 116,
	  F6: 117,
	  F7: 118,
	  F8: 119,
	  F9: 120,
	  F10: 121,
	  F12: 123,
	  NumLock: 144,
	  ScrollLock: 145,
	  SemiColon: 186,
	  EqualSign: 187,
	  Comma: 188,
	  Dash: 189,
	  Period: 190,
	  ForwardSlash: 191,
	  GraveAccent: 192,
	  OpenBracket: 219,
	  BackSlash: 220,
	  CloseBracket: 221,
	  SingleQuote: 222
	};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.OverflowCellComponent = undefined;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _focusableComponentWrapper = __webpack_require__(126);

	var _focusableComponentWrapper2 = _interopRequireDefault(_focusableComponentWrapper);

	__webpack_require__(37);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var OverflowCell = function (_React$Component) {
	  _inherits(OverflowCell, _React$Component);

	  function OverflowCell() {
	    _classCallCheck(this, OverflowCell);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  OverflowCell.prototype.getStyle = function getStyle() {
	    var style = {
	      position: 'absolute',
	      width: this.props.column.width,
	      height: this.props.height,
	      left: this.props.column.left,
	      border: '1px solid #eee'
	    };
	    return style;
	  };

	  OverflowCell.prototype.render = function render() {
	    return _react2['default'].createElement('div', { tabIndex: '-1', style: this.getStyle(), width: '100%', className: 'react-grid-Cell' });
	  };

	  return OverflowCell;
	}(_react2['default'].Component);

	OverflowCell.isSelected = function (props) {
	  var cellMetaData = props.cellMetaData,
	      rowIdx = props.rowIdx,
	      idx = props.idx;

	  if (cellMetaData == null) {
	    return false;
	  }

	  var selected = cellMetaData.selected;


	  return selected && selected.rowIdx === rowIdx && selected.idx === idx;
	};

	OverflowCell.isScrolling = function (props) {
	  return props.cellMetaData.isScrollingHorizontallyWithKeyboard;
	};

	OverflowCell.propTypes = {
	  rowIdx: _propTypes2['default'].number,
	  idx: _propTypes2['default'].number,
	  height: _propTypes2['default'].number,
	  column: _propTypes2['default'].object,
	  cellMetaData: _propTypes2['default'].object
	};

	OverflowCell.displayName = 'Cell';

	var OverflowCellComponent = OverflowCell;
	exports['default'] = (0, _focusableComponentWrapper2['default'])(OverflowCell);
	exports.OverflowCellComponent = OverflowCellComponent;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var CellActionShape = {
	  icon: _propTypes2['default'].string.isRequired,
	  callback: _propTypes2['default'].func,
	  actions: _propTypes2['default'].arrayOf(_propTypes2['default'].shape({
	    text: _propTypes2['default'].string,
	    callback: _propTypes2['default'].func
	  }))
	};

	exports['default'] = CellActionShape;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _ExcelColumn = __webpack_require__(12);

	var _ExcelColumn2 = _interopRequireDefault(_ExcelColumn);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports['default'] = { ExcelColumn: _ExcelColumn2['default'] };

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _SelectAll = __webpack_require__(50);

	var _SelectAll2 = _interopRequireDefault(_SelectAll);

	var _AppConstants = __webpack_require__(30);

	var _AppConstants2 = _interopRequireDefault(_AppConstants);

	var _SortableHeaderCell = __webpack_require__(46);

	var _keyboardUtils = __webpack_require__(55);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var BaseGrid = __webpack_require__(111);
	var CheckboxEditor = __webpack_require__(47);
	var RowUtils = __webpack_require__(44);
	var ColumnUtils = __webpack_require__(6);
	var KeyCodes = __webpack_require__(115);
	var isFunction = __webpack_require__(19);

	var ColumnMetrics = __webpack_require__(31);
	__webpack_require__(20);
	__webpack_require__(70);

	if (!Object.assign) {
	  Object.assign = __webpack_require__(146);
	}

	var ReactDataGrid = function (_React$Component) {
	  _inherits(ReactDataGrid, _React$Component);

	  function ReactDataGrid(props, context) {
	    _classCallCheck(this, ReactDataGrid);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

	    _initialiseProps.call(_this);

	    var columnMetrics = _this.createColumnMetrics();
	    var initialState = { columnMetrics: columnMetrics, selectedRows: [], copied: null, expandedRows: [], canFilter: false, columnFilters: {}, sortDirection: null, sortColumn: null, dragged: null, scrollOffset: 0, lastRowIdxUiSelected: -1 };
	    if (props.enableCellSelect) {
	      initialState.selected = { rowIdx: 0, idx: 0 };
	    } else {
	      initialState.selected = { rowIdx: -1, idx: -1 };
	    }

	    if (_this.props.sortColumn && _this.props.sortDirection) {
	      initialState.sortColumn = _this.props.sortColumn;
	      initialState.sortDirection = _this.props.sortDirection;
	    }

	    _this.state = initialState;
	    return _this;
	  }

	  ReactDataGrid.prototype.componentWillMount = function componentWillMount() {
	    this._mounted = true;
	  };

	  ReactDataGrid.prototype.componentDidMount = function componentDidMount() {
	    if (window.addEventListener) {
	      window.addEventListener('resize', this.metricsUpdated);
	    } else {
	      window.attachEvent('resize', this.metricsUpdated);
	    }
	    this.metricsUpdated();
	  };

	  ReactDataGrid.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._mounted = false;
	    window.removeEventListener('resize', this.metricsUpdated);
	  };

	  ReactDataGrid.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.columns) {
	      if (!ColumnMetrics.sameColumns(this.props.columns, nextProps.columns, this.props.columnEquality) || nextProps.minWidth !== this.props.minWidth) {
	        var columnMetrics = this.createColumnMetrics(nextProps);
	        this.setState({ columnMetrics: columnMetrics });
	      }
	    }
	  };

	  // return false if not a shift select so can be handled as normal row selection


	  // columnKey not used here as this function will select the whole row,
	  // but needed to match the function signature in the CheckboxEditor


	  ReactDataGrid.prototype.render = function render() {
	    var _this2 = this;

	    var cellMetaData = {
	      rowKey: this.props.rowKey,
	      selected: this.state.selected,
	      dragged: this.state.dragged,
	      hoveredRowIdx: this.state.hoveredRowIdx,
	      onCellClick: this.onCellClick,
	      onCellFocus: this.onCellFocus,
	      onCellContextMenu: this.onCellContextMenu,
	      onCellDoubleClick: this.onCellDoubleClick,
	      onCommit: this.onCellCommit,
	      onCommitCancel: this.setInactive,
	      copied: this.state.copied,
	      handleDragEnterRow: this.handleDragEnter,
	      handleTerminateDrag: this.handleTerminateDrag,
	      enableCellSelect: this.props.enableCellSelect,
	      onColumnEvent: this.onColumnEvent,
	      openCellEditor: this.openCellEditor,
	      onDragHandleDoubleClick: this.onDragHandleDoubleClick,
	      onCellExpand: this.onCellExpand,
	      onRowExpandToggle: this.onRowExpandToggle,
	      onRowHover: this.onRowHover,
	      getDataGridDOMNode: this.getDataGridDOMNode,
	      getCellActions: this.props.getCellActions,
	      onDeleteSubRow: this.props.onDeleteSubRow,
	      onAddSubRow: this.props.onAddSubRow,
	      isScrollingVerticallyWithKeyboard: this.isKeyDown(KeyCodes.DownArrow) || this.isKeyDown(KeyCodes.UpArrow),
	      isScrollingHorizontallyWithKeyboard: this.isKeyDown(KeyCodes.LeftArrow) || this.isKeyDown(KeyCodes.RightArrow) || this.isKeyDown(KeyCodes.Tab),
	      enableCellAutoFocus: this.props.enableCellAutoFocus
	    };

	    var toolbar = this.renderToolbar();
	    var containerWidth = this.props.minWidth || this.gridWidth();
	    var gridWidth = containerWidth - this.state.scrollOffset;

	    // depending on the current lifecycle stage, gridWidth() may not initialize correctly
	    // this also handles cases where it always returns undefined -- such as when inside a div with display:none
	    // eg Bootstrap tabs and collapses
	    if (typeof containerWidth === 'undefined' || isNaN(containerWidth) || containerWidth === 0) {
	      containerWidth = '100%';
	    }
	    if (typeof gridWidth === 'undefined' || isNaN(gridWidth) || gridWidth === 0) {
	      gridWidth = '100%';
	    }
	    return React.createElement(
	      'div',
	      { className: 'react-grid-Container', style: { width: containerWidth },
	        ref: function ref(node) {
	          _this2.grid = node;
	        } },
	      toolbar,
	      React.createElement(
	        'div',
	        { className: 'react-grid-Main' },
	        React.createElement(BaseGrid, _extends({
	          ref: function ref(node) {
	            return _this2.base = node;
	          }
	        }, this.props, {
	          rowKey: this.props.rowKey,
	          headerRows: this.getHeaderRows(),
	          columnMetrics: this.state.columnMetrics,
	          rowGetter: this.props.rowGetter,
	          rowsCount: this.props.rowsCount,
	          rowHeight: this.props.rowHeight,
	          cellMetaData: cellMetaData,
	          selectedRows: this.getSelectedRows(),
	          rowSelection: this.getRowSelectionProps(),
	          expandedRows: this.state.expandedRows,
	          rowOffsetHeight: this.getRowOffsetHeight(),
	          sortColumn: this.state.sortColumn,
	          sortDirection: this.state.sortDirection,
	          onSort: this.handleSort,
	          minHeight: this.props.minHeight,
	          totalWidth: gridWidth,
	          onViewportKeydown: this.onKeyDown,
	          onViewportKeyup: this.onKeyUp,
	          onViewportDragStart: this.onDragStart,
	          onViewportDragEnd: this.handleDragEnd,
	          onViewportClick: this.deselect,
	          onViewportDoubleClick: this.deselect,
	          onColumnResize: this.onColumnResize,
	          rowScrollTimeout: this.props.rowScrollTimeout,
	          scrollToRowIndex: this.props.scrollToRowIndex,
	          contextMenu: this.props.contextMenu,
	          overScan: this.props.overScan }))
	      )
	    );
	  };

	  return ReactDataGrid;
	}(React.Component);

	ReactDataGrid.displayName = 'ReactDataGrid';
	ReactDataGrid.propTypes = {
	  rowHeight: _propTypes2['default'].number.isRequired,
	  headerRowHeight: _propTypes2['default'].number,
	  headerFiltersHeight: _propTypes2['default'].number,
	  minHeight: _propTypes2['default'].number.isRequired,
	  minWidth: _propTypes2['default'].number,
	  enableRowSelect: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].string]),
	  onRowUpdated: _propTypes2['default'].func,
	  rowGetter: _propTypes2['default'].func.isRequired,
	  rowsCount: _propTypes2['default'].number.isRequired,
	  toolbar: _propTypes2['default'].element,
	  enableCellSelect: _propTypes2['default'].bool,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  onFilter: _propTypes2['default'].func,
	  onCellCopyPaste: _propTypes2['default'].func,
	  onCellsDragged: _propTypes2['default'].func,
	  getCellActions: _propTypes2['default'].func,
	  onAddFilter: _propTypes2['default'].func,
	  onGridSort: _propTypes2['default'].func,
	  sortColumn: _propTypes2['default'].string,
	  sortDirection: _propTypes2['default'].oneOf(Object.keys(_SortableHeaderCell.DEFINE_SORT)),
	  onDragHandleDoubleClick: _propTypes2['default'].func,
	  onGridRowsUpdated: _propTypes2['default'].func,
	  onRowSelect: _propTypes2['default'].func,
	  rowKey: _propTypes2['default'].string,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  onClearFilters: _propTypes2['default'].func,
	  contextMenu: _propTypes2['default'].element,
	  cellNavigationMode: _propTypes2['default'].oneOf(['none', 'loopOverRow', 'changeRow']),
	  onCellSelected: _propTypes2['default'].func,
	  onCellDeSelected: _propTypes2['default'].func,
	  onCellExpand: _propTypes2['default'].func,
	  enableDragAndDrop: _propTypes2['default'].bool,
	  tabIndex: _propTypes2['default'].number,
	  onRowExpandToggle: _propTypes2['default'].func,
	  draggableHeaderCell: _propTypes2['default'].func,
	  getValidFilterValues: _propTypes2['default'].func,
	  rowSelection: _propTypes2['default'].shape({
	    enableShiftSelect: _propTypes2['default'].bool,
	    onRowsSelected: _propTypes2['default'].func,
	    onRowsDeselected: _propTypes2['default'].func,
	    showCheckbox: _propTypes2['default'].bool,
	    selectBy: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	      indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	    }), _propTypes2['default'].shape({
	      isSelectedKey: _propTypes2['default'].string.isRequired
	    }), _propTypes2['default'].shape({
	      keys: _propTypes2['default'].shape({
	        values: _propTypes2['default'].array.isRequired,
	        rowKey: _propTypes2['default'].string.isRequired
	      }).isRequired
	    })]).isRequired
	  }),
	  onRowClick: _propTypes2['default'].func,
	  onRowDoubleClick: _propTypes2['default'].func,
	  onGridKeyUp: _propTypes2['default'].func,
	  onGridKeyDown: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func,
	  rowActionsCell: _propTypes2['default'].func,
	  onCheckCellIsEditable: _propTypes2['default'].func,
	  /* called before cell is set active, returns a boolean to determine whether cell is editable */
	  overScan: _propTypes2['default'].object,
	  onDeleteSubRow: _propTypes2['default'].func,
	  onAddSubRow: _propTypes2['default'].func,
	  enableCellAutoFocus: _propTypes2['default'].bool,
	  onBeforeEdit: _propTypes2['default'].func,
	  selectAllRenderer: _propTypes2['default'].object,
	  minColumnWidth: _propTypes2['default'].number,
	  columnEquality: _propTypes2['default'].func,
	  onColumnResize: _propTypes2['default'].func
	};
	ReactDataGrid.defaultProps = {
	  enableCellSelect: false,
	  tabIndex: -1,
	  rowHeight: 35,
	  headerFiltersHeight: 45,
	  enableRowSelect: false,
	  minHeight: 350,
	  rowKey: 'id',
	  rowScrollTimeout: 0,
	  scrollToRowIndex: 0,
	  cellNavigationMode: 'none',
	  overScan: {
	    colsStart: 5,
	    colsEnd: 5,
	    rowsStart: 5,
	    rowsEnd: 5
	  },
	  enableCellAutoFocus: true,
	  onBeforeEdit: function onBeforeEdit() {},
	  minColumnWidth: 80,
	  columnEquality: ColumnMetrics.sameColumn
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this3 = this;

	  this.gridWidth = function () {
	    return _this3.grid ? _this3.grid.parentElement.offsetWidth : 0;
	  };

	  this.getTotalWidth = function () {
	    var totalWidth = 0;
	    if (_this3._mounted) {
	      totalWidth = _this3.gridWidth();
	    } else {
	      totalWidth = ColumnUtils.getSize(_this3.props.columns) * _this3.props.minColumnWidth;
	    }
	    return totalWidth;
	  };

	  this.getColumnMetricsType = function (metrics) {
	    var totalWidth = metrics.totalWidth || _this3.getTotalWidth();
	    var currentMetrics = {
	      columns: metrics.columns,
	      totalWidth: totalWidth,
	      minColumnWidth: metrics.minColumnWidth
	    };
	    var updatedMetrics = ColumnMetrics.recalculate(currentMetrics);
	    return updatedMetrics;
	  };

	  this.getColumn = function (idx) {
	    var columns = _this3.state.columnMetrics.columns;
	    if (Array.isArray(columns)) {
	      return columns[idx];
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.get(idx);
	    }
	  };

	  this.getSize = function () {
	    var columns = _this3.state.columnMetrics.columns;
	    if (Array.isArray(columns)) {
	      return columns.length;
	    } else if (typeof Immutable !== 'undefined') {
	      return columns.size;
	    }
	  };

	  this.metricsUpdated = function () {
	    var columnMetrics = _this3.createColumnMetrics();
	    _this3.setState({ columnMetrics: columnMetrics });
	  };

	  this.createColumnMetrics = function () {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;

	    var gridColumns = _this3.setupGridColumns(props);
	    return _this3.getColumnMetricsType({
	      columns: gridColumns,
	      minColumnWidth: _this3.props.minColumnWidth,
	      totalWidth: props.minWidth
	    });
	  };

	  this.onColumnResize = function (index, width) {
	    var columnMetrics = ColumnMetrics.resizeColumn(_this3.state.columnMetrics, index, width);
	    _this3.setState({ columnMetrics: columnMetrics });
	    if (_this3.props.onColumnResize) {
	      _this3.props.onColumnResize(index, width);
	    }
	  };

	  this.onKeyDown = function (e) {
	    if ((0, _keyboardUtils.isCtrlKeyHeldDown)(e)) {
	      _this3.checkAndCall('onPressKeyWithCtrl', e);
	    } else if (_this3.isKeyExplicitlyHandled(e.key)) {
	      // break up individual keyPress events to have their own specific callbacks
	      var callBack = 'onPress' + e.key;
	      _this3.checkAndCall(callBack, e);
	    } else if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this3.checkAndCall('onPressChar', e);
	    }

	    // Track which keys are currently down for shift clicking etc
	    _this3._keysDown = _this3._keysDown || {};
	    _this3._keysDown[e.keyCode] = true;
	    if (isFunction(_this3.props.onGridKeyDown)) {
	      _this3.props.onGridKeyDown(e);
	    }
	  };

	  this.onKeyUp = function (e) {
	    // Track which keys are currently down for shift clicking etc
	    _this3._keysDown = _this3._keysDown || {};
	    delete _this3._keysDown[e.keyCode];

	    if (isFunction(_this3.props.onGridKeyUp)) {
	      _this3.props.onGridKeyUp(e);
	    }
	  };

	  this.isKeyDown = function (keyCode) {
	    if (!_this3._keysDown) return false;
	    return keyCode in _this3._keysDown;
	  };

	  this.isSingleKeyDown = function (keyCode) {
	    if (!_this3._keysDown) return false;
	    return keyCode in _this3._keysDown && Object.keys(_this3._keysDown).length === 1;
	  };

	  this.checkAndCall = function (methodName, args) {
	    if (typeof _this3[methodName] === 'function') {
	      _this3[methodName](args);
	    }
	  };

	  this.isKeyExplicitlyHandled = function (key) {
	    return typeof _this3['onPress' + key] === 'function';
	  };

	  this.hasSelectedCellChanged = function (selected) {
	    var previouslySelected = Object.assign({}, _this3.state.selected);
	    return previouslySelected.rowIdx !== selected.rowIdx || previouslySelected.idx !== selected.idx || previouslySelected.active === false;
	  };

	  this.onContextMenuHide = function () {
	    document.removeEventListener('click', _this3.onContextMenuHide);
	    var newSelected = Object.assign({}, _this3.state.selected, { contextMenuDisplayed: false });
	    _this3.setState({ selected: newSelected });
	  };

	  this.onColumnEvent = function (ev, columnEvent) {
	    var idx = columnEvent.idx,
	        name = columnEvent.name;


	    if (name && typeof idx !== 'undefined') {
	      var column = _this3.getColumn(idx);

	      if (column && column.events && column.events[name] && typeof column.events[name] === 'function') {
	        var eventArgs = {
	          idx: idx,
	          rowIdx: columnEvent.rowIdx,
	          rowId: columnEvent.rowId,
	          column: column
	        };

	        column.events[name](ev, eventArgs);
	      }
	    }
	  };

	  this.onSelect = function (selected) {
	    if (_this3.state.selected.rowIdx !== selected.rowIdx || _this3.state.selected.idx !== selected.idx || _this3.state.selected.active === false) {
	      var _idx = selected.idx;
	      var _rowIdx = selected.rowIdx;
	      if (_this3.isCellWithinBounds(selected)) {
	        var oldSelection = _this3.state.selected;
	        _this3.setState({ selected: selected }, function () {
	          if (typeof _this3.props.onCellDeSelected === 'function') {
	            _this3.props.onCellDeSelected(oldSelection);
	          }
	          if (typeof _this3.props.onCellSelected === 'function') {
	            _this3.props.onCellSelected(selected);
	          }
	        });
	      } else if (_rowIdx === -1 && _idx === -1) {
	        // When it's outside of the grid, set rowIdx anyway
	        _this3.setState({ selected: { idx: _idx, rowIdx: _rowIdx } });
	      }
	    }
	  };

	  this.onCellClick = function (cell, e) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });

	    if (_this3.props.onRowClick && typeof _this3.props.onRowClick === 'function') {
	      _this3.props.onRowClick(cell.rowIdx, _this3.props.rowGetter(cell.rowIdx), _this3.getColumn(cell.idx));
	    }

	    if (e) {
	      e.stopPropagation();
	    }
	  };

	  this.onCellFocus = function (cell) {
	    _this3.onSelect(cell);
	  };

	  this.onCellContextMenu = function (cell) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx, contextMenuDisplayed: _this3.props.contextMenu });
	    if (_this3.props.contextMenu) {
	      document.addEventListener('click', _this3.onContextMenuHide);
	    }
	  };

	  this.onCellDoubleClick = function (cell, e) {
	    _this3.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });
	    if (_this3.props.onRowDoubleClick && typeof _this3.props.onRowDoubleClick === 'function') {
	      _this3.props.onRowDoubleClick(cell.rowIdx, _this3.props.rowGetter(cell.rowIdx), _this3.getColumn(cell.idx));
	    }
	    _this3.setActive();
	    if (e) {
	      e.stopPropagation();
	    }
	  };

	  this.onPressArrowUp = function (e) {
	    _this3.moveSelectedCell(e, -1, 0);
	  };

	  this.onPressArrowDown = function (e) {
	    _this3.moveSelectedCell(e, 1, 0);
	  };

	  this.onPressArrowLeft = function (e) {
	    _this3.moveSelectedCell(e, 0, -1);
	  };

	  this.onPressArrowRight = function (e) {
	    _this3.moveSelectedCell(e, 0, 1);
	  };

	  this.isFocusedOnCell = function () {
	    return document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('react-grid-Cell');
	  };

	  this.isFocusedOnTable = function () {
	    var domNode = _this3.getDataGridDOMNode();
	    return domNode && domNode.contains(document.activeElement);
	  };

	  this.exitGrid = function (oldSelectedCell, newSelectedValue) {
	    _this3.setState({ selected: newSelectedValue }, function () {
	      if (typeof _this3.props.onCellDeSelected === 'function') {
	        _this3.props.onCellDeSelected(oldSelectedCell);
	      }
	    });
	  };

	  this.enterGrid = function (newSelectedValue) {
	    _this3.setState({ selected: newSelectedValue }, function () {
	      if (typeof _this3.props.onCellSelected === 'function') {
	        _this3.props.onCellSelected(newSelectedValue);
	      }
	    });
	  };

	  this.onPressTab = function (e) {
	    // Scenario 0a: When there are no rows in the grid, pressing tab needs to allow the browser to handle it
	    if (_this3.props.rowsCount === 0) {
	      return;
	    }
	    // Scenario 0b: When we're editing a cell
	    var idx = _this3.state.selected.idx;
	    var rowIdx = _this3.state.selected.rowIdx;
	    if (_this3.state.selected.active === true) {
	      // if we are in a position to leave the grid, stop editing but stay in that cell
	      if (_this3.canExitGrid(e)) {
	        _this3.moveSelectedCell(e, 0, 0);
	        return;
	      }
	      // otherwise move left or right as appropriate
	      _this3.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
	      return;
	    }
	    var shift = e.shiftKey === true;
	    // Scenario 1: we're at a cell where we can exit the grid
	    if (_this3.canExitGrid(e) && _this3.isFocusedOnCell()) {
	      if (shift && idx >= 0) {
	        _this3.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx, exitedLeft: true });
	        return;
	      } else if (!shift && idx >= 0) {
	        _this3.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx });
	        return;
	      }
	    }
	    // Scenario 2: we're on the div surrounding the grid and press shift+Tab
	    // and we just exited left, so we want to let the browser handle it
	    // KNOWN ISSUE: Focus on the table can come from either side and at this point we can't know how
	    // they user arrived, so it is possible that exitLeft gets set and then the user clicks out of the table
	    // and they won't be able to Shift+Tab around the site to re-enter the table from the right.
	    if (_this3.isFocusedOnTable() && !_this3.isFocusedOnCell() && shift && _this3.state.selected.exitedLeft) {
	      _this3.enterGrid({ idx: idx, rowIdx: rowIdx });
	      return;
	    }
	    // Scenario 3: we're on the div surrounding the grid and we want to enter the grid
	    if (!_this3.isFocusedOnCell()) {
	      // Scenario 3A: idx has been set to -1 (eg can happen when clicking into the filter box)
	      // we want to go to the first cell in the row if we press Tab
	      // we want to go to the last cell in the row if we press Shift+Tab
	      if (idx === -1) {
	        _this3.moveSelectedCell(e, rowIdx === -1 ? 1 : 0, shift ? _this3.getNbrColumns() : 1);
	        return;
	      }
	      // otherwise, there is a selected cell in the table already, and
	      // we want to trigger it to focus - setting selected in state will update
	      // the cell props, and checkFocus will be called
	      _this3.enterGrid({ idx: idx, rowIdx: rowIdx, changeSomething: true });
	      // make sure the browser doesn't handle it
	      e.preventDefault();
	      return;
	    }
	    _this3.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
	  };

	  this.onPressEnter = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressDelete = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressEscape = function (e) {
	    _this3.setInactive(e.key);
	    _this3.handleCancelCopy();
	  };

	  this.onPressBackspace = function (e) {
	    _this3.setActive(e.key);
	  };

	  this.onPressChar = function (e) {
	    if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this3.setActive(e.keyCode);
	    }
	  };

	  this.onPressKeyWithCtrl = function (e) {
	    var keys = {
	      KeyCode_c: 99,
	      KeyCode_C: 67,
	      KeyCode_V: 86,
	      KeyCode_v: 118
	    };

	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var col = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect)) {
	      if (e.keyCode === keys.KeyCode_c || e.keyCode === keys.KeyCode_C) {
	        var _value = _this3.getSelectedValue();
	        _this3.handleCopy({ value: _value });
	      } else if (e.keyCode === keys.KeyCode_v || e.keyCode === keys.KeyCode_V) {
	        _this3.handlePaste();
	      }
	    }
	  };

	  this.onGridRowsUpdated = function (cellKey, fromRow, toRow, updated, action, originRow) {
	    var rowIds = [];

	    for (var i = fromRow; i <= toRow; i++) {
	      rowIds.push(_this3.props.rowGetter(i)[_this3.props.rowKey]);
	    }

	    var fromRowData = _this3.props.rowGetter(action === 'COPY_PASTE' ? originRow : fromRow);
	    var fromRowId = fromRowData[_this3.props.rowKey];
	    var toRowId = _this3.props.rowGetter(toRow)[_this3.props.rowKey];
	    _this3.props.onGridRowsUpdated({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, fromRowId: fromRowId, toRowId: toRowId, rowIds: rowIds, updated: updated, action: action, fromRowData: fromRowData });
	  };

	  this.onCellCommit = function (commit) {
	    var selected = Object.assign({}, _this3.state.selected);
	    selected.active = false;
	    var expandedRows = _this3.state.expandedRows;
	    // if(commit.changed && commit.changed.expandedHeight){
	    //   expandedRows = this.expandRow(commit.rowIdx, commit.changed.expandedHeight);
	    // }
	    _this3.setState({ selected: selected, expandedRows: expandedRows });

	    if (_this3.props.onRowUpdated) {
	      _this3.props.onRowUpdated(commit);
	    }

	    var targetRow = commit.rowIdx;

	    if (_this3.props.onGridRowsUpdated) {
	      _this3.onGridRowsUpdated(commit.cellKey, targetRow, targetRow, commit.updated, _AppConstants2['default'].UpdateActions.CELL_UPDATE);
	    }
	  };

	  this.onDragStart = function (e) {
	    var idx = _this3.state.selected.idx;
	    // To prevent dragging down/up when reordering rows.
	    var isViewportDragging = e && e.target && e.target.className;
	    if (idx > -1 && isViewportDragging) {
	      var _value2 = _this3.getSelectedValue();
	      _this3.handleDragStart({ idx: _this3.state.selected.idx, rowIdx: _this3.state.selected.rowIdx, value: _value2 });
	      // need to set dummy data for FF
	      if (e && e.dataTransfer) {
	        if (e.dataTransfer.setData) {
	          e.dataTransfer.dropEffect = 'move';
	          e.dataTransfer.effectAllowed = 'move';
	          e.dataTransfer.setData('text/plain', '');
	        }
	      }
	    }
	  };

	  this.onToggleFilter = function () {
	    // setState() does not immediately mutate this.state but creates a pending state transition.
	    // Therefore if you want to do something after the state change occurs, pass it in as a callback function.
	    _this3.setState({ canFilter: !_this3.state.canFilter }, function () {
	      if (_this3.state.canFilter === false && _this3.props.onClearFilters) {
	        _this3.props.onClearFilters();
	      }
	    });
	  };

	  this.onDragHandleDoubleClick = function (e) {
	    if (_this3.props.onDragHandleDoubleClick) {
	      _this3.props.onDragHandleDoubleClick(e);
	    }

	    if (_this3.props.onGridRowsUpdated) {
	      var _this3$onGridRowsUpda;

	      var cellKey = _this3.getColumn(e.idx).key;
	      _this3.onGridRowsUpdated(cellKey, e.rowIdx, _this3.props.rowsCount - 1, (_this3$onGridRowsUpda = {}, _this3$onGridRowsUpda[cellKey] = e.rowData[cellKey], _this3$onGridRowsUpda), _AppConstants2['default'].UpdateActions.COLUMN_FILL);
	    }
	  };

	  this.onCellExpand = function (args) {
	    if (_this3.props.onCellExpand) {
	      _this3.props.onCellExpand(args);
	    }
	  };

	  this.onRowExpandToggle = function (args) {
	    if (typeof _this3.props.onRowExpandToggle === 'function') {
	      _this3.props.onRowExpandToggle(args);
	    }
	  };

	  this.isCellWithinBounds = function (_ref) {
	    var idx = _ref.idx,
	        rowIdx = _ref.rowIdx;

	    return idx >= 0 && rowIdx >= 0 && idx < ColumnUtils.getSize(_this3.state.columnMetrics.columns) && rowIdx < _this3.props.rowsCount;
	  };

	  this.handleDragStart = function (dragged) {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    if (_this3.isCellWithinBounds(dragged)) {
	      _this3.setState({ dragged: dragged });
	    }
	  };

	  this.handleDragEnd = function () {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    var _state = _this3.state,
	        selected = _state.selected,
	        dragged = _state.dragged;

	    var column = _this3.getColumn(_this3.state.selected.idx);
	    if (selected && dragged && column) {
	      var cellKey = column.key;
	      var fromRow = selected.rowIdx < dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
	      var toRow = selected.rowIdx > dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
	      if (_this3.props.onCellsDragged) {
	        _this3.props.onCellsDragged({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, value: dragged.value });
	      }
	      if (_this3.props.onGridRowsUpdated) {
	        var _this3$onGridRowsUpda2;

	        _this3.onGridRowsUpdated(cellKey, fromRow, toRow, (_this3$onGridRowsUpda2 = {}, _this3$onGridRowsUpda2[cellKey] = dragged.value, _this3$onGridRowsUpda2), _AppConstants2['default'].UpdateActions.CELL_DRAG);
	      }
	    }
	    _this3.setState({ dragged: { complete: true } });
	  };

	  this.handleDragEnter = function (row) {
	    if (!_this3.dragEnabled() || _this3.state.dragged == null) {
	      return;
	    }
	    var dragged = _this3.state.dragged;
	    dragged.overRowIdx = row;
	    _this3.setState({ dragged: dragged });
	  };

	  this.handleTerminateDrag = function () {
	    if (!_this3.dragEnabled()) {
	      return;
	    }
	    _this3.setState({ dragged: null });
	  };

	  this.handlePaste = function () {
	    if (!_this3.copyPasteEnabled() || !_this3.state.copied) {
	      return;
	    }
	    var selected = _this3.state.selected;
	    var cellKey = _this3.getColumn(_this3.state.selected.idx).key;
	    var textToCopy = _this3.state.textToCopy;
	    var fromRow = _this3.state.copied.rowIdx;
	    var toRow = selected.rowIdx;

	    if (_this3.props.onCellCopyPaste) {
	      _this3.props.onCellCopyPaste({ cellKey: cellKey, rowIdx: toRow, value: textToCopy, fromRow: fromRow, toRow: toRow });
	    }

	    if (_this3.props.onGridRowsUpdated) {
	      var _this3$onGridRowsUpda3;

	      _this3.onGridRowsUpdated(cellKey, toRow, toRow, (_this3$onGridRowsUpda3 = {}, _this3$onGridRowsUpda3[cellKey] = textToCopy, _this3$onGridRowsUpda3), _AppConstants2['default'].UpdateActions.COPY_PASTE, fromRow);
	    }
	  };

	  this.handleCancelCopy = function () {
	    _this3.setState({ copied: null });
	  };

	  this.handleCopy = function (args) {
	    if (!_this3.copyPasteEnabled()) {
	      return;
	    }
	    var textToCopy = args.value;
	    var selected = _this3.state.selected;
	    var copied = { idx: selected.idx, rowIdx: selected.rowIdx };
	    _this3.setState({ textToCopy: textToCopy, copied: copied });
	  };

	  this.handleSort = function (columnKey, direction) {
	    _this3.setState({ sortDirection: direction, sortColumn: columnKey }, function () {
	      this.props.onGridSort(columnKey, direction);
	    });
	  };

	  this.getSelectedRow = function (rows, key) {
	    var selectedRow = rows.filter(function (r) {
	      if (r[_this3.props.rowKey] === key) {
	        return true;
	      }
	      return false;
	    });
	    if (selectedRow.length > 0) {
	      return selectedRow[0];
	    }
	  };

	  this.useNewRowSelection = function () {
	    return _this3.props.rowSelection && _this3.props.rowSelection.selectBy;
	  };

	  this.handleShiftSelect = function (rowIdx) {
	    if (_this3.state.lastRowIdxUiSelected > -1 && _this3.isSingleKeyDown(KeyCodes.Shift)) {
	      var _props$rowSelection$s = _this3.props.rowSelection.selectBy,
	          keys = _props$rowSelection$s.keys,
	          indexes = _props$rowSelection$s.indexes,
	          isSelectedKey = _props$rowSelection$s.isSelectedKey;

	      var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, _this3.props.rowGetter(rowIdx), rowIdx);

	      if (isPreviouslySelected) return false;

	      var handled = false;

	      if (rowIdx > _this3.state.lastRowIdxUiSelected) {
	        var rowsSelected = [];

	        for (var i = _this3.state.lastRowIdxUiSelected + 1; i <= rowIdx; i++) {
	          rowsSelected.push({ rowIdx: i, row: _this3.props.rowGetter(i) });
	        }

	        if (typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	          _this3.props.rowSelection.onRowsSelected(rowsSelected);
	        }

	        handled = true;
	      } else if (rowIdx < _this3.state.lastRowIdxUiSelected) {
	        var _rowsSelected = [];

	        for (var _i = rowIdx; _i <= _this3.state.lastRowIdxUiSelected - 1; _i++) {
	          _rowsSelected.push({ rowIdx: _i, row: _this3.props.rowGetter(_i) });
	        }

	        if (typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	          _this3.props.rowSelection.onRowsSelected(_rowsSelected);
	        }

	        handled = true;
	      }

	      if (handled) {
	        _this3.setState({ lastRowIdxUiSelected: rowIdx });
	      }

	      return handled;
	    }

	    return false;
	  };

	  this.handleNewRowSelect = function (rowIdx, rowData) {
	    if (_this3.selectAllCheckbox && _this3.selectAllCheckbox.checked === true) {
	      _this3.selectAllCheckbox.checked = false;
	    }

	    var _props$rowSelection$s2 = _this3.props.rowSelection.selectBy,
	        keys = _props$rowSelection$s2.keys,
	        indexes = _props$rowSelection$s2.indexes,
	        isSelectedKey = _props$rowSelection$s2.isSelectedKey;

	    var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx);

	    _this3.setState({ lastRowIdxUiSelected: isPreviouslySelected ? -1 : rowIdx, selected: { rowIdx: rowIdx, idx: 0 } });

	    if (isPreviouslySelected && typeof _this3.props.rowSelection.onRowsDeselected === 'function') {
	      _this3.props.rowSelection.onRowsDeselected([{ rowIdx: rowIdx, row: rowData }]);
	    } else if (!isPreviouslySelected && typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	      _this3.props.rowSelection.onRowsSelected([{ rowIdx: rowIdx, row: rowData }]);
	    }
	  };

	  this.handleRowSelect = function (rowIdx, columnKey, rowData, e) {
	    e.stopPropagation();

	    if (_this3.useNewRowSelection()) {
	      if (_this3.props.rowSelection.enableShiftSelect === true) {
	        if (!_this3.handleShiftSelect(rowIdx)) {
	          _this3.handleNewRowSelect(rowIdx, rowData);
	        }
	      } else {
	        _this3.handleNewRowSelect(rowIdx, rowData);
	      }
	    } else {
	      // Fallback to old onRowSelect handler
	      var selectedRows = _this3.props.enableRowSelect === 'single' ? [] : _this3.state.selectedRows.slice(0);
	      var selectedRow = _this3.getSelectedRow(selectedRows, rowData[_this3.props.rowKey]);
	      if (selectedRow) {
	        selectedRow.isSelected = !selectedRow.isSelected;
	      } else {
	        rowData.isSelected = true;
	        selectedRows.push(rowData);
	      }
	      _this3.setState({ selectedRows: selectedRows, selected: { rowIdx: rowIdx, idx: 0 } });
	      if (_this3.props.onRowSelect) {
	        _this3.props.onRowSelect(selectedRows.filter(function (r) {
	          return r.isSelected === true;
	        }));
	      }
	    }
	  };

	  this.handleCheckboxChange = function (e) {
	    var allRowsSelected = void 0;
	    if (e.currentTarget instanceof HTMLInputElement && e.currentTarget.checked === true) {
	      allRowsSelected = true;
	    } else {
	      allRowsSelected = false;
	    }
	    if (_this3.useNewRowSelection()) {
	      var _props$rowSelection$s3 = _this3.props.rowSelection.selectBy,
	          keys = _props$rowSelection$s3.keys,
	          indexes = _props$rowSelection$s3.indexes,
	          isSelectedKey = _props$rowSelection$s3.isSelectedKey;


	      if (allRowsSelected && typeof _this3.props.rowSelection.onRowsSelected === 'function') {
	        var selectedRows = [];
	        for (var i = 0; i < _this3.props.rowsCount; i++) {
	          var rowData = _this3.props.rowGetter(i);
	          if (!RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, i)) {
	            selectedRows.push({ rowIdx: i, row: rowData });
	          }
	        }

	        if (selectedRows.length > 0) {
	          _this3.props.rowSelection.onRowsSelected(selectedRows);
	        }
	      } else if (!allRowsSelected && typeof _this3.props.rowSelection.onRowsDeselected === 'function') {
	        var deselectedRows = [];
	        for (var _i2 = 0; _i2 < _this3.props.rowsCount; _i2++) {
	          var _rowData = _this3.props.rowGetter(_i2);
	          if (RowUtils.isRowSelected(keys, indexes, isSelectedKey, _rowData, _i2)) {
	            deselectedRows.push({ rowIdx: _i2, row: _rowData });
	          }
	        }

	        if (deselectedRows.length > 0) {
	          _this3.props.rowSelection.onRowsDeselected(deselectedRows);
	        }
	      }
	    } else {
	      var _selectedRows = [];
	      for (var _i3 = 0; _i3 < _this3.props.rowsCount; _i3++) {
	        var row = Object.assign({}, _this3.props.rowGetter(_i3), { isSelected: allRowsSelected });
	        _selectedRows.push(row);
	      }
	      _this3.setState({ selectedRows: _selectedRows });
	      if (typeof _this3.props.onRowSelect === 'function') {
	        _this3.props.onRowSelect(_selectedRows.filter(function (r) {
	          return r.isSelected === true;
	        }));
	      }
	    }
	  };

	  this.getScrollOffSet = function () {
	    var scrollOffset = 0;
	    if (_this3.grid) {
	      var canvas = _this3.grid.querySelector('.react-grid-Canvas');
	      if (canvas) {
	        scrollOffset = canvas.offsetWidth - canvas.clientWidth;
	      }
	    }
	    _this3.setState({ scrollOffset: scrollOffset });
	  };

	  this.getRowOffsetHeight = function () {
	    var offsetHeight = 0;
	    _this3.getHeaderRows().forEach(function (row) {
	      return offsetHeight += parseFloat(row.height, 10);
	    });
	    return offsetHeight;
	  };

	  this.getHeaderRows = function () {
	    var rows = [{ ref: function ref(node) {
	        return _this3.row = node;
	      }, height: _this3.props.headerRowHeight || _this3.props.rowHeight, rowType: 'header' }];
	    if (_this3.state.canFilter === true) {
	      rows.push({
	        ref: function ref(node) {
	          return _this3.filterRow = node;
	        },
	        filterable: true,
	        onFilterChange: _this3.props.onAddFilter,
	        height: _this3.props.headerFiltersHeight,
	        rowType: 'filter'
	      });
	    }
	    return rows;
	  };

	  this.getInitialSelectedRows = function () {
	    var selectedRows = [];
	    for (var i = 0; i < _this3.props.rowsCount; i++) {
	      selectedRows.push(false);
	    }
	    return selectedRows;
	  };

	  this.getRowSelectionProps = function () {
	    if (_this3.props.rowSelection) {
	      return _this3.props.rowSelection.selectBy;
	    }

	    return null;
	  };

	  this.getSelectedRows = function () {
	    if (_this3.props.rowSelection) {
	      return null;
	    }

	    return _this3.state.selectedRows.filter(function (r) {
	      return r.isSelected === true;
	    });
	  };

	  this.getSelectedValue = function () {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var idx = _this3.state.selected.idx;
	    var cellKey = _this3.getColumn(idx).key;
	    var row = _this3.props.rowGetter(rowIdx);
	    return RowUtils.get(row, cellKey);
	  };

	  this.canExitGrid = function (e) {
	    // When the cellNavigationMode is 'none', you can exit the grid if you're at the start or end of the row
	    // When the cellNavigationMode is 'changeRow', you can exit the grid if you're at the first or last cell of the grid
	    // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid
	    var atLastCellInRow = _this3.isAtLastCellInRow(_this3.getNbrColumns());
	    var atFirstCellInRow = _this3.isAtFirstCellInRow();
	    var atLastRow = _this3.isAtLastRow();
	    var atFirstRow = _this3.isAtFirstRow();
	    var shift = e.shiftKey === true;
	    var cellNavigationMode = _this3.props.cellNavigationMode;

	    if (shift) {
	      if (cellNavigationMode === 'none') {
	        if (atFirstCellInRow) {
	          return true;
	        }
	      } else if (cellNavigationMode === 'changeRow') {
	        if (atFirstCellInRow && atFirstRow) {
	          return true;
	        }
	      }
	    } else {
	      if (cellNavigationMode === 'none') {
	        if (atLastCellInRow) {
	          return true;
	        }
	      } else if (cellNavigationMode === 'changeRow') {
	        if (atLastCellInRow && atLastRow) {
	          return true;
	        }
	      }
	    }
	    return false;
	  };

	  this.moveSelectedCell = function (e, rowDelta, cellDelta) {
	    // we need to prevent default as we control grid scroll
	    // otherwise it moves every time you left/right which is janky
	    e.preventDefault();
	    var rowIdx = void 0;
	    var idx = void 0;
	    var cellNavigationMode = _this3.props.cellNavigationMode;

	    if (cellNavigationMode !== 'none') {
	      var _calculateNextSelecti = _this3.calculateNextSelectionPosition(cellNavigationMode, cellDelta, rowDelta);

	      idx = _calculateNextSelecti.idx;
	      rowIdx = _calculateNextSelecti.rowIdx;
	    } else {
	      rowIdx = _this3.state.selected.rowIdx + rowDelta;
	      idx = _this3.state.selected.idx + cellDelta;
	    }
	    _this3.scrollToColumn(idx);
	    _this3.onSelect({ idx: idx, rowIdx: rowIdx });
	  };

	  this.getNbrColumns = function () {
	    var _props = _this3.props,
	        columns = _props.columns,
	        enableRowSelect = _props.enableRowSelect;

	    return enableRowSelect ? columns.length + 1 : columns.length;
	  };

	  this.getDataGridDOMNode = function () {
	    return _this3.grid;
	  };

	  this.calculateNextSelectionPosition = function (cellNavigationMode, cellDelta, rowDelta) {
	    var _rowDelta = rowDelta;
	    var idx = _this3.state.selected.idx + cellDelta;
	    var nbrColumns = _this3.getNbrColumns();
	    if (cellDelta > 0) {
	      if (_this3.isAtLastCellInRow(nbrColumns)) {
	        if (cellNavigationMode === 'changeRow') {
	          _rowDelta = _this3.isAtLastRow() ? rowDelta : rowDelta + 1;
	          idx = _this3.isAtLastRow() ? idx : 0;
	        } else {
	          idx = 0;
	        }
	      }
	    } else if (cellDelta < 0) {
	      if (_this3.isAtFirstCellInRow()) {
	        if (cellNavigationMode === 'changeRow') {
	          _rowDelta = _this3.isAtFirstRow() ? rowDelta : rowDelta - 1;
	          idx = _this3.isAtFirstRow() ? 0 : nbrColumns - 1;
	        } else {
	          idx = nbrColumns - 1;
	        }
	      }
	    }
	    var rowIdx = _this3.state.selected.rowIdx + _rowDelta;
	    return { idx: idx, rowIdx: rowIdx };
	  };

	  this.isAtLastCellInRow = function (nbrColumns) {
	    return _this3.state.selected.idx === nbrColumns - 1;
	  };

	  this.isAtLastRow = function () {
	    return _this3.state.selected.rowIdx === _this3.props.rowsCount - 1;
	  };

	  this.isAtFirstCellInRow = function () {
	    return _this3.state.selected.idx === 0;
	  };

	  this.isAtFirstRow = function () {
	    return _this3.state.selected.rowIdx === 0;
	  };

	  this.openCellEditor = function (rowIdx, idx) {
	    var row = _this3.props.rowGetter(rowIdx);
	    var col = _this3.getColumn(idx);

	    if (!ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect)) {
	      return;
	    }

	    var selected = { rowIdx: rowIdx, idx: idx };
	    if (_this3.hasSelectedCellChanged(selected)) {
	      _this3.setState({ selected: selected }, function () {
	        _this3.setActive('Enter');
	      });
	    } else {
	      _this3.setActive('Enter');
	    }
	  };

	  this.scrollToColumn = function (colIdx) {
	    if (_this3.grid) {
	      var canvas = _this3.grid.querySelector('.react-grid-Canvas');
	      if (canvas) {
	        var left = 0;
	        var locked = 0;

	        for (var i = 0; i < colIdx; i++) {
	          var column = _this3.getColumn(i);
	          if (column) {
	            if (column.width) {
	              left += column.width;
	            }
	            if (column.locked) {
	              locked += column.width;
	            }
	          }
	        }

	        var selectedColumn = _this3.getColumn(colIdx);
	        if (selectedColumn) {
	          var scrollLeft = left - locked - canvas.scrollLeft;
	          var scrollRight = left + selectedColumn.width - canvas.scrollLeft;

	          if (scrollLeft < 0) {
	            canvas.scrollLeft += scrollLeft;
	          } else if (scrollRight > canvas.clientWidth) {
	            var scrollAmount = scrollRight - canvas.clientWidth;
	            canvas.scrollLeft += scrollAmount;
	          }
	        }
	      }
	    }
	  };

	  this.deselect = function () {
	    var selected = { rowIdx: -1, idx: -1 };
	    _this3.setState({ selected: selected });
	  };

	  this.setActive = function (keyPressed) {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var column = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(column, row, _this3.props.enableCellSelect) && !_this3.isActive()) {
	      var selected = Object.assign({}, _this3.state.selected, { idx: idx, rowIdx: rowIdx, active: true, initialKeyCode: keyPressed });
	      var showEditor = true;
	      if (typeof _this3.props.onCheckCellIsEditable === 'function') {
	        var args = Object.assign({}, { row: row, column: column }, selected);
	        showEditor = _this3.props.onCheckCellIsEditable(args);
	      }
	      if (showEditor !== false) {
	        if (column.locked) {
	          _this3.setState({ selected: selected });
	        } else {
	          _this3.setState({ selected: selected }, function () {
	            _this3.scrollToColumn(idx);
	          });
	        }
	        _this3.props.onBeforeEdit();
	        _this3.handleCancelCopy();
	      }
	    }
	  };

	  this.setInactive = function () {
	    var rowIdx = _this3.state.selected.rowIdx;
	    var row = _this3.props.rowGetter(rowIdx);

	    var idx = _this3.state.selected.idx;
	    var col = _this3.getColumn(idx);

	    if (ColumnUtils.canEdit(col, row, _this3.props.enableCellSelect) && _this3.isActive()) {
	      var selected = Object.assign({}, _this3.state.selected, { idx: idx, rowIdx: rowIdx, active: false });
	      _this3.setState({ selected: selected });
	    }
	  };

	  this.isActive = function () {
	    return _this3.state.selected.active === true;
	  };

	  this.setupGridColumns = function () {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;
	    var columns = props.columns;

	    if (_this3._cachedColumns === columns) {
	      return _this3._cachedComputedColumns;
	    }

	    _this3._cachedColumns = columns;

	    var cols = columns.slice(0);
	    var unshiftedCols = {};
	    if (_this3.props.rowActionsCell || props.enableRowSelect && !_this3.props.rowSelection || props.rowSelection && props.rowSelection.showCheckbox !== false) {
	      var SelectAllComponent = _this3.props.selectAllRenderer || _SelectAll2['default'];
	      var SelectAllRenderer = React.createElement(SelectAllComponent, { onChange: _this3.handleCheckboxChange, inputRef: function inputRef(grid) {
	          return _this3.selectAllCheckbox = grid;
	        } });
	      var headerRenderer = props.enableRowSelect === 'single' ? null : SelectAllRenderer;
	      var Formatter = _this3.props.rowActionsCell ? _this3.props.rowActionsCell : CheckboxEditor;
	      var selectColumn = {
	        key: 'select-row',
	        name: '',
	        formatter: React.createElement(Formatter, { rowSelection: _this3.props.rowSelection }),
	        onCellChange: _this3.handleRowSelect,
	        filterable: false,
	        headerRenderer: headerRenderer,
	        width: 60,
	        locked: true,
	        getRowMetaData: function getRowMetaData(rowData) {
	          return rowData;
	        },
	        cellClass: _this3.props.rowActionsCell ? 'rdg-row-actions-cell' : ''
	      };
	      unshiftedCols = cols.unshift(selectColumn);
	      cols = unshiftedCols > 0 ? cols : unshiftedCols;
	    }
	    _this3._cachedComputedColumns = cols;

	    return _this3._cachedComputedColumns;
	  };

	  this.copyPasteEnabled = function () {
	    return _this3.props.onCellCopyPaste !== null;
	  };

	  this.dragEnabled = function () {
	    return _this3.props.onGridRowsUpdated !== undefined || _this3.props.onCellsDragged !== undefined;
	  };

	  this.renderToolbar = function () {
	    var Toolbar = _this3.props.toolbar;
	    var toolBarProps = { columns: _this3.props.columns, onToggleFilter: _this3.onToggleFilter, numberOfRows: _this3.props.rowsCount };
	    if (React.isValidElement(Toolbar)) {
	      return React.cloneElement(Toolbar, toolBarProps);
	    } else if (isFunction(Toolbar)) {
	      return React.createElement(Toolbar, toolBarProps);
	    }
	  };
	};

	module.exports = ReactDataGrid;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var Draggable = __webpack_require__(109);
	__webpack_require__(15);

	var style = {
	  position: 'absolute',
	  top: 0,
	  right: 0,
	  width: 6,
	  height: '100%'
	};

	var ResizeHandle = function (_React$Component) {
	  _inherits(ResizeHandle, _React$Component);

	  function ResizeHandle() {
	    _classCallCheck(this, ResizeHandle);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  ResizeHandle.prototype.render = function render() {
	    return React.createElement(Draggable, _extends({}, this.props, {
	      className: 'react-grid-HeaderCell__resizeHandle',
	      style: style
	    }));
	  };

	  return ResizeHandle;
	}(React.Component);

	module.exports = ResizeHandle;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _utils = __webpack_require__(53);

	var _utils2 = _interopRequireDefault(_utils);

	__webpack_require__(29);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var cellMetaDataShape = __webpack_require__(11);

	var RowGroup = function (_Component) {
	  _inherits(RowGroup, _Component);

	  function RowGroup(props) {
	    _classCallCheck(this, RowGroup);

	    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

	    _this.onRowExpandToggle = _this.onRowExpandToggle.bind(_this);
	    _this.onRowExpandClick = _this.onRowExpandClick.bind(_this);
	    _this.setScrollLeft = _this.setScrollLeft.bind(_this);
	    return _this;
	  }

	  RowGroup.prototype.onRowExpandToggle = function onRowExpandToggle(expand) {
	    var shouldExpand = expand == null ? !this.props.isExpanded : expand;
	    var meta = this.props.cellMetaData;
	    if (meta != null && meta.onRowExpandToggle && typeof meta.onRowExpandToggle === 'function') {
	      meta.onRowExpandToggle({ rowIdx: this.props.idx, shouldExpand: shouldExpand, columnGroupName: this.props.columnGroupName, name: this.props.name });
	    }
	  };

	  RowGroup.prototype.onRowExpandClick = function onRowExpandClick() {
	    this.onRowExpandToggle(!this.props.isExpanded);
	  };

	  RowGroup.prototype.setScrollLeft = function setScrollLeft(scrollLeft) {
	    if (this.rowGroupRenderer) {
	      this.rowGroupRenderer.setScrollLeft ? this.rowGroupRenderer.setScrollLeft(scrollLeft) : null;
	    }
	  };

	  RowGroup.prototype.render = function render() {
	    var _this2 = this;

	    var lastColumn = _utils2['default'].last(this.props.columns);

	    var style = { width: lastColumn.left + lastColumn.width };

	    return _react2['default'].createElement(
	      'div',
	      { style: style, className: 'react-grid-row-group' },
	      _react2['default'].createElement(this.props.renderer, _extends({ ref: function ref(node) {
	          _this2.rowGroupRenderer = node;
	        } }, this.props, { onRowExpandClick: this.onRowExpandClick, onRowExpandToggle: this.onRowExpandToggle }))
	    );
	  };

	  return RowGroup;
	}(_react.Component);

	RowGroup.propTypes = {
	  height: _propTypes2['default'].number.isRequired,
	  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
	  row: _propTypes2['default'].any.isRequired,
	  cellRenderer: _propTypes2['default'].func,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  isSelected: _propTypes2['default'].bool,
	  idx: _propTypes2['default'].number.isRequired,
	  expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
	  extraClasses: _propTypes2['default'].string,
	  forceUpdate: _propTypes2['default'].bool,
	  subRowDetails: _propTypes2['default'].object,
	  isRowHovered: _propTypes2['default'].bool,
	  colVisibleStart: _propTypes2['default'].number.isRequired,
	  colVisibleEnd: _propTypes2['default'].number.isRequired,
	  colDisplayStart: _propTypes2['default'].number.isRequired,
	  colDisplayEnd: _propTypes2['default'].number.isRequired,
	  isScrolling: _propTypes2['default'].bool.isRequired,
	  columnGroupName: _propTypes2['default'].string.isRequired,
	  isExpanded: _propTypes2['default'].bool.isRequired,
	  treeDepth: _propTypes2['default'].number.isRequired,
	  name: _propTypes2['default'].string.isRequired,
	  renderer: _propTypes2['default'].func
	};

	var DefaultRowGroupRenderer = function DefaultRowGroupRenderer(props) {
	  var treeDepth = props.treeDepth || 0;
	  var marginLeft = treeDepth * 20;

	  var style = {
	    height: '50px',
	    border: '1px solid #dddddd',
	    paddingTop: '15px',
	    paddingLeft: '5px'
	  };

	  var onKeyDown = function onKeyDown(e) {
	    if (e.key === 'ArrowLeft') {
	      props.onRowExpandToggle(false);
	    }
	    if (e.key === 'ArrowRight') {
	      props.onRowExpandToggle(true);
	    }
	    if (e.key === 'Enter') {
	      props.onRowExpandToggle(!props.isExpanded);
	    }
	  };
	  return _react2['default'].createElement(
	    'div',
	    { style: style, onKeyDown: onKeyDown, tabIndex: 0 },
	    _react2['default'].createElement(
	      'span',
	      { className: 'row-expand-icon', style: { float: 'left', marginLeft: marginLeft, cursor: 'pointer' }, onClick: props.onRowExpandClick },
	      props.isExpanded ? String.fromCharCode('9660') : String.fromCharCode('9658')
	    ),
	    _react2['default'].createElement(
	      'strong',
	      null,
	      props.columnGroupName,
	      ': ',
	      props.name
	    )
	  );
	};

	DefaultRowGroupRenderer.propTypes = {
	  onRowExpandClick: _propTypes2['default'].func.isRequired,
	  onRowExpandToggle: _propTypes2['default'].func.isRequired,
	  isExpanded: _propTypes2['default'].bool.isRequired,
	  treeDepth: _propTypes2['default'].number.isRequired,
	  name: _propTypes2['default'].string.isRequired,
	  columnGroupName: _propTypes2['default'].string.isRequired,
	  hideColumnName: _propTypes2['default'].bool
	};

	RowGroup.defaultProps = {
	  renderer: DefaultRowGroupRenderer
	};

	exports['default'] = RowGroup;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	var _viewportUtils = __webpack_require__(137);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var Canvas = __webpack_require__(104);
	var cellMetaDataShape = __webpack_require__(11);

	var Viewport = function (_React$Component) {
	  _inherits(Viewport, _React$Component);

	  function Viewport() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Viewport);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = (0, _viewportUtils.getGridState)(_this.props), _this.onScroll = function (scroll) {
	      _this.updateScroll(scroll.scrollTop, scroll.scrollLeft, _this.state.height, _this.props.rowHeight, _this.props.rowsCount);

	      if (_this.props.onScroll) {
	        _this.props.onScroll({ scrollTop: scroll.scrollTop, scrollLeft: scroll.scrollLeft });
	      }
	    }, _this.getScroll = function () {
	      return _this.canvas.getScroll();
	    }, _this.setScrollLeft = function (scrollLeft) {
	      _this.canvas.setScrollLeft(scrollLeft);
	    }, _this.getDOMNodeOffsetWidth = function () {
	      return _this.viewport ? _this.viewport.offsetWidth : 0;
	    }, _this.clearScrollTimer = function () {
	      if (_this.resetScrollStateTimeoutId) {
	        clearTimeout(_this.resetScrollStateTimeoutId);
	      }
	    }, _this.resetScrollStateAfterDelay = function () {
	      _this.clearScrollTimer();
	      _this.resetScrollStateTimeoutId = setTimeout(_this.resetScrollStateAfterDelayCallback, 500);
	    }, _this.resetScrollStateAfterDelayCallback = function () {
	      _this.resetScrollStateTimeoutId = null;
	      _this.setState({
	        isScrolling: false
	      });
	    }, _this.updateScroll = function (scrollTop, scrollLeft, height, rowHeight, length, width) {
	      _this.resetScrollStateAfterDelay();
	      var nextScrollState = (0, _viewportUtils.getNextScrollState)(_this.props, _this.getDOMNodeOffsetWidth, scrollTop, scrollLeft, height, rowHeight, length, width);

	      _this.setState(nextScrollState);
	    }, _this.metricsUpdated = function () {
	      var height = _this.viewportHeight();
	      var width = _this.viewportWidth();
	      if (height) {
	        _this.updateScroll(_this.state.scrollTop, _this.state.scrollLeft, height, _this.props.rowHeight, _this.props.rowsCount, width);
	      }
	    }, _this.viewportHeight = function () {
	      return _this.viewport ? _this.viewport.offsetHeight : 0;
	    }, _this.viewportWidth = function () {
	      return _this.viewport ? _this.viewport.offsetWidth : 0;
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Viewport.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (this.props.rowHeight !== nextProps.rowHeight || this.props.minHeight !== nextProps.minHeight) {
	      var newState = (0, _viewportUtils.getGridState)(nextProps);
	      this.updateScroll(newState.scrollTop, newState.scrollLeft, newState.height, nextProps.rowHeight, nextProps.rowsCount);
	    } else if (_ColumnUtils2['default'].getSize(this.props.columnMetrics.columns) !== _ColumnUtils2['default'].getSize(nextProps.columnMetrics.columns)) {
	      this.setState((0, _viewportUtils.getGridState)(nextProps));
	    } else if (this.props.rowsCount !== nextProps.rowsCount) {
	      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height, nextProps.rowHeight, nextProps.rowsCount);
	      // Added to fix the hiding of the bottom scrollbar when showing the filters.
	    } else if (this.props.rowOffsetHeight !== nextProps.rowOffsetHeight) {
	      // The value of height can be positive or negative and will be added to the current height to cater for changes in the header height (due to the filer)
	      var height = this.props.rowOffsetHeight - nextProps.rowOffsetHeight;

	      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height + height, nextProps.rowHeight, nextProps.rowsCount);
	    }
	  };

	  Viewport.prototype.componentDidMount = function componentDidMount() {
	    if (window.addEventListener) {
	      window.addEventListener('resize', this.metricsUpdated);
	    } else {
	      window.attachEvent('resize', this.metricsUpdated);
	    }
	    this.metricsUpdated();
	  };

	  Viewport.prototype.componentWillUnmount = function componentWillUnmount() {
	    window.removeEventListener('resize', this.metricsUpdated);
	    this.clearScrollTimer();
	  };

	  Viewport.prototype.render = function render() {
	    var _this2 = this;

	    var style = {
	      padding: 0,
	      bottom: 0,
	      left: 0,
	      right: 0,
	      overflow: 'hidden',
	      position: 'absolute',
	      top: this.props.rowOffsetHeight
	    };
	    return React.createElement(
	      'div',
	      {
	        className: 'react-grid-Viewport',
	        style: style,
	        ref: function ref(node) {
	          _this2.viewport = node;
	        } },
	      React.createElement(Canvas, {
	        ref: function ref(node) {
	          return _this2.canvas = node;
	        },
	        rowKey: this.props.rowKey,
	        totalWidth: this.props.totalWidth,
	        width: this.props.columnMetrics.width,
	        rowGetter: this.props.rowGetter,
	        rowsCount: this.props.rowsCount,
	        selectedRows: this.props.selectedRows,
	        expandedRows: this.props.expandedRows,
	        columns: this.props.columnMetrics.columns,
	        rowRenderer: this.props.rowRenderer,
	        displayStart: this.state.displayStart,
	        displayEnd: this.state.displayEnd,
	        visibleStart: this.state.visibleStart,
	        visibleEnd: this.state.visibleEnd,
	        colVisibleStart: this.state.colVisibleStart,
	        colVisibleEnd: this.state.colVisibleEnd,
	        colDisplayStart: this.state.colDisplayStart,
	        colDisplayEnd: this.state.colDisplayEnd,
	        cellMetaData: this.props.cellMetaData,
	        height: this.state.height,
	        rowHeight: this.props.rowHeight,
	        onScroll: this.onScroll,
	        onRows: this.props.onRows,
	        rowScrollTimeout: this.props.rowScrollTimeout,
	        scrollToRowIndex: this.props.scrollToRowIndex,
	        contextMenu: this.props.contextMenu,
	        rowSelection: this.props.rowSelection,
	        getSubRowDetails: this.props.getSubRowDetails,
	        rowGroupRenderer: this.props.rowGroupRenderer,
	        isScrolling: this.state.isScrolling || false
	      })
	    );
	  };

	  return Viewport;
	}(React.Component);

	Viewport.displayName = 'Viewport';
	Viewport.propTypes = {
	  rowOffsetHeight: _propTypes2['default'].number.isRequired,
	  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]).isRequired,
	  columnMetrics: _propTypes2['default'].object.isRequired,
	  rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
	  selectedRows: _propTypes2['default'].array,
	  rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
	    indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
	  }), _propTypes2['default'].shape({
	    isSelectedKey: _propTypes2['default'].string.isRequired
	  }), _propTypes2['default'].shape({
	    keys: _propTypes2['default'].shape({
	      values: _propTypes2['default'].array.isRequired,
	      rowKey: _propTypes2['default'].string.isRequired
	    }).isRequired
	  })]),
	  expandedRows: _propTypes2['default'].array,
	  rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
	  rowsCount: _propTypes2['default'].number.isRequired,
	  rowHeight: _propTypes2['default'].number.isRequired,
	  onRows: _propTypes2['default'].func,
	  onScroll: _propTypes2['default'].func,
	  minHeight: _propTypes2['default'].number,
	  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
	  rowKey: _propTypes2['default'].string.isRequired,
	  rowScrollTimeout: _propTypes2['default'].number,
	  scrollToRowIndex: _propTypes2['default'].number,
	  contextMenu: _propTypes2['default'].element,
	  getSubRowDetails: _propTypes2['default'].func,
	  rowGroupRenderer: _propTypes2['default'].func
	};
	Viewport.defaultProps = {
	  rowHeight: 30
	};


	module.exports = Viewport;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ExcelColumn = __webpack_require__(12);

	var FilterableHeaderCell = function (_React$Component) {
	  _inherits(FilterableHeaderCell, _React$Component);

	  function FilterableHeaderCell() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, FilterableHeaderCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { filterTerm: '' }, _this.handleChange = function (e) {
	      var val = e.target.value;
	      _this.setState({ filterTerm: val });
	      _this.props.onChange({ filterTerm: val, column: _this.props.column });
	    }, _this.renderInput = function () {
	      if (_this.props.column.filterable === false) {
	        return React.createElement('span', null);
	      }

	      var inputKey = 'header-filter-' + _this.props.column.key;
	      return React.createElement('input', { key: inputKey, type: 'text', className: 'form-control input-sm', placeholder: 'Search', value: _this.state.filterTerm, onChange: _this.handleChange });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  FilterableHeaderCell.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'div',
	        { className: 'form-group' },
	        this.renderInput()
	      )
	    );
	  };

	  return FilterableHeaderCell;
	}(React.Component);

	FilterableHeaderCell.propTypes = {
	  onChange: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn)
	};


	module.exports = FilterableHeaderCell;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _keyboardUtils = __webpack_require__(55);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var joinClasses = __webpack_require__(5);
	var SimpleTextEditor = __webpack_require__(49);
	var isFunction = __webpack_require__(19);


	__webpack_require__(20);

	var EditorContainer = function (_React$Component) {
	  _inherits(EditorContainer, _React$Component);

	  function EditorContainer() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, EditorContainer);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  EditorContainer.prototype.componentDidMount = function componentDidMount() {
	    var inputNode = this.getInputNode();
	    if (inputNode !== undefined) {
	      this.setTextInputFocus();
	      if (!this.getEditor().disableContainerStyles) {
	        inputNode.className += ' editor-main';
	        inputNode.style.height = this.props.height - 1 + 'px';
	      }
	    }
	  };

	  EditorContainer.prototype.componentWillUnmount = function componentWillUnmount() {
	    if (!this.changeCommitted && !this.changeCanceled) {
	      this.commit({ key: 'Enter' });
	    }
	  };

	  EditorContainer.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      { className: this.getContainerClass(), onBlur: this.handleBlur, onKeyDown: this.onKeyDown, onContextMenu: this.handleRightClick },
	      this.createEditor(),
	      this.renderStatusIcon()
	    );
	  };

	  return EditorContainer;
	}(React.Component);

	EditorContainer.displayName = 'EditorContainer';
	EditorContainer.propTypes = {
	  rowIdx: _propTypes2['default'].number,
	  rowData: _propTypes2['default'].object.isRequired,
	  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired,
	  cellMetaData: _propTypes2['default'].shape({
	    selected: _propTypes2['default'].object.isRequired,
	    copied: _propTypes2['default'].object,
	    dragged: _propTypes2['default'].object,
	    onCellClick: _propTypes2['default'].func,
	    onCellDoubleClick: _propTypes2['default'].func,
	    onCommitCancel: _propTypes2['default'].func,
	    onCommit: _propTypes2['default'].func
	  }).isRequired,
	  column: _propTypes2['default'].object.isRequired,
	  height: _propTypes2['default'].number.isRequired,
	  onGridKeyDown: _propTypes2['default'].func
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this2 = this;

	  this.state = { isInvalid: false };
	  this.changeCommitted = false;
	  this.changeCanceled = false;

	  this.isKeyExplicitlyHandled = function (key) {
	    return isFunction(_this2['onPress' + key]);
	  };

	  this.checkAndCall = function (methodName, args) {
	    if (isFunction(_this2[methodName])) {
	      _this2[methodName](args);
	    }
	  };

	  this.onKeyDown = function (e) {
	    if ((0, _keyboardUtils.isCtrlKeyHeldDown)(e)) {
	      _this2.checkAndCall('onPressKeyWithCtrl', e);
	    } else if (_this2.isKeyExplicitlyHandled(e.key)) {
	      // break up individual keyPress events to have their own specific callbacks
	      var callBack = 'onPress' + e.key;
	      _this2.checkAndCall(callBack, e);
	    } else if ((0, _keyboardUtils.isKeyPrintable)(e.keyCode)) {
	      _this2.checkAndCall('onPressChar', e);
	    }

	    // Track which keys are currently down for shift clicking etc
	    _this2._keysDown = _this2._keysDown || {};
	    _this2._keysDown[e.keyCode] = true;
	    if (isFunction(_this2.props.onGridKeyDown)) {
	      _this2.props.onGridKeyDown(e);
	    }
	  };

	  this.createEditorRef = function (ref) {
	    _this2.editor = ref;
	  };

	  this.createEditor = function () {
	    var editorProps = {
	      ref: _this2.createEditorRef,
	      column: _this2.props.column,
	      value: _this2.getInitialValue(),
	      onCommit: _this2.commit,
	      onCommitCancel: _this2.commitCancel,
	      rowMetaData: _this2.getRowMetaData(),
	      rowData: _this2.props.rowData,
	      height: _this2.props.height,
	      onBlur: _this2.commit,
	      onOverrideKeyDown: _this2.onKeyDown
	    };

	    var CustomEditor = _this2.props.column.editor;
	    // return custom column editor or SimpleEditor if none specified
	    if (React.isValidElement(CustomEditor)) {
	      return React.cloneElement(CustomEditor, editorProps);
	    }
	    if (isFunction(CustomEditor)) {
	      return React.createElement(CustomEditor, _extends({ ref: _this2.createEditorRef }, editorProps));
	    }

	    return React.createElement(SimpleTextEditor, { ref: _this2.createEditorRef, column: _this2.props.column, value: _this2.getInitialValue(), onBlur: _this2.commit, rowMetaData: _this2.getRowMetaData(), onKeyDown: function onKeyDown() {}, commit: function commit() {} });
	  };

	  this.onPressEnter = function () {
	    _this2.commit({ key: 'Enter' });
	  };

	  this.onPressTab = function () {
	    _this2.commit({ key: 'Tab' });
	  };

	  this.onPressEscape = function (e) {
	    if (!_this2.editorIsSelectOpen()) {
	      _this2.commitCancel();
	    } else {
	      // prevent event from bubbling if editor has results to select
	      e.stopPropagation();
	    }
	  };

	  this.onPressArrowDown = function (e) {
	    if (_this2.editorHasResults()) {
	      // dont want to propogate as that then moves us round the grid
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowUp = function (e) {
	    if (_this2.editorHasResults()) {
	      // dont want to propogate as that then moves us round the grid
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowLeft = function (e) {
	    // prevent event propogation. this disables left cell navigation
	    if (!_this2.isCaretAtBeginningOfInput()) {
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.onPressArrowRight = function (e) {
	    // prevent event propogation. this disables right cell navigation
	    if (!_this2.isCaretAtEndOfInput()) {
	      e.stopPropagation();
	    } else {
	      _this2.commit(e);
	    }
	  };

	  this.editorHasResults = function () {
	    if (isFunction(_this2.getEditor().hasResults)) {
	      return _this2.getEditor().hasResults();
	    }

	    return false;
	  };

	  this.editorIsSelectOpen = function () {
	    if (isFunction(_this2.getEditor().isSelectOpen)) {
	      return _this2.getEditor().isSelectOpen();
	    }

	    return false;
	  };

	  this.getRowMetaData = function () {
	    // clone row data so editor cannot actually change this
	    // convention based method to get corresponding Id or Name of any Name or Id property
	    if (typeof _this2.props.column.getRowMetaData === 'function') {
	      return _this2.props.column.getRowMetaData(_this2.props.rowData, _this2.props.column);
	    }
	  };

	  this.getEditor = function () {
	    return _this2.editor;
	  };

	  this.getInputNode = function () {
	    return _this2.getEditor().getInputNode();
	  };

	  this.getInitialValue = function () {
	    var selected = _this2.props.cellMetaData.selected;
	    var keyCode = selected.initialKeyCode;
	    if (keyCode === 'Delete' || keyCode === 'Backspace') {
	      return '';
	    } else if (keyCode === 'Enter') {
	      return _this2.props.value;
	    }

	    var text = keyCode ? String.fromCharCode(keyCode) : _this2.props.value;
	    return text;
	  };

	  this.getContainerClass = function () {
	    return joinClasses({
	      'has-error': _this2.state.isInvalid === true
	    });
	  };

	  this.commit = function (args) {
	    var opts = args || {};
	    var updated = _this2.getEditor().getValue();
	    if (_this2.isNewValueValid(updated)) {
	      _this2.changeCommitted = true;
	      var cellKey = _this2.props.column.key;
	      _this2.props.cellMetaData.onCommit({ cellKey: cellKey, rowIdx: _this2.props.rowIdx, updated: updated, key: opts.key });
	    }
	  };

	  this.commitCancel = function () {
	    _this2.changeCanceled = true;
	    _this2.props.cellMetaData.onCommitCancel();
	  };

	  this.isNewValueValid = function (value) {
	    if (isFunction(_this2.getEditor().validate)) {
	      var isValid = _this2.getEditor().validate(value);
	      _this2.setState({ isInvalid: !isValid });
	      return isValid;
	    }

	    return true;
	  };

	  this.setCaretAtEndOfInput = function () {
	    var input = _this2.getInputNode();
	    // taken from http://stackoverflow.com/questions/511088/use-javascript-to-place-cursor-at-end-of-text-in-text-input-element
	    var txtLength = input.value.length;
	    if (input.setSelectionRange) {
	      input.setSelectionRange(txtLength, txtLength);
	    } else if (input.createTextRange) {
	      var fieldRange = input.createTextRange();
	      fieldRange.moveStart('character', txtLength);
	      fieldRange.collapse();
	      fieldRange.select();
	    }
	  };

	  this.isCaretAtBeginningOfInput = function () {
	    var inputNode = _this2.getInputNode();
	    return inputNode.selectionStart === inputNode.selectionEnd && inputNode.selectionStart === 0;
	  };

	  this.isCaretAtEndOfInput = function () {
	    var inputNode = _this2.getInputNode();
	    return inputNode.selectionStart === inputNode.value.length;
	  };

	  this.isBodyClicked = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return relatedTarget === null;
	  };

	  this.isViewportClicked = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return relatedTarget.className.indexOf('react-grid-Viewport') > -1;
	  };

	  this.isClickInsideEditor = function (e) {
	    var relatedTarget = _this2.getRelatedTarget(e);
	    return e.currentTarget.contains(relatedTarget) || relatedTarget.className.indexOf('editing') > -1 || relatedTarget.className.indexOf('react-grid-Cell') > -1;
	  };

	  this.getRelatedTarget = function (e) {
	    return e.relatedTarget || e.explicitOriginalTarget || document.activeElement; // IE11
	  };

	  this.handleRightClick = function (e) {
	    e.stopPropagation();
	  };

	  this.handleBlur = function (e) {
	    e.stopPropagation();
	    if (_this2.isBodyClicked(e)) {
	      _this2.commit(e);
	    }

	    if (!_this2.isBodyClicked(e)) {
	      // prevent null reference
	      if (_this2.isViewportClicked(e) || !_this2.isClickInsideEditor(e)) {
	        _this2.commit(e);
	      }
	    }
	  };

	  this.setTextInputFocus = function () {
	    var selected = _this2.props.cellMetaData.selected;
	    var keyCode = selected.initialKeyCode;
	    var inputNode = _this2.getInputNode();
	    inputNode.focus();
	    if (inputNode.tagName === 'INPUT') {
	      if (!(0, _keyboardUtils.isKeyPrintable)(keyCode)) {
	        inputNode.focus();
	        inputNode.select();
	      } else {
	        inputNode.select();
	      }
	    }
	  };

	  this.renderStatusIcon = function () {
	    if (_this2.state.isInvalid === true) {
	      return React.createElement('span', { className: 'glyphicon glyphicon-remove form-control-feedback' });
	    }
	  };
	};

	module.exports = EditorContainer;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  CheckboxEditor: __webpack_require__(47),
	  EditorBase: __webpack_require__(48),
	  SimpleTextEditor: __webpack_require__(49)
	};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(9);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/prop-types */


	var focusableComponentWrapper = function focusableComponentWrapper(WrappedComponent) {
	  return function (_Component) {
	    _inherits(ComponentWrapper, _Component);

	    function ComponentWrapper() {
	      _classCallCheck(this, ComponentWrapper);

	      var _this = _possibleConstructorReturn(this, _Component.call(this));

	      _this.checkFocus = _this.checkFocus.bind(_this);
	      _this.state = { isScrolling: false };
	      return _this;
	    }

	    ComponentWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	      return WrappedComponent.isSelected(this.props) !== WrappedComponent.isSelected(nextProps);
	    };

	    ComponentWrapper.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	      var isScrolling = WrappedComponent.isScrolling(nextProps);
	      if (isScrolling && !this.state.isScrolling) {
	        this.setState({ isScrolling: isScrolling });
	      }
	    };

	    ComponentWrapper.prototype.componentDidMount = function componentDidMount() {
	      this.checkFocus();
	    };

	    ComponentWrapper.prototype.componentDidUpdate = function componentDidUpdate() {
	      this.checkFocus();
	    };

	    ComponentWrapper.prototype.checkFocus = function checkFocus() {
	      if (WrappedComponent.isSelected(this.props) && this.state.isScrolling) {
	        this.focus();
	        this.setState({ isScrolling: false });
	      }
	    };

	    ComponentWrapper.prototype.focus = function focus() {
	      _reactDom2['default'].findDOMNode(this).focus();
	    };

	    ComponentWrapper.prototype.render = function render() {
	      return _react2['default'].createElement(WrappedComponent, _extends({}, this.props, this.state));
	    };

	    return ComponentWrapper;
	  }(_react.Component);
	};

	exports['default'] = focusableComponentWrapper;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  SimpleCellFormatter: __webpack_require__(51),
	  SelectAll: __webpack_require__(50)
	};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _GridPropHelpers = __webpack_require__(129);

	var _GridPropHelpers2 = _interopRequireDefault(_GridPropHelpers);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = {
	  test: { GridPropHelpers: _GridPropHelpers2['default'] }
	};

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	'use strict';

	var _rows = [];
	for (var i = 0; i < 1000; i++) {
	  _rows.push({
	    id: i,
	    title: 'Title ' + i,
	    count: i * 1000
	  });
	}
	module.exports = {
	  columns: [{
	    key: 'id',
	    name: 'ID',
	    width: 100
	  }, {
	    key: 'title',
	    name: 'Title',
	    width: 100
	  }, {
	    key: 'count',
	    name: 'Count',
	    width: 100
	  }],
	  rowGetter: function rowGetter(i) {
	    return _rows[i];
	  },
	  rowsCount: function rowsCount() {
	    return _rows.length;
	  },
	  cellMetaData: {
	    selected: { idx: 2, rowIdx: 3 },
	    dragged: null,
	    copied: null
	  }
	};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _RowComparer = __webpack_require__(43);

	var _RowComparer2 = _interopRequireDefault(_RowComparer);

	var _RowsContainer = __webpack_require__(45);

	var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var Grid = __webpack_require__(119);

	module.exports = Grid;
	module.exports.Row = __webpack_require__(42);
	module.exports.Cell = __webpack_require__(40);
	module.exports.HeaderCell = __webpack_require__(41);
	module.exports.RowComparer = _RowComparer2['default'];
	module.exports.EmptyChildRow = __webpack_require__(110);
	module.exports.RowsContainer = _RowsContainer2['default'];
	module.exports.editors = __webpack_require__(125);
	module.exports.formatters = __webpack_require__(127);
	module.exports.utils = __webpack_require__(53);
	module.exports.shapes = __webpack_require__(118);
	module.exports._constants = __webpack_require__(30);
	module.exports._helpers = __webpack_require__(128);

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	"use strict";

	var isEmptyArray = function isEmptyArray(obj) {
	  return Array.isArray(obj) && obj.length === 0;
	};

	module.exports = isEmptyArray;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

	"use strict";

	function isEmpty(obj) {
	  return Object.keys(obj).length === 0 && obj.constructor === Object;
	}

	module.exports = isEmpty;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _immutable = __webpack_require__(18);

	var isImmutableCollection = function isImmutableCollection(objToVerify) {
	  return _immutable.Iterable.isIterable(objToVerify);
	};

	module.exports = isImmutableCollection;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _immutable = __webpack_require__(18);

	module.exports = _immutable.Map.isMap;

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	"use strict";

	var getMixedTypeValueRetriever = function getMixedTypeValueRetriever(isImmutable) {
	  var retObj = {};
	  var retriever = function retriever(item, key) {
	    return item[key];
	  };
	  var immutableRetriever = function immutableRetriever(immutable, key) {
	    return immutable.get(key);
	  };

	  retObj.getValue = isImmutable ? immutableRetriever : retriever;

	  return retObj;
	};

	module.exports = getMixedTypeValueRetriever;

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	function createScrollShim(size) {
	  var shim = document.createElement('div');
	  if (shim.classList) {
	    shim.classList.add('react-grid-ScrollShim'); // flow - not compatible with HTMLElement
	  } else {
	    shim.className += ' react-grid-ScrollShim';
	  }
	  shim.style.position = 'absolute';
	  shim.style.top = 0;
	  shim.style.left = 0;
	  shim.style.width = size.width + 'px';
	  shim.style.height = size.height + 'px';

	  return shim;
	}

	exports.createScrollShim = createScrollShim;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.getRenderedColumnCount = exports.getNextScrollState = exports.getGridState = undefined;

	var _ColumnUtils = __webpack_require__(6);

	var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var min = Math.min;
	var max = Math.max;
	var floor = Math.floor;
	var ceil = Math.ceil;

	function getGridState(props) {
	  var totalNumberColumns = _ColumnUtils2['default'].getSize(props.columnMetrics.columns);
	  var canvasHeight = props.minHeight - props.rowOffsetHeight;
	  var renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);
	  var totalRowCount = min(renderedRowsCount * 4, props.rowsCount);
	  return {
	    displayStart: 0,
	    displayEnd: totalRowCount,
	    visibleStart: 0,
	    visibleEnd: totalRowCount,
	    height: canvasHeight,
	    scrollTop: 0,
	    scrollLeft: 0,
	    colVisibleStart: 0,
	    colVisibleEnd: totalNumberColumns,
	    colDisplayStart: 0,
	    colDisplayEnd: totalNumberColumns
	  };
	}

	function getRenderedColumnCount(props, getDOMNodeOffsetWidth, displayStart, width) {
	  var remainingWidth = width && width > 0 ? width : props.columnMetrics.totalWidth;
	  if (remainingWidth === 0) {
	    remainingWidth = getDOMNodeOffsetWidth();
	  }
	  var columnIndex = displayStart;
	  var columnCount = 0;
	  while (remainingWidth > 0) {
	    var column = _ColumnUtils2['default'].getColumn(props.columnMetrics.columns, columnIndex);

	    if (!column) {
	      break;
	    }

	    columnCount++;
	    columnIndex++;
	    remainingWidth -= column.width;
	  }
	  return columnCount;
	}

	function getVisibleColStart(props, scrollLeft) {
	  var remainingScroll = scrollLeft;
	  var columnIndex = -1;
	  while (remainingScroll >= 0) {
	    columnIndex++;
	    remainingScroll -= _ColumnUtils2['default'].getColumn(props.columnMetrics.columns, columnIndex).width;
	  }
	  return columnIndex;
	}

	function getNextScrollState(props, getDOMNodeOffsetWidth, scrollTop, scrollLeft, height, rowHeight, length, width) {
	  var isScrolling = true;
	  var renderedRowsCount = ceil(height / rowHeight);
	  var visibleStart = max(0, floor(scrollTop / rowHeight));
	  var visibleEnd = min(visibleStart + renderedRowsCount, length);
	  var displayStart = max(0, visibleStart - props.overScan.rowsStart);
	  var displayEnd = min(visibleEnd + props.overScan.rowsEnd, length);
	  var totalNumberColumns = _ColumnUtils2['default'].getSize(props.columnMetrics.columns);
	  var colVisibleStart = totalNumberColumns > 0 ? max(0, getVisibleColStart(props, scrollLeft)) : 0;
	  var renderedColumnCount = getRenderedColumnCount(props, getDOMNodeOffsetWidth, colVisibleStart, width);
	  var colVisibleEnd = renderedColumnCount !== 0 ? colVisibleStart + renderedColumnCount : totalNumberColumns;
	  var colDisplayStart = max(0, colVisibleStart - props.overScan.colsStart);
	  var colDisplayEnd = min(colVisibleEnd + props.overScan.colsEnd, totalNumberColumns);

	  var nextScrollState = {
	    visibleStart: visibleStart,
	    visibleEnd: visibleEnd,
	    displayStart: displayStart,
	    displayEnd: displayEnd,
	    height: height,
	    scrollTop: scrollTop,
	    scrollLeft: scrollLeft,
	    colVisibleStart: colVisibleStart,
	    colVisibleEnd: colVisibleEnd,
	    colDisplayStart: colDisplayStart,
	    colDisplayEnd: colDisplayEnd,
	    isScrolling: isScrolling
	  };

	  return nextScrollState;
	}

	exports.getGridState = getGridState;
	exports.getNextScrollState = getNextScrollState;
	exports.getRenderedColumnCount = getRenderedColumnCount;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Cell{background-color:#fff;padding-left:8px;padding-right:8px;border-right:1px solid #eee;border-bottom:1px solid #ddd}.react-grid-Cell:focus{outline:2px solid #66afe9;outline-offset:-2px}.react-grid-Cell--locked:focus{z-index:100}.react-grid-Cell:focus .drag-handle{position:absolute;bottom:-5px;right:-4px;background:#66afe9;width:8px;height:8px;border:1px solid #fff;border-right:0;border-bottom:0;z-index:8;cursor:crosshair;cursor:-webkit-grab}.react-grid-Cell:not(.editing) .react-grid-Cell__value{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.react-grid-Cell:not(.editing):not(.rdg-child-cell) .react-grid-Cell__value{position:relative;top:50%;transform:translateY(-50%)}.rdg-child-cell .react-grid-Cell__value{line-height:35px}.react-grid-Cell.readonly{background-color:#000}.react-grid-Cell.copied{background:rgba(0,0,255,.2)!important}.react-grid-Cell--locked:last-of-type{border-right:1px solid #ddd;box-shadow:none}.react-grid-Cell:hover:focus .drag-handle .glyphicon-arrow-down{display:\"block\"}.react-grid-Cell.is-dragged-over-down{border-right:1px dashed #000;border-left:1px dashed #000;border-bottom:1px dashed #000}.react-grid-Cell.is-dragged-over-up{border-right:1px dashed #000;border-left:1px dashed #000;border-top:1px dashed #000}.react-grid-Cell.is-dragged-over-up .drag-handle{top:-5px}.react-grid-Cell:hover{background:#eee}.react-grid-cell .form-control-feedback{color:#a94442;position:absolute;top:0;right:10px;z-index:1000000;display:block;width:34px;height:34px}.react-grid-Cell.was-dragged-over{border-right:1px dashed #000;border-left:1px dashed #000}.react-grid-Cell:hover:focus .drag-handle{position:absolute;bottom:-8px;right:-7px;background:#fff;width:16px;height:16px;border:1px solid #66afe9;z-index:8;cursor:crosshair;cursor:-webkit-grab}.react-grid-Row.row-selected .react-grid-Cell{background-color:#dbecfa}.react-grid-Cell.editing{padding:0;overflow:visible!important}.react-grid-Cell--locked.editing{z-index:100}.react-grid-Cell.editing .has-error input{border:2px solid red!important;border-radius:2px!important}.react-grid-Cell__value ul{margin-top:0;margin-bottom:0;display:inline-block}.react-grid-Cell__value .btn-sm{padding:0}.cell-tooltip{position:relative;display:inline-block}.cell-tooltip:hover{z-index:101}.cell-tooltip .cell-tooltip-text{visibility:hidden;width:150px;background-color:#000;color:#fff;text-align:center;border-radius:6px;padding:5px 0;position:absolute;z-index:1;bottom:-150%;left:50%;margin-left:-60px;opacity:1s}.cell-tooltip:hover .cell-tooltip-text{visibility:visible;opacity:.8}.cell-tooltip .cell-tooltip-text:after{content:\" \";position:absolute;bottom:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:transparent transparent #000}.react-grid-Canvas.opaque .react-grid-Cell.cell-tooltip:hover .cell-tooltip-text{visibility:hidden}.rdg-cell-expand{top:0;right:20px;position:absolute;cursor:pointer}.rdg-child-row-action-cross-last:before,.rdg-child-row-action-cross:before,rdg-child-row-action-cross-last:after,rdg-child-row-action-cross:after{content:\"\";position:absolute;background:grey;height:50%}.rdg-child-row-action-cross:before{left:21px;width:1px;height:35px}.rdg-child-row-action-cross-last:before{left:21px;width:1px}.rdg-child-row-action-cross-last:after,.rdg-child-row-action-cross:after{top:50%;left:20px;height:1px;width:15px;content:\"\";position:absolute;background:grey}.rdg-child-row-action-cross:hover{background:red}.rdg-child-row-btn{position:absolute;cursor:pointer;border:1px solid grey;border-radius:14px;z-index:3;background:#fff}.rdg-child-row-btn div{font-size:12px;text-align:center;line-height:19px;color:grey;height:20px;width:20px;position:absolute;top:60%;left:53%;margin-top:-10px;margin-left:-10px}.rdg-empty-child-row:hover .glyphicon-plus-sign,.rdg-empty-child-row:hover a{color:green}.rdg-child-row-btn .glyphicon-remove-sign:hover{color:red}.last-column .cell-tooltip-text{right:100%;left:0!important}.rdg-cell-action{float:right;height:100%}.rdg-cell-action-last{margin-right:-8px}.rdg-cell-action-button{width:35px;height:100%;text-align:center;position:relative;display:table}.rdg-cell-action-button>span{display:table-cell;vertical-align:middle}.rdg-cell-action-button:hover{background-color:#fff}.rdg-cell-action-button-toggled{background-color:#fff;border-right:1px solid #ccc;border-left:1px solid #ccc}.rdg-cell-action-button-toggled:after{content:\"\";height:1px;position:absolute;bottom:-1px;left:0;right:0;background:inherit;z-index:10001}.rdg-cell-action-menu{position:absolute;top:100%;right:0;z-index:1000;float:left;min-width:160px;padding:5px 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc}.rdg-cell-action-menu>span{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.rdg-cell-action-menu>span:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}", ""]);

	// exports


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".radio-custom,.react-grid-checkbox{opacity:0;position:absolute}.radio-custom,.radio-custom-label,.react-grid-checkbox,.react-grid-checkbox-label{display:inline-block;vertical-align:middle;cursor:pointer}.radio-custom-label,.react-grid-checkbox-label{position:relative}.radio-custom+.radio-custom-label:before,.react-grid-checkbox+.react-grid-checkbox-label:before{content:\"\";background:#fff;border:2px solid #ddd;display:inline-block;vertical-align:middle;width:20px;height:20px;text-align:center}.react-grid-checkbox:checked+.react-grid-checkbox-label:before{background:#005295;box-shadow:inset 0 0 0 4px #fff}.radio-custom:focus+.radio-custom-label,.react-grid-checkbox:focus+.react-grid-checkbox-label{outline:1px solid #ddd}.react-grid-HeaderCell input[type=checkbox]{z-index:99999}.react-grid-HeaderCell>.react-grid-checkbox-container{padding:0 10px;height:100%}.react-grid-HeaderCell>.react-grid-checkbox-container>.react-grid-checkbox-label{margin:0;position:relative;top:50%;transform:translateY(-50%)}.radio-custom+.radio-custom-label:before{border-radius:50%}.radio-custom:checked+.radio-custom-label:before{background:#ccc;box-shadow:inset 0 0 0 4px #fff}.checkbox-align{text-align:center}", ""]);

	// exports


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Container{clear:both;margin-top:0;padding:0}.react-grid-Main{background-color:#fff;color:inherit;padding:0;outline:1px solid #e7eaec;clear:both}.react-grid-Grid{border:1px solid #ddd}.react-grid-Canvas,.react-grid-Grid{background-color:#fff}.react-grid-Cell input.editor-main,select.editor-main{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}input.editor-main:focus,select.editor-main:focus{border-color:#66afe9;border:2px solid #66afe9;background:#eee;border-radius:4px}.react-grid-Cell input.editor-main::-moz-placeholder,select.editor-main::-moz-placeholder{color:#999;opacity:1}.react-grid-Cell input.editor-main:-ms-input-placeholder,select.editor-main:-ms-input-placeholder{color:#999}.react-grid-Cell input.editor-main::-webkit-input-placeholder,select.editor-main::-webkit-input-placeholder{color:#999}.react-grid-Cell input.editor-main[disabled],.react-grid-Cell input.editor-main[readonly],fieldset[disabled] .react-grid-Cell input.editor-main,fieldset[disabled] select.editor-main,select.editor-main[disabled],select.editor-main[readonly]{cursor:not-allowed;background-color:#eee;opacity:1}textarea.react-grid-Cell input.editor-main,textareaselect.editor-main{height:auto}.react-grid-ScrollShim{z-index:10002}", ""]);

	// exports


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Header{box-shadow:0 0 4px 0 #ddd;background:#f9f9f9}.react-grid-Header--resizing{cursor:ew-resize}.react-grid-HeaderCell,.react-grid-HeaderRow{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.react-grid-HeaderCell{background:#f9f9f9;padding:8px;font-weight:700;border-right:1px solid #ddd;border-bottom:1px solid #ddd}.react-grid-HeaderCell__value{white-space:nowrap;text-overflow:ellipsis;overflow:hidden;position:relative;top:50%;transform:translateY(-50%)}.react-grid-HeaderCell__resizeHandle:hover{cursor:ew-resize;background:#ddd}.react-grid-HeaderCell--locked:last-of-type{box-shadow:none}.react-grid-HeaderCell--resizing .react-grid-HeaderCell__resizeHandle{background:#ddd}.react-grid-HeaderCell__draggable{cursor:col-resize}.rdg-can-drop>.react-grid-HeaderCell{background:#ececec}.react-grid-HeaderCell .Select{max-height:30px;font-size:12px;font-weight:400}.react-grid-HeaderCell .Select-control{max-height:30px;border:1px solid #ccc;color:#555;border-radius:3px}.react-grid-HeaderCell .is-focused:not(.is-open)>.Select-control{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.react-grid-HeaderCell .Select-control .Select-placeholder{line-height:20px;color:#999;padding:4px}.react-grid-HeaderCell .Select-control .Select-input{max-height:28px;padding:4px;margin-left:0}.react-grid-HeaderCell .Select-control .Select-input input{padding:0;height:100%}.react-grid-HeaderCell .Select-control .Select-arrow-zone .Select-arrow{border-color:gray transparent transparent;border-width:4px 4px 2.5px}.react-grid-HeaderCell .Select-control .Select-value{padding:4px;line-height:20px!important}.react-grid-HeaderCell .Select--multi .Select-control .Select-value{padding:0;line-height:16px!important;max-height:20px}.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-icon,.react-grid-HeaderCell .Select--multi .Select-control .Select-value .Select-value-label{max-height:20px}.react-grid-HeaderCell .Select-control .Select-value .Select-value-label{color:#555!important}.react-grid-HeaderCell .Select-menu-outer .Select-option{padding:4px;line-height:20px}.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-focused,.react-grid-HeaderCell .Select-menu-outer .Select-menu .Select-option.is-selected{color:#555}", ""]);

	// exports


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, ".react-grid-Row.row-context-menu .react-grid-Cell,.react-grid-Row:hover .react-grid-Cell{background-color:#f9f9f9}.react-grid-Row:hover .rdg-row-index{display:none}.react-grid-Row:hover .rdg-actions-checkbox{display:block}.react-grid-Row:hover .rdg-drag-row-handle{cursor:move;cursor:grab;cursor:-moz-grab;cursor:-webkit-grab;width:12px;height:30px;margin-left:0;background-image:url(\"data:image/svg+xml;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjlweCIgaGVpZ2h0PSIyOXB4IiB2aWV3Qm94PSIwIDAgOSAyOSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggMzkgKDMxNjY3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5kcmFnIGljb248L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iQWN0dWFsaXNhdGlvbi12MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkRlc2t0b3AiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNS4wMDAwMDAsIC0yNjIuMDAwMDAwKSIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxnIGlkPSJJbnRlcmFjdGlvbnMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjAwMDAwMCwgMjU4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJvdy1Db250cm9scyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9ImRyYWctaWNvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMTIiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjEyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjIiIGN5PSIxNyIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSI3IiBjeT0iMTciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iMiIgY3k9IjIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0zMCIgY3g9IjciIGN5PSIyMiIgcj0iMiI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMzAiIGN4PSIyIiBjeT0iMjciIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLTMwIiBjeD0iNyIgY3k9IjI3IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==\");background-repeat:no-repeat}.react-grid-Row.row-selected,.react-grid-Row .row-selected{background-color:#dbecfa}.react-grid-row-group .row-expand-icon:hover{color:#777}.react-grid-row-index{padding:0 18px}.rdg-row-index{display:block;text-align:center}.rdg-row-actions-cell{padding:0}.rdg-actions-checkbox{display:none;text-align:center}.rdg-actions-checkbox.selected{display:block}.rdg-dragging{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.rdg-dragged-row{border-bottom:1px solid #000}", ""]);

	// exports


/***/ }),
/* 143 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (false) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2014 Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */

	"use strict";

	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function(obj) {
	  var ret = {};
	  var key;
	  if (!(obj instanceof Object && !Array.isArray(obj))) {
	    throw new Error('keyMirror(...): Argument must be an object.');
	  }
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};

	module.exports = keyMirror;


/***/ }),
/* 146 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(143);
	var invariant = __webpack_require__(144);
	var ReactPropTypesSecret = __webpack_require__(148);

	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };

	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};


/***/ }),
/* 148 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ })
/******/ ])
});
;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChartView = function (_React$Component) {
    _inherits(ChartView, _React$Component);

    function ChartView(props) {
        _classCallCheck(this, ChartView);

        var _this = _possibleConstructorReturn(this, (ChartView.__proto__ || Object.getPrototypeOf(ChartView)).call(this, props));

        _this.state = {};
        return _this;
    }

    _createClass(ChartView, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            //window.addEventListener("resize", this.redrawChart.bind(this));
            this.redrawChart();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.redrawChart();
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.state.chart != undefined) {
                this.state.chart.destroy();
            }
        }
    }, {
        key: 'redrawChart',
        value: function redrawChart() {
            if (this.state.chart != undefined) {
                this.state.chart.destroy();
                this.state.chart = undefined;
            }

            if (this.state.chart == undefined) {
                var ctx = document.getElementById(this.getDivId()).getContext("2d");
                var data = this.getChartData();
                var yAxes = undefined;
                if (data != undefined && Array.isArray(data.datasets)) {
                    var axis = [];
                    data.datasets.forEach(function (e) {
                        if (e.yAxisID != undefined && e.yAxisID != null) {
                            if (!axis.includes(e.yAxisID)) axis.push(e.yAxisID);
                        }
                    });

                    if (axis.length > 0) {
                        yAxes = [];
                        for (var i = 0; i < axis.length; i++) {
                            if (i == 0) {
                                yAxes.push({ type: 'linear', display: true, position: 'left', id: axis[i] });
                            } else {
                                yAxes.push({ type: 'linear', display: true, position: 'right', id: axis[i], gridLines: {
                                        drawOnChartArea: false
                                    } });
                            }
                        }
                    }
                }

                var config = {
                    type: this.props.chartType,
                    data: data,
                    options: {
                        responsive: Boolean(this.props.responsive),
                        legend: {
                            position: this.props.legendPosition
                        },
                        title: {
                            fontSize: this.props.titleSize == undefined ? 14 : this.props.titleSize,
                            display: this.props.title != undefined && this.props.title != "",
                            text: this.props.title
                        }
                    }
                };

                if (yAxes != undefined) config.options.scales = { yAxes: yAxes };

                this.state.chart = new Chart(ctx, config);
            } else {
                this.state.chart.update();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var style = this.props.style;
            var width = this.props.width != undefined ? this.props.width : "400px";
            if (style.width != undefined) width = style.width;
            var height = this.props.height != undefined ? this.props.height : "300px";
            if (style.height != undefined) {
                height = style.height;
            }

            if ((this.state.width != width || this.state.height != height) && this.state.chart != undefined) {
                this.state.chart.destroy();
                this.state.chart = undefined;
            }

            this.state.width = width;
            this.state.height = height;

            var className = "field";
            if (this.props.className != undefined) className += " " + this.props.className;

            return _react2.default.createElement(
                'div',
                { className: className, style: style },
                _react2.default.createElement('canvas', { id: this.getDivId(), width: width, height: height })
            );
        }
    }, {
        key: 'getDivId',
        value: function getDivId() {
            return "dwkit-chart-" + this.props.name;
        }
    }, {
        key: 'getChartData',
        value: function getChartData() {
            if (this.props.datasetCustom) {
                var me = this;

                var labels = [];
                if (me.props.dataLabels != undefined) {
                    labels = me.props.dataLabels.split(',');
                }

                var res = {
                    labels: labels,
                    datasets: [{
                        label: me.props.datasetLabel,
                        steppedLine: me.props.datasetSteppedLine,
                        borderColor: me.props.datasetBorderColor,
                        backgroundColor: me.props.datasetBackgroundColor,
                        fill: me.props.datasetFill,
                        borderWidth: me.props.datasetBorderWidth,
                        data: me.props.value
                    }]
                };
                return res;
            }

            return this.copyObj(this.props.value);
        }
    }, {
        key: 'copyObj',
        value: function copyObj(obj) {
            if (null == obj || "object" != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;
            var copy = obj.constructor();

            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = this.copyObj(obj[attr]);
            }
            return copy;
        }
    }]);

    return ChartView;
}(_react2.default.Component);

exports.default = ChartView;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WorkflowBar = function (_React$Component) {
  _inherits(WorkflowBar, _React$Component);

  function WorkflowBar(props) {
    _classCallCheck(this, WorkflowBar);

    var _this = _possibleConstructorReturn(this, (WorkflowBar.__proto__ || Object.getPrototypeOf(WorkflowBar)).call(this, props));

    _this.state = {
      commands: props.commands,
      states: props.states
    };

    _this.checkGetAdditionalDataForControl();
    return _this;
  }

  _createClass(WorkflowBar, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.isMount = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.isMount = false;
    }
  }, {
    key: 'checkGetAdditionalDataForControl',
    value: function checkGetAdditionalDataForControl() {
      if (this.props.getAdditionalDataForControl == undefined && this.props.commands == undefined && this.props.states == undefined) {
        if (console != undefined) {
          console.log("WorkflowBar: This control requres getAdditionalDataForControl or commands and states not undefined parameters!");
        }
      } else {
        var me = this;
        this.props.getAdditionalDataForControl(this, {}, function (_ref) {
          var commands = _ref.commands,
              states = _ref.states;

          me.state.commands = commands;
          me.state.states = states;

          if (me.props.handleEvent != undefined) {
            me.props.handleEvent({ key: me.props.name, eventName: "onReceivedCommands",
              parameters: {
                commands: me.state.commands,
                states: me.state.states
              }
            });
          }

          if (me.isMount) me.forceUpdate();
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var className = this.props.className + " dwkit-workflowbar";
      var style = this.props.style;

      var commands = this.state.commands != undefined ? this.state.commands : this.props.commands;
      var states = this.state.states != undefined ? this.state.states : this.props.states;

      return _react2.default.createElement(
        'div',
        { className: className, style: style },
        _react2.default.createElement(
          _semanticUiReact.Form.Group,
          null,
          this.renderCommands(commands),
          this.renderSetState(states)
        )
      );
    }
  }, {
    key: 'renderCommands',
    value: function renderCommands(commands) {
      if (Array.isArray(commands) && commands.length > 0) {
        var me = this;
        var res = [];

        commands.forEach(function (b) {
          res.push(_react2.default.createElement(
            _semanticUiReact.Button,
            { key: b.value, className: "buttontype" + b.type, onClick: me.onCommand.bind(me, b) },
            b.text
          ));
        });

        return res;
      }
      return undefined;
    }
  }, {
    key: 'renderSetState',
    value: function renderSetState(states) {
      if (Boolean(this.props.blockSetState)) {
        return;
      }

      if (Array.isArray(states) && states.length > 0) {
        var disableClick = this.state["setstate"] == undefined || this.state["setstate"] == "";

        var setStateButton = "Set state";

        if (this.props.setStateButton != undefined && this.props.setStateButton != "") {
          setStateButton = this.props.setStateButton;
        } else {
          if (window.DWKitAdminLang != undefined && window.DWKitAdminLang.workflowbar != undefined) {
            setStateButton = window.DWKitAdminLang.workflowbar.setstate;
          }
        }

        return [_react2.default.createElement(_semanticUiReact.Form.Dropdown, {
          key: 'setstate',
          name: 'setstate',
          className: 'setstate',
          placeholder: 'States',
          options: states,
          onChange: this.handleChanged.bind(this),
          selection: true, fluid: true, search: true }), _react2.default.createElement(
          _semanticUiReact.Button,
          { key: 'btnsetstate', disabled: disableClick, className: 'buttontype2', onClick: this.onSetState.bind(this) },
          setStateButton
        )];
      }
      return undefined;
    }
  }, {
    key: 'onCommand',
    value: function onCommand(button) {
      if (this.props.handleEvent != undefined) {
        this.props.handleEvent({ key: this.props.name, eventName: "onCommandClick", parameters: { command: button } });
      }
    }
  }, {
    key: 'onSetState',
    value: function onSetState() {
      if (this.props.handleEvent != undefined) {

        var states = this.state.states != undefined ? this.state.states : this.props.states;
        var currentState = undefined;
        for (var i = 0; i < states.length; i++) {
          if (states[i].value == this.state.setstate) {
            currentState = states[i];
            break;
          }
        }

        this.props.handleEvent({ key: this.props.name, eventName: "onSetStateClick", parameters: { state: currentState } });
      }
    }
  }, {
    key: 'handleChanged',
    value: function handleChanged(e, _ref2) {
      var name = _ref2.name,
          value = _ref2.value;

      this.state[name] = value;
      this.forceUpdate();
    }
  }]);

  return WorkflowBar;
}(_react2.default.Component);

exports.default = WorkflowBar;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dictionary = function (_React$Component) {
    _inherits(Dictionary, _React$Component);

    function Dictionary(props) {
        _classCallCheck(this, Dictionary);

        var _this = _possibleConstructorReturn(this, (Dictionary.__proto__ || Object.getPrototypeOf(Dictionary)).call(this, props));

        _this.state = {
            options: []
        };

        _this.pageSize = props.pageSize;
        if (_this.pageSize == undefined || _this.pageSize == "") _this.pageSize = 100;
        return _this;
    }

    _createClass(Dictionary, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.GetAdditionalData();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this.GetAdditionalData();
        }
    }, {
        key: 'GetAdditionalData',
        value: function GetAdditionalData() {
            if (this.state.dataModel === undefined) {
                if (console !== undefined && this.props.buildermode == true) console.log("Dictionary: Set DataModel label!");
            } else if (this.state.getAdditionalDataForControl === undefined) {
                if (console !== undefined && this.props.buildermode == true) console.log("Dictionary: For paging on server need to set getAdditionalDataForControl func!");
            } else {
                if (this.state.needFetch) {
                    var me = this;
                    var settings = { model: this.state.dataModel };
                    var lastLoadPage = 0;
                    if (this.props.paging) {
                        settings.startIndex = 0;
                        settings.pageSize = this.pageSize;
                    }

                    this.state.isFetching = true;
                    this.state.needFetch = false;
                    this.state.getAdditionalDataForControl(this, settings, function (_ref) {
                        var items = _ref.items,
                            rowsCount = _ref.rowsCount;
                        //TODO cancellation token from async request
                        me.setData({ items: items, rowsCount: rowsCount, page: lastLoadPage }, true);
                    });
                }

                if (this.state.needValueFetch) {
                    this.state.needValueFetch = false;
                    this.loadCurrentValue();
                }
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var me = this;

            var controlProps = {};
            for (var p in this.props) {
                if (p == "parentIsForm" || p == "getAdditionalDataForControl" || p == "dataModel" || p == "clearable" || p == "columns" || p == "paging" || p == "pageSize") continue;
                controlProps[p] = this.props[p];
            }

            if (this.props.readOnly) controlProps.disabled = true;

            controlProps.options = this.state.options;
            controlProps.onChange = this.onChange.bind(this);
            if (this.props.paging) {
                controlProps.onSearchChange = this.handleSearchChange.bind(this);
                controlProps.onClose = this.onClose.bind(this);
                if (this.state.open) {
                    controlProps.open = true;
                }
            }

            if (controlProps.multiple) {
                if (controlProps.value == undefined || controlProps.value == null) {
                    controlProps.value = [];
                }

                if (!Array.isArray(controlProps.value)) {
                    controlProps.value = this.getArrayValues(controlProps.value);
                }
            }

            controlProps.loading = this.state.isFetching;
            controlProps.searchQuery = this.state.searchQuery;

            if (this.props.parentIsForm) {
                return _react2.default.createElement(_semanticUiReact.Form.Dropdown, controlProps);
            } else {
                var divClass = "ui labeled input";

                if (this.props.fluid) divClass += " fluid";

                if (this.props.error) divClass += " error";
                return _react2.default.createElement(
                    'div',
                    { className: divClass },
                    this.props.label != undefined && _react2.default.createElement(
                        'div',
                        { className: 'ui label label' },
                        this.props.label
                    ),
                    _react2.default.createElement(_semanticUiReact.Dropdown, controlProps)
                );
            }
        }
    }, {
        key: 'onChange',
        value: function onChange(e, _ref2) {
            var name = _ref2.name,
                value = _ref2.value;

            var loadFlag = false;
            if (this.props.multiple) {
                if (Array.isArray(value)) {
                    var isFind = false;
                    value.forEach(function (v) {
                        if (v === "__load") {
                            isFind = true;
                        }
                    });

                    if (isFind) {
                        loadFlag = true;
                    }
                }
            } else if (value === "__load") {
                loadFlag = true;
            }

            if (loadFlag) {
                this.state.open = true;
                this.setState({ isFetching: true });
                this.loadNextPage();
                value = this.props.value;
            } else if (this.state.open != undefined) {
                this.state.open = undefined;
            }

            if (this.props.onChange != undefined) this.props.onChange(e, { name: this.props.name, value: value });
        }
    }, {
        key: 'onClose',
        value: function onClose() {
            if (this.state.open != true && this.state.searchQuery != "") {
                this.state.isFetching = true;
                this.state.searchQuery = "";
                this.state.lastLoadPage = -1;

                this.loadNextPage(true);
            }
        }
    }, {
        key: 'handleSearchChange',
        value: function handleSearchChange(e, _ref3) {
            var searchQuery = _ref3.searchQuery;

            var me = this;
            setTimeout(function () {
                me.setState({
                    isFetching: true,
                    searchQuery: searchQuery,
                    lastLoadPage: -1
                });

                me.loadNextPage(true);
            }, 100);
        }
    }, {
        key: 'loadNextPage',
        value: function loadNextPage(reset) {
            var me = this;
            var settings = { model: this.state.dataModel };
            var page = this.state.lastLoadPage + 1;

            if (me.state.searchQuery != undefined && me.state.searchQuery != "") {
                settings.filters = [{
                    column: this.getCollumnsForFilter(),
                    term: "like",
                    value: me.state.searchQuery
                }];
            }

            settings.startIndex = page * this.pageSize;
            settings.pageSize = this.pageSize;

            this.state.getAdditionalDataForControl(this, settings, function (_ref4) {
                var items = _ref4.items,
                    rowsCount = _ref4.rowsCount;

                me.setData({ items: items, rowsCount: rowsCount, page: page }, reset);
            });
        }
    }, {
        key: 'setData',
        value: function setData(_ref5, reset) {
            var items = _ref5.items,
                rowsCount = _ref5.rowsCount,
                page = _ref5.page;

            var options = undefined;
            if (reset) {
                options = items;
                if (rowsCount > options.length) {
                    var text = (this.state.searchQuery != undefined ? this.state.searchQuery : "") + "...";
                    options.push({ key: "__load", value: "__load", text: text });
                }

                if (Boolean(this.props.clearable) && !Boolean(this.props.multiple)) {
                    options.unshift({ key: "__reset", value: "", text: "   " });
                }

                if (Boolean(this.props.multiple)) {
                    var values = this.getArrayValues(this.props.value);
                    for (var i = 0; i < values.length; i++) {
                        var value = values[i];
                        for (var j = 0; j < this.state.options.length; j++) {
                            var option = this.state.options[j];
                            if (value == option.value) {
                                options.unshift(option);
                            }
                        }
                    }
                }
            } else {
                options = this.state.options;
                var loadingItem = undefined;
                if (options.length > 0 && options[options.length - 1].key == "__load") {
                    loadingItem = options.pop();
                }

                for (var _i = 0; _i < items.length; _i++) {
                    var item = items[_i];
                    for (var _j = 0; _j < options.length; _j++) {
                        var _option = options[_j];
                        if (_option.key == item.key) {
                            options.splice(_j, 1);
                            break;
                        }
                    }
                    options.push(item);
                }

                if (loadingItem != undefined && rowsCount > options.length) options.push(loadingItem);
            }

            this.setState({
                needFetch: false,
                options: options,
                rowsCount: rowsCount,
                isFetching: false,
                lastLoadPage: page });
        }
    }, {
        key: 'getArrayValues',
        value: function getArrayValues(value) {
            var res = value;
            if (!Array.isArray(res)) {
                var valueArray = void 0;
                try {
                    valueArray = JSON.parse(res);
                } catch (e) {}
                ;

                if (!Array.isArray(valueArray)) {
                    valueArray = [res];
                }

                res = valueArray;
            }
            return res;
        }
    }, {
        key: 'loadCurrentValue',
        value: function loadCurrentValue() {
            var me = this;
            if (this.props.value != undefined && this.props.value != null) {
                if (this.props.multiple) {
                    var values = this.getArrayValues(this.props.value);
                    var unfindedValues = [];
                    for (var i = 0; i < values.length; i++) {
                        var value = values[i];
                        var isFind = false;
                        for (var j = 0; j < this.state.options.length; j++) {
                            var option = this.state.options[j];
                            if (option.value == value) {
                                isFind = true;
                                break;
                            }
                        }

                        if (!isFind) {
                            unfindedValues.push(value);
                        }
                    }

                    if (unfindedValues.length > 0) {
                        var settings = { model: this.state.dataModel };
                        settings.filters = [{
                            column: "__id",
                            term: 'in',
                            value: unfindedValues
                        }];
                        this.state.isFetching = true;

                        this.state.getAdditionalDataForControl(this, settings, function (_ref6) {
                            var items = _ref6.items;

                            me.addAdditionalOptions(items);
                        });
                    }
                } else {
                    var _isFind = false;
                    for (var _i2 = 0; _i2 < this.state.options.length; _i2++) {
                        var _option2 = this.state.options[_i2];
                        if (_option2.value == this.props.value) {
                            _isFind = true;
                            break;
                        }
                    }

                    if (!_isFind) {
                        var settings = { model: this.state.dataModel };
                        settings.filters = [{
                            column: "__id",
                            term: '=',
                            value: me.props.value
                        }];
                        this.state.isFetching = true;

                        this.state.getAdditionalDataForControl(this, settings, function (_ref7) {
                            var items = _ref7.items;

                            me.addAdditionalOptions(items);
                        });
                    }
                }
            }
        }
    }, {
        key: 'addAdditionalOptions',
        value: function addAdditionalOptions(items) {
            if (!Array.isArray(items) || items.length == 0) return;

            var options = this.state.options;

            for (var i = items.length - 1; i >= 0; i--) {
                var isFind = false;
                for (var j = 0; j < options.length; j++) {
                    if (options[j].key == items[i].key) {
                        isFind = true;
                        break;
                    }
                }

                if (!isFind) {
                    options.unshift(items[i]);
                }
            }

            this.state.isFetching = false;
            this.forceUpdate();
        }
    }, {
        key: 'getCollumnsForFilter',
        value: function getCollumnsForFilter() {
            var pattern = new RegExp(' asc', 'gi');
            var res = this.props.columns.replace(pattern, '');

            pattern = new RegExp(' desc', 'gi');
            res = res.replace(pattern, '');

            pattern = new RegExp(' ', 'gi');
            res = res.replace(pattern, '');

            return res;
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (nextProps.dataModel != prevState.dataModel) {
                return {
                    getAdditionalDataForControl: nextProps.getAdditionalDataForControl,
                    dataModel: nextProps.dataModel,
                    needFetch: true,
                    needValueFetch: true
                };
            }

            if (nextProps.paging && nextProps.value != prevState.value && nextProps.value != undefined) {
                return {
                    needValueFetch: true
                };
            }

            return null;
        }
    }]);

    return Dictionary;
}(_react2.default.Component);

exports.default = Dictionary;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(Container, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement('div', this.props);
    }
  }]);

  return Container;
}(_react2.default.Component);

exports.default = Container;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StaticContent = function (_React$Component) {
  _inherits(StaticContent, _React$Component);

  function StaticContent(props) {
    _classCallCheck(this, StaticContent);

    var _this = _possibleConstructorReturn(this, (StaticContent.__proto__ || Object.getPrototypeOf(StaticContent)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(StaticContent, [{
    key: "render",
    value: function render() {
      var spanProps = {
        name: this.props.name,
        className: this.props["style-customcss"],
        style: this.props.style,
        "data-buildertype": this.props["data-buildertype"]
      };

      if (this.props.isHtml) {
        return _react2.default.createElement("span", _extends({}, spanProps, { dangerouslySetInnerHTML: { __html: this.props.content } }));
      } else {
        var content = this.props.content != undefined ? this.props.content.replace('\n', '<br/>') : undefined;
        return _react2.default.createElement(
          "span",
          spanProps,
          content
        );
      }
    }
  }]);

  return StaticContent;
}(_react2.default.Component);

exports.default = StaticContent;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _actions = __webpack_require__(18);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ControlBar = function (_React$Component) {
  _inherits(ControlBar, _React$Component);

  function ControlBar() {
    _classCallCheck(this, ControlBar);

    return _possibleConstructorReturn(this, (ControlBar.__proto__ || Object.getPrototypeOf(ControlBar)).apply(this, arguments));
  }

  _createClass(ControlBar, [{
    key: 'onDragStart',
    value: function onDragStart(item, e) {
      var selector = '.dwkit-formbuilder-zone';

      e.dataTransfer.setData('text', '');
      if (item.forContainerType != undefined) {
        var cTypes = item.forContainerType.split(',');
        var subSelector = "";
        cTypes.forEach(function (c) {
          if (subSelector.length > 0) subSelector += ",";
          subSelector += "[data-buildertype='" + c + "'] > " + selector;
        });
        selector = subSelector;
      }

      $(selector).addClass('dwkit-formbuilder-zone-active').on('dragenter', this.onTargetDragEnter.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragleave', this.onTargetDragLeave.bind(this, item, 'dwkit-formbuilder-zone-select')).on('dragover', function (e) {
        e.preventDefault();
      }).on('drop', this.onDrop.bind(this, item));
    }
  }, {
    key: 'onTargetDragEnter',
    value: function onTargetDragEnter(item, css, e) {
      $(e.target).addClass(css);
    }
  }, {
    key: 'onTargetDragLeave',
    value: function onTargetDragLeave(item, css, e) {
      $(e.target).removeClass(css);
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(item) {
      var zones = $('.dwkit-formbuilder-zone');

      zones.removeClass('dwkit-formbuilder-zone-active');
      zones.removeClass('dwkit-formbuilder-zone-select');
      zones.off();
    }
  }, {
    key: 'onDrop',
    value: function onDrop(item, e) {
      var el = $(e.target);
      if (el.length > 0) {
        _actions2.default.move(item.key, el[0]);
      }

      this.onDragEnd(item);
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var className = "dwkit-formbuilder-item-toolbar-header";
      if (this.props.isGroup) className += " " + "dwkit-formbuilder-item-toolbar-controlbargroup";

      if (this.props.controlOnRight) {
        className += " " + "dwkit-formbuilder-item-toolbar-right";
      } else {
        className += " " + "dwkit-formbuilder-item-toolbar-left";
      }

      return _react2.default.createElement(
        'div',
        { className: className,
          onMouseOver: this.onMouseOver.bind(this),
          onMouseLeave: this.onMouseLeave.bind(this) },
        _react2.default.createElement(
          'div',
          { className: 'dwkit-formbuilder-item-toolbar-header-buttons' },
          _react2.default.createElement(
            'div',
            { className: 'dwkit-formbuilder-item-toolbar-header-title' },
            this.props.text
          ),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-move.svg', className: 'move', height: '16px', draggable: true,
            onDragStart: this.onDragStart.bind(this, this.props.model),
            onDragEnd: this.onDragEnd.bind(this, this.props.model),
            onDrag: this.onDrag.bind(this) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-edit.svg', height: '16px', onClick: this.props.onEdit.bind(this.props.parent, this.props.model) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-copy.svg', height: '16px', onClick: this.props.onCopy.bind(this.props.parent, this.props.model) }),
          _react2.default.createElement('img', { src: '/images/dwkitbuilder-delete.svg', height: '16px', onClick: this.props.onDelete.bind(this.props.parent, this.props.model) })
        )
      );
    }
  }, {
    key: 'onMouseOver',
    value: function onMouseOver(e) {
      var el = $(e.target).parents(".dwkit-formbuilder-item-toolbar-header");
      if (this.props.controlOnRight) {
        el.prev().addClass("dwkit-formbuilder-item-selected");
      } else {
        el.next().addClass("dwkit-formbuilder-item-selected");
      }
    }
  }, {
    key: 'onMouseLeave',
    value: function onMouseLeave(e) {
      var el = $(e.target);
      var parents = $(e.target).parents(".dwkit-formbuilder-item-toolbar-header");
      if (this.props.controlOnRight) {
        el.prev().removeClass("dwkit-formbuilder-item-selected");
        parents.prev().removeClass("dwkit-formbuilder-item-selected");
      } else {
        el.next().removeClass("dwkit-formbuilder-item-selected");
        parents.next().removeClass("dwkit-formbuilder-item-selected");
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(e) {
      var step = 10;
      if (e.clientY < 150) {
        this.scroll(-step);
      }

      if (e.clientY > $(window).height() - 150) {
        this.scroll(step);
      }
    }
  }, {
    key: 'scroll',
    value: function (_scroll) {
      function scroll(_x) {
        return _scroll.apply(this, arguments);
      }

      scroll.toString = function () {
        return _scroll.toString();
      };

      return scroll;
    }(function (step) {
      var scrollY = $(window).scrollTop();
      $(window).scrollTop(scrollY + step);
      if (!stop) {
        setTimeout(function () {
          scroll(step);
        }, 20);
      }
    })
  }]);

  return ControlBar;
}(_react2.default.Component);

exports.default = ControlBar;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropdownTrigger = function (_React$Component) {
  _inherits(DropdownTrigger, _React$Component);

  function DropdownTrigger(props) {
    _classCallCheck(this, DropdownTrigger);

    var _this = _possibleConstructorReturn(this, (DropdownTrigger.__proto__ || Object.getPrototypeOf(DropdownTrigger)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(DropdownTrigger, [{
    key: 'render',
    value: function render() {
      var me = this;

      var controlProps = {};
      for (var p in this.props) {
        if (p == "imageUrl" || p == "defaultValue" || p == "value" || p == "handleEvent" || p == "items") continue;
        controlProps[p] = this.props[p];
      }

      controlProps.options = [];
      this.props.items.forEach(function (item) {

        var isSkip = false;
        if (item.visibleCondition !== undefined && item.visibleCondition !== null && item.visibleCondition !== "") {
          var args = '';
          var body = 'return ' + item.visibleCondition;
          try {
            if (!new Function(args, body)()) {
              isSkip = true;
            }
          } catch (e) {};
        }

        if (!isSkip) controlProps.options.push({ value: item.target, text: item.title, target: item.target });
      });
      controlProps.onChange = this.onChange.bind(this);
      controlProps.trigger = _react2.default.createElement(
        'span',
        null,
        this.props.imageUrl != undefined && _react2.default.createElement(_semanticUiReact.Image, { avatar: true, src: this.props.imageUrl }),
        ' ',
        this.props.value != undefined ? this.props.value : this.props.defaultValue
      );
      return _react2.default.createElement(_semanticUiReact.Dropdown, _extends({}, controlProps, {
        onMouseDown: this.onMouseDown.bind(this)
      }));
    }
  }, {
    key: 'onChange',
    value: function onChange(e, _ref) {
      var name = _ref.name,
          value = _ref.value;

      if (this.state.opendialog == true) {
        this.state.opendialog = false;
        return;
      }

      if (this.props.handleEvent != undefined) {
        this.props.handleEvent({ e: e, key: this.props.name, eventName: "onItemClick", parameters: { target: value } });
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.state.opendialog = !Boolean(this.state.opendialog);
    }
  }]);

  return DropdownTrigger;
}(_react2.default.Component);

exports.default = DropdownTrigger;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _upload = __webpack_require__(20);

var _upload2 = _interopRequireDefault(_upload);

var _json = __webpack_require__(4);

var _json2 = _interopRequireDefault(_json);

var _datepicker = __webpack_require__(21);

var _datepicker2 = _interopRequireDefault(_datepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SemanticControl = function (_React$Component) {
  _inherits(SemanticControl, _React$Component);

  function SemanticControl(props) {
    _classCallCheck(this, SemanticControl);

    var _this = _possibleConstructorReturn(this, (SemanticControl.__proto__ || Object.getPrototypeOf(SemanticControl)).call(this, props));

    _this.state = {};
    return _this;
  }

  _createClass(SemanticControl, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var me = this;
      var propsControl = {};
      for (var p in this.props) {
        if (p === "additionalParams" || p === "items") continue;

        propsControl[p] = this.props[p];
      }

      var model = this.props.additionalParams.model;
      var data = this.props.additionalParams.data;
      var errors = this.props.additionalParams.errors;
      var children = this.props.additionalParams.children;
      var parentItem = this.props.additionalParams.parentItem;
      var handleEvent = this.props.additionalParams.handleEvent;

      var type = model["data-buildertype"];

      var res;
      if (type === 'header') {
        res = _react2.default.createElement(_semanticUiReact.Header, _extends({}, propsControl, {
          textAlign: model.textAlign,
          size: model.size,
          content: this.props.content,
          subheader: this.props.subheader }));
      } else if (type === 'button') {
        propsControl.floated = model.floated;
        propsControl.size = model.size !== "" ? model.size : null;
        propsControl.content = model.content;
        propsControl.type = model.buttonType;
        propsControl.basic = model.basic;
        propsControl.circular = model.circular;
        propsControl.compact = model.compact;
        propsControl.disabled = model.disabled;
        propsControl.fluid = model.fluid;
        propsControl.inverted = model.inverted;
        propsControl.loading = model.loading;
        propsControl.primary = model.primary;
        propsControl.secondary = model.secondary;
        propsControl.toggle = model.toggle;

        if (handleEvent !== undefined) {
          propsControl.onClick = function (e) {
            return handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onClick" });
          };
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Button, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Button, propsControl);
        }
      } else if (type === 'label') {
        res = _react2.default.createElement(_semanticUiReact.Label, _extends({}, propsControl, {
          size: model.size,
          content: this.props.content,
          attached: model.attached,
          basic: model.basic,
          circular: model.circular,
          corner: model.corner,
          floating: model.floating,
          horizontal: model.horizontal,
          pointing: model.pointing }));
      } else if (type === 'message') {
        res = _react2.default.createElement(_semanticUiReact.Message, _extends({}, propsControl, {
          floated: model.floated,
          size: model.size,
          content: this.props.content,
          compact: model.compact,
          error: model.error,
          floating: model.floating,
          info: model.info,
          negative: model.negative,
          positive: model.positive,
          success: model.success,
          warning: model.warning,
          header: this.props.header
        }));
      } else if (type === 'input') {
        propsControl.defaultValue = model.defaultvalue;
        propsControl.size = model.size;

        if (model.label != undefined && model.label != "") propsControl.label = model.label;

        propsControl.labelPosition = model.labelPosition;
        propsControl.placeholder = model.placeholder;
        propsControl.type = model.type;
        propsControl.loading = model.loading;
        propsControl.inverted = model.inverted;
        propsControl.error = model.error;
        propsControl.disabled = model.disabled;
        propsControl.transparent = model.transparent;
        propsControl.fluid = model.fluid;
        propsControl.readOnly = model.readOnly || this.props.readOnly;

        if (handleEvent != null) {
          propsControl.onChange = function (e, _ref) {
            var name = _ref.name,
                value = _ref.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        if (data != undefined && data != null) {
          propsControl.value = data[propsControl.name];
        } else propsControl.value = "";

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (propsControl.type === "file") {
          propsControl.isForm = this.isForm(parentItem);
          res = _react2.default.createElement(_upload2.default, _extends({}, propsControl, {
            downloadUrl: this.props.additionalParams.downloadUrl,
            uploadUrl: this.props.additionalParams.uploadUrl }));
        } else if (propsControl.type === "date" || propsControl.type === "time" || propsControl.type === "datetime") {
          propsControl.isForm = this.isForm(parentItem);
          // propsControl.dateFormat = model.dateFormat;
          res = _react2.default.createElement(_datepicker2.default, propsControl);
        } else {
          if (this.isForm(parentItem)) {
            res = _react2.default.createElement(_semanticUiReact.Form.Input, propsControl);
          } else {
            res = _react2.default.createElement(_semanticUiReact.Input, propsControl);
          }
        }
      } else if (type === 'textarea') {
        propsControl.placeholder = model.placeholder;
        propsControl.rows = model.rows !== null && model.rows !== undefined ? Number(model.rows) : undefined;

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.autoHeight = model.autoHeight;
        propsControl.readOnly = model.readOnly || this.props.readOnly;

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref2) {
            var name = _ref2.name,
                value = _ref2.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        if (data != undefined) propsControl.value = data[propsControl.name];

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.TextArea, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.TextArea, propsControl);
        }
      } else if (type === 'checkbox') {

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.placeholder = model.placeholder;
        propsControl.type = model.type;
        propsControl.disabled = model.disabled;
        propsControl.fitted = model.fitted;
        propsControl.indeterminate = model.indeterminate;
        propsControl.readOnly = model.readOnly || this.props.readOnly;
        propsControl.slider = model.slider;
        propsControl.toggle = model.toggle;

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref3) {
            var name = _ref3.name,
                checked = _ref3.checked;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: checked });
          };
        }

        if (data !== undefined) {
          if (typeof variable === "boolean") {
            propsControl.checked = data[propsControl.name];
          } else if (data[propsControl.name] === "true" || data[propsControl.name] === "1") {
            propsControl.checked = true;
          } else if (data[propsControl.name] === "false" || data[propsControl.name] === "0") {
            propsControl.checked = false;
          } else {
            propsControl.checked = Boolean(data[propsControl.name]);
          }
        }

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Checkbox, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Checkbox, propsControl);
        }
      } else if (type === 'dropdown') {
        var options = [];
        if (model["data-elements"] !== undefined) {
          if (Array.isArray(model["data-elements"])) {
            options = model["data-elements"];
          } else {
            options = _json2.default.parse(model["data-elements"]);
          }
        }

        if (model.label !== undefined && model.label !== "") propsControl.label = model.label;

        propsControl.defaultValue = model.defaultvalue;
        propsControl.placeholder = model.placeholder;
        propsControl.options = options;
        propsControl.loading = model.loading;
        propsControl.error = model.error;
        propsControl.fluid = model.fluid;
        propsControl.selection = model.selection;
        propsControl.multiple = model.multiple;
        propsControl.search = model.search;
        propsControl.disabled = model.disabled || model.readOnly || this.props.readOnly;

        if (data !== undefined) propsControl.value = data[propsControl.name];

        if ((typeof errors === 'undefined' ? 'undefined' : _typeof(errors)) === "object" && errors[model.key] !== undefined) {
          propsControl.error = Boolean(errors[model.key]);
        }

        if (handleEvent !== null) {
          propsControl.onChange = function (e, _ref4) {
            var name = _ref4.name,
                value = _ref4.value;

            handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onChange", name: name, value: value });
          };
        }

        propsControl.allowAdditions = model.allowAddItems;
        if (propsControl.allowAdditions) {
          propsControl.onAddItem = function (e, _ref5) {
            var value = _ref5.value;

            var v = propsControl.value;
            if (Array.isArray(v)) v.push(value);else {
              v = [value];
            }

            propsControl.onChange(e, { name: propsControl.name, value: v });
          };
        }

        if (propsControl.multiple) {
          if (propsControl.value === undefined || propsControl.value === null) {
            propsControl.value = [];
          }

          if (!Array.isArray(propsControl.value)) {
            var valueArray = void 0;
            try {
              valueArray = _json2.default.parse(propsControl.value);
            } catch (e) {};

            if (!Array.isArray(valueArray)) {
              valueArray = [propsControl.value];
            }

            propsControl.value = valueArray;
          }

          if (propsControl.allowAdditions) {
            this.dropdownCheckAdditional(propsControl.value, propsControl.options);
          }
        }

        if (this.isForm(parentItem)) {
          res = _react2.default.createElement(_semanticUiReact.Form.Dropdown, propsControl);
        } else {
          res = _react2.default.createElement(_semanticUiReact.Dropdown, propsControl);
        }
      } else if (type === 'statistic') {
        var items = [];
        if (model["data-elements"] !== undefined) {
          if (Array.isArray(model["data-elements"])) {
            items = model["data-elements"];
          } else {
            items = _json2.default.parse(model["data-elements"]);
          }
        }

        res = _react2.default.createElement(_semanticUiReact.Statistic.Group, _extends({}, propsControl, {
          floated: model.floated,
          horizontal: model.horizontal,
          size: model.size,
          items: items }));
      } else if (type === 'image') {
        res = _react2.default.createElement(_semanticUiReact.Image, _extends({}, propsControl, {
          avatar: model.avatar,
          bordered: model.bordered,
          centered: model.centered,
          disabled: model.disabled,
          inline: model.inline,
          href: this.props.href,
          src: this.props.src,
          floated: model.floated,
          shape: model.shape,
          spaced: model.spaced,
          verticalAlign: model.verticalAlign,
          height: model.height,
          width: model.width }));
      } else if (type === 'form') {
        res = _react2.default.createElement(_semanticUiReact.Form, _extends({}, propsControl, {
          children: children,
          size: model.size,
          loading: model.loading,
          error: model.error,
          inverted: model.inverted,
          reply: model.reply,
          success: model.success,
          warning: model.warning }));
      } else if (type === 'formgroup') {
        var widths = model.widths;
        if (widths === "custom") widths = model.widthsCustom;

        if (model.orientation) propsControl[model.orientation] = true;

        res = _react2.default.createElement(_semanticUiReact.Form.Group, _extends({}, propsControl, {
          widths: widths,
          children: children }));
      } else if (type === 'breadcrumb') {
        var _children = [];
        if (Array.isArray(this.props.items)) {
          var _loop = function _loop(i) {
            var item = _this2.props.items[i];
            var childProps = { key: i };
            childProps.active = item.active;
            childProps.href = item.url;
            if (handleEvent !== null) {
              childProps.onClick = function (e, _ref6) {
                var name = _ref6.name,
                    checked = _ref6.checked;

                handleEvent({ syntheticEvent: e, key: propsControl.name, eventName: "onItemClick", parameters: { target: item.url } });
                e.preventDefault();
              };
            }
            _children.push(_react2.default.createElement(
              _semanticUiReact.Breadcrumb.Section,
              childProps,
              item.text === undefined ? "<not set>" : item.text
            ));
            if (i < _this2.props.items.length - 1) {
              var dividerProps = {
                key: i + "_d"
              };
              if (item.divider !== "") dividerProps.icon = item.divider;
              _children.push(_react2.default.createElement(_semanticUiReact.Breadcrumb.Divider, dividerProps));
            }
          };

          for (var i = 0; i < this.props.items.length; i++) {
            _loop(i);
          }
        }
        res = _react2.default.createElement(_semanticUiReact.Breadcrumb, _extends({}, propsControl, { children: _children }));
      } else {
        res = _react2.default.createElement(
          'span',
          null,
          'Unknow type \'',
          type,
          '\' of \'',
          this.props.name,
          '\' element.'
        );
      }
      return res;
    }
  }, {
    key: 'isForm',
    value: function isForm(m) {
      return m != null && (m["data-buildertype"] === "form" || m["data-buildertype"] === "formgroup");
    }
  }, {
    key: 'dropdownCheckAdditional',
    value: function dropdownCheckAdditional(value, options) {
      if (!Array.isArray(value)) return;
      value.forEach(function (v) {
        var isFind = false;
        for (var i = 0; i < options.length; i++) {
          var o = options[i];
          if (v === o.value) {
            isFind = true;
            break;
          }
        }

        if (isFind == false) {
          options.push({ value: v, text: v });
        }
      });
    }
  }]);

  return SemanticControl;
}(_react2.default.Component);

exports.default = SemanticControl;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

var _reactDropzoneComponent = __webpack_require__(64);

var _reactDropzoneComponent2 = _interopRequireDefault(_reactDropzoneComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dropzone = function (_React$Component) {
  _inherits(Dropzone, _React$Component);

  function Dropzone(props) {
    _classCallCheck(this, Dropzone);

    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this, props));

    _this.state = {
      commands: props.commands,
      states: props.states
    };
    return _this;
  }

  _createClass(Dropzone, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.isMount = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.isMount = false;
    }
  }, {
    key: 'render',
    value: function render() {
      var me = this;

      var data = this.props.additionalParams.data;
      var errors = this.props.additionalParams.errors;
      var parentItem = this.props.additionalParams.parentItem;
      var handleEvent = this.props.additionalParams.handleEvent;

      var iconFiletypes = undefined;
      if (this.props.iconFiletypes != undefined && this.props.iconFiletypes != "") {
        var types = this.props.iconFiletypes.split(",");
        if (Array.isArray(types) && types.length > 0) {
          iconFiletypes = [];
          types.forEach(function (t) {
            iconFiletypes.push(t.trim());
          });
        }
      }

      var djsConfig = {
        addRemoveLinks: this.props.addRemoveLinks,
        autoProcessQueue: this.props.autoProcessQueue && this.props.postUrl != undefined
      };

      var componentConfig = {
        iconFiletypes: iconFiletypes,
        showFiletypeIcon: this.props.showFiletypeIcon,
        postUrl: this.props.postUrl == undefined ? "no-url" : this.props.postUrl
      };

      var eventHandlers = {
        success: me.fileUploadSuccess.bind(this)
      };
      // if(handleEvent != undefined){
      //   var events = this.getEvents();
      //   events.forEach(function(e){
      //     eventHandlers[e] = handleEvent({ key: me.props.name, eventName: e});
      //   });
      // }

      var control = this.props.readOnly ? _react2.default.createElement('div', null) : _react2.default.createElement(_reactDropzoneComponent2.default, { config: componentConfig, eventHandlers: eventHandlers, djsConfig: djsConfig });

      var res = undefined;
      if (this.isForm(parentItem)) {
        res = _react2.default.createElement(
          'div',
          { className: 'field' },
          control
        );
      } else {
        res = control;
      }
      return res;
    }
  }, {
    key: 'isForm',
    value: function isForm(m) {
      return m != null && (m["data-buildertype"] == "form" || m["data-buildertype"] == "formgroup");
    }
  }, {
    key: 'fileUploadSuccess',
    value: function fileUploadSuccess(file, response) {
      var handleEvent = this.props.additionalParams.handleEvent;
      if (handleEvent != undefined) {
        handleEvent({ key: this.props.name,
          eventName: "success",
          name: this.props.name,
          value: response.message,
          parameters: {
            name: file.name,
            size: file.size,
            token: response.message
          }
        });

        setTimeout(function () {
          file._removeLink.click();
        }, 500);
      }
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      return ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "removedfile", "thumbnail", "error", "processing", "uploadprogress", "sending", "success", "complete", "canceled", "maxfilesreached", "maxfilesexceeded", "processingmultiple", "sendingmultiple", "successmultiple", "completemultiple", "canceledmultiple", "totaluploadprogress", "reset", "queuecompleted"];
    }
  }]);

  return Dropzone;
}(_react2.default.Component);

exports.default = Dropzone;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(0),__webpack_require__(6)):"function"==typeof define&&define.amd?define(["react","react-dom"],t):"object"==typeof exports?exports.ReactDropzone=t(require("react"),require("react-dom")):e.ReactDropzone=t(e.React,e.ReactDOM)}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=1)}([function(t,n){t.exports=e},function(e,t,n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.DropzoneComponent=void 0;var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),o=i(n(0)),s=i(n(2)),a=i(n(3)),l=n(4),u=null,c=t.DropzoneComponent=function(e){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.state={files:[]},n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,o.default.Component),r(t,[{key:"getDjsConfig",value:function(){var e={url:this.props.config.postUrl?this.props.config.postUrl:null};return this.props.djsConfig?(0,a.default)(!0,{},e,this.props.djsConfig):e}},{key:"componentDidMount",value:function(){var e=this.getDjsConfig();(u=u||n(5)).autoDiscover=!1,this.props.config.postUrl||this.props.eventHandlers.drop||console.info('Neither postUrl nor a "drop" eventHandler specified, the React-Dropzone component might misbehave.');var t=this.props.config.dropzoneSelector||s.default.findDOMNode(this);this.dropzone=new u(t,e),this.setupEvents()}},{key:"componentWillUnmount",value:function(){var e=this;if(this.dropzone)if(this.dropzone.getActiveFiles().length>0){this.queueDestroy=!0;var t=window.setInterval(function(){return!1===e.queueDestroy?window.clearInterval(t):0===e.dropzone.getActiveFiles().length?(e.dropzone=e.destroy(e.dropzone),window.clearInterval(t)):void 0},500)}else this.dropzone=this.destroy(this.dropzone)}},{key:"componentDidUpdate",value:function(){if(this.queueDestroy=!1,!this.dropzone){var e=this.props.config.dropzoneSelector||s.default.findDOMNode(this);this.dropzone=new u(e,this.getDjsConfig())}}},{key:"componentWillUpdate",value:function(){var e,t=void 0;e=this.props.djsConfig?this.props.djsConfig:{};try{t=this.props.config.postUrl?{url:this.props.config.postUrl}:{}}catch(e){t={}}this.dropzone.options=(0,a.default)(!0,{},this.dropzone.options,e,t)}},{key:"render",value:function(){var e=[],t=this.state.files,n=this.props.config,i=this.props.className?"filepicker dropzone "+this.props.className:"filepicker dropzone";if(n.showFiletypeIcon&&n.iconFiletypes&&(!t||t.length<1))for(var r=0;r<this.props.config.iconFiletypes.length;r+=1)e.push(o.default.createElement(l.Icon,{filetype:n.iconFiletypes[r],key:"icon-component"+r}));return!this.props.config.postUrl&&this.props.action?o.default.createElement("form",{action:this.props.action,className:i},e,this.props.children):o.default.createElement("div",{className:i}," ",e," ",this.props.children," ")}},{key:"setupEvents",value:function(){var e=this,t=this.props.eventHandlers;if(this.dropzone&&t){for(var n in t)if(t.hasOwnProperty(n)&&t[n])if("[object Array]"===Object.prototype.toString.call(t[n]))for(var i=0;i<t[n].length;i+=1)"init"===n?t[n][i](this.dropzone):this.dropzone.on(n,t[n][i]);else"init"===n?t[n](this.dropzone):this.dropzone.on(n,t[n]);this.dropzone.on("addedfile",function(t){if(t){var n=e.state.files||[];n.push(t),e.setState({files:n})}}),this.dropzone.on("removedfile",function(t){if(t){var n=e.state.files||[];n.forEach(function(e,i){e.name===t.name&&e.size===t.size&&n.splice(i,1)}),e.setState({files:n})}})}}},{key:"destroy",value:function(e){return e.off(),e.destroy()}}]),t}();c.defaultProps={djsConfig:{},config:{},eventHandlers:{}},t.default=c},function(e,n){e.exports=t},function(e,t,n){"use strict";var i=Object.prototype.hasOwnProperty,r=Object.prototype.toString,o=function(e){return"function"==typeof Array.isArray?Array.isArray(e):"[object Array]"===r.call(e)},s=function(e){if(!e||"[object Object]"!==r.call(e))return!1;var t,n=i.call(e,"constructor"),o=e.constructor&&e.constructor.prototype&&i.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!n&&!o)return!1;for(t in e);return void 0===t||i.call(e,t)};e.exports=function e(){var t,n,i,r,a,l,u=arguments[0],c=1,d=arguments.length,p=!1;for("boolean"==typeof u&&(p=u,u=arguments[1]||{},c=2),(null==u||"object"!=typeof u&&"function"!=typeof u)&&(u={});c<d;++c)if(null!=(t=arguments[c]))for(n in t)i=u[n],u!==(r=t[n])&&(p&&r&&(s(r)||(a=o(r)))?(a?(a=!1,l=i&&o(i)?i:[]):l=i&&s(i)?i:{},u[n]=e(p,l,r)):void 0!==r&&(u[n]=r));return u}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Icon=void 0;var i,r=n(0),o=(i=r)&&i.__esModule?i:{default:i};t.Icon=function(e){return o.default.createElement("div",{"data-filetype":e.filetype,className:"filepicker-file-icon"})}},function(e,t,n){"use strict";(function(e){function t(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),r=function(){function e(){n(this,e)}return i(e,[{key:"on",value:function(e,t){return this._callbacks=this._callbacks||{},this._callbacks[e]||(this._callbacks[e]=[]),this._callbacks[e].push(t),this}},{key:"emit",value:function(e){this._callbacks=this._callbacks||{};var t=this._callbacks[e];if(t){for(var n=arguments.length,i=Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];for(var o=0,s=s=t;!(o>=s.length);)s[o++].apply(this,i)}return this}},{key:"off",value:function(e,t){if(!this._callbacks||0===arguments.length)return this._callbacks={},this;var n=this._callbacks[e];if(!n)return this;if(1===arguments.length)return delete this._callbacks[e],this;for(var i=0;i<n.length;i++)if(n[i]===t){n.splice(i,1);break}return this}}]),e}(),o=function(e){function o(e,i){n(this,o);var r,s=t(this,(o.__proto__||Object.getPrototypeOf(o)).call(this)),a=void 0;if(s.element=e,s.version=o.version,s.defaultOptions.previewTemplate=s.defaultOptions.previewTemplate.replace(/\n*/g,""),s.clickableElements=[],s.listeners=[],s.files=[],"string"==typeof s.element&&(s.element=document.querySelector(s.element)),!s.element||null==s.element.nodeType)throw new Error("Invalid dropzone element.");if(s.element.dropzone)throw new Error("Dropzone already attached.");o.instances.push(s),s.element.dropzone=s;var l,u=null!=(r=o.optionsForElement(s.element))?r:{};if(s.options=o.extend({},s.defaultOptions,u,null!=i?i:{}),s.options.forceFallback||!o.isBrowserSupported())return l=s.options.fallback.call(s),t(s,l);if(null==s.options.url&&(s.options.url=s.element.getAttribute("action")),!s.options.url)throw new Error("No URL provided.");if(s.options.acceptedFiles&&s.options.acceptedMimeTypes)throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");if(s.options.uploadMultiple&&s.options.chunking)throw new Error("You cannot set both: uploadMultiple and chunking.");return s.options.acceptedMimeTypes&&(s.options.acceptedFiles=s.options.acceptedMimeTypes,delete s.options.acceptedMimeTypes),null!=s.options.renameFilename&&(s.options.renameFile=function(e){return s.options.renameFilename.call(s,e.name,e)}),s.options.method=s.options.method.toUpperCase(),(a=s.getExistingFallback())&&a.parentNode&&a.parentNode.removeChild(a),!1!==s.options.previewsContainer&&(s.options.previewsContainer?s.previewsContainer=o.getElement(s.options.previewsContainer,"previewsContainer"):s.previewsContainer=s.element),s.options.clickable&&(!0===s.options.clickable?s.clickableElements=[s.element]:s.clickableElements=o.getElements(s.options.clickable,"clickable")),s.init(),s}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(o,r),i(o,null,[{key:"initClass",value:function(){this.prototype.Emitter=r,this.prototype.events=["drop","dragstart","dragend","dragenter","dragover","dragleave","addedfile","addedfiles","removedfile","thumbnail","error","errormultiple","processing","processingmultiple","uploadprogress","totaluploadprogress","sending","sendingmultiple","success","successmultiple","canceled","canceledmultiple","complete","completemultiple","reset","maxfilesexceeded","maxfilesreached","queuecomplete"],this.prototype.defaultOptions={url:null,method:"post",withCredentials:!1,timeout:3e4,parallelUploads:2,uploadMultiple:!1,chunking:!1,forceChunking:!1,chunkSize:2e6,parallelChunkUploads:!1,retryChunks:!1,retryChunksLimit:3,maxFilesize:256,paramName:"file",createImageThumbnails:!0,maxThumbnailFilesize:10,thumbnailWidth:120,thumbnailHeight:120,thumbnailMethod:"crop",resizeWidth:null,resizeHeight:null,resizeMimeType:null,resizeQuality:.8,resizeMethod:"contain",filesizeBase:1e3,maxFiles:null,headers:null,clickable:!0,ignoreHiddenFiles:!0,acceptedFiles:null,acceptedMimeTypes:null,autoProcessQueue:!0,autoQueue:!0,addRemoveLinks:!1,previewsContainer:null,hiddenInputContainer:"body",capture:null,renameFilename:null,renameFile:null,forceFallback:!1,dictDefaultMessage:"Drop files here to upload",dictFallbackMessage:"Your browser does not support drag'n'drop file uploads.",dictFallbackText:"Please use the fallback form below to upload your files like in the olden days.",dictFileTooBig:"File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",dictInvalidFileType:"You can't upload files of this type.",dictResponseError:"Server responded with {{statusCode}} code.",dictCancelUpload:"Cancel upload",dictUploadCanceled:"Upload canceled.",dictCancelUploadConfirmation:"Are you sure you want to cancel this upload?",dictRemoveFile:"Remove file",dictRemoveFileConfirmation:null,dictMaxFilesExceeded:"You can not upload any more files.",dictFileSizeUnits:{tb:"TB",gb:"GB",mb:"MB",kb:"KB",b:"b"},init:function(){},params:function(e,t,n){if(n)return{dzuuid:n.file.upload.uuid,dzchunkindex:n.index,dztotalfilesize:n.file.size,dzchunksize:this.options.chunkSize,dztotalchunkcount:n.file.upload.totalChunkCount,dzchunkbyteoffset:n.index*this.options.chunkSize}},accept:function(e,t){return t()},chunksUploaded:function(e,t){t()},fallback:function(){var e=void 0;this.element.className=this.element.className+" dz-browser-not-supported";for(var t=0,n=n=this.element.getElementsByTagName("div");!(t>=n.length);){var i=n[t++];if(/(^| )dz-message($| )/.test(i.className)){e=i,i.className="dz-message";break}}e||(e=o.createElement('<div class="dz-message"><span></span></div>'),this.element.appendChild(e));var r=e.getElementsByTagName("span")[0];return r&&(null!=r.textContent?r.textContent=this.options.dictFallbackMessage:null!=r.innerText&&(r.innerText=this.options.dictFallbackMessage)),this.element.appendChild(this.getFallbackForm())},resize:function(e,t,n,i){var r={srcX:0,srcY:0,srcWidth:e.width,srcHeight:e.height},o=e.width/e.height;null==t&&null==n?(t=r.srcWidth,n=r.srcHeight):null==t?t=n*o:null==n&&(n=t/o);var s=(t=Math.min(t,r.srcWidth))/(n=Math.min(n,r.srcHeight));if(r.srcWidth>t||r.srcHeight>n)if("crop"===i)o>s?(r.srcHeight=e.height,r.srcWidth=r.srcHeight*s):(r.srcWidth=e.width,r.srcHeight=r.srcWidth/s);else{if("contain"!==i)throw new Error("Unknown resizeMethod '"+i+"'");o>s?n=t/o:t=n*o}return r.srcX=(e.width-r.srcWidth)/2,r.srcY=(e.height-r.srcHeight)/2,r.trgWidth=t,r.trgHeight=n,r},transformFile:function(e,t){return(this.options.resizeWidth||this.options.resizeHeight)&&e.type.match(/image.*/)?this.resizeImage(e,this.options.resizeWidth,this.options.resizeHeight,this.options.resizeMethod,t):t(e)},previewTemplate:'<div class="dz-preview dz-file-preview">\n  <div class="dz-image"><img data-dz-thumbnail /></div>\n  <div class="dz-details">\n    <div class="dz-size"><span data-dz-size></span></div>\n    <div class="dz-filename"><span data-dz-name></span></div>\n  </div>\n  <div class="dz-progress"><span class="dz-upload" data-dz-uploadprogress></span></div>\n  <div class="dz-error-message"><span data-dz-errormessage></span></div>\n  <div class="dz-success-mark">\n    <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n      <title>Check</title>\n      <defs></defs>\n      <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <path d="M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" id="Oval-2" stroke-opacity="0.198794158" stroke="#747474" fill-opacity="0.816519475" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>\n      </g>\n    </svg>\n  </div>\n  <div class="dz-error-mark">\n    <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n      <title>Error</title>\n      <defs></defs>\n      <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <g id="Check-+-Oval-2" sketch:type="MSLayerGroup" stroke="#747474" stroke-opacity="0.198794158" fill="#FFFFFF" fill-opacity="0.816519475">\n          <path d="M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" id="Oval-2" sketch:type="MSShapeGroup"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>',drop:function(e){return this.element.classList.remove("dz-drag-hover")},dragstart:function(e){},dragend:function(e){return this.element.classList.remove("dz-drag-hover")},dragenter:function(e){return this.element.classList.add("dz-drag-hover")},dragover:function(e){return this.element.classList.add("dz-drag-hover")},dragleave:function(e){return this.element.classList.remove("dz-drag-hover")},paste:function(e){},reset:function(){return this.element.classList.remove("dz-started")},addedfile:function(e){var t=this;if(this.element===this.previewsContainer&&this.element.classList.add("dz-started"),this.previewsContainer){e.previewElement=o.createElement(this.options.previewTemplate.trim()),e.previewTemplate=e.previewElement,this.previewsContainer.appendChild(e.previewElement);for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-name]");!(n>=i.length);){var r=i[n++];r.textContent=e.name}for(var s=0,a=a=e.previewElement.querySelectorAll("[data-dz-size]");!(s>=a.length);)(r=a[s++]).innerHTML=this.filesize(e.size);this.options.addRemoveLinks&&(e._removeLink=o.createElement('<a class="dz-remove" href="javascript:undefined;" data-dz-remove>'+this.options.dictRemoveFile+"</a>"),e.previewElement.appendChild(e._removeLink));for(var l=function(n){return n.preventDefault(),n.stopPropagation(),e.status===o.UPLOADING?o.confirm(t.options.dictCancelUploadConfirmation,function(){return t.removeFile(e)}):t.options.dictRemoveFileConfirmation?o.confirm(t.options.dictRemoveFileConfirmation,function(){return t.removeFile(e)}):t.removeFile(e)},u=0,c=c=e.previewElement.querySelectorAll("[data-dz-remove]");!(u>=c.length);)c[u++].addEventListener("click",l)}},removedfile:function(e){return null!=e.previewElement&&null!=e.previewElement.parentNode&&e.previewElement.parentNode.removeChild(e.previewElement),this._updateMaxFilesReachedClass()},thumbnail:function(e,t){if(e.previewElement){e.previewElement.classList.remove("dz-file-preview");for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-thumbnail]");!(n>=i.length);){var r=i[n++];r.alt=e.name,r.src=t}return setTimeout(function(){return e.previewElement.classList.add("dz-image-preview")},1)}},error:function(e,t){if(e.previewElement){e.previewElement.classList.add("dz-error"),"String"!=typeof t&&t.error&&(t=t.error);for(var n=0,i=i=e.previewElement.querySelectorAll("[data-dz-errormessage]");!(n>=i.length);)i[n++].textContent=t}},errormultiple:function(){},processing:function(e){if(e.previewElement&&(e.previewElement.classList.add("dz-processing"),e._removeLink))return e._removeLink.textContent=this.options.dictCancelUpload},processingmultiple:function(){},uploadprogress:function(e,t,n){if(e.previewElement)for(var i=0,r=r=e.previewElement.querySelectorAll("[data-dz-uploadprogress]");!(i>=r.length);){var o=r[i++];"PROGRESS"===o.nodeName?o.value=t:o.style.width=t+"%"}},totaluploadprogress:function(){},sending:function(){},sendingmultiple:function(){},success:function(e){if(e.previewElement)return e.previewElement.classList.add("dz-success")},successmultiple:function(){},canceled:function(e){return this.emit("error",e,this.options.dictUploadCanceled)},canceledmultiple:function(){},complete:function(e){if(e._removeLink&&(e._removeLink.textContent=this.options.dictRemoveFile),e.previewElement)return e.previewElement.classList.add("dz-complete")},completemultiple:function(){},maxfilesexceeded:function(){},maxfilesreached:function(){},queuecomplete:function(){},addedfiles:function(){}},this.prototype._thumbnailQueue=[],this.prototype._processingThumbnail=!1}},{key:"extend",value:function(e){for(var t=arguments.length,n=Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];for(var r=0,o=o=n;!(r>=o.length);){var s=o[r++];for(var a in s){var l=s[a];e[a]=l}}return e}}]),i(o,[{key:"getAcceptedFiles",value:function(){return this.files.filter(function(e){return e.accepted}).map(function(e){return e})}},{key:"getRejectedFiles",value:function(){return this.files.filter(function(e){return!e.accepted}).map(function(e){return e})}},{key:"getFilesWithStatus",value:function(e){return this.files.filter(function(t){return t.status===e}).map(function(e){return e})}},{key:"getQueuedFiles",value:function(){return this.getFilesWithStatus(o.QUEUED)}},{key:"getUploadingFiles",value:function(){return this.getFilesWithStatus(o.UPLOADING)}},{key:"getAddedFiles",value:function(){return this.getFilesWithStatus(o.ADDED)}},{key:"getActiveFiles",value:function(){return this.files.filter(function(e){return e.status===o.UPLOADING||e.status===o.QUEUED}).map(function(e){return e})}},{key:"init",value:function(){var e=this;"form"===this.element.tagName&&this.element.setAttribute("enctype","multipart/form-data"),this.element.classList.contains("dropzone")&&!this.element.querySelector(".dz-message")&&this.element.appendChild(o.createElement('<div class="dz-default dz-message"><span>'+this.options.dictDefaultMessage+"</span></div>")),this.clickableElements.length&&function t(){return e.hiddenFileInput&&e.hiddenFileInput.parentNode.removeChild(e.hiddenFileInput),e.hiddenFileInput=document.createElement("input"),e.hiddenFileInput.setAttribute("type","file"),(null===e.options.maxFiles||e.options.maxFiles>1)&&e.hiddenFileInput.setAttribute("multiple","multiple"),e.hiddenFileInput.className="dz-hidden-input",null!==e.options.acceptedFiles&&e.hiddenFileInput.setAttribute("accept",e.options.acceptedFiles),null!==e.options.capture&&e.hiddenFileInput.setAttribute("capture",e.options.capture),e.hiddenFileInput.style.visibility="hidden",e.hiddenFileInput.style.position="absolute",e.hiddenFileInput.style.top="0",e.hiddenFileInput.style.left="0",e.hiddenFileInput.style.height="0",e.hiddenFileInput.style.width="0",document.querySelector(e.options.hiddenInputContainer).appendChild(e.hiddenFileInput),e.hiddenFileInput.addEventListener("change",function(){var n=e.hiddenFileInput.files;if(n.length)for(var i=0,r=r=n;!(i>=r.length);){var o=r[i++];e.addFile(o)}return e.emit("addedfiles",n),t()})}(),this.URL=null!==window.URL?window.URL:window.webkitURL;for(var t=0,n=n=this.events;!(t>=n.length);){var i=n[t++];this.on(i,this.options[i])}this.on("uploadprogress",function(){return e.updateTotalUploadProgress()}),this.on("removedfile",function(){return e.updateTotalUploadProgress()}),this.on("canceled",function(t){return e.emit("complete",t)}),this.on("complete",function(t){if(0===e.getAddedFiles().length&&0===e.getUploadingFiles().length&&0===e.getQueuedFiles().length)return setTimeout(function(){return e.emit("queuecomplete")},0)});var r=function(e){return e.stopPropagation(),e.preventDefault?e.preventDefault():e.returnValue=!1};return this.listeners=[{element:this.element,events:{dragstart:function(t){return e.emit("dragstart",t)},dragenter:function(t){return r(t),e.emit("dragenter",t)},dragover:function(t){var n=void 0;try{n=t.dataTransfer.effectAllowed}catch(e){}return t.dataTransfer.dropEffect="move"===n||"linkMove"===n?"move":"copy",r(t),e.emit("dragover",t)},dragleave:function(t){return e.emit("dragleave",t)},drop:function(t){return r(t),e.drop(t)},dragend:function(t){return e.emit("dragend",t)}}}],this.clickableElements.forEach(function(t){return e.listeners.push({element:t,events:{click:function(n){return(t!==e.element||n.target===e.element||o.elementInside(n.target,e.element.querySelector(".dz-message")))&&e.hiddenFileInput.click(),!0}}})}),this.enable(),this.options.init.call(this)}},{key:"destroy",value:function(){return this.disable(),this.removeAllFiles(!0),(null!=this.hiddenFileInput?this.hiddenFileInput.parentNode:void 0)&&(this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput),this.hiddenFileInput=null),delete this.element.dropzone,o.instances.splice(o.instances.indexOf(this),1)}},{key:"updateTotalUploadProgress",value:function(){var e=void 0,t=0,n=0;if(this.getActiveFiles().length){for(var i=0,r=r=this.getActiveFiles();!(i>=r.length);){var o=r[i++];t+=o.upload.bytesSent,n+=o.upload.total}e=100*t/n}else e=100;return this.emit("totaluploadprogress",e,n,t)}},{key:"_getParamName",value:function(e){return"function"==typeof this.options.paramName?this.options.paramName(e):this.options.paramName+(this.options.uploadMultiple?"["+e+"]":"")}},{key:"_renameFile",value:function(e){return"function"!=typeof this.options.renameFile?e.name:this.options.renameFile(e)}},{key:"getFallbackForm",value:function(){var e,t=void 0;if(e=this.getExistingFallback())return e;var n='<div class="dz-fallback">';this.options.dictFallbackText&&(n+="<p>"+this.options.dictFallbackText+"</p>"),n+='<input type="file" name="'+this._getParamName(0)+'" '+(this.options.uploadMultiple?'multiple="multiple"':void 0)+' /><input type="submit" value="Upload!"></div>';var i=o.createElement(n);return"FORM"!==this.element.tagName?(t=o.createElement('<form action="'+this.options.url+'" enctype="multipart/form-data" method="'+this.options.method+'"></form>')).appendChild(i):(this.element.setAttribute("enctype","multipart/form-data"),this.element.setAttribute("method",this.options.method)),null!=t?t:i}},{key:"getExistingFallback",value:function(){for(var e=["div","form"],t=0;t<e.length;t++){var n,i=e[t];if(n=function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];if(/(^| )fallback($| )/.test(i.className))return i}}(this.element.getElementsByTagName(i)))return n}}},{key:"setupEventListeners",value:function(){return this.listeners.map(function(e){return function(){var t=[];for(var n in e.events){var i=e.events[n];t.push(e.element.addEventListener(n,i,!1))}return t}()})}},{key:"removeEventListeners",value:function(){return this.listeners.map(function(e){return function(){var t=[];for(var n in e.events){var i=e.events[n];t.push(e.element.removeEventListener(n,i,!1))}return t}()})}},{key:"disable",value:function(){var e=this;return this.clickableElements.forEach(function(e){return e.classList.remove("dz-clickable")}),this.removeEventListeners(),this.disabled=!0,this.files.map(function(t){return e.cancelUpload(t)})}},{key:"enable",value:function(){return delete this.disabled,this.clickableElements.forEach(function(e){return e.classList.add("dz-clickable")}),this.setupEventListeners()}},{key:"filesize",value:function(e){var t=0,n="b";if(e>0){for(var i=["tb","gb","mb","kb","b"],r=0;r<i.length;r++){var o=i[r];if(e>=Math.pow(this.options.filesizeBase,4-r)/10){t=e/Math.pow(this.options.filesizeBase,4-r),n=o;break}}t=Math.round(10*t)/10}return"<strong>"+t+"</strong> "+this.options.dictFileSizeUnits[n]}},{key:"_updateMaxFilesReachedClass",value:function(){return null!=this.options.maxFiles&&this.getAcceptedFiles().length>=this.options.maxFiles?(this.getAcceptedFiles().length===this.options.maxFiles&&this.emit("maxfilesreached",this.files),this.element.classList.add("dz-max-files-reached")):this.element.classList.remove("dz-max-files-reached")}},{key:"drop",value:function(e){if(e.dataTransfer){this.emit("drop",e);for(var t=[],n=0;n<e.dataTransfer.files.length;n++)t[n]=e.dataTransfer.files[n];if(this.emit("addedfiles",t),t.length){var i=e.dataTransfer.items;i&&i.length&&null!=i[0].webkitGetAsEntry?this._addFilesFromItems(i):this.handleFiles(t)}}}},{key:"paste",value:function(e){if(null!=(void 0!==(t=null!=e?e.clipboardData:void 0)&&null!==t?function(e){return e.items}(t):void 0)){var t;this.emit("paste",e);var n=e.clipboardData.items;return n.length?this._addFilesFromItems(n):void 0}}},{key:"handleFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];this.addFile(i)}}},{key:"_addFilesFromItems",value:function(e){var t=this;return function(){for(var n=[],i=0,r=r=e;!(i>=r.length);){var o,s=r[i++];null!=s.webkitGetAsEntry&&(o=s.webkitGetAsEntry())?o.isFile?n.push(t.addFile(s.getAsFile())):o.isDirectory?n.push(t._addFilesFromDirectory(o,o.name)):n.push(void 0):null==s.getAsFile||null!=s.kind&&"file"!==s.kind?n.push(void 0):n.push(t.addFile(s.getAsFile()))}return n}()}},{key:"_addFilesFromDirectory",value:function(e,t){var n=this,i=e.createReader(),r=function(e){return t=console,n="log",i=function(t){return t.log(e)},void 0!==t&&null!==t&&"function"==typeof t[n]?i(t,n):void 0;var t,n,i};return function e(){return i.readEntries(function(i){if(i.length>0){for(var r=0,o=o=i;!(r>=o.length);){var s=o[r++];s.isFile?s.file(function(e){if(!n.options.ignoreHiddenFiles||"."!==e.name.substring(0,1))return e.fullPath=t+"/"+e.name,n.addFile(e)}):s.isDirectory&&n._addFilesFromDirectory(s,t+"/"+s.name)}e()}return null},r)}()}},{key:"accept",value:function(e,t){return e.size>1024*this.options.maxFilesize*1024?t(this.options.dictFileTooBig.replace("{{filesize}}",Math.round(e.size/1024/10.24)/100).replace("{{maxFilesize}}",this.options.maxFilesize)):o.isValidFile(e,this.options.acceptedFiles)?null!=this.options.maxFiles&&this.getAcceptedFiles().length>=this.options.maxFiles?(t(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}",this.options.maxFiles)),this.emit("maxfilesexceeded",e)):this.options.accept.call(this,e,t):t(this.options.dictInvalidFileType)}},{key:"addFile",value:function(e){var t=this;return e.upload={uuid:o.uuidv4(),progress:0,total:e.size,bytesSent:0,filename:this._renameFile(e),chunked:this.options.chunking&&(this.options.forceChunking||e.size>this.options.chunkSize),totalChunkCount:Math.ceil(e.size/this.options.chunkSize)},this.files.push(e),e.status=o.ADDED,this.emit("addedfile",e),this._enqueueThumbnail(e),this.accept(e,function(n){return n?(e.accepted=!1,t._errorProcessing([e],n)):(e.accepted=!0,t.options.autoQueue&&t.enqueueFile(e)),t._updateMaxFilesReachedClass()})}},{key:"enqueueFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];this.enqueueFile(i)}return null}},{key:"enqueueFile",value:function(e){var t=this;if(e.status!==o.ADDED||!0!==e.accepted)throw new Error("This file can't be queued because it has already been processed or was rejected.");if(e.status=o.QUEUED,this.options.autoProcessQueue)return setTimeout(function(){return t.processQueue()},0)}},{key:"_enqueueThumbnail",value:function(e){var t=this;if(this.options.createImageThumbnails&&e.type.match(/image.*/)&&e.size<=1024*this.options.maxThumbnailFilesize*1024)return this._thumbnailQueue.push(e),setTimeout(function(){return t._processThumbnailQueue()},0)}},{key:"_processThumbnailQueue",value:function(){var e=this;if(!this._processingThumbnail&&0!==this._thumbnailQueue.length){this._processingThumbnail=!0;var t=this._thumbnailQueue.shift();return this.createThumbnail(t,this.options.thumbnailWidth,this.options.thumbnailHeight,this.options.thumbnailMethod,!0,function(n){return e.emit("thumbnail",t,n),e._processingThumbnail=!1,e._processThumbnailQueue()})}}},{key:"removeFile",value:function(e){if(e.status===o.UPLOADING&&this.cancelUpload(e),this.files=s(this.files,e),this.emit("removedfile",e),0===this.files.length)return this.emit("reset")}},{key:"removeAllFiles",value:function(e){null==e&&(e=!1);for(var t=0,n=n=this.files.slice();!(t>=n.length);){var i=n[t++];(i.status!==o.UPLOADING||e)&&this.removeFile(i)}return null}},{key:"resizeImage",value:function(e,t,n,i,r){var s=this;return this.createThumbnail(e,t,n,i,!1,function(t,n){if(null==n)return r(e);var i=s.options.resizeMimeType;null==i&&(i=e.type);var a=n.toDataURL(i,s.options.resizeQuality);return"image/jpeg"!==i&&"image/jpg"!==i||(a=u.restore(e.dataURL,a)),r(o.dataURItoBlob(a))})}},{key:"createThumbnail",value:function(e,t,n,i,r,o){var s=this,a=new FileReader;return a.onload=function(){if(e.dataURL=a.result,"image/svg+xml"!==e.type)return s.createThumbnailFromUrl(e,t,n,i,r,o);null!=o&&o(a.result)},a.readAsDataURL(e)}},{key:"createThumbnailFromUrl",value:function(e,t,n,i,r,o,s){var a=this,u=document.createElement("img");return s&&(u.crossOrigin=s),u.onload=function(){var s=function(e){return e(1)};return"undefined"!=typeof EXIF&&null!==EXIF&&r&&(s=function(e){return EXIF.getData(u,function(){return e(EXIF.getTag(this,"Orientation"))})}),s(function(r){e.width=u.width,e.height=u.height;var s=a.options.resize.call(a,e,t,n,i),c=document.createElement("canvas"),d=c.getContext("2d");switch(c.width=s.trgWidth,c.height=s.trgHeight,r>4&&(c.width=s.trgHeight,c.height=s.trgWidth),r){case 2:d.translate(c.width,0),d.scale(-1,1);break;case 3:d.translate(c.width,c.height),d.rotate(Math.PI);break;case 4:d.translate(0,c.height),d.scale(1,-1);break;case 5:d.rotate(.5*Math.PI),d.scale(1,-1);break;case 6:d.rotate(.5*Math.PI),d.translate(0,-c.height);break;case 7:d.rotate(.5*Math.PI),d.translate(c.width,-c.height),d.scale(-1,1);break;case 8:d.rotate(-.5*Math.PI),d.translate(-c.width,0)}l(d,u,null!=s.srcX?s.srcX:0,null!=s.srcY?s.srcY:0,s.srcWidth,s.srcHeight,null!=s.trgX?s.trgX:0,null!=s.trgY?s.trgY:0,s.trgWidth,s.trgHeight);var p=c.toDataURL("image/png");if(null!=o)return o(p,c)})},null!=o&&(u.onerror=o),u.src=e.dataURL}},{key:"processQueue",value:function(){var e=this.options.parallelUploads,t=this.getUploadingFiles().length,n=t;if(!(t>=e)){var i=this.getQueuedFiles();if(i.length>0){if(this.options.uploadMultiple)return this.processFiles(i.slice(0,e-t));for(;n<e;){if(!i.length)return;this.processFile(i.shift()),n++}}}}},{key:"processFile",value:function(e){return this.processFiles([e])}},{key:"processFiles",value:function(e){for(var t=0,n=n=e;!(t>=n.length);){var i=n[t++];i.processing=!0,i.status=o.UPLOADING,this.emit("processing",i)}return this.options.uploadMultiple&&this.emit("processingmultiple",e),this.uploadFiles(e)}},{key:"_getFilesWithXhr",value:function(e){return this.files.filter(function(t){return t.xhr===e}).map(function(e){return e})}},{key:"cancelUpload",value:function(e){if(e.status===o.UPLOADING){for(var t=this._getFilesWithXhr(e.xhr),n=0,i=i=t;!(n>=i.length);)i[n++].status=o.CANCELED;void 0!==e.xhr&&e.xhr.abort();for(var r=0,s=s=t;!(r>=s.length);){var a=s[r++];this.emit("canceled",a)}this.options.uploadMultiple&&this.emit("canceledmultiple",t)}else e.status!==o.ADDED&&e.status!==o.QUEUED||(e.status=o.CANCELED,this.emit("canceled",e),this.options.uploadMultiple&&this.emit("canceledmultiple",[e]));if(this.options.autoProcessQueue)return this.processQueue()}},{key:"resolveOption",value:function(e){if("function"==typeof e){for(var t=arguments.length,n=Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return e.apply(this,n)}return e}},{key:"uploadFile",value:function(e){return this.uploadFiles([e])}},{key:"uploadFiles",value:function(e){var t=this;this._transformFiles(e,function(n){if(e[0].upload.chunked){var i=e[0],r=n[0];i.upload.chunks=[];var s=function(){for(var n=0;void 0!==i.upload.chunks[n];)n++;if(!(n>=i.upload.totalChunkCount)){var s=n*t.options.chunkSize,a=Math.min(s+t.options.chunkSize,i.size),l={name:t._getParamName(0),data:r.webkitSlice?r.webkitSlice(s,a):r.slice(s,a),filename:i.upload.filename,chunkIndex:n};i.upload.chunks[n]={file:i,index:n,dataBlock:l,status:o.UPLOADING,progress:0,retries:0},t._uploadData(e,[l])}};if(i.upload.finishedChunkUpload=function(n){var r=!0;n.status=o.SUCCESS,n.dataBlock=null;for(var a=0;a<i.upload.totalChunkCount;a++){if(void 0===i.upload.chunks[a])return s();i.upload.chunks[a].status!==o.SUCCESS&&(r=!1)}r&&t.options.chunksUploaded(i,function(){t._finished(e,"",null)})},t.options.parallelChunkUploads)for(var a=0;a<i.upload.totalChunkCount;a++)s();else s()}else{for(var l=[],u=0;u<e.length;u++)l[u]={name:t._getParamName(u),data:n[u],filename:e[u].upload.filename};t._uploadData(e,l)}})}},{key:"_getChunk",value:function(e,t){for(var n=0;n<e.upload.totalChunkCount;n++)if(void 0!==e.upload.chunks[n]&&e.upload.chunks[n].xhr===t)return e.upload.chunks[n]}},{key:"_uploadData",value:function(e,t){for(var n=this,i=new XMLHttpRequest,r=0,s=s=e;!(r>=s.length);)s[r++].xhr=i;e[0].upload.chunked&&(e[0].upload.chunks[t[0].chunkIndex].xhr=i);var a=this.resolveOption(this.options.method,e),l=this.resolveOption(this.options.url,e);i.open(a,l,!0),i.timeout=this.resolveOption(this.options.timeout,e),i.withCredentials=!!this.options.withCredentials,i.onload=function(t){n._finishedUploading(e,i,t)},i.onerror=function(){n._handleUploadError(e,i)},(null!=i.upload?i.upload:i).onprogress=function(t){return n._updateFilesUploadProgress(e,i,t)};var u={Accept:"application/json","Cache-Control":"no-cache","X-Requested-With":"XMLHttpRequest"};for(var c in this.options.headers&&o.extend(u,this.options.headers),u){var d=u[c];d&&i.setRequestHeader(c,d)}var p=new FormData;if(this.options.params){var h=this.options.params;for(var f in"function"==typeof h&&(h=h.call(this,e,i,e[0].upload.chunked?this._getChunk(e[0],i):null)),h){var m=h[f];p.append(f,m)}}for(var v=0,g=g=e;!(v>=g.length);){var y=g[v++];this.emit("sending",y,i,p)}this.options.uploadMultiple&&this.emit("sendingmultiple",e,i,p),this._addFormElementData(p);for(var k=0;k<t.length;k++){var b=t[k];p.append(b.name,b.data,b.filename)}this.submitRequest(i,p,e)}},{key:"_transformFiles",value:function(e,t){for(var n=this,i=[],r=0,o=0;o<e.length;o++)!function(o){n.options.transformFile.call(n,e[o],function(n){i[o]=n,++r===e.length&&t(i)})}(o)}},{key:"_addFormElementData",value:function(e){if("FORM"===this.element.tagName)for(var t=0,n=n=this.element.querySelectorAll("input, textarea, select, button");!(t>=n.length);){var i=n[t++],r=i.getAttribute("name"),o=i.getAttribute("type");if(o&&(o=o.toLowerCase()),void 0!==r&&null!==r)if("SELECT"===i.tagName&&i.hasAttribute("multiple"))for(var s=0,a=a=i.options;!(s>=a.length);){var l=a[s++];l.selected&&e.append(r,l.value)}else(!o||"checkbox"!==o&&"radio"!==o||i.checked)&&e.append(r,i.value)}}},{key:"_updateFilesUploadProgress",value:function(e,t,n){var i=void 0;if(void 0!==n){if(i=100*n.loaded/n.total,e[0].upload.chunked){var r=e[0],o=this._getChunk(r,t);o.progress=i,o.total=n.total,o.bytesSent=n.loaded,r.upload.progress=0,r.upload.total=0,r.upload.bytesSent=0;for(var s=0;s<r.upload.totalChunkCount;s++)void 0!==r.upload.chunks[s]&&void 0!==r.upload.chunks[s].progress&&(r.upload.progress+=r.upload.chunks[s].progress,r.upload.total+=r.upload.chunks[s].total,r.upload.bytesSent+=r.upload.chunks[s].bytesSent);r.upload.progress=r.upload.progress/r.upload.totalChunkCount}else for(var a=0,l=l=e;!(a>=l.length);){var u=l[a++];u.upload.progress=i,u.upload.total=n.total,u.upload.bytesSent=n.loaded}for(var c=0,d=d=e;!(c>=d.length);){var p=d[c++];this.emit("uploadprogress",p,p.upload.progress,p.upload.bytesSent)}}else{var h=!0;i=100;for(var f=0,m=m=e;!(f>=m.length);){var v=m[f++];100===v.upload.progress&&v.upload.bytesSent===v.upload.total||(h=!1),v.upload.progress=i,v.upload.bytesSent=v.upload.total}if(h)return;for(var g=0,y=y=e;!(g>=y.length);){var k=y[g++];this.emit("uploadprogress",k,i,k.upload.bytesSent)}}}},{key:"_finishedUploading",value:function(e,t,n){var i=void 0;if(e[0].status!==o.CANCELED&&4===t.readyState){if("arraybuffer"!==t.responseType&&"blob"!==t.responseType&&(i=t.responseText,t.getResponseHeader("content-type")&&~t.getResponseHeader("content-type").indexOf("application/json")))try{i=JSON.parse(i)}catch(e){n=e,i="Invalid JSON response from server."}this._updateFilesUploadProgress(e),200<=t.status&&t.status<300?e[0].upload.chunked?e[0].upload.finishedChunkUpload(this._getChunk(e[0],t)):this._finished(e,i,n):this._handleUploadError(e,t,i)}}},{key:"_handleUploadError",value:function(e,t,n){if(e[0].status!==o.CANCELED){if(e[0].upload.chunked&&this.options.retryChunks){var i=this._getChunk(e[0],t);if(i.retries++<this.options.retryChunksLimit)return void this._uploadData(e,[i.dataBlock]);console.warn("Retried this chunk too often. Giving up.")}for(var r=0,s=s=e;!(r>=s.length);)s[r++],this._errorProcessing(e,n||this.options.dictResponseError.replace("{{statusCode}}",t.status),t)}}},{key:"submitRequest",value:function(e,t,n){e.send(t)}},{key:"_finished",value:function(e,t,n){for(var i=0,r=r=e;!(i>=r.length);){var s=r[i++];s.status=o.SUCCESS,this.emit("success",s,t,n),this.emit("complete",s)}if(this.options.uploadMultiple&&(this.emit("successmultiple",e,t,n),this.emit("completemultiple",e)),this.options.autoProcessQueue)return this.processQueue()}},{key:"_errorProcessing",value:function(e,t,n){for(var i=0,r=r=e;!(i>=r.length);){var s=r[i++];s.status=o.ERROR,this.emit("error",s,t,n),this.emit("complete",s)}if(this.options.uploadMultiple&&(this.emit("errormultiple",e,t,n),this.emit("completemultiple",e)),this.options.autoProcessQueue)return this.processQueue()}}],[{key:"uuidv4",value:function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)})}}]),o}();o.initClass(),o.version="5.4.0",o.options={},o.optionsForElement=function(e){return e.getAttribute("id")?o.options[a(e.getAttribute("id"))]:void 0},o.instances=[],o.forElement=function(e){if("string"==typeof e&&(e=document.querySelector(e)),null==(null!=e?e.dropzone:void 0))throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");return e.dropzone},o.autoDiscover=!0,o.discover=function(){var e=void 0;if(document.querySelectorAll)e=document.querySelectorAll(".dropzone");else{e=[];var t=function(t){return function(){for(var n=[],i=0,r=r=t;!(i>=r.length);){var o=r[i++];/(^| )dropzone($| )/.test(o.className)?n.push(e.push(o)):n.push(void 0)}return n}()};t(document.getElementsByTagName("div")),t(document.getElementsByTagName("form"))}return function(){for(var t=[],n=0,i=i=e;!(n>=i.length);){var r=i[n++];!1!==o.optionsForElement(r)?t.push(new o(r)):t.push(void 0)}return t}()},o.blacklistedBrowsers=[/opera.*(Macintosh|Windows Phone).*version\/12/i],o.isBrowserSupported=function(){var e=!0;if(window.File&&window.FileReader&&window.FileList&&window.Blob&&window.FormData&&document.querySelector)if("classList"in document.createElement("a"))for(var t=0,n=n=o.blacklistedBrowsers;!(t>=n.length);)n[t++].test(navigator.userAgent)&&(e=!1);else e=!1;else e=!1;return e},o.dataURItoBlob=function(e){for(var t=atob(e.split(",")[1]),n=e.split(",")[0].split(":")[1].split(";")[0],i=new ArrayBuffer(t.length),r=new Uint8Array(i),o=0,s=t.length,a=0<=s;a?o<=s:o>=s;a?o++:o--)r[o]=t.charCodeAt(o);return new Blob([i],{type:n})};var s=function(e,t){return e.filter(function(e){return e!==t}).map(function(e){return e})},a=function(e){return e.replace(/[\-_](\w)/g,function(e){return e.charAt(1).toUpperCase()})};o.createElement=function(e){var t=document.createElement("div");return t.innerHTML=e,t.childNodes[0]},o.elementInside=function(e,t){if(e===t)return!0;for(;e=e.parentNode;)if(e===t)return!0;return!1},o.getElement=function(e,t){var n=void 0;if("string"==typeof e?n=document.querySelector(e):null!=e.nodeType&&(n=e),null==n)throw new Error("Invalid `"+t+"` option provided. Please provide a CSS selector or a plain HTML element.");return n},o.getElements=function(e,t){var n=void 0,i=void 0;if(e instanceof Array){i=[];try{for(var r=0,o=o=e;!(r>=o.length);)n=o[r++],i.push(this.getElement(n,t))}catch(e){i=null}}else if("string"==typeof e){i=[];for(var s=0,a=a=document.querySelectorAll(e);!(s>=a.length);)n=a[s++],i.push(n)}else null!=e.nodeType&&(i=[e]);if(null==i||!i.length)throw new Error("Invalid `"+t+"` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");return i},o.confirm=function(e,t,n){return window.confirm(e)?t():null!=n?n():void 0},o.isValidFile=function(e,t){if(!t)return!0;t=t.split(",");for(var n=e.type,i=n.replace(/\/.*$/,""),r=0,o=o=t;!(r>=o.length);){var s=o[r++];if("."===(s=s.trim()).charAt(0)){if(-1!==e.name.toLowerCase().indexOf(s.toLowerCase(),e.name.length-s.length))return!0}else if(/\/\*$/.test(s)){if(i===s.replace(/\/.*$/,""))return!0}else if(n===s)return!0}return!1},"undefined"!=typeof jQuery&&null!==jQuery&&(jQuery.fn.dropzone=function(e){return this.each(function(){return new o(this,e)})}),void 0!==e&&null!==e?e.exports=o:window.Dropzone=o,o.ADDED="added",o.QUEUED="queued",o.ACCEPTED=o.QUEUED,o.UPLOADING="uploading",o.PROCESSING=o.UPLOADING,o.CANCELED="canceled",o.ERROR="error",o.SUCCESS="success";var l=function(e,t,n,i,r,o,s,a,l,u){var c=function(e){e.naturalWidth;var t=e.naturalHeight,n=document.createElement("canvas");n.width=1,n.height=t;var i=n.getContext("2d");i.drawImage(e,0,0);for(var r=i.getImageData(1,0,1,t).data,o=0,s=t,a=t;a>o;)0===r[4*(a-1)+3]?s=a:o=a,a=s+o>>1;var l=a/t;return 0===l?1:l}(t);return e.drawImage(t,n,i,r,o,s,a,l,u/c)},u=function(){function e(){n(this,e)}return i(e,null,[{key:"initClass",value:function(){this.KEY_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}},{key:"encode64",value:function(e){for(var t="",n=void 0,i=void 0,r="",o=void 0,s=void 0,a=void 0,l="",u=0;o=(n=e[u++])>>2,s=(3&n)<<4|(i=e[u++])>>4,a=(15&i)<<2|(r=e[u++])>>6,l=63&r,isNaN(i)?a=l=64:isNaN(r)&&(l=64),t=t+this.KEY_STR.charAt(o)+this.KEY_STR.charAt(s)+this.KEY_STR.charAt(a)+this.KEY_STR.charAt(l),n=i=r="",o=s=a=l="",u<e.length;);return t}},{key:"restore",value:function(e,t){if(!e.match("data:image/jpeg;base64,"))return t;var n=this.decode64(e.replace("data:image/jpeg;base64,","")),i=this.slice2Segments(n),r=this.exifManipulation(t,i);return"data:image/jpeg;base64,"+this.encode64(r)}},{key:"exifManipulation",value:function(e,t){var n=this.getExifArray(t),i=this.insertExif(e,n);return new Uint8Array(i)}},{key:"getExifArray",value:function(e){for(var t=void 0,n=0;n<e.length;){if(255===(t=e[n])[0]&225===t[1])return t;n++}return[]}},{key:"insertExif",value:function(e,t){var n=e.replace("data:image/jpeg;base64,",""),i=this.decode64(n),r=i.indexOf(255,3),o=i.slice(0,r),s=i.slice(r),a=o;return a=(a=a.concat(t)).concat(s)}},{key:"slice2Segments",value:function(e){for(var t=0,n=[];!(255===e[t]&218===e[t+1]);){if(255===e[t]&216===e[t+1])t+=2;else{var i=t+(256*e[t+2]+e[t+3])+2,r=e.slice(t,i);n.push(r),t=i}if(t>e.length)break}return n}},{key:"decode64",value:function(e){var t=void 0,n=void 0,i="",r=void 0,o=void 0,s="",a=0,l=[];for(/[^A-Za-z0-9\+\/\=]/g.exec(e)&&console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding."),e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");t=this.KEY_STR.indexOf(e.charAt(a++))<<2|(r=this.KEY_STR.indexOf(e.charAt(a++)))>>4,n=(15&r)<<4|(o=this.KEY_STR.indexOf(e.charAt(a++)))>>2,i=(3&o)<<6|(s=this.KEY_STR.indexOf(e.charAt(a++))),l.push(t),64!==o&&l.push(n),64!==s&&l.push(i),t=n=i="",r=o=s="",a<e.length;);return l}}]),e}();u.initClass(),o._autoDiscoverFunction=function(){if(o.autoDiscover)return o.discover()},function(e,t){var n=!1,i=!0,r=e.document,o=r.documentElement,s=r.addEventListener?"addEventListener":"attachEvent",a=r.addEventListener?"removeEventListener":"detachEvent",l=r.addEventListener?"":"on",u=function i(o){if("readystatechange"!==o.type||"complete"===r.readyState)return("load"===o.type?e:r)[a](l+o.type,i,!1),!n&&(n=!0)?t.call(e,o.type||o):void 0};if("complete"!==r.readyState){if(r.createEventObject&&o.doScroll){try{i=!e.frameElement}catch(e){}i&&function e(){try{o.doScroll("left")}catch(t){return void setTimeout(e,50)}return u("poll")}()}r[s](l+"DOMContentLoaded",u,!1),r[s](l+"readystatechange",u,!1),e[s](l+"load",u,!1)}}(window,o._autoDiscoverFunction)}).call(t,n(6)(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}}])});
//# sourceMappingURL=react-dropzone.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _semanticUiReact = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchControl = function (_React$Component) {
  _inherits(SearchControl, _React$Component);

  function SearchControl(props) {
    _classCallCheck(this, SearchControl);

    var _this = _possibleConstructorReturn(this, (SearchControl.__proto__ || Object.getPrototypeOf(SearchControl)).call(this, props));

    _this.state = { value: '' };
    return _this;
  }

  _createClass(SearchControl, [{
    key: 'render',
    value: function render() {
      var me = this;

      var controlProps = {};
      for (var p in this.props) {
        if (p == "value" || p == "handleEvent") continue;
        controlProps[p] = this.props[p];
      }

      return _react2.default.createElement(_semanticUiReact.Search, _extends({}, controlProps, {
        fluid: true,
        loading: this.state.isLoading,
        onResultSelect: this.handleResultSelect.bind(this),
        onSearchChange: this.handleSearchChange.bind(this),
        results: this.state.results,
        value: this.state.value
      }));
    }
  }, {
    key: 'resetSearch',
    value: function resetSearch() {
      this.setState({ isLoading: false, results: [] });
    }
  }, {
    key: 'handleResultSelect',
    value: function handleResultSelect(e, _ref) {
      var result = _ref.result;

      if (this.props.handleEvent !== undefined) {
        this.props.handleEvent({ key: this.props.name, eventName: "onSelect", parameters: result });
      }
    }
  }, {
    key: 'handleSearchChange',
    value: function handleSearchChange(e, _ref2) {
      var value = _ref2.value;

      var me = this;
      me.setState({ isLoading: true, value: value });

      setTimeout(function () {
        if (me.state.value === null || me.state.value === undefined || me.state.value.length < 2) {
          return me.resetSearch();
        }
        me.search(me.state.value);
      }, 200);
    }
  }, {
    key: 'search',
    value: function search(searchStr) {
      var me = this;
      var url = this.props.url;
      url += this.props.url.includes('?') ? "&" : "?";
      url += "term=" + searchStr;
      fetch(url, {
        credentials: 'same-origin'
      }).then(function (response) {
        return response.json();
      }).then(function (results) {
        me.setState({
          isLoading: false,
          results: results
        });
      }).catch(function (error) {
        if (console == undefined) alert(error);else console.error(error);
      });
    }
  }]);

  return SearchControl;
}(_react2.default.Component);

exports.default = SearchControl;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var timeoutsIdNameMap = {};

var Timeout = function () {
    function Timeout() {
        _classCallCheck(this, Timeout);
    }

    _createClass(Timeout, null, [{
        key: "Set",
        value: function Set(name, callback, delay) {
            if (timeoutsIdNameMap.hasOwnProperty(name)) {
                clearTimeout(timeoutsIdNameMap[name]);
            }

            var timeoutId = setTimeout(callback, delay);
            timeoutsIdNameMap[name] = timeoutId;
        }
    }, {
        key: "Clear",
        value: function Clear(name) {
            if (timeoutsIdNameMap.hasOwnProperty(name)) {
                clearTimeout(timeoutsIdNameMap[name]);
                delete timeoutsIdNameMap[name];
            }
        }
    }]);

    return Timeout;
}();

exports.default = Timeout;

/***/ })
/******/ ]);
});